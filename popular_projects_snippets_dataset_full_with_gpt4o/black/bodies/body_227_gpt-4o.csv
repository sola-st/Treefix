prompt,raw_predictions,predictions,prompt_type,input_size,input_price,output_size,output_price,total_price
"Provide self-contained and concrete Python values to initialize the undefined variables in the code snippet.

# begin code snippet
""""""Run formatting of `sources` in parallel using the provided `executor`.

    (Use ProcessPoolExecutors for actual parallelism.)

    `write_back`, `fast`, and `mode` options are passed to
    :func:`format_file_in_place`.
    """"""
cache: Cache = {}
if write_back not in (WriteBack.DIFF, WriteBack.COLOR_DIFF):
    cache = read_cache(mode)
    sources, cached = filter_cached(cache, sources)
    for src in sorted(cached):
        report.done(src, Changed.CACHED)
if not sources:
    exit()

cancelled = []
sources_to_cache = []
lock = None
if write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF):
    # For diff output, we need locks to ensure we don't interleave output
    # from different processes.
    manager = Manager()
    lock = manager.Lock()
tasks = {
    asyncio.ensure_future(
        loop.run_in_executor(
            executor, format_file_in_place, src, fast, mode, write_back, lock
        )
    ): src
    for src in sorted(sources)
}
pending = tasks.keys()
try:
    loop.add_signal_handler(signal.SIGINT, cancel, pending)
    loop.add_signal_handler(signal.SIGTERM, cancel, pending)
except NotImplementedError:
    # There are no good alternatives for these on Windows.
    pass
while pending:
    done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)
    for task in done:
        src = tasks.pop(task)
        if task.cancelled():
            cancelled.append(task)
        elif task.exception():
            report.failed(src, str(task.exception()))
        else:
            changed = Changed.YES if task.result() else Changed.NO
            # If the file was written back or was successfully checked as
            # well-formatted, store this information in the cache.
            if write_back is WriteBack.YES or (
                write_back is WriteBack.CHECK and changed is Changed.NO
            ):
                sources_to_cache.append(src)
            report.done(src, changed)
if cancelled:
    await asyncio.gather(*cancelled, return_exceptions=True)
if sources_to_cache:
    write_cache(cache, sources_to_cache, mode)

# end code snippet

# begin undefined variables
Cache
write_back
WriteBack
read_cache
mode
filter_cached
sources
report
Changed
Manager
loop
signal
cancel
asyncio
write_cache
executor
format_file_in_place
fast
# end undefined variables

# begin undefined attributes and methods
WriteBack.DIFF
WriteBack.COLOR_DIFF
report.done
Changed.CACHED
asyncio.ensure_future
loop.run_in_executor
loop.add_signal_handler
signal.SIGINT
signal.SIGTERM
asyncio.wait
asyncio.FIRST_COMPLETED
report.failed
Changed.YES
Changed.NO
WriteBack.YES
WriteBack.CHECK
asyncio.gather
# end undefined attributes and methods

Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from unittest.mock import Mock"",
            ""from enum import Enum"",
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):\n    DIFF = 1\n    COLOR_DIFF = 2\n    YES = 3\n    CHECK = 4"",
            """",
            ""def read_cache(mode):\n    return {}"",
            """",
            ""mode = 'default_mode'"",
            """",
            ""def filter_cached(cache, sources):\n    return sources, []"",
            """",
            ""sources = ['file1.py', 'file2.py']"",
            """",
            ""report = Mock()\nreport.done = Mock()\nreport.failed = Mock()"",
            """",
            ""class Changed(Enum):\n    CACHED = 1\n    YES = 2\n    NO = 3"",
            """",
            ""executor = Mock()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):\n    return True"",
            """",
            ""fast = True"",
            """",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def cancel(pending):\n    pass"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):\n    pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from asyncio import AbstractEventLoop"",
            ""from typing import Any, Dict, List, Tuple""
        ],
        ""initialization"": [
            ""Cache = Dict[str, Any]"",
            ""write_back = type('WriteBack', (object,), {'DIFF': 'DIFF', 'COLOR_DIFF': 'COLOR_DIFF', 'YES': 'YES', 'CHECK': 'CHECK'})()"",
            ""read_cache = lambda mode: {}  # Dummy function to return an empty dict"",
            ""mode = 'some_mode'  # Example mode string"",
            ""filter_cached = lambda cache, sources: (sources, sources)  # Dummy function that returns input sources"",
            ""sources = ['source1.py', 'source2.py']  # Example list of sources"",
            ""report = type('Mock', (object,), {'done': lambda self, src, status: print(f\""done: {src}, status: {status}\""), 'failed': lambda self, src, error: print(f\""failed: {src}, error: {error}\"")})()"",
            ""Changed = type('Changed', (object,), {'CACHED': 'CACHED', 'YES': 'YES', 'NO': 'NO'})()"",
            ""Manager = Manager"",
            ""loop = asyncio.get_event_loop()"",
            ""signal = signal"",
            ""cancel = lambda pending: print('Cancel called')  # Dummy cancel function"",
            ""asyncio = asyncio"",
            ""write_cache = lambda cache, sources, mode: print(f\""Cache written for sources: {sources} in mode: {mode}\"")  # Dummy function to simulate cache writing"",
            ""executor = ProcessPoolExecutor()"",
            ""format_file_in_place = lambda src, fast, mode, write_back, lock: True  # Dummy function always returns True"",
            ""fast = True  # Example fast option""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report: def done(self, src, status): pass; def failed(self, src, error): pass"",
            ""report = Report()"",
            ""class Changed(Enum): YES = 1; NO = 0; CACHED = 2"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): pass"",
            ""def format_file_in_place(src, fast, mode, write_back, lock): return False"",
            ""executor = None"",
            ""fast = False"",
            ""class Mock: pass"",
            ""asyncio.ensure_future = lambda coro: Mock()"",
            ""loop.run_in_executor = lambda executor, func, *args: asyncio.Future()"",
            ""loop.add_signal_handler = lambda signum, func, *args: None"",
            ""signal.SIGINT = 2"",
            ""signal.SIGTERM = 15"",
            ""asyncio.wait = lambda futs, return_when: ([], [])"",
            ""asyncio.FIRST_COMPLETED = 'FIRST_COMPLETED'"",
            ""asyncio.gather = lambda *coros, return_exceptions: asyncio.Future()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""write_back = type('WriteBack', (object,), dict(DIFF='diff', COLOR_DIFF='color_diff', YES='yes', CHECK='check'))()"",
            ""read_cache = lambda mode: {}"",
            ""mode = 'default_mode'"",
            ""filter_cached = lambda cache, sources: (sources, [])"",
            ""sources = ['source_file1.py', 'source_file2.py']"",
            ""report = type('Mock', (object,), dict(done=lambda src, status: None, failed=lambda src, msg: None))()"",
            ""Changed = type('Changed', (object,), dict(CACHED='cached', YES='yes', NO='no'))()"",
            ""Manager = Manager"",
            ""loop = asyncio.get_event_loop()"",
            ""signal = signal"",
            ""cancel = lambda pending: None"",
            ""asyncio = type('Mock', (object,), dict(ensure_future=asyncio.ensure_future, wait=asyncio.wait, gather=asyncio.gather, FIRST_COMPLETED=asyncio.FIRST_COMPLETED))"",
            ""write_cache = lambda cache, sources_to_cache, mode: None"",
            ""executor = ProcessPoolExecutor()"",
            ""format_file_in_place = lambda src, fast, mode, write_back, lock: True"",
            ""fast = True""
        ]
    },
    {
        ""imports"": [
            ""from multiprocessing import Manager"",
            ""import asyncio"",
            ""import signal""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""write_back = type('WriteBack', (object,), {'DIFF': 'DIFF', 'COLOR_DIFF': 'COLOR_DIFF', 'YES': 'YES', 'CHECK': 'CHECK'})"",
            ""WriteBack = write_back"",
            ""def read_cache(mode): return {}"",
            ""mode = 'default_mode'"",
            ""def filter_cached(cache, sources): return (sources, [])"",
            ""sources = ['file1.py', 'file2.py']"",
            ""report = type('Mock', (object,), {'done': lambda src, status: None, 'failed': lambda src, msg: None})"",
            ""Changed = type('ChangedEnum', (object,), {'CACHED': 'CACHED', 'YES': 'YES', 'NO': 'NO'})"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): pass"",
            ""asyncio.ensure_future = asyncio.create_task"",
            ""executor = None"",
            ""def format_file_in_place(src, fast, mode, write_back, lock): return False"",
            ""fast = False"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report:\n    def done(self, src, change): pass\n    def failed(self, src, msg): pass"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3"",
            ""def cancel(pending): pass"",
            ""loop = asyncio.get_event_loop()"",
            ""executor = asyncio.get_event_loop().run_in_executor"",
            ""def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""import signal"",
            ""import asyncio"",
            ""from unittest.mock import Mock""
        ],
        ""initialization"": [
            ""Cache = type('Cache', (object,), {})"",
            ""write_back = Mock()"",
            ""WriteBack = type('WriteBack', (object,), {'DIFF': 'diff', 'COLOR_DIFF': 'color_diff', 'YES': 'yes', 'CHECK': 'check'})"",
            ""read_cache = Mock()"",
            ""mode = 'default_mode'"",
            ""filter_cached = Mock()"",
            ""sources = ['source1', 'source2', 'source3']"",
            ""report = Mock()"",
            ""Changed = type('Changed', (object,), {'CACHED': 'cached', 'YES': 'yes', 'NO': 'no'})"",
            ""loop = asyncio.get_event_loop()"",
            ""signal = signal"",
            ""cancel = Mock()"",
            ""asyncio = asyncio"",
            ""write_cache = Mock()"",
            ""executor = ProcessPoolExecutor()"",
            ""format_file_in_place = Mock()"",
            ""fast = True""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from unittest.mock import Mock""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""write_back = Mock(spec_set=[])"",
            ""WriteBack = type('WriteBack', (), {'DIFF': 'DIFF', 'COLOR_DIFF': 'COLOR_DIFF', 'YES': 'YES', 'CHECK': 'CHECK'})"",
            ""read_cache = Mock(return_value={})"",
            ""mode = 'default_mode'"",
            ""filter_cached = Mock(return_value=([], []))"",
            ""sources = []"",
            ""report = Mock(spec_set=['done', 'failed'])"",
            ""Changed = type('Changed', (), {'CACHED': 'CACHED', 'YES': 'YES', 'NO': 'NO'})"",
            ""loop = asyncio.get_event_loop()"",
            ""cancel = Mock()"",
            ""write_cache = Mock()"",
            ""executor = Mock()"",
            ""format_file_in_place = Mock(return_value=True)"",
            ""fast = True""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""write_back = type('WriteBack', (), {'DIFF': 'DIFF', 'COLOR_DIFF': 'COLOR_DIFF', 'YES': 'YES', 'CHECK': 'CHECK'})"",
            ""WriteBack = type('WriteBack', (), {'DIFF': 'DIFF', 'COLOR_DIFF': 'COLOR_DIFF', 'YES': 'YES', 'CHECK': 'CHECK'})"",
            ""read_cache = lambda mode: {}"",
            ""mode = 'default_mode'"",
            ""filter_cached = lambda cache, sources: (sources, [])"",
            ""sources = ['source1', 'source2']"",
            ""report = type('Mock', (object,), {'done': lambda src, status: None, 'failed': lambda src, exc: None})"",
            ""Changed = type('Changed', (), {'CACHED': 'CACHED', 'YES': 'YES', 'NO': 'NO'})"",
            ""Manager = Manager"",
            ""loop = asyncio.get_event_loop()"",
            ""signal = signal"",
            ""cancel = lambda pending: None"",
            ""asyncio = asyncio"",
            ""write_cache = lambda cache, sources, mode: None"",
            ""executor = ProcessPoolExecutor()"",
            ""format_file_in_place = lambda src, fast, mode, write_back, lock: True"",
            ""fast = False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Any, Dict, List, Tuple"",
            ""from unittest.mock import Mock"",
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):"",
            ""    DIFF = auto()"",
            ""    COLOR_DIFF = auto()"",
            ""    YES = auto()"",
            ""    CHECK = auto()"",
            """",
            ""def read_cache(mode: str) -> Cache:"",
            ""    return Cache()"",
            """",
            ""mode = 'default_mode'"",
            """",
            ""def filter_cached(cache: Cache, sources: List[str]) -> Tuple[List[str], List[str]]:"",
            ""    return sources, []"",
            """",
            ""sources = ['source1', 'source2']"",
            """",
            ""class Changed(Enum):"",
            ""    CACHED = auto()"",
            ""    YES = auto()"",
            ""    NO = auto()"",
            """",
            ""report = type('Mock', (object,), {'done': Mock(), 'failed': Mock()})"",
            """",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def cancel(pending: List[Any]):"",
            ""    pass"",
            """",
            ""def write_cache(cache: Cache, sources_to_cache: List[str], mode: str):"",
            ""    pass"",
            """",
            ""executor = ProcessPoolExecutor()"",
            """",
            ""def format_file_in_place(src: str, fast: bool, mode: str, write_back: WriteBack, lock: Any) -> bool:"",
            ""    return True"",
            """",
            ""fast = True"",
            """",
            ""write_back = WriteBack.YES""
        ]
    }
]","[
    {
        ""imports"": [
            ""from unittest.mock import Mock # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class WriteBack(Enum):# pragma: no cover"",
            ""    DIFF = 1# pragma: no cover"",
            ""    COLOR_DIFF = 2# pragma: no cover"",
            ""    YES = 3# pragma: no cover"",
            ""    CHECK = 4 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode):# pragma: no cover"",
            ""    return {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources):# pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Mock()# pragma: no cover"",
            ""report.done = Mock()# pragma: no cover"",
            ""report.failed = Mock() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum):# pragma: no cover"",
            ""    CACHED = 1# pragma: no cover"",
            ""    YES = 2# pragma: no cover"",
            ""    NO = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""executor = Mock() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):# pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            "" # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode):# pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from asyncio import AbstractEventLoop # pragma: no cover"",
            ""from typing import Any, Dict, List, Tuple # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = Dict[str, Any] # pragma: no cover"",
            ""write_back = type('WriteBack', (object,), {'DIFF': 'DIFF', 'COLOR_DIFF': 'COLOR_DIFF', 'YES': 'YES', 'CHECK': 'CHECK'})() # pragma: no cover"",
            ""read_cache = lambda mode: {}  # Dummy function to return an empty dict # pragma: no cover"",
            ""mode = 'some_mode'  # Example mode string # pragma: no cover"",
            ""filter_cached = lambda cache, sources: (sources, sources)  # Dummy function that returns input sources # pragma: no cover"",
            ""sources = ['source1.py', 'source2.py']  # Example list of sources # pragma: no cover"",
            ""report = type('Mock', (object,), {'done': lambda self, src, status: print(f\""done: {src}, status: {status}\""), 'failed': lambda self, src, error: print(f\""failed: {src}, error: {error}\"")})() # pragma: no cover"",
            ""Changed = type('Changed', (object,), {'CACHED': 'CACHED', 'YES': 'YES', 'NO': 'NO'})() # pragma: no cover"",
            ""Manager = Manager # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""signal = signal # pragma: no cover"",
            ""cancel = lambda pending: print('Cancel called')  # Dummy cancel function # pragma: no cover"",
            ""asyncio = asyncio # pragma: no cover"",
            ""write_cache = lambda cache, sources, mode: print(f\""Cache written for sources: {sources} in mode: {mode}\"")  # Dummy function to simulate cache writing # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""format_file_in_place = lambda src, fast, mode, write_back, lock: True  # Dummy function always returns True # pragma: no cover"",
            ""fast = True  # Example fast option # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""write_back = type('WriteBack', (object,), dict(DIFF='diff', COLOR_DIFF='color_diff', YES='yes', CHECK='check'))() # pragma: no cover"",
            ""read_cache = lambda mode: {} # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""filter_cached = lambda cache, sources: (sources, []) # pragma: no cover"",
            ""sources = ['source_file1.py', 'source_file2.py'] # pragma: no cover"",
            ""report = type('Mock', (object,), dict(done=lambda src, status: None, failed=lambda src, msg: None))() # pragma: no cover"",
            ""Changed = type('Changed', (object,), dict(CACHED='cached', YES='yes', NO='no'))() # pragma: no cover"",
            ""Manager = Manager # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""signal = signal # pragma: no cover"",
            ""cancel = lambda pending: None # pragma: no cover"",
            ""asyncio = type('Mock', (object,), dict(ensure_future=asyncio.ensure_future, wait=asyncio.wait, gather=asyncio.gather, FIRST_COMPLETED=asyncio.FIRST_COMPLETED)) # pragma: no cover"",
            ""write_cache = lambda cache, sources_to_cache, mode: None # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""format_file_in_place = lambda src, fast, mode, write_back, lock: True # pragma: no cover"",
            ""fast = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from multiprocessing import Manager # pragma: no cover"",
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""write_back = type('WriteBack', (object,), {'DIFF': 'DIFF', 'COLOR_DIFF': 'COLOR_DIFF', 'YES': 'YES', 'CHECK': 'CHECK'}) # pragma: no cover"",
            ""WriteBack = write_back # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return (sources, []) # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""report = type('Mock', (object,), {'done': lambda src, status: None, 'failed': lambda src, msg: None}) # pragma: no cover"",
            ""Changed = type('ChangedEnum', (object,), {'CACHED': 'CACHED', 'YES': 'YES', 'NO': 'NO'}) # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""asyncio.ensure_future = asyncio.create_task # pragma: no cover"",
            ""executor = None # pragma: no cover"",
            ""def format_file_in_place(src, fast, mode, write_back, lock): return False # pragma: no cover"",
            ""fast = False # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, change): pass# pragma: no cover"",
            ""    def failed(self, src, msg): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3 # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""executor = asyncio.get_event_loop().run_in_executor # pragma: no cover"",
            ""def format_file_in_place(src, fast, mode, write_back, lock): return True # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""import asyncio # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = type('Cache', (object,), {}) # pragma: no cover"",
            ""write_back = Mock() # pragma: no cover"",
            ""WriteBack = type('WriteBack', (object,), {'DIFF': 'diff', 'COLOR_DIFF': 'color_diff', 'YES': 'yes', 'CHECK': 'check'}) # pragma: no cover"",
            ""read_cache = Mock() # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""filter_cached = Mock() # pragma: no cover"",
            ""sources = ['source1', 'source2', 'source3'] # pragma: no cover"",
            ""report = Mock() # pragma: no cover"",
            ""Changed = type('Changed', (object,), {'CACHED': 'cached', 'YES': 'yes', 'NO': 'no'}) # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""signal = signal # pragma: no cover"",
            ""cancel = Mock() # pragma: no cover"",
            ""asyncio = asyncio # pragma: no cover"",
            ""write_cache = Mock() # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""format_file_in_place = Mock() # pragma: no cover"",
            ""fast = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""write_back = Mock(spec_set=[]) # pragma: no cover"",
            ""WriteBack = type('WriteBack', (), {'DIFF': 'DIFF', 'COLOR_DIFF': 'COLOR_DIFF', 'YES': 'YES', 'CHECK': 'CHECK'}) # pragma: no cover"",
            ""read_cache = Mock(return_value={}) # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""filter_cached = Mock(return_value=([], [])) # pragma: no cover"",
            ""sources = [] # pragma: no cover"",
            ""report = Mock(spec_set=['done', 'failed']) # pragma: no cover"",
            ""Changed = type('Changed', (), {'CACHED': 'CACHED', 'YES': 'YES', 'NO': 'NO'}) # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""cancel = Mock() # pragma: no cover"",
            ""write_cache = Mock() # pragma: no cover"",
            ""executor = Mock() # pragma: no cover"",
            ""format_file_in_place = Mock(return_value=True) # pragma: no cover"",
            ""fast = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""write_back = type('WriteBack', (), {'DIFF': 'DIFF', 'COLOR_DIFF': 'COLOR_DIFF', 'YES': 'YES', 'CHECK': 'CHECK'}) # pragma: no cover"",
            ""WriteBack = type('WriteBack', (), {'DIFF': 'DIFF', 'COLOR_DIFF': 'COLOR_DIFF', 'YES': 'YES', 'CHECK': 'CHECK'}) # pragma: no cover"",
            ""read_cache = lambda mode: {} # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""filter_cached = lambda cache, sources: (sources, []) # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            ""report = type('Mock', (object,), {'done': lambda src, status: None, 'failed': lambda src, exc: None}) # pragma: no cover"",
            ""Changed = type('Changed', (), {'CACHED': 'CACHED', 'YES': 'YES', 'NO': 'NO'}) # pragma: no cover"",
            ""Manager = Manager # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""signal = signal # pragma: no cover"",
            ""cancel = lambda pending: None # pragma: no cover"",
            ""asyncio = asyncio # pragma: no cover"",
            ""write_cache = lambda cache, sources, mode: None # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""format_file_in_place = lambda src, fast, mode, write_back, lock: True # pragma: no cover"",
            ""fast = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Any, Dict, List, Tuple # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover"",
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = auto() # pragma: no cover"",
            ""    COLOR_DIFF = auto() # pragma: no cover"",
            ""    YES = auto() # pragma: no cover"",
            ""    CHECK = auto() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode: str) -> Cache: # pragma: no cover"",
            ""    return Cache() # pragma: no cover"",
            "" # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache: Cache, sources: List[str]) -> Tuple[List[str], List[str]]: # pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    CACHED = auto() # pragma: no cover"",
            ""    YES = auto() # pragma: no cover"",
            ""    NO = auto() # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = type('Mock', (object,), {'done': Mock(), 'failed': Mock()}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending: List[Any]): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache: Cache, sources_to_cache: List[str], mode: str): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def format_file_in_place(src: str, fast: bool, mode: str, write_back: WriteBack, lock: Any) -> bool: # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover""
        ]
    }
]",1,867,0.0004335,3212,0.004818,0.0052515
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 90:
              ^
SyntaxError: 'await' outside function
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from unittest.mock import Mock"",
            ""from enum import Enum"",
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):\n    DIFF = 1\n    COLOR_DIFF = 2\n    YES = 3\n    CHECK = 4"",
            """",
            ""def read_cache(mode):\n    return {}"",
            """",
            ""mode = 'default_mode'"",
            """",
            ""def filter_cached(cache, sources):\n    return sources, []"",
            """",
            ""sources = ['file1.py', 'file2.py']"",
            """",
            ""report = Mock()\nreport.done = Mock()\nreport.failed = Mock()"",
            """",
            ""class Changed(Enum):\n    CACHED = 1\n    YES = 2\n    NO = 3"",
            """",
            ""executor = Mock()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):\n    return True"",
            """",
            ""fast = True"",
            """",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def cancel(pending):\n    pass"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):\n    pass"",
            """",
            ""# Wrapping main code into an async function"",
            ""async def main():"",
            ""    cache = {}"",
            ""    if write_back not in (WriteBack.DIFF, WriteBack.COLOR_DIFF):"",
            ""        cache = read_cache(mode)"",
            ""        filtered_sources, cached = filter_cached(cache, sources)"",
            ""        for src in sorted(cached):"",
            ""            report.done(src, Changed.CACHED)"",
            ""        sources_to_process = filtered_sources"",
            ""    else:"",
            ""        sources_to_process = sources"",
            """",
            ""    if not sources_to_process:"",
            ""        exit()"",
            """",
            ""    cancelled = []"",
            ""    sources_to_cache = []"",
            ""    lock = None"",
            ""    if write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF):"",
            ""        manager = Manager()"",
            ""        lock = manager.Lock()"",
            """",
            ""    tasks = {"",
            ""        asyncio.ensure_future("",
            ""            loop.run_in_executor("",
            ""                executor, format_file_in_place, src, fast, mode, write_back, lock"",
            ""            )"",
            ""        ): src"",
            ""        for src in sorted(sources_to_process)"",
            ""    }"",
            ""    pending = tasks.keys()"",
            """",
            ""    try:"",
            ""        loop.add_signal_handler(signal.SIGINT, cancel, pending)"",
            ""        loop.add_signal_handler(signal.SIGTERM, cancel, pending)"",
            ""    except NotImplementedError:"",
            ""        pass"",
            """",
            ""    while pending:"",
            ""        done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)"",
            ""        for task in done:"",
            ""            src = tasks.pop(task)"",
            ""            if task.cancelled():"",
            ""                cancelled.append(task)"",
            ""            elif task.exception():"",
            ""                report.failed(src, str(task.exception()))"",
            ""            else:"",
            ""                changed = Changed.YES if task.result() else Changed.NO"",
            ""                if write_back is WriteBack.YES or ("",
            ""                    write_back is WriteBack.CHECK and changed is Changed.NO"",
            ""                ):"",
            ""                    sources_to_cache.append(src)"",
            ""                report.done(src, changed)"",
            """",
            ""    if cancelled:"",
            ""        await asyncio.gather(*cancelled, return_exceptions=True)"",
            """",
            ""    if sources_to_cache:"",
            ""        write_cache(cache, sources_to_cache, mode)"",
            """",
            ""asyncio.run(main())""
        ]
    },
    {
        ""imports"": [
            ""from unittest.mock import Mock"",
            ""from enum import Enum"",
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):\n    DIFF = 1\n    COLOR_DIFF = 2\n    YES = 3\n    CHECK = 4"",
            """",
            ""def read_cache(mode):\n    return {}"",
            """",
            ""mode = 'default_mode'"",
            """",
            ""def filter_cached(cache, sources):\n    return sources, []"",
            """",
            ""sources = ['file1.py', 'file2.py']"",
            """",
            ""report = Mock()\nreport.done = Mock()\nreport.failed = Mock()"",
            """",
            ""class Changed(Enum):\n    CACHED = 1\n    YES = 2\n    NO = 3"",
            """",
            ""executor = Mock()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):\n    return True"",
            """",
            ""fast = True"",
            """",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def cancel(pending):\n    pass"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):\n    pass"",
            """",
            ""async def main():\n    cache = Cache()\n    if write_back not in (WriteBack.DIFF, WriteBack.COLOR_DIFF):\n        cache = read_cache(mode)\n        global sources\n        sources, cached = filter_cached(cache, sources)\n        for src in sorted(cached):\n            report.done(src, Changed.CACHED)\n    if not sources:\n        return\n\n    cancelled = []\n    sources_to_cache = []\n    lock = None\n    if write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF):\n        manager = Manager()\n        lock = manager.Lock()\n    tasks = {\n        asyncio.ensure_future(\n            loop.run_in_executor(\n                executor, format_file_in_place, src, fast, mode, write_back, lock\n            )\n        ): src\n        for src in sorted(sources)\n    }\n    pending = tasks.keys()\n    try:\n        loop.add_signal_handler(signal.SIGINT, cancel, pending)\n        loop.add_signal_handler(signal.SIGTERM, cancel, pending)\n    except NotImplementedError:\n        pass\n    while pending:\n        done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)\n        for task in done:\n            src = tasks.pop(task)\n            if task.cancelled():\n                cancelled.append(task)\n            elif task.exception():\n                report.failed(src, str(task.exception()))\n            else:\n                changed = Changed.YES if task.result() else Changed.NO\n                if write_back is WriteBack.YES or (\n                    write_back is WriteBack.CHECK and changed is Changed.NO\n                ):\n                    sources_to_cache.append(src)\n                report.done(src, changed)\n    if cancelled:\n        await asyncio.gather(*cancelled, return_exceptions=True)\n    if sources_to_cache:\n        write_cache(cache, sources_to_cache, mode)\n\nasyncio.run(main())""
        ]
    },
    {
        ""imports"": [
            ""from unittest.mock import Mock"",
            ""from enum import Enum"",
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):\n    DIFF = 1\n    COLOR_DIFF = 2\n    YES = 3\n    CHECK = 4"",
            """",
            ""def read_cache(mode):\n    return {}"",
            """",
            ""mode = 'default_mode'"",
            """",
            ""def filter_cached(cache, sources):\n    return sources, []"",
            """",
            ""sources = ['file1.py', 'file2.py']"",
            """",
            ""report = Mock()\nreport.done = Mock()\nreport.failed = Mock()"",
            """",
            ""class Changed(Enum):\n    CACHED = 1\n    YES = 2\n    NO = 3"",
            """",
            ""executor = Mock()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):\n    return True"",
            """",
            ""fast = True"",
            """",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def cancel(pending):\n    pass"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):\n    pass"",
            """",
            ""async def main():\n"",
            ""    cache: Cache = {}\n"",
            ""    if write_back not in (WriteBack.DIFF, WriteBack.COLOR_DIFF):\n"",
            ""        cache = read_cache(mode)\n"",
            ""        sources, cached = filter_cached(cache, sources)\n"",
            ""        for src in sorted(cached):\n"",
            ""            report.done(src, Changed.CACHED)\n"",
            ""    if not sources:\n"",
            ""        exit()\n"",
            ""\n"",
            ""    cancelled = []\n"",
            ""    sources_to_cache = []\n"",
            ""    lock = None\n"",
            ""    if write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF):\n"",
            ""        manager = Manager()\n"",
            ""        lock = manager.Lock()\n"",
            ""    tasks = {\n"",
            ""        asyncio.ensure_future(\n"",
            ""            loop.run_in_executor(\n"",
            ""                executor, format_file_in_place, src, fast, mode, write_back, lock\n"",
            ""            )\n"",
            ""        ): src\n"",
            ""        for src in sorted(sources)\n"",
            ""    }\n"",
            ""    pending = tasks.keys()\n"",
            ""    try:\n"",
            ""        loop.add_signal_handler(signal.SIGINT, cancel, pending)\n"",
            ""        loop.add_signal_handler(signal.SIGTERM, cancel, pending)\n"",
            ""    except NotImplementedError:\n"",
            ""        pass\n"",
            ""    while pending:\n"",
            ""        done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)\n"",
            ""        for task in done:\n"",
            ""            src = tasks.pop(task)\n"",
            ""            if task.cancelled():\n"",
            ""                cancelled.append(task)\n"",
            ""            elif task.exception():\n"",
            ""                report.failed(src, str(task.exception()))\n"",
            ""            else:\n"",
            ""                changed = Changed.YES if task.result() else Changed.NO\n"",
            ""                if write_back is WriteBack.YES or (\n"",
            ""                    write_back is WriteBack.CHECK and changed is Changed.NO\n"",
            ""                ):\n"",
            ""                    sources_to_cache.append(src)\n"",
            ""                report.done(src, changed)\n"",
            ""    if cancelled:\n"",
            ""        await asyncio.gather(*cancelled, return_exceptions=True)\n"",
            ""    if sources_to_cache:\n"",
            ""        write_cache(cache, sources_to_cache, mode)\n"",
            ""asyncio.run(main())""
        ]
    },
    {
        ""imports"": [
            ""from unittest.mock import Mock"",
            ""from enum import Enum"",
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):\n    DIFF = 1\n    COLOR_DIFF = 2\n    YES = 3\n    CHECK = 4"",
            """",
            ""def read_cache(mode):\n    return {}"",
            """",
            ""mode = 'default_mode'"",
            """",
            ""def filter_cached(cache, sources):\n    return sources, []"",
            """",
            ""sources = ['file1.py', 'file2.py']"",
            """",
            ""report = Mock()\nreport.done = Mock()\nreport.failed = Mock()"",
            """",
            ""class Changed(Enum):\n    CACHED = 1\n    YES = 2\n    NO = 3"",
            """",
            ""executor = Mock()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):\n    return True"",
            """",
            ""fast = True"",
            """",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def cancel(pending):\n    pass"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):\n    pass"",
            """",
            ""async def main():\n    cache = Cache()\n    if write_back not in (WriteBack.DIFF, WriteBack.COLOR_DIFF):\n        cache = read_cache(mode)\n        sources, cached = filter_cached(cache, sources)\n        for src in sorted(cached):\n            report.done(src, Changed.CACHED)\n    if not sources:\n        exit()\n\n    cancelled = []\n    sources_to_cache = []\n    lock = None\n    if write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF):\n        manager = Manager()\n        lock = manager.Lock()\n    tasks = {\n        asyncio.ensure_future(\n            loop.run_in_executor(\n                executor, format_file_in_place, src, fast, mode, write_back, lock\n            )\n        ): src\n        for src in sorted(sources)\n    }\n    pending = tasks.keys()\n    try:\n        loop.add_signal_handler(signal.SIGINT, cancel, pending)\n        loop.add_signal_handler(signal.SIGTERM, cancel, pending)\n    except NotImplementedError:\n        pass\n    while pending:\n        done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)\n        for task in done:\n            src = tasks.pop(task)\n            if task.cancelled():\n                cancelled.append(task)\n            elif task.exception():\n                report.failed(src, str(task.exception()))\n            else:\n                changed = Changed.YES if task.result() else Changed.NO\n                if write_back is WriteBack.YES or (\n                    write_back is WriteBack.CHECK and changed is Changed.NO\n                ):\n                    sources_to_cache.append(src)\n                report.done(src, changed)\n    if cancelled:\n        await asyncio.gather(*cancelled, return_exceptions=True)\n    if sources_to_cache:\n        write_cache(cache, sources_to_cache, mode)"",
            """",
            ""if __name__ == '__main__':\n    asyncio.run(main())""
        ]
    },
    {
        ""imports"": [
            ""from unittest.mock import Mock"",
            ""from enum import Enum"",
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):\n    DIFF = 1\n    COLOR_DIFF = 2\n    YES = 3\n    CHECK = 4"",
            """",
            ""def read_cache(mode):\n    return {}"",
            """",
            ""mode = 'default_mode'"",
            """",
            ""def filter_cached(cache, sources):\n    return sources, []"",
            """",
            ""sources = ['file1.py', 'file2.py']"",
            """",
            ""report = Mock()\nreport.done = Mock()\nreport.failed = Mock()"",
            """",
            ""class Changed(Enum):\n    CACHED = 1\n    YES = 2\n    NO = 3"",
            """",
            ""executor = Mock()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):\n    return True"",
            """",
            ""fast = True"",
            """",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def cancel(pending):\n    pass"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):\n    pass"",
            """",
            ""async def main():\n    # Place the entire code snippet within this main function\n    cache: Cache = {}\n    if write_back not in (WriteBack.DIFF, WriteBack.COLOR_DIFF):\n        cache = read_cache(mode)\n        sources, cached = filter_cached(cache, sources)\n        for src in sorted(cached):\n            report.done(src, Changed.CACHED)\n    if not sources:\n        return\n\n    cancelled = []\n    sources_to_cache = []\n    lock = None\n    if write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF):\n        # For diff output, we need locks to ensure we don't interleave output\n        # from different processes.\n        manager = Manager()\n        lock = manager.Lock()\n    tasks = {\n        asyncio.ensure_future(\n            loop.run_in_executor(\n                executor, format_file_in_place, src, fast, mode, write_back, lock\n            )\n        ): src\n        for src in sorted(sources)\n    }\n    pending = tasks.keys()\n    try:\n        loop.add_signal_handler(signal.SIGINT, cancel, pending)\n        loop.add_signal_handler(signal.SIGTERM, cancel, pending)\n    except NotImplementedError:\n        # There are no good alternatives for these on Windows.\n        pass\n    while pending:\n        done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)\n        for task in done:\n            src = tasks.pop(task)\n            if task.cancelled():\n                cancelled.append(task)\n            elif task.exception():\n                report.failed(src, str(task.exception()))\n            else:\n                changed = Changed.YES if task.result() else Changed.NO\n                # If the file was written back or was successfully checked as\n                # well-formatted, store this information in the cache.\n                if write_back is WriteBack.YES or (\n                    write_back is WriteBack.CHECK and changed is Changed.NO\n                ):\n                    sources_to_cache.append(src)\n                report.done(src, changed)\n    if cancelled:\n        await asyncio.gather(*cancelled, return_exceptions=True)\n    if sources_to_cache:\n        write_cache(cache, sources_to_cache, mode)\n\n# Run the main function\nasyncio.run(main())""
        ]
    },
    {
        ""imports"": [
            ""from unittest.mock import Mock"",
            ""from enum import Enum"",
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):\n    DIFF = 1\n    COLOR_DIFF = 2\n    YES = 3\n    CHECK = 4"",
            """",
            ""def read_cache(mode):\n    return {}"",
            """",
            ""mode = 'default_mode'"",
            """",
            ""def filter_cached(cache, sources):\n    return sources, []"",
            """",
            ""sources = ['file1.py', 'file2.py']"",
            """",
            ""report = Mock()\nreport.done = Mock()\nreport.failed = Mock()"",
            """",
            ""class Changed(Enum):\n    CACHED = 1\n    YES = 2\n    NO = 3"",
            """",
            ""executor = Mock()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):\n    return True"",
            """",
            ""fast = True"",
            """",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def cancel(pending):\n    pass"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):\n    pass"",
            """",
            ""async def main():\n    # Paste the provided code snippet here and indent it properly\n    '''Run formatting of `sources` in parallel using the provided `executor`.\n\n    (Use ProcessPoolExecutors for actual parallelism.)\n\n    `write_back`, `fast`, and `mode` options are passed to\n    :func:`format_file_in_place`.\n    '''\n    cache = {}\n    if write_back not in (WriteBack.DIFF, WriteBack.COLOR_DIFF):\n        cache = read_cache(mode)\n        sources, cached = filter_cached(cache, sources)\n        for src in sorted(cached):\n            report.done(src, Changed.CACHED)\n    if not sources:\n        exit()\n\n    cancelled = []\n    sources_to_cache = []\n    lock = None\n    if write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF):\n        manager = Manager()\n        lock = manager.Lock()\n    tasks = {\n        asyncio.ensure_future(\n            loop.run_in_executor(\n                executor, format_file_in_place, src, fast, mode, write_back, lock\n            )\n        ): src\n        for src in sorted(sources)\n    }\n    pending = tasks.keys()\n    try:\n        loop.add_signal_handler(signal.SIGINT, cancel, pending)\n        loop.add_signal_handler(signal.SIGTERM, cancel, pending)\n    except NotImplementedError:\n        pass\n    while pending:\n        done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)\n        for task in done:\n            src = tasks.pop(task)\n            if task.cancelled():\n                cancelled.append(task)\n            elif task.exception():\n                report.failed(src, str(task.exception()))\n            else:\n                changed = Changed.YES if task.result() else Changed.NO\n                if write_back is WriteBack.YES or (\n                    write_back is WriteBack.CHECK and changed is Changed.NO\n                ):\n                    sources_to_cache.append(src)\n                report.done(src, changed)\n    if cancelled:\n        await asyncio.gather(*cancelled, return_exceptions=True)\n    if sources_to_cache:\n        write_cache(cache, sources_to_cache, mode)\n\n# Run the main function\nasyncio.run(main())""
        ]
    },
    {
        ""imports"": [
            ""from unittest.mock import Mock"",
            ""from enum import Enum"",
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):\n    DIFF = 1\n    COLOR_DIFF = 2\n    YES = 3\n    CHECK = 4"",
            """",
            ""def read_cache(mode):\n    return {}"",
            """",
            ""mode = 'default_mode'"",
            """",
            ""def filter_cached(cache, sources):\n    return sources, []"",
            """",
            ""sources = ['file1.py', 'file2.py']"",
            """",
            ""report = Mock()\nreport.done = Mock()\nreport.failed = Mock()"",
            """",
            ""class Changed(Enum):\n    CACHED = 1\n    YES = 2\n    NO = 3"",
            """",
            ""executor = Mock()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):\n    return True"",
            """",
            ""fast = True"",
            """",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def cancel(pending):\n    pass"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):\n    pass"",
            """",
            ""async def main():\n    # original code snippet here\n    cache = Cache()\n    if write_back not in (WriteBack.DIFF, WriteBack.COLOR_DIFF):\n        cache = read_cache(mode)\n        sources, cached = filter_cached(cache, sources)\n        for src in sorted(cached):\n            report.done(src, Changed.CACHED)\n    if not sources:\n        exit()\n\n    cancelled = []\n    sources_to_cache = []\n    lock = None\n    if write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF):\n        manager = Manager()\n        lock = manager.Lock()\n    tasks = {\n        asyncio.ensure_future(\n            loop.run_in_executor(\n                executor, format_file_in_place, src, fast, mode, write_back, lock\n            )\n        ): src\n        for src in sorted(sources)\n    }\n    pending = tasks.keys()\n    try:\n        loop.add_signal_handler(signal.SIGINT, cancel, pending)\n        loop.add_signal_handler(signal.SIGTERM, cancel, pending)\n    except NotImplementedError:\n        pass\n    while pending:\n        done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)\n        for task in done:\n            src = tasks.pop(task)\n            if task.cancelled():\n                cancelled.append(task)\n            elif task.exception():\n                report.failed(src, str(task.exception()))\n            else:\n                changed = Changed.YES if task.result() else Changed.NO\n                if write_back is WriteBack.YES or (\n                    write_back is WriteBack.CHECK and changed is Changed.NO\n                ):\n                    sources_to_cache.append(src)\n                report.done(src, changed)\n    if cancelled:\n        await asyncio.gather(*cancelled, return_exceptions=True)\n    if sources_to_cache:\n        write_cache(cache, sources_to_cache, mode)\n\n# Execute the main coroutine\nasyncio.run(main())""
        ]
    },
    {
        ""imports"": [
            ""from unittest.mock import Mock"",
            ""from enum import Enum"",
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):\n    DIFF = 1\n    COLOR_DIFF = 2\n    YES = 3\n    CHECK = 4"",
            """",
            ""def read_cache(mode):\n    return {}"",
            """",
            ""mode = 'default_mode'"",
            """",
            ""def filter_cached(cache, sources):\n    return sources, []"",
            """",
            ""sources = ['file1.py', 'file2.py']"",
            """",
            ""report = Mock()\nreport.done = Mock()\nreport.failed = Mock()"",
            """",
            ""class Changed(Enum):\n    CACHED = 1\n    YES = 2\n    NO = 3"",
            """",
            ""executor = Mock()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):\n    return True"",
            """",
            ""fast = True"",
            """",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def cancel(pending):\n    pass"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):\n    pass"",
            """",
            ""async def main():\n    cache = Cache()\n    if write_back not in (WriteBack.DIFF, WriteBack.COLOR_DIFF):\n        cache = read_cache(mode)\n        sources, cached = filter_cached(cache, sources)\n        for src in sorted(cached):\n            report.done(src, Changed.CACHED)\n    if not sources:\n        exit()\n\n    cancelled = []\n    sources_to_cache = []\n    lock = None\n    if write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF):\n        manager = Manager()\n        lock = manager.Lock()\n    tasks = {\n        asyncio.ensure_future(\n            loop.run_in_executor(\n                executor, format_file_in_place, src, fast, mode, write_back, lock\n            )\n        ): src\n        for src in sorted(sources)\n    }\n    pending = tasks.keys()\n    try:\n        loop.add_signal_handler(signal.SIGINT, cancel, pending)\n        loop.add_signal_handler(signal.SIGTERM, cancel, pending)\n    except NotImplementedError:\n        pass\n    while pending:\n        done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)\n        for task in done:\n            src = tasks.pop(task)\n            if task.cancelled():\n                cancelled.append(task)\n            elif task.exception():\n                report.failed(src, str(task.exception()))\n            else:\n                changed = Changed.YES if task.result() else Changed.NO\n                if write_back is WriteBack.YES or (\n                    write_back is WriteBack.CHECK and changed is Changed.NO\n                ):\n                    sources_to_cache.append(src)\n                report.done(src, changed)\n    if cancelled:\n        await asyncio.gather(*cancelled, return_exceptions=True)\n    if sources_to_cache:\n        write_cache(cache, sources_to_cache, mode)"",
            """",
            ""if __name__ == '__main__':\n    asyncio.run(main())""
        ]
    },
    {
        ""imports"": [
            ""from unittest.mock import Mock"",
            ""from enum import Enum"",
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):\n    DIFF = 1\n    COLOR_DIFF = 2\n    YES = 3\n    CHECK = 4"",
            """",
            ""def read_cache(mode):\n    return {}"",
            """",
            ""mode = 'default_mode'"",
            """",
            ""def filter_cached(cache, sources):\n    return sources, []"",
            """",
            ""sources = ['file1.py', 'file2.py']"",
            """",
            ""report = Mock()\nreport.done = Mock()\nreport.failed = Mock()"",
            """",
            ""class Changed(Enum):\n    CACHED = 1\n    YES = 2\n    NO = 3"",
            """",
            ""executor = Mock()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):\n    return True"",
            """",
            ""fast = True"",
            """",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def cancel(pending):\n    pass"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):\n    pass"",
            """",
            ""async def main():\n    cache = Cache()\n    if write_back not in (WriteBack.DIFF, WriteBack.COLOR_DIFF):\n        cache = read_cache(mode)\n        sources, cached = filter_cached(cache, sources)\n        for src in sorted(cached):\n            report.done(src, Changed.CACHED)\n    if not sources:\n        return\n\n    cancelled = []\n    sources_to_cache = []\n    lock = None\n    if write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF):\n        manager = Manager()\n        lock = manager.Lock()\n    tasks = {\n        asyncio.ensure_future(\n            loop.run_in_executor(\n                executor, format_file_in_place, src, fast, mode, write_back, lock\n            )\n        ): src\n        for src in sorted(sources)\n    }\n    pending = tasks.keys()\n    try:\n        loop.add_signal_handler(signal.SIGINT, cancel, pending)\n        loop.add_signal_handler(signal.SIGTERM, cancel, pending)\n    except NotImplementedError:\n        pass\n    while pending:\n        done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)\n        for task in done:\n            src = tasks.pop(task)\n            if task.cancelled():\n                cancelled.append(task)\n            elif task.exception():\n                report.failed(src, str(task.exception()))\n            else:\n                changed = Changed.YES if task.result() else Changed.NO\n                if write_back is WriteBack.YES or (\n                    write_back is WriteBack.CHECK and changed is Changed.NO\n                ):\n                    sources_to_cache.append(src)\n                report.done(src, changed)\n    if cancelled:\n        await asyncio.gather(*cancelled, return_exceptions=True)\n    if sources_to_cache:\n        write_cache(cache, sources_to_cache, mode)\n\n# to run the corrected asynchronous main function\naio_loop = asyncio.get_event_loop()\naio_loop.run_until_complete(main())""
        ]
    },
    {
        ""imports"": [
            ""from unittest.mock import Mock"",
            ""from enum import Enum"",
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):\n    DIFF = 1\n    COLOR_DIFF = 2\n    YES = 3\n    CHECK = 4"",
            """",
            ""def read_cache(mode):\n    return {}"",
            """",
            ""mode = 'default_mode'"",
            """",
            ""def filter_cached(cache, sources):\n    return sources, []"",
            """",
            ""sources = ['file1.py', 'file2.py']"",
            """",
            ""report = Mock()\nreport.done = Mock()\nreport.failed = Mock()"",
            """",
            ""class Changed(Enum):\n    CACHED = 1\n    YES = 2\n    NO = 3"",
            """",
            ""executor = Mock()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):\n    return True"",
            """",
            ""fast = True"",
            """",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def cancel(pending):\n    pass"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):\n    pass"",
            """",
            ""async def main():\n    cache: Cache = {}\n    if write_back not in (WriteBack.DIFF, WriteBack.COLOR_DIFF):\n        cache = read_cache(mode)\n        sources, cached = filter_cached(cache, sources)\n        for src in sorted(cached):\n            report.done(src, Changed.CACHED)\n        if not sources:\n            return\n\n    cancelled = []\n    sources_to_cache = []\n    lock = None\n    if write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF):\n        manager = Manager()\n        lock = manager.Lock()\n    tasks = {\n        asyncio.ensure_future(\n            loop.run_in_executor(\n                executor, format_file_in_place, src, fast, mode, write_back, lock\n            )\n        ): src\n        for src in sorted(sources)\n    }\n    pending = tasks.keys()\n    try:\n        loop.add_signal_handler(signal.SIGINT, cancel, pending)\n        loop.add_signal_handler(signal.SIGTERM, cancel, pending)\n    except NotImplementedError:\n        pass\n    while pending:\n        done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)\n        for task in done:\n            src = tasks.pop(task)\n            if task.cancelled():\n                cancelled.append(task)\n            elif task.exception():\n                report.failed(src, str(task.exception()))\n            else:\n                changed = Changed.YES if task.result() else Changed.NO\n                if write_back is WriteBack.YES or (\n                    write_back is WriteBack.CHECK and changed is Changed.NO\n                )\n                    sources_to_cache.append(src)\n                report.done(src, changed)\n    if cancelled:\n        await asyncio.gather(*cancelled, return_exceptions=True)\n    if sources_to_cache:\n        write_cache(cache, sources_to_cache, mode)\n\nloop.run_until_complete(main())""
        ]
    }
]","[
    {
        ""imports"": [
            ""from unittest.mock import Mock # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover""
        ],
        ""initialization"": [
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from unittest.mock import Mock # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from unittest.mock import Mock # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover""
        ],
        ""initialization"": [
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from unittest.mock import Mock # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from unittest.mock import Mock # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from unittest.mock import Mock # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from unittest.mock import Mock # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from unittest.mock import Mock # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from unittest.mock import Mock # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from unittest.mock import Mock # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class WriteBack(Enum):# pragma: no cover"",
            ""    DIFF = 1# pragma: no cover"",
            ""    COLOR_DIFF = 2# pragma: no cover"",
            ""    YES = 3# pragma: no cover"",
            ""    CHECK = 4 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode):# pragma: no cover"",
            ""    return {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources):# pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Mock()# pragma: no cover"",
            ""report.done = Mock()# pragma: no cover"",
            ""report.failed = Mock() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum):# pragma: no cover"",
            ""    CACHED = 1# pragma: no cover"",
            ""    YES = 2# pragma: no cover"",
            ""    NO = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""executor = Mock() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):# pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            "" # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def main():# pragma: no cover"",
            ""    cache: Cache = {}# pragma: no cover"",
            ""    if write_back not in (WriteBack.DIFF, WriteBack.COLOR_DIFF):# pragma: no cover"",
            ""        cache = read_cache(mode)# pragma: no cover"",
            ""        sources, cached = filter_cached(cache, sources)# pragma: no cover"",
            ""        for src in sorted(cached):# pragma: no cover"",
            ""            report.done(src, Changed.CACHED)# pragma: no cover"",
            ""        if not sources:# pragma: no cover"",
            ""            return# pragma: no cover"",
            ""# pragma: no cover"",
            ""    cancelled = []# pragma: no cover"",
            ""    sources_to_cache = []# pragma: no cover"",
            ""    lock = None# pragma: no cover"",
            ""    if write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF):# pragma: no cover"",
            ""        manager = Manager()# pragma: no cover"",
            ""        lock = manager.Lock()# pragma: no cover"",
            ""    tasks = {# pragma: no cover"",
            ""        asyncio.ensure_future(# pragma: no cover"",
            ""            loop.run_in_executor(# pragma: no cover"",
            ""                executor, format_file_in_place, src, fast, mode, write_back, lock# pragma: no cover"",
            ""            )# pragma: no cover"",
            ""        ): src# pragma: no cover"",
            ""        for src in sorted(sources)# pragma: no cover"",
            ""    }# pragma: no cover"",
            ""    pending = tasks.keys()# pragma: no cover"",
            ""    try:# pragma: no cover"",
            ""        loop.add_signal_handler(signal.SIGINT, cancel, pending)# pragma: no cover"",
            ""        loop.add_signal_handler(signal.SIGTERM, cancel, pending)# pragma: no cover"",
            ""    except NotImplementedError:# pragma: no cover"",
            ""        pass# pragma: no cover"",
            ""    while pending:# pragma: no cover"",
            ""        done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)# pragma: no cover"",
            ""        for task in done:# pragma: no cover"",
            ""            src = tasks.pop(task)# pragma: no cover"",
            ""            if task.cancelled():# pragma: no cover"",
            ""                cancelled.append(task)# pragma: no cover"",
            ""            elif task.exception():# pragma: no cover"",
            ""                report.failed(src, str(task.exception()))# pragma: no cover"",
            ""            else:# pragma: no cover"",
            ""                changed = Changed.YES if task.result() else Changed.NO# pragma: no cover""
        ]
    }
]",2,1451,0.0007255,7754,0.011631,0.0123565
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 67:
              ^
SyntaxError: 'await' outside function
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import asyncio"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from asyncio import AbstractEventLoop"",
            ""from typing import Any, Dict, List, Tuple"",
            ""from unittest.mock import Mock""
        ],
        ""initialization"": [
            ""Cache = Dict[str, Any]"",
            ""write_back = type('WriteBack', (object,), {'DIFF': 'DIFF', 'COLOR_DIFF': 'COLOR_DIFF', 'YES': 'YES', 'CHECK': 'CHECK'})()"",
            ""read_cache = lambda mode: {}  # Dummy function to return an empty dict"",
            ""mode = 'some_mode'  # Example mode string"",
            ""filter_cached = lambda cache, sources: (sources, sources)  # Dummy function that returns input sources"",
            ""sources = ['source1.py', 'source2.py']  # Example list of sources"",
            ""report = Mock()\nreport.done = Mock()\nreport.failed = Mock()"",
            ""Changed = type('Changed', (object,), {'CACHED': 'CACHED', 'YES': 'YES', 'NO': 'NO'})()"",
            ""executor = ProcessPoolExecutor()"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):\n    return True"",
            ""fast = True  # Example fast option"",
            ""loop = asyncio.get_event_loop()"",
            ""cancel = lambda pending: print('Cancel called')"",
            ""def write_cache(cache, sources, mode):\n    print(f\""Cache written for sources: {sources} in mode: {mode}\"")  # Dummy function to simulate cache writing"",
            ""Manager = Manager""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from asyncio import AbstractEventLoop"",
            ""from typing import Any, Dict, List, Tuple""
        ],
        ""initialization"": [
            ""Cache = Dict[str, Any]"",
            ""write_back = type('WriteBack', (object,), {'DIFF': 'DIFF', 'COLOR_DIFF': 'COLOR_DIFF', 'YES': 'YES', 'CHECK': 'CHECK'})()"",
            ""read_cache = lambda mode: {}  # Dummy function to return an empty dict"",
            ""mode = 'some_mode'  # Example mode string"",
            ""filter_cached = lambda cache, sources: (sources, sources)  # Dummy function that returns input sources"",
            ""sources = ['source1.py', 'source2.py']  # Example list of sources"",
            ""report = type('Mock', (object,), {'done': lambda self, src, status: print(f\""done: {src}, status: {status}\""), 'failed': lambda self, src, error: print(f\""failed: {src}, error: {error}\"")})()"",
            ""Changed = type('Changed', (object,), {'CACHED': 'CACHED', 'YES': 'YES', 'NO': 'NO'})()"",
            ""Manager = Manager"",
            ""loop = asyncio.get_event_loop()"",
            ""signal = signal"",
            ""cancel = lambda pending: print('Cancel called')  # Dummy cancel function"",
            ""asyncio = asyncio"",
            ""write_cache = lambda cache, sources, mode: print(f\""Cache written for sources: {sources} in mode: {mode}\"")  # Dummy function to simulate cache writing"",
            ""executor = ProcessPoolExecutor()"",
            ""format_file_in_place = lambda src, fast, mode, write_back, lock: True  # Dummy function always returns True"",
            ""fast = True  # Example fast option""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from asyncio import AbstractEventLoop"",
            ""from typing import Any, Dict, List, Tuple""
        ],
        ""initialization"": [
            ""Cache = Dict[str, Any]"",
            ""write_back = type('WriteBack', (object,), {'DIFF': 'DIFF', 'COLOR_DIFF': 'COLOR_DIFF', 'YES': 'YES', 'CHECK': 'CHECK'})()"",
            ""read_cache = lambda mode: {}  # Dummy function to return an empty dict"",
            ""mode = 'some_mode'  # Example mode string"",
            ""filter_cached = lambda cache, sources: (sources, sources)  # Dummy function that returns input sources"",
            ""sources = ['source1.py', 'source2.py']  # Example list of sources"",
            ""report = type('Mock', (object,), {'done': lambda self, src, status: print(f\""done: {src}, status: {status}\""), 'failed': lambda self, src, error: print(f\""failed: {src}, error: {error}\"")})()"",
            ""Changed = type('Changed', (object,), {'CACHED': 'CACHED', 'YES': 'YES', 'NO': 'NO'})()"",
            ""Manager = Manager"",
            ""loop = asyncio.get_event_loop()"",
            ""signal = signal"",
            ""cancel = lambda pending: print('Cancel called')  # Dummy cancel function"",
            ""asyncio = asyncio"",
            ""write_cache = lambda cache, sources, mode: print(f\""Cache written for sources: {sources} in mode: {mode}\"")  # Dummy function to simulate cache writing"",
            ""executor = ProcessPoolExecutor()"",
            ""format_file_in_place = lambda src, fast, mode, write_back, lock: True  # Dummy function always returns True"",
            ""fast = True  # Example fast option""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from typing import Any, Dict, List, Tuple""
        ],
        ""initialization"": [
            ""Cache = Dict[str, Any]"",
            ""write_back = type('WriteBack', (object,), {'DIFF': 'DIFF', 'COLOR_DIFF': 'COLOR_DIFF', 'YES': 'YES', 'CHECK': 'CHECK'})()"",
            ""read_cache = lambda mode: {}  # Dummy function to return an empty dict"",
            ""mode = 'some_mode'  # Example mode string"",
            ""filter_cached = lambda cache, sources: (sources, sources)  # Dummy function that returns input sources"",
            ""sources = ['source1.py', 'source2.py']  # Example list of sources"",
            ""report = type('Mock', (object,), {'done': lambda self, src, status: print(f\""done: {src}, status: {status}\""), 'failed': lambda self, src, error: print(f\""failed: {src}, error: {error}\"")})()"",
            ""Changed = type('Changed', (object,), {'CACHED': 'CACHED', 'YES': 'YES', 'NO': 'NO'})()"",
            ""Manager = Manager"",
            ""loop = asyncio.get_event_loop()"",
            ""signal = signal"",
            ""cancel = lambda pending: print('Cancel called')  # Dummy cancel function"",
            ""asyncio = asyncio"",
            ""write_cache = lambda cache, sources, mode: print(f\""Cache written for sources: {sources} in mode: {mode}\"")  # Dummy function to simulate cache writing"",
            ""executor = ProcessPoolExecutor()"",
            ""format_file_in_place = lambda src, fast, mode, write_back, lock: True  # Dummy function always returns True"",
            ""fast = True  # Example fast option""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from asyncio import AbstractEventLoop"",
            ""from typing import Any, Dict, List, Tuple""
        ],
        ""initialization"": [
            ""Cache = Dict[str, Any]"",
            ""write_back = type('WriteBack', (object,), {'DIFF': 'DIFF', 'COLOR_DIFF': 'COLOR_DIFF', 'YES': 'YES', 'CHECK': 'CHECK'})()"",
            ""read_cache = lambda mode: {}  # Dummy function to return an empty dict"",
            ""mode = 'some_mode'  # Example mode string"",
            ""filter_cached = lambda cache, sources: (sources, sources)  # Dummy function that returns input sources"",
            ""sources = ['source1.py', 'source2.py']  # Example list of sources"",
            ""report = type('Mock', (object,), {'done': lambda self, src, status: print(f\""done: {src}, status: {status}\""), 'failed': lambda self, src, error: print(f\""failed: {src}, error: {error}\"")})()"",
            ""Changed = type('Changed', (object,), {'CACHED': 'CACHED', 'YES': 'YES', 'NO': 'NO'})()"",
            ""lock = None  # Initialize lock as None"",
            ""Manager = Manager"",
            ""loop = asyncio.get_event_loop()"",
            ""signal = signal"",
            ""cancel = lambda pending: print('Cancel called')  # Dummy cancel function"",
            ""asyncio = asyncio"",
            ""write_cache = lambda cache, sources, mode: print(f\""Cache written for sources: {sources} in mode: {mode}\"")  # Dummy function to simulate cache writing"",
            ""executor = ProcessPoolExecutor()"",
            ""format_file_in_place = lambda src, fast, mode, write_back, lock: True  # Dummy function always returns True"",
            ""fast = True  # Example fast option""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from asyncio import AbstractEventLoop"",
            ""from typing import Any, Dict, List, Tuple"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):\n    DIFF = 1\n    COLOR_DIFF = 2\n    YES = 3\n    CHECK = 4"",
            """",
            ""def read_cache(mode):\n    return {}"",
            """",
            ""mode = 'default_mode'"",
            """",
            ""def filter_cached(cache, sources):\n    return sources, []"",
            """",
            ""sources = ['file1.py', 'file2.py']"",
            """",
            ""report = type('Mock', (object,), {'done': lambda self, src, status: print(f'done: {src}, status: {status}'), 'failed': lambda self, src, error: print(f'failed: {src}, error: {error}')})()"",
            """",
            ""class Changed(Enum):\n    CACHED = 1\n    YES = 2\n    NO = 3"",
            """",
            ""executor = ProcessPoolExecutor()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):\n    return True"",
            """",
            ""fast = True"",
            """",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def cancel(pending):\n    pass"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):\n    pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from asyncio import AbstractEventLoop"",
            ""from typing import Any, Dict, List, Tuple"",
            ""from unittest.mock import Mock""
        ],
        ""initialization"": [
            ""Cache = Dict[str, Any]"",
            ""write_back = type('WriteBack', (object,), {'DIFF': 'DIFF', 'COLOR_DIFF': 'COLOR_DIFF', 'YES': 'YES', 'CHECK': 'CHECK'})()"",
            ""def read_cache(mode): return {}  # Dummy function to return an empty dict"",
            ""mode = 'some_mode'  # Example mode string"",
            ""def filter_cached(cache, sources): return sources, sources  # Dummy function that returns input sources"",
            ""sources = ['source1.py', 'source2.py']  # Example list of sources"",
            ""report = Mock()\nreport.done = Mock()\nreport.failed = Mock()"",
            ""Changed = type('Changed', (object,), {'CACHED': 'CACHED', 'YES': 'YES', 'NO': 'NO'})()"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): print('Cancel called')  # Dummy cancel function"",
            ""def write_cache(cache, sources_to_cache, mode): print(f'Cache written for sources: {sources_to_cache} in mode: {mode}')  # Dummy function to simulate cache writing"",
            ""executor = ProcessPoolExecutor()"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True  # Dummy async function always returns True"",
            ""fast = True  # Example fast option"",
            ""signal = signal"",
            ""Manager = Manager""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from typing import Any, Dict, List, Tuple"",
            ""from unittest.mock import Mock""
        ],
        ""initialization"": [
            ""Cache = Dict[str, Any]"",
            ""write_back = Mock()\nwrite_back.DIFF = 'DIFF'\nwrite_back.COLOR_DIFF = 'COLOR_DIFF'\nwrite_back.YES = 'YES'\nwrite_back.CHECK = 'CHECK'"",
            ""def read_cache(mode: str) -> Dict[str, Any]:\n    return {}"",
            ""mode = 'default_mode'"",
            ""def filter_cached(cache: Dict[str, Any], sources: List[str]) -> Tuple[List[str], List[str]]:\n    return sources, []"",
            ""sources = ['file1.py', 'file2.py']"",
            ""report = Mock()\nreport.done = Mock()\nreport.failed = Mock()"",
            ""Changed = Mock()\nChanged.CACHED = 'CACHED'\nChanged.YES = 'YES'\nChanged.NO = 'NO'"",
            ""manager = Manager"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending: List[asyncio.Task]) -> None:\n    for task in pending:\n        task.cancel()"",
            ""def write_cache(cache: Dict[str, Any], sources_to_cache: List[str], mode: str) -> None:\n    pass"",
            ""executor = ProcessPoolExecutor()"",
            ""async def format_file_in_place(src: str, fast: bool, mode: str, write_back: Any, lock: Any) -> bool:\n    return True"",
            ""fast = True"",
            ""async def main():\n    # Code snippet provided by the user here\n    pass\n\nif __name__ == '__main__':\n    asyncio.run(main())""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from typing import Any, Dict, List, Tuple""
        ],
        ""initialization"": [
            ""Cache = Dict[str, Any]"",
            ""class WriteBack:\n    DIFF = 'DIFF'\n    COLOR_DIFF = 'COLOR_DIFF'\n    YES = 'YES'\n    CHECK = 'CHECK'"",
            ""def read_cache(mode: str) -> Cache:\n    return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache: Cache, sources: List[str]) -> Tuple[List[str], List[str]]:\n    return sources, []"",
            ""sources = ['source1.py', 'source2.py']"",
            ""class Report:\n    def done(self, src: str, status: str) -> None:\n        print(f'done: {src}, status: {status}')\n    def failed(self, src: str, error: str) -> None: \n        print(f'failed: {src}, error: {error}')\nreport = Report()"",
            ""class Changed:\n    CACHED = 'CACHED'\n    YES = 'YES'\n    NO = 'NO'"",
            ""manager = Manager"",
            ""loop = asyncio.get_event_loop()"",
            ""signal = signal"",
            ""def cancel(pending) -> None:\n    print('Cancel called')"",
            ""asyncio = asyncio"",
            ""def write_cache(cache: Cache, sources: List[str], mode: str) -> None:\n    print(f'Cache written for sources: {sources} in mode: {mode}')"",
            ""executor = ProcessPoolExecutor()"",
            ""async def format_file_in_place(src: str, fast: bool, mode: str, write_back: str, lock: Any) -> bool:\n    return True"",
            ""fast = True""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from asyncio import AbstractEventLoop"",
            ""from typing import Any, Dict, List, Tuple""
        ],
        ""initialization"": [
            ""Cache = Dict[str, Any]"",
            ""write_back = type('WriteBack', (object,), {'DIFF': 'DIFF', 'COLOR_DIFF': 'COLOR_DIFF', 'YES': 'YES', 'CHECK': 'CHECK'})()"",
            ""read_cache = lambda mode: {}  # Dummy function to return an empty dict"",
            ""mode = 'some_mode'  # Example mode string"",
            ""filter_cached = lambda cache, sources: (sources, sources)  # Dummy function that returns input sources"",
            ""sources = ['source1.py', 'source2.py']  # Example list of sources"",
            ""report = type('Mock', (object,), {'done': lambda self, src, status: print(f\""done: {src}, status: {status}\""), 'failed': lambda self, src, error: print(f\""failed: {src}, error: {error}\"")})()"",
            ""Changed = type('Changed', (object,), {'CACHED': 'CACHED', 'YES': 'YES', 'NO': 'NO'})()"",
            ""Manager = Manager"",
            ""loop = asyncio.get_event_loop()"",
            ""signal = signal"",
            ""cancel = lambda pending: print('Cancel called')  # Dummy cancel function"",
            ""asyncio = asyncio"",
            ""write_cache = lambda cache, sources, mode: print(f\""Cache written for sources: {sources} in mode: {mode}\"")  # Dummy function to simulate cache writing"",
            ""executor = ProcessPoolExecutor()"",
            ""format_file_in_place = lambda src, fast, mode, write_back, lock: True  # Dummy function always returns True"",
            ""fast = True  # Example fast option""
        ]
    }
]","[
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from asyncio import AbstractEventLoop # pragma: no cover"",
            ""from typing import Any, Dict, List, Tuple # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = Dict[str, Any] # pragma: no cover"",
            ""write_back = type('WriteBack', (object,), {'DIFF': 'DIFF', 'COLOR_DIFF': 'COLOR_DIFF', 'YES': 'YES', 'CHECK': 'CHECK'})() # pragma: no cover"",
            ""read_cache = lambda mode: {}  # Dummy function to return an empty dict # pragma: no cover"",
            ""mode = 'some_mode'  # Example mode string # pragma: no cover"",
            ""filter_cached = lambda cache, sources: (sources, sources)  # Dummy function that returns input sources # pragma: no cover"",
            ""sources = ['source1.py', 'source2.py']  # Example list of sources # pragma: no cover"",
            ""report = Mock()# pragma: no cover"",
            ""report.done = Mock()# pragma: no cover"",
            ""report.failed = Mock() # pragma: no cover"",
            ""Changed = type('Changed', (object,), {'CACHED': 'CACHED', 'YES': 'YES', 'NO': 'NO'})() # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):# pragma: no cover"",
            ""    return True # pragma: no cover"",
            ""fast = True  # Example fast option # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""cancel = lambda pending: print('Cancel called') # pragma: no cover"",
            ""def write_cache(cache, sources, mode):# pragma: no cover"",
            ""    print(f\""Cache written for sources: {sources} in mode: {mode}\"")  # Dummy function to simulate cache writing # pragma: no cover"",
            ""Manager = Manager # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from asyncio import AbstractEventLoop # pragma: no cover"",
            ""from typing import Any, Dict, List, Tuple # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = Dict[str, Any] # pragma: no cover"",
            ""write_back = type('WriteBack', (object,), {'DIFF': 'DIFF', 'COLOR_DIFF': 'COLOR_DIFF', 'YES': 'YES', 'CHECK': 'CHECK'})() # pragma: no cover"",
            ""read_cache = lambda mode: {}  # Dummy function to return an empty dict # pragma: no cover"",
            ""mode = 'some_mode'  # Example mode string # pragma: no cover"",
            ""filter_cached = lambda cache, sources: (sources, sources)  # Dummy function that returns input sources # pragma: no cover"",
            ""sources = ['source1.py', 'source2.py']  # Example list of sources # pragma: no cover"",
            ""report = type('Mock', (object,), {'done': lambda self, src, status: print(f\""done: {src}, status: {status}\""), 'failed': lambda self, src, error: print(f\""failed: {src}, error: {error}\"")})() # pragma: no cover"",
            ""Changed = type('Changed', (object,), {'CACHED': 'CACHED', 'YES': 'YES', 'NO': 'NO'})() # pragma: no cover"",
            ""Manager = Manager # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""signal = signal # pragma: no cover"",
            ""cancel = lambda pending: print('Cancel called')  # Dummy cancel function # pragma: no cover"",
            ""asyncio = asyncio # pragma: no cover"",
            ""write_cache = lambda cache, sources, mode: print(f\""Cache written for sources: {sources} in mode: {mode}\"")  # Dummy function to simulate cache writing # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""format_file_in_place = lambda src, fast, mode, write_back, lock: True  # Dummy function always returns True # pragma: no cover"",
            ""fast = True  # Example fast option # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from asyncio import AbstractEventLoop # pragma: no cover"",
            ""from typing import Any, Dict, List, Tuple # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = Dict[str, Any] # pragma: no cover"",
            ""write_back = type('WriteBack', (object,), {'DIFF': 'DIFF', 'COLOR_DIFF': 'COLOR_DIFF', 'YES': 'YES', 'CHECK': 'CHECK'})() # pragma: no cover"",
            ""read_cache = lambda mode: {}  # Dummy function to return an empty dict # pragma: no cover"",
            ""mode = 'some_mode'  # Example mode string # pragma: no cover"",
            ""filter_cached = lambda cache, sources: (sources, sources)  # Dummy function that returns input sources # pragma: no cover"",
            ""sources = ['source1.py', 'source2.py']  # Example list of sources # pragma: no cover"",
            ""report = type('Mock', (object,), {'done': lambda self, src, status: print(f\""done: {src}, status: {status}\""), 'failed': lambda self, src, error: print(f\""failed: {src}, error: {error}\"")})() # pragma: no cover"",
            ""Changed = type('Changed', (object,), {'CACHED': 'CACHED', 'YES': 'YES', 'NO': 'NO'})() # pragma: no cover"",
            ""Manager = Manager # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""signal = signal # pragma: no cover"",
            ""cancel = lambda pending: print('Cancel called')  # Dummy cancel function # pragma: no cover"",
            ""asyncio = asyncio # pragma: no cover"",
            ""write_cache = lambda cache, sources, mode: print(f\""Cache written for sources: {sources} in mode: {mode}\"")  # Dummy function to simulate cache writing # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""format_file_in_place = lambda src, fast, mode, write_back, lock: True  # Dummy function always returns True # pragma: no cover"",
            ""fast = True  # Example fast option # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from typing import Any, Dict, List, Tuple # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = Dict[str, Any] # pragma: no cover"",
            ""write_back = type('WriteBack', (object,), {'DIFF': 'DIFF', 'COLOR_DIFF': 'COLOR_DIFF', 'YES': 'YES', 'CHECK': 'CHECK'})() # pragma: no cover"",
            ""read_cache = lambda mode: {}  # Dummy function to return an empty dict # pragma: no cover"",
            ""mode = 'some_mode'  # Example mode string # pragma: no cover"",
            ""filter_cached = lambda cache, sources: (sources, sources)  # Dummy function that returns input sources # pragma: no cover"",
            ""sources = ['source1.py', 'source2.py']  # Example list of sources # pragma: no cover"",
            ""report = type('Mock', (object,), {'done': lambda self, src, status: print(f\""done: {src}, status: {status}\""), 'failed': lambda self, src, error: print(f\""failed: {src}, error: {error}\"")})() # pragma: no cover"",
            ""Changed = type('Changed', (object,), {'CACHED': 'CACHED', 'YES': 'YES', 'NO': 'NO'})() # pragma: no cover"",
            ""Manager = Manager # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""signal = signal # pragma: no cover"",
            ""cancel = lambda pending: print('Cancel called')  # Dummy cancel function # pragma: no cover"",
            ""asyncio = asyncio # pragma: no cover"",
            ""write_cache = lambda cache, sources, mode: print(f\""Cache written for sources: {sources} in mode: {mode}\"")  # Dummy function to simulate cache writing # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""format_file_in_place = lambda src, fast, mode, write_back, lock: True  # Dummy function always returns True # pragma: no cover"",
            ""fast = True  # Example fast option # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from asyncio import AbstractEventLoop # pragma: no cover"",
            ""from typing import Any, Dict, List, Tuple # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = Dict[str, Any] # pragma: no cover"",
            ""write_back = type('WriteBack', (object,), {'DIFF': 'DIFF', 'COLOR_DIFF': 'COLOR_DIFF', 'YES': 'YES', 'CHECK': 'CHECK'})() # pragma: no cover"",
            ""read_cache = lambda mode: {}  # Dummy function to return an empty dict # pragma: no cover"",
            ""mode = 'some_mode'  # Example mode string # pragma: no cover"",
            ""filter_cached = lambda cache, sources: (sources, sources)  # Dummy function that returns input sources # pragma: no cover"",
            ""sources = ['source1.py', 'source2.py']  # Example list of sources # pragma: no cover"",
            ""report = type('Mock', (object,), {'done': lambda self, src, status: print(f\""done: {src}, status: {status}\""), 'failed': lambda self, src, error: print(f\""failed: {src}, error: {error}\"")})() # pragma: no cover"",
            ""Changed = type('Changed', (object,), {'CACHED': 'CACHED', 'YES': 'YES', 'NO': 'NO'})() # pragma: no cover"",
            ""lock = None  # Initialize lock as None # pragma: no cover"",
            ""Manager = Manager # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""signal = signal # pragma: no cover"",
            ""cancel = lambda pending: print('Cancel called')  # Dummy cancel function # pragma: no cover"",
            ""asyncio = asyncio # pragma: no cover"",
            ""write_cache = lambda cache, sources, mode: print(f\""Cache written for sources: {sources} in mode: {mode}\"")  # Dummy function to simulate cache writing # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""format_file_in_place = lambda src, fast, mode, write_back, lock: True  # Dummy function always returns True # pragma: no cover"",
            ""fast = True  # Example fast option # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from asyncio import AbstractEventLoop # pragma: no cover"",
            ""from typing import Any, Dict, List, Tuple # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class WriteBack(Enum):# pragma: no cover"",
            ""    DIFF = 1# pragma: no cover"",
            ""    COLOR_DIFF = 2# pragma: no cover"",
            ""    YES = 3# pragma: no cover"",
            ""    CHECK = 4 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode):# pragma: no cover"",
            ""    return {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources):# pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = type('Mock', (object,), {'done': lambda self, src, status: print(f'done: {src}, status: {status}'), 'failed': lambda self, src, error: print(f'failed: {src}, error: {error}')})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum):# pragma: no cover"",
            ""    CACHED = 1# pragma: no cover"",
            ""    YES = 2# pragma: no cover"",
            ""    NO = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):# pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            "" # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode):# pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from asyncio import AbstractEventLoop # pragma: no cover"",
            ""from typing import Any, Dict, List, Tuple # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = Dict[str, Any] # pragma: no cover"",
            ""write_back = type('WriteBack', (object,), {'DIFF': 'DIFF', 'COLOR_DIFF': 'COLOR_DIFF', 'YES': 'YES', 'CHECK': 'CHECK'})() # pragma: no cover"",
            ""def read_cache(mode): return {}  # Dummy function to return an empty dict # pragma: no cover"",
            ""mode = 'some_mode'  # Example mode string # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, sources  # Dummy function that returns input sources # pragma: no cover"",
            ""sources = ['source1.py', 'source2.py']  # Example list of sources # pragma: no cover"",
            ""report = Mock()# pragma: no cover"",
            ""report.done = Mock()# pragma: no cover"",
            ""report.failed = Mock() # pragma: no cover"",
            ""Changed = type('Changed', (object,), {'CACHED': 'CACHED', 'YES': 'YES', 'NO': 'NO'})() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""def cancel(pending): print('Cancel called')  # Dummy cancel function # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): print(f'Cache written for sources: {sources_to_cache} in mode: {mode}')  # Dummy function to simulate cache writing # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True  # Dummy async function always returns True # pragma: no cover"",
            ""fast = True  # Example fast option # pragma: no cover"",
            ""signal = signal # pragma: no cover"",
            ""Manager = Manager # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from typing import Any, Dict, List, Tuple # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = Dict[str, Any] # pragma: no cover"",
            ""write_back = Mock()# pragma: no cover"",
            ""write_back.DIFF = 'DIFF'# pragma: no cover"",
            ""write_back.COLOR_DIFF = 'COLOR_DIFF'# pragma: no cover"",
            ""write_back.YES = 'YES'# pragma: no cover"",
            ""write_back.CHECK = 'CHECK' # pragma: no cover"",
            ""def read_cache(mode: str) -> Dict[str, Any]:# pragma: no cover"",
            ""    return {} # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""def filter_cached(cache: Dict[str, Any], sources: List[str]) -> Tuple[List[str], List[str]]:# pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""report = Mock()# pragma: no cover"",
            ""report.done = Mock()# pragma: no cover"",
            ""report.failed = Mock() # pragma: no cover"",
            ""Changed = Mock()# pragma: no cover"",
            ""Changed.CACHED = 'CACHED'# pragma: no cover"",
            ""Changed.YES = 'YES'# pragma: no cover"",
            ""Changed.NO = 'NO' # pragma: no cover"",
            ""manager = Manager # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""def cancel(pending: List[asyncio.Task]) -> None:# pragma: no cover"",
            ""    for task in pending:# pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            ""def write_cache(cache: Dict[str, Any], sources_to_cache: List[str], mode: str) -> None:# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""async def format_file_in_place(src: str, fast: bool, mode: str, write_back: Any, lock: Any) -> bool:# pragma: no cover"",
            ""    return True # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""async def main():# pragma: no cover"",
            ""    # Code snippet provided by the user here# pragma: no cover"",
            ""    pass# pragma: no cover"",
            ""# pragma: no cover"",
            ""if __name__ == '__main__':# pragma: no cover"",
            ""    asyncio.run(main()) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from typing import Any, Dict, List, Tuple # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = Dict[str, Any] # pragma: no cover"",
            ""class WriteBack:# pragma: no cover"",
            ""    DIFF = 'DIFF'# pragma: no cover"",
            ""    COLOR_DIFF = 'COLOR_DIFF'# pragma: no cover"",
            ""    YES = 'YES'# pragma: no cover"",
            ""    CHECK = 'CHECK' # pragma: no cover"",
            ""def read_cache(mode: str) -> Cache:# pragma: no cover"",
            ""    return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache: Cache, sources: List[str]) -> Tuple[List[str], List[str]]:# pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            ""sources = ['source1.py', 'source2.py'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src: str, status: str) -> None:# pragma: no cover"",
            ""        print(f'done: {src}, status: {status}')# pragma: no cover"",
            ""    def failed(self, src: str, error: str) -> None: # pragma: no cover"",
            ""        print(f'failed: {src}, error: {error}')# pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed:# pragma: no cover"",
            ""    CACHED = 'CACHED'# pragma: no cover"",
            ""    YES = 'YES'# pragma: no cover"",
            ""    NO = 'NO' # pragma: no cover"",
            ""manager = Manager # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""signal = signal # pragma: no cover"",
            ""def cancel(pending) -> None:# pragma: no cover"",
            ""    print('Cancel called') # pragma: no cover"",
            ""asyncio = asyncio # pragma: no cover"",
            ""def write_cache(cache: Cache, sources: List[str], mode: str) -> None:# pragma: no cover"",
            ""    print(f'Cache written for sources: {sources} in mode: {mode}') # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""async def format_file_in_place(src: str, fast: bool, mode: str, write_back: str, lock: Any) -> bool:# pragma: no cover"",
            ""    return True # pragma: no cover"",
            ""fast = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from asyncio import AbstractEventLoop # pragma: no cover"",
            ""from typing import Any, Dict, List, Tuple # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = Dict[str, Any] # pragma: no cover"",
            ""write_back = type('WriteBack', (object,), {'DIFF': 'DIFF', 'COLOR_DIFF': 'COLOR_DIFF', 'YES': 'YES', 'CHECK': 'CHECK'})() # pragma: no cover"",
            ""read_cache = lambda mode: {}  # Dummy function to return an empty dict # pragma: no cover"",
            ""mode = 'some_mode'  # Example mode string # pragma: no cover"",
            ""filter_cached = lambda cache, sources: (sources, sources)  # Dummy function that returns input sources # pragma: no cover"",
            ""sources = ['source1.py', 'source2.py']  # Example list of sources # pragma: no cover"",
            ""report = type('Mock', (object,), {'done': lambda self, src, status: print(f\""done: {src}, status: {status}\""), 'failed': lambda self, src, error: print(f\""failed: {src}, error: {error}\"")})() # pragma: no cover"",
            ""Changed = type('Changed', (object,), {'CACHED': 'CACHED', 'YES': 'YES', 'NO': 'NO'})() # pragma: no cover"",
            ""Manager = Manager # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""signal = signal # pragma: no cover"",
            ""cancel = lambda pending: print('Cancel called')  # Dummy cancel function # pragma: no cover"",
            ""asyncio = asyncio # pragma: no cover"",
            ""write_cache = lambda cache, sources, mode: print(f\""Cache written for sources: {sources} in mode: {mode}\"")  # Dummy function to simulate cache writing # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""format_file_in_place = lambda src, fast, mode, write_back, lock: True  # Dummy function always returns True # pragma: no cover"",
            ""fast = True  # Example fast option # pragma: no cover""
        ]
    }
]",2,2166,0.001083,4136,0.006204,0.007287
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 55:
              ^
SyntaxError: 'await' outside function
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report: def done(self, src, status): print(f\""Done: {src}, {status}\""); def failed(self, src, error): print(f\""Failed: {src}, {error}\"")"",
            ""report = Report()"",
            ""class Changed(Enum): YES = 1; NO = 0; CACHED = 2"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): print('Cancel called')"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""executor = None"",
            ""fast = False"",
            ""class MockFuture(asyncio.Future): def __init__(self): super().__init__(); self.set_result(True)"",
            ""asyncio.ensure_future = lambda coro: MockFuture()"",
            ""loop.run_in_executor = lambda executor, func, *args: MockFuture()"",
            ""loop.add_signal_handler = lambda signum, func, *args: None"",
            ""signal.SIGINT = 2"",
            ""signal.SIGTERM = 15"",
            ""asyncio.wait = lambda futs, return_when: ([MockFuture()], [])"",
            ""asyncio.FIRST_COMPLETED = 'FIRST_COMPLETED'"",
            ""asyncio.gather = lambda *coros, return_exceptions: MockFuture()"",
            ""def write_cache(cache, sources_to_cache, mode): print(f\""Cache written for sources: {sources_to_cache}\"")""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report: def done(self, src, status): pass; def failed(self, src, error): pass"",
            ""report = Report()"",
            ""class Changed(Enum): YES = 1; NO = 0; CACHED = 2"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): pass"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return False"",
            ""executor = None"",
            ""fast = False"",
            ""class Mock: pass"",
            ""asyncio.ensure_future = lambda coro: Mock()"",
            ""loop.run_in_executor = lambda executor, func, *args: asyncio.Future()"",
            ""loop.add_signal_handler = lambda signum, func, *args: None"",
            ""signal.SIGINT = 2"",
            ""signal.SIGTERM = 15"",
            ""asyncio.wait = lambda futs, return_when: ([], [])"",
            ""asyncio.FIRST_COMPLETED = 'FIRST_COMPLETED'"",
            ""asyncio.gather = lambda *coros, return_exceptions: asyncio.Future()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report: def done(self, src, status): pass; def failed(self, src, error): pass"",
            ""report = Report()"",
            ""class Changed(Enum): YES = 1; NO = 0; CACHED = 2"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): pass"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return False"",
            ""executor = None"",
            ""fast = False"",
            ""class Mock: pass"",
            ""asyncio.ensure_future = lambda coro: asyncio.ensure_future(coro)"",
            ""loop.run_in_executor = lambda executor, func, *args: asyncio.ensure_future(func(*args))"",
            ""loop.add_signal_handler = lambda signum, func, *args: None"",
            ""signal.SIGINT = signal.SIGINT"",
            ""signal.SIGTERM = signal.SIGTERM"",
            ""asyncio.wait = asyncio.wait"",
            ""asyncio.FIRST_COMPLETED = asyncio.FIRST_COMPLETED"",
            ""asyncio.gather = asyncio.gather""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report: def done(self, src, status): pass; def failed(self, src, error): pass"",
            ""report = Report()"",
            ""class Changed(Enum): YES = 1; NO = 0; CACHED = 2"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): pass"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return False"",
            ""executor = None"",
            ""fast = False"",
            ""class Mock: pass"",
            ""asyncio.ensure_future = lambda coro: Mock()"",
            ""loop.run_in_executor = lambda executor, func, *args: asyncio.Future()"",
            ""loop.add_signal_handler = lambda signum, func, *args: None"",
            ""signal.SIGINT = 2"",
            ""signal.SIGTERM = 15"",
            ""asyncio.wait = lambda futs, return_when: ([], [])"",
            ""asyncio.FIRST_COMPLETED = 'FIRST_COMPLETED'"",
            ""asyncio.gather = lambda *coros, return_exceptions: asyncio.Future()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report: def done(self, src, status): pass; def failed(self, src, error): pass"",
            ""report = Report()"",
            ""class Changed(Enum): YES = 1; NO = 0; CACHED = 2"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): pass"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return False"",
            ""executor = None"",
            ""fast = False"",
            ""class MockFuture(asyncio.Future):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._result = False\n        self._exception = None"",
            ""asyncio.ensure_future = lambda coro: MockFuture()"",
            ""asyncio.Future = MockFuture"",
            ""loop.run_in_executor = lambda executor, func, *args: MockFuture()"",
            ""loop.add_signal_handler = lambda signum, func, *args: None"",
            ""signal.SIGINT = 2"",
            ""signal.SIGTERM = 15"",
            ""asyncio.wait = lambda futs, return_when: ([], [])"",
            ""asyncio.FIRST_COMPLETED = 'FIRST_COMPLETED'"",
            ""asyncio.gather = lambda *coros, return_exceptions: MockFuture().set_result([])""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report: def done(self, src, status): pass; def failed(self, src, error): pass"",
            ""report = Report()"",
            ""class Changed(Enum): YES = 1; NO = 0; CACHED = 2"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): pass"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return False"",
            ""executor = None"",
            ""fast = False"",
            ""Manager = Manager"",
            ""asyncio.ensure_future = asyncio.ensure_future"",
            ""loop.run_in_executor = loop.run_in_executor"",
            ""loop.add_signal_handler = loop.add_signal_handler"",
            ""signal.SIGINT = signal.SIGINT"",
            ""signal.SIGTERM = signal.SIGTERM"",
            ""asyncio.wait = asyncio.wait"",
            ""asyncio.FIRST_COMPLETED = asyncio.FIRST_COMPLETED"",
            ""asyncio.gather = asyncio.gather""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report: def done(self, src, status): pass; def failed(self, src, error): pass"",
            ""report = Report()"",
            ""class Changed(Enum): YES = 1; NO = 0; CACHED = 2"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): pass"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return False"",
            ""executor = None"",
            ""fast = False"",
            ""class Mock: pass"",
            ""asyncio.ensure_future = lambda coro: Mock()"",
            ""loop.run_in_executor = lambda executor, func, *args: asyncio.Future()"",
            ""loop.add_signal_handler = lambda signum, func, *args: None"",
            ""signal.SIGINT = 2"",
            ""signal.SIGTERM = 15"",
            ""asyncio.wait = asyncio.wait"",
            ""asyncio.FIRST_COMPLETED = asyncio.FIRST_COMPLETED"",
            ""asyncio.gather = asyncio.gather""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report: \n    def done(self, src, status): pass\n    def failed(self, src, error): pass"",
            ""report = Report()"",
            ""class Changed(Enum): YES = 1; NO = 0; CACHED = 2"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): pass"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return False"",
            ""executor = None"",
            ""fast = False"",
            ""class MockFuture(asyncio.Future):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.set_result(None)"",
            ""asyncio.ensure_future = lambda coro: MockFuture()"",
            ""loop.run_in_executor = lambda executor, func, *args: MockFuture()"",
            ""loop.add_signal_handler = lambda signum, func, *args: None"",
            ""signal.SIGINT = 2"",
            ""signal.SIGTERM = 15"",
            ""asyncio.wait = lambda futs, return_when: ([], [])"",
            ""asyncio.FIRST_COMPLETED = 'FIRST_COMPLETED'"",
            ""asyncio.gather = lambda *coros, return_exceptions: MockFuture()"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report: def done(self, src, status): pass; def failed(self, src, error): pass"",
            ""report = Report()"",
            ""class Changed(Enum): YES = 1; NO = 0; CACHED = 2"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): pass"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return False"",
            ""executor = None"",
            ""fast = False"",
            ""class Mock: pass"",
            ""asyncio.ensure_future = lambda coro: Mock()"",
            ""loop.run_in_executor = lambda executor, func, *args: asyncio.Future()"",
            ""loop.add_signal_handler = lambda signum, func, *args: None"",
            ""signal.SIGINT = 2"",
            ""signal.SIGTERM = 15"",
            ""asyncio.wait = lambda futs, return_when: ([], [])"",
            ""asyncio.FIRST_COMPLETED = 'FIRST_COMPLETED'"",
            ""asyncio.gather = lambda *coros, return_exceptions: asyncio.Future()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report: def done(self, src, status): pass; def failed(self, src, error): pass"",
            ""report = Report()"",
            ""class Changed(Enum): YES = 1; NO = 0; CACHED = 2"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): pass"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return False"",
            ""executor = None"",
            ""fast = False"",
            ""await asyncio.sleep(0)  # Needed to allow other tasks to run while waiting"",
            ""class MockFuture(asyncio.Future): async def ensure_future(coro): return MockFuture()"",
            ""asyncio.ensure_future = MockFuture.ensure_future"",
            ""loop.run_in_executor = lambda executor, func, *args: asyncio.ensure_future(func(*args))"",
            ""loop.add_signal_handler = lambda signum, func, *args: None"",
            ""signal.SIGINT = 2"",
            ""signal.SIGTERM = 15"",
            ""asyncio.wait = lambda futs, return_when: asyncio.ensure_future(MockFuture())"",
            ""asyncio.FIRST_COMPLETED = 'FIRST_COMPLETED'"",
            ""asyncio.gather = lambda *coros, return_exceptions: asyncio.ensure_future(MockFuture())""
        ]
    }
]","[
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): pass# pragma: no cover"",
            ""    def failed(self, src, error): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): YES = 1; NO = 0; CACHED = 2 # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return False # pragma: no cover"",
            ""executor = None # pragma: no cover"",
            ""fast = False # pragma: no cover"",
            ""class MockFuture(asyncio.Future):# pragma: no cover"",
            ""    def __init__(self, *args, **kwargs):# pragma: no cover"",
            ""        super().__init__(*args, **kwargs)# pragma: no cover"",
            ""        self.set_result(None) # pragma: no cover"",
            ""asyncio.ensure_future = lambda coro: MockFuture() # pragma: no cover"",
            ""loop.run_in_executor = lambda executor, func, *args: MockFuture() # pragma: no cover"",
            ""loop.add_signal_handler = lambda signum, func, *args: None # pragma: no cover"",
            ""signal.SIGINT = 2 # pragma: no cover"",
            ""signal.SIGTERM = 15 # pragma: no cover"",
            ""asyncio.wait = lambda futs, return_when: ([], []) # pragma: no cover"",
            ""asyncio.FIRST_COMPLETED = 'FIRST_COMPLETED' # pragma: no cover"",
            ""asyncio.gather = lambda *coros, return_exceptions: MockFuture() # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover""
        ]
    }
]",2,2820,0.00141,3891,0.0058365,0.0072464999999999
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 65:
              ^
SyntaxError: 'await' outside function
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            ""class WriteBack(Enum):\n    DIFF = 1\n    COLOR_DIFF = 2\n    YES = 3\n    CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode):\n    return {}"",
            ""mode = 'default_mode'"",
            ""def filter_cached(cache, sources):\n    return sources, []"",
            ""sources = ['file1.py', 'file2.py']"",
            ""class Report:\n    def done(self, src, status):\n        print(f'Report done: {src}, {status}')\n    def failed(self, src, error):\n        print(f'Report failed: {src}, {error}')"",
            ""report = Report()"",
            ""class Changed(Enum):\n    CACHED = 1\n    YES = 2\n    NO = 3"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending):\n    print('Cancelled')"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):\n    return True"",
            ""executor = ProcessPoolExecutor()"",
            ""fast = True"",
            ""asyncio.ensure_future = lambda coro: asyncio.ensure_future(coro)"",
            ""loop.run_in_executor = lambda executor, func, *args: asyncio.ensure_future(asyncio.get_event_loop().run_in_executor(executor, func, *args))"",
            ""loop.add_signal_handler = lambda signum, func, *args: None"",
            ""signal.SIGINT = signal.SIGINT"",
            ""signal.SIGTERM = signal.SIGTERM"",
            ""async def asyncio_wait(futs, return_when):\n    return await asyncio.wait(futs, return_when=return_when)"",
            ""asyncio.wait = asyncio_wait"",
            ""asyncio.FIRST_COMPLETED = 'FIRST_COMPLETED'"",
            ""async def asyncio_gather(*coros, return_exceptions=False):\n    return await asyncio.gather(*coros, return_exceptions=return_exceptions)"",
            ""asyncio.gather = asyncio_gather"",
            ""def write_cache(cache, sources_to_cache, mode):\n    print(f'Writing cache for {sources_to_cache}')""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack(Enum): DIFF = 'diff'; COLOR_DIFF = 'color_diff'; YES = 'yes'; CHECK = 'check'"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'default_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source_file1.py', 'source_file2.py']"",
            ""class Report:\n    def done(self, src, status): print(f'done: {src}, {status}')\n    def failed(self, src, msg): print(f'failed: {src}, {msg}')"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 'cached'; YES = 'yes'; NO = 'no'"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): pass"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""executor = None"",
            ""fast = False"",
            ""asyncio.ensure_future = lambda coro: asyncio.ensure_future(coro)"",
            ""loop.run_in_executor = lambda executor, func, *args: asyncio.ensure_future(func(*args))"",
            ""loop.add_signal_handler = lambda signum, func, *args: None"",
            ""signal.SIGINT = signal.SIGINT"",
            ""signal.SIGTERM = signal.SIGTERM"",
            ""asyncio.wait = asyncio.wait"",
            ""asyncio.FIRST_COMPLETED = asyncio.FIRST_COMPLETED"",
            ""asyncio.gather = asyncio.gather"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from unittest.mock import Mock""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack:\n    DIFF = 'diff'\n    COLOR_DIFF = 'color_diff'\n    YES = 'yes'\n    CHECK = 'check'\nwrite_back = WriteBack.DIFF"",
            ""def read_cache(mode):\n    return {}"",
            ""mode = 'default_mode'"",
            ""def filter_cached(cache, sources):\n    return sources, []"",
            ""sources = ['source_file1.py', 'source_file2.py']"",
            ""class Report:\n    def done(self, src, status):\n        print(f\""done: {src}, status: {status}\"")\n    def failed(self, src, error):\n        print(f\""failed: {src}, error: {error}\"")\nreport = Report()"",
            ""class Changed:\n    CACHED = 'cached'\n    YES = 'yes'\n    NO = 'no'"",
            ""Manager = Manager"",
            ""loop = asyncio.get_event_loop()"",
            ""cancel = lambda pending: None"",
            ""asyncio.ensure_future = lambda coro: asyncio.create_task(coro)"",
            ""loop.run_in_executor = lambda executor, func, *args: asyncio.create_task(func(*args))"",
            ""loop.add_signal_handler = lambda signum, func, *args: None"",
            ""signal.SIGINT = signal.SIGINT"",
            ""signal.SIGTERM = signal.SIGTERM"",
            ""asyncio.wait = asyncio.wait"",
            ""asyncio.FIRST_COMPLETED = asyncio.FIRST_COMPLETED"",
            ""asyncio.gather = asyncio.gather"",
            ""def write_cache(cache, sources_to_cache, mode):\n    print(f\""Cache written for sources: {sources_to_cache} in mode: {mode}\"")"",
            ""executor = ProcessPoolExecutor()"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):\n    await asyncio.sleep(0.1)\n    return True"",
            ""fast = True""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report: def done(self, src, status): pass; def failed(self, src, error): pass"",
            ""report = Report()"",
            ""class Changed(Enum): YES = 1; NO = 0; CACHED = 2"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): pass"",
            ""def format_file_in_place(src, fast, mode, write_back, lock): return False"",
            ""executor = ProcessPoolExecutor()"",
            ""fast = False"",
            ""asyncio_ensure_future = asyncio.ensure_future"",
            ""loop_run_in_executor = loop.run_in_executor"",
            ""loop_add_signal_handler = loop.add_signal_handler"",
            ""signal_SIGINT = signal.SIGINT"",
            ""signal_SIGTERM = signal.SIGTERM"",
            ""asyncio_wait = asyncio.wait"",
            ""asyncio_FIRST_COMPLETED = asyncio.FIRST_COMPLETED"",
            ""asyncio_gather = asyncio.gather"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report: def done(self, src, status): pass; def failed(self, src, error): pass"",
            ""report = Report()"",
            ""class Changed(Enum): YES = 'yes'; NO = 'no'; CACHED = 'cached'"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): pass"",
            ""def format_file_in_place(src, fast, mode, write_back, lock): return False"",
            ""executor = ProcessPoolExecutor()"",
            ""fast = False"",
            ""class Mock: pass"",
            ""asyncio.ensure_future = lambda coro: asyncio.ensure_future(coro)"",
            ""loop.run_in_executor = lambda executor, func, *args: asyncio.ensure_future(asyncio.to_thread(func, *args))"",
            ""loop.add_signal_handler = lambda signum, func, *args: None"",
            ""signal.SIGINT = signal.SIGINT"",
            ""signal.SIGTERM = signal.SIGTERM"",
            ""asyncio.wait = asyncio.wait"",
            ""asyncio.FIRST_COMPLETED = 'FIRST_COMPLETED'"",
            ""asyncio.gather = asyncio.gather"",
            ""def write_cache(cache, sources, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from unittest.mock import Mock"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack(Enum):\n    DIFF = 1\n    COLOR_DIFF = 2\n    YES = 3\n    CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'default_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source_file1.py', 'source_file2.py']"",
            ""report = Mock()\nreport.done = Mock()\nreport.failed = Mock()"",
            ""class Changed(Enum):\n    CACHED = 1\n    YES = 2\n    NO = 3"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): pass"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""executor = ProcessPoolExecutor()"",
            ""fast = True"",
            ""asyncio.ensure_future = asyncio.ensure_future"",
            ""loop.run_in_executor = loop.run_in_executor"",
            ""loop.add_signal_handler = loop.add_signal_handler"",
            ""signal.SIGINT = signal.SIGINT"",
            ""signal.SIGTERM = signal.SIGTERM"",
            ""asyncio.wait = asyncio.wait"",
            ""asyncio.FIRST_COMPLETED = asyncio.FIRST_COMPLETED"",
            ""asyncio.gather = asyncio.gather"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):\n    DIFF = 1\n    COLOR_DIFF = 2\n    YES = 3\n    CHECK = 4"",
            """",
            ""write_back = WriteBack.DIFF"",
            """",
            ""def read_cache(mode):\n    return {}"",
            """",
            ""mode = 'default_mode'"",
            """",
            ""def filter_cached(cache, sources):\n    return sources, []"",
            """",
            ""sources = ['source1.py', 'source2.py']"",
            """",
            ""class Report:\n    def done(self, src, status):\n        print(f\""done: {src}, status: {status}\"")\n    def failed(self, src, error):\n        print(f\""failed: {src}, error: {error}\"")"",
            """",
            ""report = Report()"",
            """",
            ""class Changed(Enum):\n    CACHED = 1\n    YES = 2\n    NO = 3"",
            """",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def cancel(pending):\n    print('Cancel called')"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):\n    return True"",
            """",
            ""executor = ProcessPoolExecutor()"",
            """",
            ""fast = True"",
            """",
            ""Manager = Manager"",
            """",
            ""asyncio.ensure_future = lambda coro: asyncio.create_task(coro)"",
            """",
            ""async def mock_run_in_executor(executor, func, *args):\n    loop = asyncio.get_event_loop()\n    return await loop.run_in_executor(executor, func, *args)"",
            """",
            ""loop.run_in_executor = mock_run_in_executor"",
            """",
            ""loop.add_signal_handler = lambda s, c, p: None"",
            """",
            ""signal.SIGINT = signal.SIGINT"",
            """",
            ""signal.SIGTERM = signal.SIGTERM"",
            """",
            ""asyncio.wait = asyncio.wait"",
            """",
            ""asyncio.FIRST_COMPLETED = asyncio.FIRST_COMPLETED"",
            """",
            ""asyncio.gather = asyncio.gather"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):\n    print(f\""Cache written for sources: {sources_to_cache} in mode: {mode}\"")""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1.py', 'source2.py']"",
            ""class Report: def done(self, src, status): pass; def failed(self, src, error): pass"",
            ""report = Report()"",
            ""class Changed(Enum): YES = 1; NO = 0; CACHED = 2"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): pass"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return False"",
            ""executor = ProcessPoolExecutor()"",
            ""fast = False"",
            ""class Mock: pass"",
            ""asyncio.ensure_future = lambda coro: asyncio.ensure_future(coro)"",
            ""loop.run_in_executor = lambda executor, func, *args: asyncio.ensure_future(func(*args))"",
            ""loop.add_signal_handler = lambda signum, func, *args: None"",
            ""signal.SIGINT = signal.SIGINT"",
            ""signal.SIGTERM = signal.SIGTERM"",
            ""asyncio.wait = asyncio.wait"",
            ""asyncio.FIRST_COMPLETED = asyncio.FIRST_COMPLETED"",
            ""asyncio.gather = asyncio.gather"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'default_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source_file1.py', 'source_file2.py']"",
            ""class Report: def done(self, src, status): pass; def failed(self, src, error): pass"",
            ""report = Report()"",
            ""class Changed(Enum): YES = 1; NO = 0; CACHED = 2"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): pass"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return False"",
            ""executor = ProcessPoolExecutor()"",
            ""fast = False"",
            ""Manager = Manager"",
            ""asyncio.ensure_future = lambda coro: asyncio.create_task(coro)"",
            ""loop.run_in_executor = lambda executor, func, *args: asyncio.Future()"",
            ""loop.add_signal_handler = lambda signum, func, *args: None"",
            ""signal.SIGINT = signal.SIGINT"",
            ""signal.SIGTERM = signal.SIGTERM"",
            ""asyncio.wait = asyncio.wait"",
            ""asyncio.FIRST_COMPLETED = asyncio.FIRST_COMPLETED"",
            ""asyncio.gather = asyncio.gather"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack(Enum):\n    DIFF = 'diff'\n    COLOR_DIFF = 'color_diff'\n    YES = 'yes'\n    CHECK = 'check'"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode):\n    return {}"",
            ""mode = 'default_mode'"",
            ""def filter_cached(cache, sources):\n    return sources, []"",
            ""sources = ['source_file1.py', 'source_file2.py']"",
            ""class Report:\n    def done(self, src, status):\n        pass\n    def failed(self, src, msg):\n        pass"",
            ""report = Report()"",
            ""class Changed(Enum):\n    CACHED = 'cached'\n    YES = 'yes'\n    NO = 'no'"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending):\n    pass"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):\n    return True"",
            ""executor = ProcessPoolExecutor()"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode):\n    pass"",
            ""asyncio.ensure_future = lambda coro: asyncio.ensure_future(coro)"",
            ""loop.run_in_executor = lambda executor, func, *args: asyncio.ensure_future(asyncio.to_thread(func, *args))"",
            ""loop.add_signal_handler = lambda signum, func, *args: None"",
            ""signal.SIGINT = signal.SIGINT"",
            ""signal.SIGTERM = signal.SIGTERM"",
            ""asyncio.wait = asyncio.wait"",
            ""asyncio.FIRST_COMPLETED = asyncio.FIRST_COMPLETED"",
            ""asyncio.gather = asyncio.gather""
        ]
    }
]","[
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            ""class WriteBack(Enum):# pragma: no cover"",
            ""    DIFF = 1# pragma: no cover"",
            ""    COLOR_DIFF = 2# pragma: no cover"",
            ""    YES = 3# pragma: no cover"",
            ""    CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode):# pragma: no cover"",
            ""    return {} # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources):# pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, status):# pragma: no cover"",
            ""        print(f'Report done: {src}, {status}')# pragma: no cover"",
            ""    def failed(self, src, error):# pragma: no cover"",
            ""        print(f'Report failed: {src}, {error}') # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum):# pragma: no cover"",
            ""    CACHED = 1# pragma: no cover"",
            ""    YES = 2# pragma: no cover"",
            ""    NO = 3 # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""def cancel(pending):# pragma: no cover"",
            ""    print('Cancelled') # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):# pragma: no cover"",
            ""    return True # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""asyncio.ensure_future = lambda coro: asyncio.ensure_future(coro) # pragma: no cover"",
            ""loop.run_in_executor = lambda executor, func, *args: asyncio.ensure_future(asyncio.get_event_loop().run_in_executor(executor, func, *args)) # pragma: no cover"",
            ""loop.add_signal_handler = lambda signum, func, *args: None # pragma: no cover"",
            ""signal.SIGINT = signal.SIGINT # pragma: no cover"",
            ""signal.SIGTERM = signal.SIGTERM # pragma: no cover"",
            ""async def asyncio_wait(futs, return_when):# pragma: no cover"",
            ""    return await asyncio.wait(futs, return_when=return_when) # pragma: no cover"",
            ""asyncio.wait = asyncio_wait # pragma: no cover"",
            ""asyncio.FIRST_COMPLETED = 'FIRST_COMPLETED' # pragma: no cover"",
            ""async def asyncio_gather(*coros, return_exceptions=False):# pragma: no cover"",
            ""    return await asyncio.gather(*coros, return_exceptions=return_exceptions) # pragma: no cover"",
            ""asyncio.gather = asyncio_gather # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode):# pragma: no cover"",
            ""    print(f'Writing cache for {sources_to_cache}') # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 'diff'; COLOR_DIFF = 'color_diff'; YES = 'yes'; CHECK = 'check' # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source_file1.py', 'source_file2.py'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, status): print(f'done: {src}, {status}')# pragma: no cover"",
            ""    def failed(self, src, msg): print(f'failed: {src}, {msg}') # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): CACHED = 'cached'; YES = 'yes'; NO = 'no' # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True # pragma: no cover"",
            ""executor = None # pragma: no cover"",
            ""fast = False # pragma: no cover"",
            ""asyncio.ensure_future = lambda coro: asyncio.ensure_future(coro) # pragma: no cover"",
            ""loop.run_in_executor = lambda executor, func, *args: asyncio.ensure_future(func(*args)) # pragma: no cover"",
            ""loop.add_signal_handler = lambda signum, func, *args: None # pragma: no cover"",
            ""signal.SIGINT = signal.SIGINT # pragma: no cover"",
            ""signal.SIGTERM = signal.SIGTERM # pragma: no cover"",
            ""asyncio.wait = asyncio.wait # pragma: no cover"",
            ""asyncio.FIRST_COMPLETED = asyncio.FIRST_COMPLETED # pragma: no cover"",
            ""asyncio.gather = asyncio.gather # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack:# pragma: no cover"",
            ""    DIFF = 'diff'# pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff'# pragma: no cover"",
            ""    YES = 'yes'# pragma: no cover"",
            ""    CHECK = 'check'# pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode):# pragma: no cover"",
            ""    return {} # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources):# pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            ""sources = ['source_file1.py', 'source_file2.py'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, status):# pragma: no cover"",
            ""        print(f\""done: {src}, status: {status}\"")# pragma: no cover"",
            ""    def failed(self, src, error):# pragma: no cover"",
            ""        print(f\""failed: {src}, error: {error}\"")# pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed:# pragma: no cover"",
            ""    CACHED = 'cached'# pragma: no cover"",
            ""    YES = 'yes'# pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""Manager = Manager # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""cancel = lambda pending: None # pragma: no cover"",
            ""asyncio.ensure_future = lambda coro: asyncio.create_task(coro) # pragma: no cover"",
            ""loop.run_in_executor = lambda executor, func, *args: asyncio.create_task(func(*args)) # pragma: no cover"",
            ""loop.add_signal_handler = lambda signum, func, *args: None # pragma: no cover"",
            ""signal.SIGINT = signal.SIGINT # pragma: no cover"",
            ""signal.SIGTERM = signal.SIGTERM # pragma: no cover"",
            ""asyncio.wait = asyncio.wait # pragma: no cover"",
            ""asyncio.FIRST_COMPLETED = asyncio.FIRST_COMPLETED # pragma: no cover"",
            ""asyncio.gather = asyncio.gather # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode):# pragma: no cover"",
            ""    print(f\""Cache written for sources: {sources_to_cache} in mode: {mode}\"") # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):# pragma: no cover"",
            ""    await asyncio.sleep(0.1)# pragma: no cover"",
            ""    return True # pragma: no cover"",
            ""fast = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack(Enum):# pragma: no cover"",
            ""    DIFF = 1# pragma: no cover"",
            ""    COLOR_DIFF = 2# pragma: no cover"",
            ""    YES = 3# pragma: no cover"",
            ""    CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source_file1.py', 'source_file2.py'] # pragma: no cover"",
            ""report = Mock()# pragma: no cover"",
            ""report.done = Mock()# pragma: no cover"",
            ""report.failed = Mock() # pragma: no cover"",
            ""class Changed(Enum):# pragma: no cover"",
            ""    CACHED = 1# pragma: no cover"",
            ""    YES = 2# pragma: no cover"",
            ""    NO = 3 # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""asyncio.ensure_future = asyncio.ensure_future # pragma: no cover"",
            ""loop.run_in_executor = loop.run_in_executor # pragma: no cover"",
            ""loop.add_signal_handler = loop.add_signal_handler # pragma: no cover"",
            ""signal.SIGINT = signal.SIGINT # pragma: no cover"",
            ""signal.SIGTERM = signal.SIGTERM # pragma: no cover"",
            ""asyncio.wait = asyncio.wait # pragma: no cover"",
            ""asyncio.FIRST_COMPLETED = asyncio.FIRST_COMPLETED # pragma: no cover"",
            ""asyncio.gather = asyncio.gather # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class WriteBack(Enum):# pragma: no cover"",
            ""    DIFF = 1# pragma: no cover"",
            ""    COLOR_DIFF = 2# pragma: no cover"",
            ""    YES = 3# pragma: no cover"",
            ""    CHECK = 4 # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode):# pragma: no cover"",
            ""    return {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources):# pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""sources = ['source1.py', 'source2.py'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, status):# pragma: no cover"",
            ""        print(f\""done: {src}, status: {status}\"")# pragma: no cover"",
            ""    def failed(self, src, error):# pragma: no cover"",
            ""        print(f\""failed: {src}, error: {error}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum):# pragma: no cover"",
            ""    CACHED = 1# pragma: no cover"",
            ""    YES = 2# pragma: no cover"",
            ""    NO = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending):# pragma: no cover"",
            ""    print('Cancel called') # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):# pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            "" # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            "" # pragma: no cover"",
            ""Manager = Manager # pragma: no cover"",
            "" # pragma: no cover"",
            ""asyncio.ensure_future = lambda coro: asyncio.create_task(coro) # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def mock_run_in_executor(executor, func, *args):# pragma: no cover"",
            ""    loop = asyncio.get_event_loop()# pragma: no cover"",
            ""    return await loop.run_in_executor(executor, func, *args) # pragma: no cover"",
            "" # pragma: no cover"",
            ""loop.run_in_executor = mock_run_in_executor # pragma: no cover"",
            "" # pragma: no cover"",
            ""loop.add_signal_handler = lambda s, c, p: None # pragma: no cover"",
            "" # pragma: no cover"",
            ""signal.SIGINT = signal.SIGINT # pragma: no cover"",
            "" # pragma: no cover"",
            ""signal.SIGTERM = signal.SIGTERM # pragma: no cover"",
            "" # pragma: no cover"",
            ""asyncio.wait = asyncio.wait # pragma: no cover"",
            "" # pragma: no cover"",
            ""asyncio.FIRST_COMPLETED = asyncio.FIRST_COMPLETED # pragma: no cover"",
            "" # pragma: no cover"",
            ""asyncio.gather = asyncio.gather # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode):# pragma: no cover"",
            ""    print(f\""Cache written for sources: {sources_to_cache} in mode: {mode}\"") # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1.py', 'source2.py'] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source_file1.py', 'source_file2.py'] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack(Enum):# pragma: no cover"",
            ""    DIFF = 'diff'# pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff'# pragma: no cover"",
            ""    YES = 'yes'# pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode):# pragma: no cover"",
            ""    return {} # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources):# pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            ""sources = ['source_file1.py', 'source_file2.py'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, status):# pragma: no cover"",
            ""        pass# pragma: no cover"",
            ""    def failed(self, src, msg):# pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum):# pragma: no cover"",
            ""    CACHED = 'cached'# pragma: no cover"",
            ""    YES = 'yes'# pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""def cancel(pending):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):# pragma: no cover"",
            ""    return True # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""asyncio.ensure_future = lambda coro: asyncio.ensure_future(coro) # pragma: no cover"",
            ""loop.run_in_executor = lambda executor, func, *args: asyncio.ensure_future(asyncio.to_thread(func, *args)) # pragma: no cover"",
            ""loop.add_signal_handler = lambda signum, func, *args: None # pragma: no cover"",
            ""signal.SIGINT = signal.SIGINT # pragma: no cover"",
            ""signal.SIGTERM = signal.SIGTERM # pragma: no cover"",
            ""asyncio.wait = asyncio.wait # pragma: no cover"",
            ""asyncio.FIRST_COMPLETED = asyncio.FIRST_COMPLETED # pragma: no cover"",
            ""asyncio.gather = asyncio.gather # pragma: no cover""
        ]
    }
]",2,3432,0.001716,4359,0.0065385,0.0082545
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 63:
              ^
SyntaxError: 'await' outside function
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from unittest.mock import Mock""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack(Mock): DIFF = 'diff'; COLOR_DIFF = 'color_diff'; YES = 'yes'; CHECK = 'check'"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source_file1.py', 'source_file2.py']"",
            ""class Report(Mock): def done(self, src, status): print(f'done: {src}, status: {status}'); def failed(self, src, error): print(f'failed: {src}, error: {error}')"",
            ""report = Report()"",
            ""class Changed(Mock): CACHED = 'cached'; YES = 'yes'; NO = 'no'"",
            ""Manager = Manager"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): print('Cancel called')"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""executor = ProcessPoolExecutor()"",
            ""fast = True"",
            ""asyncio.ensure_future = asyncio.ensure_future"",
            ""loop.run_in_executor = loop.run_in_executor"",
            ""loop.add_signal_handler = loop.add_signal_handler"",
            ""signal.SIGINT = signal.SIGINT"",
            ""signal.SIGTERM = signal.SIGTERM"",
            ""asyncio.wait = asyncio.wait"",
            ""asyncio.FIRST_COMPLETED = asyncio.FIRST_COMPLETED"",
            ""asyncio.gather = asyncio.gather"",
            ""def write_cache(cache, sources_to_cache, mode): print(f'write_cache called with {cache}, {sources_to_cache}, {mode}')""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'default_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source_file1.py', 'source_file2.py']"",
            ""class Report:\n    def done(self, src, status): pass\n    def failed(self, src, error): pass"",
            ""report = Report()"",
            ""class Changed(Enum): YES = 1; NO = 0; CACHED = 2"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): pass"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return False"",
            ""executor = ProcessPoolExecutor()"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'default_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source_file1', 'source_file2']"",
            ""report = type('Report', (object,), {'done': lambda src, status: None, 'failed': lambda src, msg: None})()"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): pass"",
            ""asyncio.ensure_future = asyncio.create_task"",
            ""executor = ProcessPoolExecutor()"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass"",
            ""async def main():"",
            ""    cache: Cache = {}"",
            ""    if write_back not in (WriteBack.DIFF, WriteBack.COLOR_DIFF):"",
            ""        cache = read_cache(mode)"",
            ""        sources, cached = filter_cached(cache, sources)"",
            ""        for src in sorted(cached):"",
            ""            report.done(src, Changed.CACHED)"",
            ""    if not sources:"",
            ""        exit()"",
            ""    cancelled = []"",
            ""    sources_to_cache = []"",
            ""    lock = None"",
            ""    if write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF):"",
            ""        manager = Manager()"",
            ""        lock = manager.Lock()"",
            ""    tasks = {"",
            ""        asyncio.ensure_future("",
            ""            loop.run_in_executor("",
            ""                executor, format_file_in_place, src, fast, mode, write_back, lock"",
            ""            )"",
            ""        ): src"",
            ""        for src in sorted(sources)"",
            ""    }"",
            ""    pending = tasks.keys()"",
            ""    try:"",
            ""        loop.add_signal_handler(signal.SIGINT, cancel, pending)"",
            ""        loop.add_signal_handler(signal.SIGTERM, cancel, pending)"",
            ""    except NotImplementedError:"",
            ""        pass"",
            ""    while pending:"",
            ""        done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)"",
            ""        for task in done:"",
            ""            src = tasks.pop(task)"",
            ""            if task.cancelled():"",
            ""                cancelled.append(task)"",
            ""            elif task.exception():"",
            ""                report.failed(src, str(task.exception()))"",
            ""            else:"",
            ""                changed = Changed.YES if task.result() else Changed.NO"",
            ""                if write_back is WriteBack.YES or ("",
            ""                    write_back is WriteBack.CHECK and changed is Changed.NO"",
            ""                ):"",
            ""                    sources_to_cache.append(src)"",
            ""                report.done(src, changed)"",
            ""    if cancelled:"",
            ""        await asyncio.gather(*cancelled, return_exceptions=True)"",
            ""    if sources_to_cache:"",
            ""        write_cache(cache, sources_to_cache, mode)"",
            ""asyncio.run(main())""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):\n    DIFF = 1\n    COLOR_DIFF = 2\n    YES = 3\n    CHECK = 4"",
            """",
            ""write_back = WriteBack.DIFF"",
            """",
            ""def read_cache(mode):\n    return {}"",
            """",
            ""mode = 'default_mode'"",
            """",
            ""def filter_cached(cache, sources):\n    return sources, []"",
            """",
            ""sources = ['file1.py', 'file2.py']"",
            """",
            ""class Report:\n    def done(self, src, status): pass\n    def failed(self, src, error): pass"",
            """",
            ""report = Report()"",
            """",
            ""class Changed(Enum):\n    CACHED = 1\n    YES = 2\n    NO = 3"",
            """",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def cancel(pending): pass"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):\n    return True"",
            """",
            ""executor = ProcessPoolExecutor()"",
            """",
            ""fast = True"",
            """",
            ""async def main_snippet():"",
            ""    cache: Cache = {}"",
            ""    if write_back not in (WriteBack.DIFF, WriteBack.COLOR_DIFF):"",
            ""        cache = read_cache(mode)"",
            ""        sources, cached = filter_cached(cache, sources)"",
            ""        for src in sorted(cached):"",
            ""            report.done(src, Changed.CACHED)"",
            ""    if not sources:"",
            ""        exit()"",
            ""    cancelled = []"",
            ""    sources_to_cache = []"",
            ""    lock = None"",
            ""    if write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF):"",
            ""        manager = Manager()"",
            ""        lock = manager.Lock()"",
            ""    tasks = {"",
            ""        asyncio.ensure_future("",
            ""            loop.run_in_executor("",
            ""                executor, format_file_in_place, src, fast, mode, write_back, lock"",
            ""            )"",
            ""        ): src"",
            ""        for src in sorted(sources)"",
            ""    }"",
            ""    pending = tasks.keys()"",
            ""    try:"",
            ""        loop.add_signal_handler(signal.SIGINT, cancel, pending)"",
            ""        loop.add_signal_handler(signal.SIGTERM, cancel, pending)"",
            ""    except NotImplementedError:"",
            ""        pass"",
            ""    while pending:"",
            ""        done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)"",
            ""        for task in done:"",
            ""            src = tasks.pop(task)"",
            ""            if task.cancelled():"",
            ""                cancelled.append(task)"",
            ""            elif task.exception():"",
            ""                report.failed(src, str(task.exception()))"",
            ""            else:"",
            ""                changed = Changed.YES if task.result() else Changed.NO"",
            ""                if write_back is WriteBack.YES or ("",
            ""                    write_back is WriteBack.CHECK and changed is Changed.NO"",
            ""                ):"",
            ""                    sources_to_cache.append(src)"",
            ""                report.done(src, changed)"",
            ""    if cancelled:"",
            ""        await asyncio.gather(*cancelled, return_exceptions=True)"",
            ""    if sources_to_cache:"",
            ""        write_cache(cache, sources_to_cache, mode)"",
            """",
            ""asyncio.run(main_snippet())""
        ]
    },
    {
        ""imports"": [
            ""from multiprocessing import Manager"",
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):\n    DIFF = 'diff'\n    COLOR_DIFF = 'color_diff'\n    YES = 'yes'\n    CHECK = 'check'"",
            """",
            ""write_back = WriteBack.DIFF"",
            """",
            ""def read_cache(mode):\n    return {}"",
            """",
            ""mode = 'some_mode'"",
            """",
            ""def filter_cached(cache, sources):\n    return sources, []"",
            """",
            ""sources = ['source_file1.py', 'source_file2.py']"",
            """",
            ""class Report:\n    def done(self, src, status):\n        print(f'done: {src}, status: {status}')\n    def failed(self, src, error):\n        print(f'failed: {src}, error: {error}')"",
            """",
            ""report = Report()"",
            """",
            ""class Changed(Enum):\n    CACHED = 'cached'\n    YES = 'yes'\n    NO = 'no'"",
            """",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def cancel(pending):\n    print('Cancel called')"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):\n    return True"",
            """",
            ""executor = ProcessPoolExecutor()"",
            """",
            ""fast = True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):\n    print(f'Cache written for sources: {sources_to_cache} in mode: {mode}')""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            ""class WriteBack(Enum):\n    DIFF = 1\n    COLOR_DIFF = 2\n    YES = 3\n    CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode):\n    return {}"",
            ""mode = 'default_mode'"",
            ""def filter_cached(cache, sources):\n    return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report:\n    def done(self, src, status):\n        print(f'done: {src}, status: {status}')\n    def failed(self, src, error):\n        print(f'failed: {src}, error: {error}')"",
            ""report = Report()"",
            ""class Changed(Enum):\n    CACHED = 1\n    YES = 2\n    NO = 0"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending):\n    print('Cancel called')"",
            ""def format_file_in_place(src, fast, mode, write_back, lock):\n    return False"",
            ""executor = None"",
            ""fast = False"",
            ""def write_cache(cache, sources_to_cache, mode):\n    print(f'Cache written for sources: {sources_to_cache} in mode: {mode}')""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack:\n    DIFF = 'DIFF'\n    COLOR_DIFF = 'COLOR_DIFF'\n    YES = 'YES'\n    CHECK = 'CHECK'"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'default_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source_file1.py', 'source_file2.py']"",
            ""class Report:\n    def done(self, src, status): pass\n    def failed(self, src, msg): pass"",
            ""report = Report()"",
            ""class Changed:\n    CACHED = 'CACHED'\n    YES = 'YES'\n    NO = 'NO'"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): pass"",
            ""asyncio.ensure_future = asyncio.create_task"",
            ""executor = None"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return False"",
            ""fast = False"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack(Enum):\n    DIFF = 'diff'\n    COLOR_DIFF = 'color_diff'\n    YES = 'yes'\n    CHECK = 'check'"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'default_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source_file1.py', 'source_file2.py']"",
            ""class Report:\n    def done(self, src, status): print(f\""Done: {src} -> {status}\"")\n    def failed(self, src, error): print(f\""Failed: {src} -> {error}\"")"",
            ""report = Report()"",
            ""class Changed(Enum):\n    CACHED = 'cached'\n    YES = 'yes'\n    NO = 'no'"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): pass"",
            ""asyncio.ensure_future = asyncio.create_task"",
            ""executor = ProcessPoolExecutor()"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return False"",
            ""fast = False"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""from concurrent.futures import ProcessPoolExecutor""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'default_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report: def done(self, src, status): pass; def failed(self, src, error): pass"",
            ""report = Report()"",
            ""class Changed(Enum): YES = 1; NO = 0; CACHED = 2"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): pass"",
            ""asyncio.ensure_future = asyncio.create_task"",
            ""executor = ProcessPoolExecutor()"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack(Enum):\n    DIFF = 1\n    COLOR_DIFF = 2\n    YES = 3\n    CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode):\n    return {}"",
            ""mode = 'default_mode'"",
            ""def filter_cached(cache, sources):\n    return sources, []"",
            ""sources = ['source1.py', 'source2.py']"",
            ""class Report:\n    def done(self, src, status):\n        print(f'Done: {src}, Status: {status}')\n    def failed(self, src, error):\n        print(f'Failed: {src}, Error: {error}')"",
            ""report = Report()"",
            ""class Changed(Enum):\n    YES = 1\n    NO = 0\n    CACHED = 2"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending):\n    print('Cancel called')"",
            ""def format_file_in_place(src, fast, mode, write_back, lock):\n    return False"",
            ""executor = ProcessPoolExecutor()"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode):\n    print(f'Cache written for sources: {sources_to_cache} in mode: {mode}')""
        ]
    }
]","[
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack(Mock): DIFF = 'diff'; COLOR_DIFF = 'color_diff'; YES = 'yes'; CHECK = 'check' # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source_file1.py', 'source_file2.py'] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source_file1.py', 'source_file2.py'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, status): pass# pragma: no cover"",
            ""    def failed(self, src, error): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): YES = 1; NO = 0; CACHED = 2 # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return False # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from multiprocessing import Manager # pragma: no cover"",
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class WriteBack(Enum):# pragma: no cover"",
            ""    DIFF = 'diff'# pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff'# pragma: no cover"",
            ""    YES = 'yes'# pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode):# pragma: no cover"",
            ""    return {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources):# pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""sources = ['source_file1.py', 'source_file2.py'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, status):# pragma: no cover"",
            ""        print(f'done: {src}, status: {status}')# pragma: no cover"",
            ""    def failed(self, src, error):# pragma: no cover"",
            ""        print(f'failed: {src}, error: {error}') # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum):# pragma: no cover"",
            ""    CACHED = 'cached'# pragma: no cover"",
            ""    YES = 'yes'# pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            "" # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending):# pragma: no cover"",
            ""    print('Cancel called') # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):# pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            "" # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode):# pragma: no cover"",
            ""    print(f'Cache written for sources: {sources_to_cache} in mode: {mode}') # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            ""class WriteBack(Enum):# pragma: no cover"",
            ""    DIFF = 1# pragma: no cover"",
            ""    COLOR_DIFF = 2# pragma: no cover"",
            ""    YES = 3# pragma: no cover"",
            ""    CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode):# pragma: no cover"",
            ""    return {} # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources):# pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, status):# pragma: no cover"",
            ""        print(f'done: {src}, status: {status}')# pragma: no cover"",
            ""    def failed(self, src, error):# pragma: no cover"",
            ""        print(f'failed: {src}, error: {error}') # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum):# pragma: no cover"",
            ""    CACHED = 1# pragma: no cover"",
            ""    YES = 2# pragma: no cover"",
            ""    NO = 0 # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""def cancel(pending):# pragma: no cover"",
            ""    print('Cancel called') # pragma: no cover"",
            ""def format_file_in_place(src, fast, mode, write_back, lock):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""executor = None # pragma: no cover"",
            ""fast = False # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode):# pragma: no cover"",
            ""    print(f'Cache written for sources: {sources_to_cache} in mode: {mode}') # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack:# pragma: no cover"",
            ""    DIFF = 'DIFF'# pragma: no cover"",
            ""    COLOR_DIFF = 'COLOR_DIFF'# pragma: no cover"",
            ""    YES = 'YES'# pragma: no cover"",
            ""    CHECK = 'CHECK' # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source_file1.py', 'source_file2.py'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, status): pass# pragma: no cover"",
            ""    def failed(self, src, msg): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed:# pragma: no cover"",
            ""    CACHED = 'CACHED'# pragma: no cover"",
            ""    YES = 'YES'# pragma: no cover"",
            ""    NO = 'NO' # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""asyncio.ensure_future = asyncio.create_task # pragma: no cover"",
            ""executor = None # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return False # pragma: no cover"",
            ""fast = False # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack(Enum):# pragma: no cover"",
            ""    DIFF = 'diff'# pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff'# pragma: no cover"",
            ""    YES = 'yes'# pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source_file1.py', 'source_file2.py'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, status): print(f\""Done: {src} -> {status}\"")# pragma: no cover"",
            ""    def failed(self, src, error): print(f\""Failed: {src} -> {error}\"") # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum):# pragma: no cover"",
            ""    CACHED = 'cached'# pragma: no cover"",
            ""    YES = 'yes'# pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""asyncio.ensure_future = asyncio.create_task # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return False # pragma: no cover"",
            ""fast = False # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack(Enum):# pragma: no cover"",
            ""    DIFF = 1# pragma: no cover"",
            ""    COLOR_DIFF = 2# pragma: no cover"",
            ""    YES = 3# pragma: no cover"",
            ""    CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode):# pragma: no cover"",
            ""    return {} # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources):# pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            ""sources = ['source1.py', 'source2.py'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, status):# pragma: no cover"",
            ""        print(f'Done: {src}, Status: {status}')# pragma: no cover"",
            ""    def failed(self, src, error):# pragma: no cover"",
            ""        print(f'Failed: {src}, Error: {error}') # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum):# pragma: no cover"",
            ""    YES = 1# pragma: no cover"",
            ""    NO = 0# pragma: no cover"",
            ""    CACHED = 2 # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""def cancel(pending):# pragma: no cover"",
            ""    print('Cancel called') # pragma: no cover"",
            ""def format_file_in_place(src, fast, mode, write_back, lock):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode):# pragma: no cover"",
            ""    print(f'Cache written for sources: {sources_to_cache} in mode: {mode}') # pragma: no cover""
        ]
    }
]",2,4002,0.002001,4274,0.006411,0.008412
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 66:
              ^
SyntaxError: 'await' outside function
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):\n    DIFF = 1\n    COLOR_DIFF = 2\n    YES = 3\n    CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            """",
            ""def read_cache(mode):\n    return {}"",
            """",
            ""mode = 'some_mode'"",
            """",
            ""def filter_cached(cache, sources):\n    return sources, []"",
            """",
            ""sources = ['source1', 'source2']"",
            """",
            ""class Report:\n    def done(self, src, change): pass\n    def failed(self, src, msg): pass"",
            ""report = Report()"",
            """",
            ""class Changed(Enum):\n    CACHED = 1\n    YES = 2\n    NO = 3"",
            """",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def cancel(pending):\n    pass"",
            """",
            ""asyncio.ensure_future = asyncio.create_task"",
            """",
            ""executor = None"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):\n    return True"",
            """",
            ""fast = True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):\n    pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""from concurrent.futures import ProcessPoolExecutor""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):\n    DIFF = 1\n    COLOR_DIFF = 2\n    YES = 3\n    CHECK = 4"",
            """",
            ""write_back = WriteBack.DIFF"",
            """",
            ""def read_cache(mode):\n    return {}"",
            """",
            ""mode = 'some_mode'"",
            """",
            ""def filter_cached(cache, sources):\n    return sources, []"",
            """",
            ""sources = ['source1', 'source2']"",
            """",
            ""class Report:\n    def done(self, src, change): pass\n    def failed(self, src, msg): pass"",
            """",
            ""report = Report()"",
            """",
            ""class Changed(Enum):\n    CACHED = 1\n    YES = 2\n    NO = 3"",
            """",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def cancel(pending): pass"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):\n    return True"",
            """",
            ""executor = ProcessPoolExecutor()"",
            """",
            ""fast = True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):\n    pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack(Enum):\n    DIFF = 'diff'\n    COLOR_DIFF = 'color_diff'\n    YES = 'yes'\n    CHECK = 'check'"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'default_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1.py', 'source2.py']"",
            ""class Report:\n    def done(self, src, status): print(f'done: {src}, status: {status}')\n    def failed(self, src, error): print(f'failed: {src}, error: {error}')"",
            ""report = Report()"",
            ""class Changed(Enum):\n    CACHED = 'cached'\n    YES = 'yes'\n    NO = 'no'"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): pass"",
            ""executor = Manager().Pool()"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): print(f'Cache updated for mode {mode}')""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):\n    DIFF = 1\n    COLOR_DIFF = 2\n    YES = 3\n    CHECK = 4"",
            """",
            ""write_back = WriteBack.DIFF"",
            """",
            ""def read_cache(mode):\n    return {}"",
            """",
            ""mode = 'some_mode'"",
            """",
            ""def filter_cached(cache, sources):\n    return sources, []"",
            """",
            ""sources = ['source1', 'source2']"",
            """",
            ""class Report:\n    def done(self, src, change): pass\n    def failed(self, src, msg): pass"",
            """",
            ""report = Report()"",
            """",
            ""class Changed(Enum):\n    CACHED = 1\n    YES = 2\n    NO = 3"",
            """",
            ""def cancel(pending): pass"",
            """",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""executor = None"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):\n    return True"",
            """",
            ""fast = True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""from unittest.mock import Mock""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report:\n    def done(self, src, change): pass\n    def failed(self, src, msg): pass"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""executor = Mock()"",
            ""fast = True"",
            ""loop = asyncio.get_event_loop()"",
            ""signal = signal"",
            ""def cancel(pending): pass"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report:\n    def done(self, src, change): pass\n    def failed(self, src, msg): pass"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3"",
            ""def cancel(pending): pass"",
            ""loop = asyncio.new_event_loop()"",
            ""asyncio.set_event_loop(loop)"",
            ""executor = Manager().Pool()"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1.py', 'source2.py']"",
            ""class Report:\n    def done(self, src, change): pass\n    def failed(self, src, msg): pass"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3"",
            ""def cancel(pending): pass"",
            ""loop = asyncio.get_event_loop()"",
            ""executor = None"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1.py', 'source2.py']"",
            ""class Report:\n    def done(self, src, change): pass\n    def failed(self, src, msg): pass"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3"",
            ""def cancel(pending): pass"",
            ""loop = asyncio.get_event_loop()"",
            ""executor = None"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return False"",
            ""fast = False"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report:\n    def done(self, src, change): pass\n    def failed(self, src, msg): pass"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3"",
            ""def cancel(pending): pass"",
            ""loop = asyncio.get_event_loop()"",
            ""executor = None"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""from concurrent.futures import ProcessPoolExecutor""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'default_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report:\n    def done(self, src, change): pass\n    def failed(self, src, msg): pass"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): pass"",
            ""executor = ProcessPoolExecutor()"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    }
]","[
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class WriteBack(Enum):# pragma: no cover"",
            ""    DIFF = 1# pragma: no cover"",
            ""    COLOR_DIFF = 2# pragma: no cover"",
            ""    YES = 3# pragma: no cover"",
            ""    CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode):# pragma: no cover"",
            ""    return {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources):# pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, change): pass# pragma: no cover"",
            ""    def failed(self, src, msg): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum):# pragma: no cover"",
            ""    CACHED = 1# pragma: no cover"",
            ""    YES = 2# pragma: no cover"",
            ""    NO = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""asyncio.ensure_future = asyncio.create_task # pragma: no cover"",
            "" # pragma: no cover"",
            ""executor = None # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):# pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode):# pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class WriteBack(Enum):# pragma: no cover"",
            ""    DIFF = 1# pragma: no cover"",
            ""    COLOR_DIFF = 2# pragma: no cover"",
            ""    YES = 3# pragma: no cover"",
            ""    CHECK = 4 # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode):# pragma: no cover"",
            ""    return {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources):# pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, change): pass# pragma: no cover"",
            ""    def failed(self, src, msg): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum):# pragma: no cover"",
            ""    CACHED = 1# pragma: no cover"",
            ""    YES = 2# pragma: no cover"",
            ""    NO = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):# pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            "" # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode):# pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack(Enum):# pragma: no cover"",
            ""    DIFF = 'diff'# pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff'# pragma: no cover"",
            ""    YES = 'yes'# pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1.py', 'source2.py'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, status): print(f'done: {src}, status: {status}')# pragma: no cover"",
            ""    def failed(self, src, error): print(f'failed: {src}, error: {error}') # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum):# pragma: no cover"",
            ""    CACHED = 'cached'# pragma: no cover"",
            ""    YES = 'yes'# pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""executor = Manager().Pool() # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): print(f'Cache updated for mode {mode}') # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class WriteBack(Enum):# pragma: no cover"",
            ""    DIFF = 1# pragma: no cover"",
            ""    COLOR_DIFF = 2# pragma: no cover"",
            ""    YES = 3# pragma: no cover"",
            ""    CHECK = 4 # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode):# pragma: no cover"",
            ""    return {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources):# pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, change): pass# pragma: no cover"",
            ""    def failed(self, src, msg): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum):# pragma: no cover"",
            ""    CACHED = 1# pragma: no cover"",
            ""    YES = 2# pragma: no cover"",
            ""    NO = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""executor = None # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):# pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, change): pass# pragma: no cover"",
            ""    def failed(self, src, msg): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3 # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True # pragma: no cover"",
            ""executor = Mock() # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""signal = signal # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, change): pass# pragma: no cover"",
            ""    def failed(self, src, msg): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3 # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""loop = asyncio.new_event_loop() # pragma: no cover"",
            ""asyncio.set_event_loop(loop) # pragma: no cover"",
            ""executor = Manager().Pool() # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1.py', 'source2.py'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, change): pass# pragma: no cover"",
            ""    def failed(self, src, msg): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3 # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""executor = None # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1.py', 'source2.py'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, change): pass# pragma: no cover"",
            ""    def failed(self, src, msg): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3 # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""executor = None # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return False # pragma: no cover"",
            ""fast = False # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, change): pass# pragma: no cover"",
            ""    def failed(self, src, msg): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3 # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""executor = None # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, change): pass# pragma: no cover"",
            ""    def failed(self, src, msg): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3 # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    }
]",2,4555,0.0022775,2909,0.0043635,0.006641
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 66:
              ^
SyntaxError: 'await' outside function
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report: def done(self, src, status): pass; def failed(self, src, msg): pass"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3"",
            ""def cancel(pending): pass"",
            ""loop = asyncio.get_event_loop()"",
            ""executor = ProcessPoolExecutor()"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report:\n    def done(self, src, change): pass\n    def failed(self, src, msg): pass"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3"",
            ""def cancel(pending): pass"",
            ""loop = asyncio.get_event_loop()"",
            ""executor = None"",
            ""def format_file_in_place(src, fast, mode, write_back, lock): return False"",
            ""fast = False"",
            ""def write_cache(cache, sources_to_cache, mode): pass"",
            ""async def main():\n    await asyncio.sleep(0)"",
            ""task = loop.create_task(main())"",
            ""loop.run_until_complete(task)""
        ]
    },
    {
        ""imports"": [
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""import signal"",
            ""import asyncio"",
            ""from unittest.mock import Mock"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'default_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report:\n    def done(self, src, change): pass\n    def failed(self, src, msg): pass"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3"",
            ""def cancel(pending): pass"",
            ""loop = asyncio.get_event_loop()"",
            ""executor = ProcessPoolExecutor()"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass"",
            ""async def main():\n    cache = {} if write_back not in (WriteBack.DIFF, WriteBack.COLOR_DIFF) else read_cache(mode)\n    if write_back not in (WriteBack.DIFF, WriteBack.COLOR_DIFF):\n        cache = read_cache(mode)\n        sources, cached = filter_cached(cache, sources)\n        for src in sorted(cached):\n            report.done(src, Changed.CACHED)\n    if not sources: exit()\n    cancelled = []\n    sources_to_cache = []\n    lock = None\n    if write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF):\n        manager = Manager()\n        lock = manager.Lock()\n    tasks = {asyncio.ensure_future(loop.run_in_executor(executor, format_file_in_place, src, fast, mode, write_back, lock)): src for src in sorted(sources)}\n    pending = tasks.keys()\n    try:\n        loop.add_signal_handler(signal.SIGINT, cancel, pending)\n        loop.add_signal_handler(signal.SIGTERM, cancel, pending)\n    except NotImplementedError:\n        pass\n    while pending:\n        done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)\n        for task in done:\n            src = tasks.pop(task)\n            if task.cancelled():\n                cancelled.append(task)\n            elif task.exception():\n                report.failed(src, str(task.exception()))\n            else:\n                changed = Changed.YES if task.result() else Changed.NO\n                if write_back is WriteBack.YES or (write_back is WriteBack.CHECK and changed is Changed.NO):\n                    sources_to_cache.append(src)\n                report.done(src, changed)\n    if cancelled:\n        await asyncio.gather(*cancelled, return_exceptions=True)\n    if sources_to_cache:\n        write_cache(cache, sources_to_cache, mode)\n\nasyncio.run(main())""
        ]
    },
    {
        ""imports"": [
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""import signal"",
            ""import asyncio"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report:\n    def done(self, src, change): pass\n    def failed(self, src, msg): pass"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3"",
            ""def cancel(pending): pass"",
            ""loop = asyncio.get_event_loop()"",
            ""executor = ProcessPoolExecutor()"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""from concurrent.futures import ProcessPoolExecutor""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1.py', 'source2.py']"",
            ""class Report:\n    def done(self, src, change): pass\n    def failed(self, src, msg): pass"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): pass"",
            ""format_file_in_place = lambda src, fast, mode, write_back, lock: True"",
            ""executor = ProcessPoolExecutor()"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.YES"",
            ""def read_cache(mode): return {}"",
            ""mode = 'default_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1.py', 'source2.py']"",
            ""class Report:\n    def done(self, src, status): print(f'done: {src}, status: {status}')\n    def failed(self, src, error): print(f'failed: {src}, error: {error}')"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3"",
            ""Manager = Manager"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): pass"",
            ""asyncio.ensure_future = asyncio.create_task"",
            ""def write_cache(cache, sources_to_cache, mode): pass"",
            ""executor = ProcessPoolExecutor()"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""fast = True"",
            ""signal.SIGINT = signal.SIGINT"",
            ""signal.SIGTERM = signal.SIGTERM""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1.py', 'source2.py']"",
            ""class Report: def done(self, src, status): pass; def failed(self, src, msg): pass"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3"",
            ""def cancel(pending): pass"",
            ""loop = asyncio.get_event_loop()"",
            ""executor = ProcessPoolExecutor()"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""from concurrent.futures import ProcessPoolExecutor""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'default_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report:\n    def done(self, src, change): pass\n    def failed(self, src, msg): pass"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3"",
            ""def cancel(pending): pass"",
            ""loop = asyncio.get_event_loop()"",
            ""executor = ProcessPoolExecutor()"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from unittest.mock import Mock""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1.py', 'source2.py']"",
            ""class Report:\n    def done(self, src, change): pass\n    def failed(self, src, error): pass"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3"",
            ""def cancel(pending): pass"",
            ""loop = asyncio.get_event_loop()"",
            ""executor = ProcessPoolExecutor()"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass"",
            ""asyncio.ensure_future = asyncio.create_task"",
            ""loop.run_in_executor = Mock(return_value=asyncio.Future())"",
            ""loop.add_signal_handler = Mock()"",
            ""signal.SIGINT = signal.SIGINT"",
            ""signal.SIGTERM = signal.SIGTERM"",
            ""asyncio.wait = asyncio.wait"",
            ""asyncio.FIRST_COMPLETED = asyncio.FIRST_COMPLETED"",
            ""asyncio.gather = asyncio.gather""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report: def done(self, src, change): pass; def failed(self, src, msg): pass"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3"",
            ""def cancel(pending): pass"",
            ""loop = asyncio.get_event_loop()"",
            ""executor = ProcessPoolExecutor()"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    }
]","[
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, change): pass# pragma: no cover"",
            ""    def failed(self, src, msg): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3 # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""executor = None # pragma: no cover"",
            ""def format_file_in_place(src, fast, mode, write_back, lock): return False # pragma: no cover"",
            ""fast = False # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover"",
            ""async def main():# pragma: no cover"",
            ""    await asyncio.sleep(0) # pragma: no cover"",
            ""task = loop.create_task(main()) # pragma: no cover"",
            ""loop.run_until_complete(task) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""import asyncio # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, change): pass# pragma: no cover"",
            ""    def failed(self, src, msg): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3 # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover"",
            ""async def main():# pragma: no cover"",
            ""    cache = {} if write_back not in (WriteBack.DIFF, WriteBack.COLOR_DIFF) else read_cache(mode)# pragma: no cover"",
            ""    if write_back not in (WriteBack.DIFF, WriteBack.COLOR_DIFF):# pragma: no cover"",
            ""        cache = read_cache(mode)# pragma: no cover"",
            ""        sources, cached = filter_cached(cache, sources)# pragma: no cover"",
            ""        for src in sorted(cached):# pragma: no cover"",
            ""            report.done(src, Changed.CACHED)# pragma: no cover"",
            ""    cancelled = []# pragma: no cover"",
            ""    sources_to_cache = []# pragma: no cover"",
            ""    lock = None# pragma: no cover"",
            ""    if write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF):# pragma: no cover"",
            ""        manager = Manager()# pragma: no cover"",
            ""        lock = manager.Lock()# pragma: no cover"",
            ""    try:# pragma: no cover"",
            ""        pass"",
            ""    except NotImplementedError:# pragma: no cover"",
            ""        pass# pragma: no cover"",
            ""    if cancelled:# pragma: no cover"",
            ""        await asyncio.gather(*cancelled, return_exceptions=True)# pragma: no cover"",
            ""    if sources_to_cache:# pragma: no cover"",
            ""        write_cache(cache, sources_to_cache, mode)# pragma: no cover"",
            ""# pragma: no cover"",
            ""asyncio.run(main()) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""import asyncio # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, change): pass# pragma: no cover"",
            ""    def failed(self, src, msg): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3 # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1.py', 'source2.py'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, change): pass# pragma: no cover"",
            ""    def failed(self, src, msg): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3 # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""format_file_in_place = lambda src, fast, mode, write_back, lock: True # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1.py', 'source2.py'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, status): print(f'done: {src}, status: {status}')# pragma: no cover"",
            ""    def failed(self, src, error): print(f'failed: {src}, error: {error}') # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3 # pragma: no cover"",
            ""Manager = Manager # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""asyncio.ensure_future = asyncio.create_task # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""signal.SIGINT = signal.SIGINT # pragma: no cover"",
            ""signal.SIGTERM = signal.SIGTERM # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1.py', 'source2.py'] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, change): pass# pragma: no cover"",
            ""    def failed(self, src, msg): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3 # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1.py', 'source2.py'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, change): pass# pragma: no cover"",
            ""    def failed(self, src, error): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3 # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover"",
            ""asyncio.ensure_future = asyncio.create_task # pragma: no cover"",
            ""loop.run_in_executor = Mock(return_value=asyncio.Future()) # pragma: no cover"",
            ""loop.add_signal_handler = Mock() # pragma: no cover"",
            ""signal.SIGINT = signal.SIGINT # pragma: no cover"",
            ""signal.SIGTERM = signal.SIGTERM # pragma: no cover"",
            ""asyncio.wait = asyncio.wait # pragma: no cover"",
            ""asyncio.FIRST_COMPLETED = asyncio.FIRST_COMPLETED # pragma: no cover"",
            ""asyncio.gather = asyncio.gather # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover""
        ]
    }
]",2,5101,0.0025505,3378,0.005067,0.0076175
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 63:
              ^
SyntaxError: 'await' outside function
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report:\n    def done(self, src, change): pass\n    def failed(self, src, msg): pass"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3"",
            ""def cancel(pending): pass"",
            ""loop = asyncio.get_event_loop()"",
            ""executor = asyncio.get_event_loop().run_in_executor"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from unittest.mock import Mock"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report:\n    def done(self, src, change): pass\n    def failed(self, src, msg): pass"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3"",
            ""cancel = Mock()"",
            ""executor = Mock()"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass"",
            ""loop = asyncio.get_event_loop()"",
            ""asyncio.ensure_future = asyncio.create_task"",
            ""loop.run_in_executor = lambda executor, func, *args: asyncio.create_task(func(*args))"",
            ""loop.add_signal_handler = lambda signum, func, *args: None"",
            ""signal.SIGINT = signal.SIGINT"",
            ""signal.SIGTERM = signal.SIGTERM"",
            ""asyncio.wait = asyncio.wait"",
            ""asyncio.FIRST_COMPLETED = asyncio.FIRST_COMPLETED"",
            ""asyncio.gather = asyncio.gather""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report:\n    def done(self, src, change): pass\n    def failed(self, src, msg): pass"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3"",
            ""def cancel(pending): pass"",
            ""loop = asyncio.get_event_loop()"",
            ""executor = asyncio.get_event_loop().run_in_executor"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report:\n    def done(self, src, change): pass\n    def failed(self, src, msg): pass"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3"",
            ""def cancel(pending): pass"",
            ""loop = asyncio.get_event_loop()"",
            ""executor = None"",
            ""def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1.py', 'source2.py']"",
            ""class Report:\n    def done(self, src, change): pass\n    def failed(self, src, msg): pass"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3"",
            ""manager = Manager()"",
            ""lock = manager.Lock()"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): pass"",
            ""executor = asyncio.get_event_loop().run_in_executor(None, lambda: None)"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):\n    DIFF = 1\n    COLOR_DIFF = 2\n    YES = 3\n    CHECK = 4"",
            """",
            ""write_back = WriteBack.DIFF"",
            """",
            ""def read_cache(mode):\n    return {}"",
            """",
            ""mode = 'some_mode'"",
            """",
            ""def filter_cached(cache, sources):\n    return sources, []"",
            """",
            ""sources = ['file1.py', 'file2.py']"",
            """",
            ""class Report:\n    def done(self, src, status):\n        print(f\""done: {src}, status: {status}\"")\n    def failed(self, src, error):\n        print(f\""failed: {src}, error: {error}\"")"",
            """",
            ""report = Report()"",
            """",
            ""class Changed(Enum):\n    CACHED = 1\n    YES = 2\n    NO = 3"",
            """",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def cancel(pending):\n    print('Cancel called')"",
            """",
            ""executor = ProcessPoolExecutor()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):\n    return True"",
            """",
            ""fast = True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):\n    print(f\""Cache written for sources: {sources_to_cache} in mode: {mode}\"")"",
            """",
            ""signal = signal""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report:\n    def done(self, src, change): pass\n    def failed(self, src, msg): pass"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3"",
            ""def cancel(pending): pass"",
            ""loop = asyncio.get_event_loop()"",
            ""executor = Manager().Pool(4)"",
            ""def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""from concurrent.futures import ProcessPoolExecutor""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            ""class WriteBack(Enum):\n    DIFF = 'diff'\n    COLOR_DIFF = 'color_diff'\n    YES = 'yes'\n    CHECK = 'check'"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report:\n    def done(self, src, status): pass\n    def failed(self, src, error): pass"",
            ""report = Report()"",
            ""class Changed(Enum):\n    CACHED = 'cached'\n    YES = 'yes'\n    NO = 'no'"",
            ""def cancel(pending): pass"",
            ""loop = asyncio.get_event_loop()"",
            ""executor = ProcessPoolExecutor()"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report:\n    def done(self, src, change): pass\n    def failed(self, src, msg): pass"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3"",
            ""def cancel(pending): pass"",
            ""loop = asyncio.get_event_loop()"",
            ""executor = ProcessPoolExecutor()"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):\n    DIFF = 'diff'\n    COLOR_DIFF = 'color_diff'\n    YES = 'yes'\n    CHECK = 'check'"",
            """",
            ""write_back = WriteBack.DIFF"",
            """",
            ""def read_cache(mode):\n    return {}"",
            """",
            ""mode = 'default_mode'"",
            """",
            ""def filter_cached(cache, sources):\n    return sources, []"",
            """",
            ""sources = ['file1.py', 'file2.py']"",
            """",
            ""class Report:\n    def done(self, src, status):\n        print(f'{src} {status}')\n    def failed(self, src, error):\n        print(f'{src} {error}')"",
            """",
            ""report = Report()"",
            """",
            ""class Changed(Enum):\n    CACHED = 1\n    YES = 2\n    NO = 3"",
            """",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def cancel(pending):\n    pass"",
            """",
            ""executor = ProcessPoolExecutor()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):\n    return True"",
            """",
            ""fast = True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):\n    pass""
        ]
    }
]","[
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, change): pass# pragma: no cover"",
            ""    def failed(self, src, msg): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3 # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""executor = asyncio.get_event_loop().run_in_executor # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, change): pass# pragma: no cover"",
            ""    def failed(self, src, msg): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3 # pragma: no cover"",
            ""cancel = Mock() # pragma: no cover"",
            ""executor = Mock() # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""asyncio.ensure_future = asyncio.create_task # pragma: no cover"",
            ""loop.run_in_executor = lambda executor, func, *args: asyncio.create_task(func(*args)) # pragma: no cover"",
            ""loop.add_signal_handler = lambda signum, func, *args: None # pragma: no cover"",
            ""signal.SIGINT = signal.SIGINT # pragma: no cover"",
            ""signal.SIGTERM = signal.SIGTERM # pragma: no cover"",
            ""asyncio.wait = asyncio.wait # pragma: no cover"",
            ""asyncio.FIRST_COMPLETED = asyncio.FIRST_COMPLETED # pragma: no cover"",
            ""asyncio.gather = asyncio.gather # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, change): pass# pragma: no cover"",
            ""    def failed(self, src, msg): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3 # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""executor = asyncio.get_event_loop().run_in_executor # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, change): pass# pragma: no cover"",
            ""    def failed(self, src, msg): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3 # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""executor = None # pragma: no cover"",
            ""def format_file_in_place(src, fast, mode, write_back, lock): return True # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1.py', 'source2.py'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, change): pass# pragma: no cover"",
            ""    def failed(self, src, msg): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3 # pragma: no cover"",
            ""manager = Manager() # pragma: no cover"",
            ""lock = manager.Lock() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""executor = asyncio.get_event_loop().run_in_executor(None, lambda: None) # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class WriteBack(Enum):# pragma: no cover"",
            ""    DIFF = 1# pragma: no cover"",
            ""    COLOR_DIFF = 2# pragma: no cover"",
            ""    YES = 3# pragma: no cover"",
            ""    CHECK = 4 # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode):# pragma: no cover"",
            ""    return {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources):# pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, status):# pragma: no cover"",
            ""        print(f\""done: {src}, status: {status}\"")# pragma: no cover"",
            ""    def failed(self, src, error):# pragma: no cover"",
            ""        print(f\""failed: {src}, error: {error}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum):# pragma: no cover"",
            ""    CACHED = 1# pragma: no cover"",
            ""    YES = 2# pragma: no cover"",
            ""    NO = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending):# pragma: no cover"",
            ""    print('Cancel called') # pragma: no cover"",
            "" # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):# pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode):# pragma: no cover"",
            ""    print(f\""Cache written for sources: {sources_to_cache} in mode: {mode}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""signal = signal # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, change): pass# pragma: no cover"",
            ""    def failed(self, src, msg): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3 # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""executor = Manager().Pool(4) # pragma: no cover"",
            ""def format_file_in_place(src, fast, mode, write_back, lock): return True # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            ""class WriteBack(Enum):# pragma: no cover"",
            ""    DIFF = 'diff'# pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff'# pragma: no cover"",
            ""    YES = 'yes'# pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, status): pass# pragma: no cover"",
            ""    def failed(self, src, error): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum):# pragma: no cover"",
            ""    CACHED = 'cached'# pragma: no cover"",
            ""    YES = 'yes'# pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, change): pass# pragma: no cover"",
            ""    def failed(self, src, msg): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3 # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class WriteBack(Enum):# pragma: no cover"",
            ""    DIFF = 'diff'# pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff'# pragma: no cover"",
            ""    YES = 'yes'# pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode):# pragma: no cover"",
            ""    return {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources):# pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, status):# pragma: no cover"",
            ""        print(f'{src} {status}')# pragma: no cover"",
            ""    def failed(self, src, error):# pragma: no cover"",
            ""        print(f'{src} {error}') # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum):# pragma: no cover"",
            ""    CACHED = 1# pragma: no cover"",
            ""    YES = 2# pragma: no cover"",
            ""    NO = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):# pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode):# pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    }
]",2,5621,0.0028105,3069,0.0046035,0.007414
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 66:
              ^
SyntaxError: 'await' outside function
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            ""class WriteBack(Enum): DIFF = 'DIFF'; COLOR_DIFF = 'COLOR_DIFF'; YES = 'YES'; CHECK = 'CHECK'"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'default_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1.py', 'source2.py']"",
            ""class Report:\n    @staticmethod\n    def done(src, status): pass\n    @staticmethod\n    def failed(src, msg): pass"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 'CACHED'; YES = 'YES'; NO = 'NO'"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): pass"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""executor = None"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from unittest.mock import Mock"",
            ""from concurrent.futures import ProcessPoolExecutor""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack:\n    DIFF = 'diff'\n    COLOR_DIFF = 'color_diff'\n    YES = 'yes'\n    CHECK = 'check'"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report:\n    def done(self, src, status): pass\n    def failed(self, src, error): pass"",
            ""report = Report()"",
            ""class Changed:\n    CACHED = 'cached'\n    YES = 'yes'\n    NO = 'no'"",
            ""def cancel(pending): pass"",
            ""loop = asyncio.get_event_loop()"",
            ""asyncio.ensure_future = asyncio.create_task"",
            ""loop.run_in_executor = lambda executor, func, *args: asyncio.ensure_future(func(*args))"",
            ""loop.add_signal_handler = lambda *args: None"",
            ""signal.SIGINT = 2"",
            ""signal.SIGTERM = 15"",
            ""asyncio.wait = asyncio.wait"",
            ""asyncio.FIRST_COMPLETED = asyncio.FIRST_COMPLETED"",
            ""asyncio.gather = asyncio.gather"",
            ""executor = ProcessPoolExecutor()"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from unittest.mock import Mock"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack(Enum):\n    DIFF = 'DIFF'\n    COLOR_DIFF = 'COLOR_DIFF'\n    YES = 'YES'\n    CHECK = 'CHECK'"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'default_mode'"",
            ""def filter_cached(cache, sources): return (sources, [])"",
            ""sources = ['file1', 'file2']"",
            ""class Report:\n    def done(self, src, change): pass\n    def failed(self, src, msg): pass"",
            ""report = Report()"",
            ""class Changed(Enum):\n    CACHED = 'CACHED'\n    YES = 'YES'\n    NO = 'NO'"",
            ""def cancel(pending): pass"",
            ""loop = asyncio.get_event_loop()"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""executor = ProcessPoolExecutor()"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""from unittest.mock import Mock""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report:\n    def done(self, src, change): print(f'done({src}, {change})')\n    def failed(self, src, msg): print(f'failed({src}, {msg})')"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3"",
            ""def cancel(pending): pass"",
            ""loop = asyncio.get_event_loop()"",
            ""executor = ProcessPoolExecutor()"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass"",
            ""asyncio.ensure_future = lambda coro: asyncio.create_task(coro)"",
            ""asyncio.FIRST_COMPLETED = asyncio.tasks.FIRST_COMPLETED"",
            ""asyncio.wait = asyncio.tasks.wait"",
            ""asyncio.gather = asyncio.tasks.gather"",
            ""loop.run_in_executor = lambda executor, func, *args: asyncio.create_task(func(*args))"",
            ""loop.add_signal_handler = lambda sig, callback, *args: None""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'default_mode'"",
            ""def filter_cached(cache, sources): return (sources, [])"",
            ""sources = ['source1.py', 'source2.py']"",
            ""class Report:\n    def done(self, src, change): pass\n    def failed(self, src, msg): pass"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): pass"",
            ""executor = ProcessPoolExecutor()"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""Cache = dict"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'default_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['file1.py', 'file2.py']"",
            ""class Report:\n    def done(self, src, status): pass\n    def failed(self, src, msg): pass"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending): pass"",
            ""asyncio.ensure_future = asyncio.create_task"",
            ""executor = ProcessPoolExecutor()"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report:\n    def done(self, src, change): print(f'done: {src}, change: {change}')\n    def failed(self, src, msg): print(f'failed: {src}, msg: {msg}')"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3"",
            ""def cancel(pending): pass"",
            ""loop = asyncio.get_event_loop()"",
            ""executor = ProcessPoolExecutor()"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return False"",
            ""fast = False"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager""
        ],
        ""initialization"": [
            ""# Define necessary classes and mocks"",
            ""class Cache(dict): pass"",
            ""class WriteBack:\n    DIFF = 'diff'\n    COLOR_DIFF = 'color_diff'\n    YES = 'yes'\n    CHECK = 'check'"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode):\n    return {}"",
            ""mode = 'default_mode'"",
            ""def filter_cached(cache, sources):\n    return sources, []"",
            ""sources = ['source1.py', 'source2.py']"",
            ""class Report:\n    def done(self, src, change):\n        print(f\""{src} done with change {change}\"")\n    def failed(self, src, msg):\n        print(f\""{src} failed with msg {msg}\"")"",
            ""report = Report()"",
            ""class Changed:\n    CACHED = 'cached'\n    YES = 'yes'\n    NO = 'no'"",
            ""loop = asyncio.get_event_loop()"",
            ""def cancel(pending):\n    print(\""Cancelled\"")"",
            ""def write_cache(cache, sources_to_cache, mode):\n    print(f\""Cache written for {sources_to_cache} in mode {mode}\"")"",
            ""executor = ProcessPoolExecutor()"",
            ""def format_file_in_place(src, fast, mode, write_back, lock):\n    return True"",
            ""fast = True"",
            ""# Wrap the main code snippet inside an async function"",
            ""async def main():\n    cache: Cache = {}\n    if write_back not in (WriteBack.DIFF, WriteBack.COLOR_DIFF):\n        cache = read_cache(mode)\n        sources, cached = filter_cached(cache, sources)\n        for src in sorted(cached):\n            report.done(src, Changed.CACHED)\n    if not sources:\n        return\n\n    cancelled = []\n    sources_to_cache = []\n    lock = None\n    if write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF):\n        # For diff output, we need locks to ensure we don't interleave output\n        # from different processes.\n        manager = Manager()\n        lock = manager.Lock()\n    tasks = {\n        asyncio.ensure_future(\n            loop.run_in_executor(\n                executor, format_file_in_place, src, fast, mode, write_back, lock\n            )\n        ): src\n        for src in sorted(sources)\n    }\n    pending = tasks.keys()\n    try:\n        loop.add_signal_handler(signal.SIGINT, cancel, pending)\n        loop.add_signal_handler(signal.SIGTERM, cancel, pending)\n    except NotImplementedError:\n        # There are no good alternatives for these on Windows.\n        pass\n    while pending:\n        done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)\n        for task in done:\n            src = tasks.pop(task)\n            if task.cancelled():\n                cancelled.append(task)\n            elif task.exception():\n                report.failed(src, str(task.exception()))\n            else:\n                changed = Changed.YES if task.result() else Changed.NO\n                # If the file was written back or was successfully checked as\n                # well-formatted, store this information in the cache.\n                if write_back is WriteBack.YES or (\n                    write_back is WriteBack.CHECK and changed is Changed.NO\n                ):\n                    sources_to_cache.append(src)\n                report.done(src, changed)\n    if cancelled:\n        await asyncio.gather(*cancelled, return_exceptions=True)\n    if sources_to_cache:\n        write_cache(cache, sources_to_cache, mode)\n\n# Run the main coroutine"",
            ""if __name__ == '__main__':\n    asyncio.run(main())""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            ""class WriteBack(Enum): DIFF = 'DIFF'; COLOR_DIFF = 'COLOR_DIFF'; YES = 'YES'; CHECK = 'CHECK'"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report:\n    def done(self, src, status): pass\n    def failed(self, src, error): pass"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 'CACHED'; YES = 'YES'; NO = 'NO'"",
            ""loop = asyncio.new_event_loop()\nasyncio.set_event_loop(loop)"",
            ""def cancel(pending): pass"",
            ""def write_cache(cache, sources_to_cache, mode): pass"",
            ""executor = None"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return False"",
            ""fast = False""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode): return {}"",
            ""mode = 'some_mode'"",
            ""def filter_cached(cache, sources): return sources, []"",
            ""sources = ['source1', 'source2']"",
            ""class Report:\n    def done(self, src, change): pass\n    def failed(self, src, msg): pass"",
            ""report = Report()"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3"",
            ""def cancel(pending): pass"",
            ""loop = asyncio.get_event_loop()"",
            ""executor = lambda func, *args: func(*args)"",
            ""asyncio.ensure_future = asyncio.create_task"",
            ""def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            ""fast = True"",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    }
]","[
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 'DIFF'; COLOR_DIFF = 'COLOR_DIFF'; YES = 'YES'; CHECK = 'CHECK' # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1.py', 'source2.py'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    @staticmethod# pragma: no cover"",
            ""    def done(src, status): pass# pragma: no cover"",
            ""    @staticmethod# pragma: no cover"",
            ""    def failed(src, msg): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): CACHED = 'CACHED'; YES = 'YES'; NO = 'NO' # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True # pragma: no cover"",
            ""executor = None # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack:# pragma: no cover"",
            ""    DIFF = 'diff'# pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff'# pragma: no cover"",
            ""    YES = 'yes'# pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, status): pass# pragma: no cover"",
            ""    def failed(self, src, error): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed:# pragma: no cover"",
            ""    CACHED = 'cached'# pragma: no cover"",
            ""    YES = 'yes'# pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""asyncio.ensure_future = asyncio.create_task # pragma: no cover"",
            ""loop.run_in_executor = lambda executor, func, *args: asyncio.ensure_future(func(*args)) # pragma: no cover"",
            ""loop.add_signal_handler = lambda *args: None # pragma: no cover"",
            ""signal.SIGINT = 2 # pragma: no cover"",
            ""signal.SIGTERM = 15 # pragma: no cover"",
            ""asyncio.wait = asyncio.wait # pragma: no cover"",
            ""asyncio.FIRST_COMPLETED = asyncio.FIRST_COMPLETED # pragma: no cover"",
            ""asyncio.gather = asyncio.gather # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack(Enum):# pragma: no cover"",
            ""    DIFF = 'DIFF'# pragma: no cover"",
            ""    COLOR_DIFF = 'COLOR_DIFF'# pragma: no cover"",
            ""    YES = 'YES'# pragma: no cover"",
            ""    CHECK = 'CHECK' # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return (sources, []) # pragma: no cover"",
            ""sources = ['file1', 'file2'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, change): pass# pragma: no cover"",
            ""    def failed(self, src, msg): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum):# pragma: no cover"",
            ""    CACHED = 'CACHED'# pragma: no cover"",
            ""    YES = 'YES'# pragma: no cover"",
            ""    NO = 'NO' # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, change): print(f'done({src}, {change})')# pragma: no cover"",
            ""    def failed(self, src, msg): print(f'failed({src}, {msg})') # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3 # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover"",
            ""asyncio.ensure_future = lambda coro: asyncio.create_task(coro) # pragma: no cover"",
            ""asyncio.FIRST_COMPLETED = asyncio.tasks.FIRST_COMPLETED # pragma: no cover"",
            ""asyncio.wait = asyncio.tasks.wait # pragma: no cover"",
            ""asyncio.gather = asyncio.tasks.gather # pragma: no cover"",
            ""loop.run_in_executor = lambda executor, func, *args: asyncio.create_task(func(*args)) # pragma: no cover"",
            ""loop.add_signal_handler = lambda sig, callback, *args: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return (sources, []) # pragma: no cover"",
            ""sources = ['source1.py', 'source2.py'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, change): pass# pragma: no cover"",
            ""    def failed(self, src, msg): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3 # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""Cache = dict # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, status): pass# pragma: no cover"",
            ""    def failed(self, src, msg): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3 # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""asyncio.ensure_future = asyncio.create_task # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, change): print(f'done: {src}, change: {change}')# pragma: no cover"",
            ""    def failed(self, src, msg): print(f'failed: {src}, msg: {msg}') # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3 # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return False # pragma: no cover"",
            ""fast = False # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 'DIFF'; COLOR_DIFF = 'COLOR_DIFF'; YES = 'YES'; CHECK = 'CHECK' # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, status): pass# pragma: no cover"",
            ""    def failed(self, src, error): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): CACHED = 'CACHED'; YES = 'YES'; NO = 'NO' # pragma: no cover"",
            ""loop = asyncio.new_event_loop()# pragma: no cover"",
            ""asyncio.set_event_loop(loop) # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover"",
            ""executor = None # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return False # pragma: no cover"",
            ""fast = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            ""class WriteBack(Enum): DIFF = 1; COLOR_DIFF = 2; YES = 3; CHECK = 4 # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): return {} # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""def filter_cached(cache, sources): return sources, [] # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            ""class Report:# pragma: no cover"",
            ""    def done(self, src, change): pass# pragma: no cover"",
            ""    def failed(self, src, msg): pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""class Changed(Enum): CACHED = 1; YES = 2; NO = 3 # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""executor = lambda func, *args: func(*args) # pragma: no cover"",
            ""asyncio.ensure_future = asyncio.create_task # pragma: no cover"",
            ""def format_file_in_place(src, fast, mode, write_back, lock): return True # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    }
]",2,6237,0.0031185,3659,0.0054885,0.008607
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 92:
              ^
SyntaxError: 'await' outside function
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):"",
            ""    DIFF = auto()"",
            ""    COLOR_DIFF = auto()"",
            ""    YES = auto()"",
            ""    CHECK = auto()"",
            """",
            ""write_back = WriteBack.DIFF"",
            """",
            ""def read_cache(mode: str) -> Cache:"",
            ""    return Cache()"",
            """",
            ""mode = 'default_mode'"",
            """",
            ""def filter_cached(cache: Cache, sources): return sources, []"",
            """",
            ""sources = ['source1', 'source2']"",
            """",
            ""class Changed(Enum):"",
            ""    CACHED = auto()"",
            ""    YES = auto()"",
            ""    NO = auto()"",
            """",
            ""class Report:"",
            ""    def done(self, src, change): pass"",
            ""    def failed(self, src, msg): pass"",
            """",
            ""report = Report()"",
            """",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def cancel(pending): pass"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True"",
            """",
            ""executor = ProcessPoolExecutor()"",
            """",
            ""fast = True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode): pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import Any, Dict, List, Tuple"",
            ""from unittest.mock import Mock"",
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):"",
            ""    DIFF = auto()"",
            ""    COLOR_DIFF = auto()"",
            ""    YES = auto()"",
            ""    CHECK = auto()"",
            """",
            ""def read_cache(mode: str) -> Cache:"",
            ""    return Cache()"",
            """",
            ""mode = 'default_mode'"",
            """",
            ""def filter_cached(cache: Cache, sources: List[str]) -> Tuple[List[str], List[str]]:"",
            ""    return sources, []"",
            """",
            ""sources = ['source1', 'source2']"",
            """",
            ""class Changed(Enum):"",
            ""    CACHED = auto()"",
            ""    YES = auto()"",
            ""    NO = auto()"",
            """",
            ""report = type('Mock', (object,), {'done': Mock(), 'failed': Mock()})"",
            """",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def cancel(pending: List[Any]):"",
            ""    pass"",
            """",
            ""def write_cache(cache: Cache, sources_to_cache: List[str], mode: str):"",
            ""    pass"",
            """",
            ""executor = ProcessPoolExecutor()"",
            """",
            ""def format_file_in_place(src: str, fast: bool, mode: str, write_back: WriteBack, lock: Any) -> bool:"",
            ""    return True"",
            """",
            ""fast = True"",
            """",
            ""write_back = WriteBack.YES"",
            """",
            ""async def main():"",
            ""    # Paste the entire code snippet here, inside the main() function"",
            """",
            ""asyncio.run(main())""
        ]
    },
    {
        ""imports"": [
            ""from typing import Any, Dict, List, Tuple"",
            ""from unittest.mock import Mock"",
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):"",
            ""    DIFF = auto()"",
            ""    COLOR_DIFF = auto()"",
            ""    YES = auto()"",
            ""    CHECK = auto()"",
            """",
            ""def read_cache(mode: str) -> Cache:"",
            ""    return Cache()"",
            """",
            ""mode = 'default_mode'"",
            """",
            ""def filter_cached(cache: Cache, sources: List[str]) -> Tuple[List[str], List[str]]:"",
            ""    return sources, []"",
            """",
            ""sources = ['source1', 'source2']"",
            """",
            ""class Changed(Enum):"",
            ""    CACHED = auto()"",
            ""    YES = auto()"",
            ""    NO = auto()"",
            """",
            ""class Report:"",
            ""    def done(self, src: str, status: Changed):"",
            ""        print(f'done: {src}, status: {status}')"",
            """",
            ""    def failed(self, src: str, error: str):"",
            ""        print(f'failed: {src}, error: {error}')"",
            """",
            ""report = Report()"",
            """",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def cancel(pending: List[Any]):"",
            ""    pass"",
            """",
            ""def write_cache(cache: Cache, sources_to_cache: List[str], mode: str):"",
            ""    pass"",
            """",
            ""executor = ProcessPoolExecutor()"",
            """",
            ""def format_file_in_place(src: str, fast: bool, mode: str, write_back: WriteBack, lock: Any) -> bool:"",
            ""    return True"",
            """",
            ""fast = True"",
            """",
            ""write_back = WriteBack.YES""
        ]
    },
    {
        ""imports"": [
            ""from typing import Any, Dict, List, Tuple"",
            ""from unittest.mock import Mock"",
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum, auto"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):"",
            ""    DIFF = auto()"",
            ""    COLOR_DIFF = auto()"",
            ""    YES = auto()"",
            ""    CHECK = auto()"",
            """",
            ""def read_cache(mode: str) -> Cache:"",
            ""    return Cache()"",
            """",
            ""mode = 'default_mode'"",
            """",
            ""def filter_cached(cache: Cache, sources: List[str]) -> Tuple[List[str], List[str]]:"",
            ""    return sources, []"",
            """",
            ""sources = ['source1', 'source2']"",
            """",
            ""class Changed(Enum):"",
            ""    CACHED = auto()"",
            ""    YES = auto()"",
            ""    NO = auto()"",
            """",
            ""report = type('Mock', (object,), {'done': Mock(), 'failed': Mock()})"",
            """",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def cancel(pending: List[Any]):"",
            ""    pass"",
            """",
            ""def write_cache(cache: Cache, sources_to_cache: List[str], mode: str):"",
            ""    pass"",
            """",
            ""executor = ProcessPoolExecutor()"",
            """",
            ""def format_file_in_place(src: str, fast: bool, mode: str, write_back: WriteBack, lock: Any) -> bool:"",
            ""    return True"",
            """",
            ""fast = True"",
            """",
            ""write_back = WriteBack.YES"",
            """",
            ""# Since 'await' needs to be inside an async function,"",
            ""# we'll run the provided code inside an async function."",
            ""async def run_code():"",
            ""    cache: Cache = {}"",
            ""    if write_back not in (WriteBack.DIFF, WriteBack.COLOR_DIFF):"",
            ""        cache = read_cache(mode)"",
            ""        sources, cached = filter_cached(cache, sources)"",
            ""        for src in sorted(cached):"",
            ""            report.done(src, Changed.CACHED)"",
            ""    if not sources:"",
            ""        sys.exit()"",
            ""    cancelled = []"",
            ""    sources_to_cache = []"",
            ""    lock = None"",
            ""    if write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF):"",
            ""        manager = Manager()"",
            ""        lock = manager.Lock()"",
            ""    tasks = {"",
            ""        asyncio.ensure_future("",
            ""            loop.run_in_executor("",
            ""                executor, format_file_in_place, src, fast, mode, write_back, lock"",
            ""            )"",
            ""        ): src"",
            ""        for src in sorted(sources)"",
            ""    }"",
            ""    pending = tasks.keys()"",
            ""    try:"",
            ""        loop.add_signal_handler(signal.SIGINT, cancel, pending)"",
            ""        loop.add_signal_handler(signal.SIGTERM, cancel, pending)"",
            ""    except NotImplementedError:"",
            ""        pass"",
            ""    while pending:"",
            ""        done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)"",
            ""        for task in done:"",
            ""            src = tasks.pop(task)"",
            ""            if task.cancelled():"",
            ""                cancelled.append(task)"",
            ""            elif task.exception():"",
            ""                report.failed(src, str(task.exception()))"",
            ""            else:"",
            ""                changed = Changed.YES if task.result() else Changed.NO"",
            ""                if write_back is WriteBack.YES or ("",
            ""                    write_back is WriteBack.CHECK and changed is Changed.NO"",
            ""                ):"",
            ""                    sources_to_cache.append(src)"",
            ""                report.done(src, changed)"",
            ""    if cancelled:"",
            ""        await asyncio.gather(*cancelled, return_exceptions=True)"",
            ""    if sources_to_cache:"",
            ""        write_cache(cache, sources_to_cache, mode)"",
            """",
            ""# Run the code"",
            ""asyncio.run(run_code())""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):"",
            ""    DIFF = auto()"",
            ""    COLOR_DIFF = auto()"",
            ""    YES = auto()"",
            ""    CHECK = auto()"",
            """",
            ""write_back = WriteBack.YES"",
            """",
            ""def read_cache(mode: str) -> Cache:"",
            ""    return Cache()"",
            """",
            ""mode = 'default_mode'"",
            """",
            ""def filter_cached(cache: Cache, sources: list) -> tuple:"",
            ""    return sources, []"",
            """",
            ""sources = ['source1.py', 'source2.py']"",
            """",
            ""class Changed(Enum):"",
            ""    CACHED = auto()"",
            ""    YES = auto()"",
            ""    NO = auto()"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f'done: {src}, status: {status}')"",
            ""    def failed(self, src, error):"",
            ""        print(f'failed: {src}, error: {error}')"",
            """",
            ""report = Report()"",
            """",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def cancel(pending):"",
            ""    print('Cancelled')"",
            """",
            ""def write_cache(cache: Cache, sources_to_cache: list, mode: str):"",
            ""    print(f'Cache written for sources: {sources_to_cache} in mode: {mode}')"",
            """",
            ""executor = ProcessPoolExecutor()"",
            """",
            ""def format_file_in_place(src: str, fast: bool, mode: str, write_back: WriteBack, lock=None) -> bool:"",
            ""    return True"",
            """",
            ""fast = True""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):"",
            ""    DIFF = auto()"",
            ""    COLOR_DIFF = auto()"",
            ""    YES = auto()"",
            ""    CHECK = auto()"",
            """",
            ""def read_cache(mode: str) -> Cache:"",
            ""    return Cache()"",
            """",
            ""mode = 'default_mode'"",
            """",
            ""def filter_cached(cache: Cache, sources: list) -> tuple:"",
            ""    return sources, []"",
            """",
            ""sources = ['source1', 'source2']"",
            """",
            ""class Changed(Enum):"",
            ""    CACHED = auto()"",
            ""    YES = auto()"",
            ""    NO = auto()"",
            """",
            ""class Report:"",
            ""    def done(self, src, change): pass"",
            ""    def failed(self, src, error): pass"",
            """",
            ""report = Report()"",
            """",
            ""def cancel(pending): pass"",
            """",
            ""def write_cache(cache: Cache, sources_to_cache: list, mode: str): pass"",
            """",
            ""executor = ProcessPoolExecutor()"",
            """",
            ""async def format_file_in_place(src: str, fast: bool, mode: str, write_back: WriteBack, lock: Any) -> bool:"",
            ""    return True"",
            """",
            ""fast = True"",
            """",
            ""write_back = WriteBack.YES"",
            """",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from unittest.mock import Mock"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):"",
            ""    DIFF = auto()"",
            ""    COLOR_DIFF = auto()"",
            ""    YES = auto()"",
            ""    CHECK = auto()"",
            """",
            ""def read_cache(mode: str) -> Cache:"",
            ""    return Cache()"",
            """",
            ""mode = 'default_mode'"",
            """",
            ""def filter_cached(cache: Cache, sources: list) -> tuple:"",
            ""    return sources, []"",
            """",
            ""sources = ['source1', 'source2']"",
            """",
            ""class Changed(Enum):"",
            ""    CACHED = auto()"",
            ""    YES = auto()"",
            ""    NO = auto()"",
            """",
            ""report = Mock()"",
            ""report.done = Mock()"",
            ""report.failed = Mock()"",
            """",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def cancel(pending):"",
            ""    pass"",
            """",
            ""def write_cache(cache: Cache, sources_to_cache: list, mode: str):"",
            ""    pass"",
            """",
            ""executor = ProcessPoolExecutor()"",
            """",
            ""async def format_file_in_place(src: str, fast: bool, mode: str, write_back: WriteBack, lock):"",
            ""    return True"",
            """",
            ""fast = True"",
            """",
            ""write_back = WriteBack.YES""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):"",
            ""    DIFF = 1"",
            ""    COLOR_DIFF = 2"",
            ""    YES = 3"",
            ""    CHECK = 4"",
            """",
            ""write_back = WriteBack.DIFF"",
            """",
            ""def read_cache(mode):"",
            ""    return {}"",
            """",
            ""mode = 'default_mode'"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    return sources, []"",
            """",
            ""sources = ['source1.py', 'source2.py']"",
            """",
            ""class Report:"",
            ""    def done(self, src, change):"",
            ""        print(f'done: {src}, {change}')"",
            ""    def failed(self, src, msg):"",
            ""        print(f'failed: {src}, {msg}')"",
            """",
            ""report = Report()"",
            """",
            ""class Changed(Enum):"",
            ""    CACHED = 1"",
            ""    YES = 2"",
            ""    NO = 3"",
            """",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def cancel(pending): pass"",
            """",
            ""def write_cache(cache, sources_to_cache, mode): pass"",
            """",
            ""executor = ProcessPoolExecutor()"",
            """",
            ""def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""fast = True""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):"",
            ""    DIFF = auto()"",
            ""    COLOR_DIFF = auto()"",
            ""    YES = auto()"",
            ""    CHECK = auto()"",
            """",
            ""def read_cache(mode: str) -> Cache:"",
            ""    return Cache()"",
            """",
            ""mode = 'default_mode'"",
            """",
            ""def filter_cached(cache: Cache, sources: list[str]) -> tuple[list[str], list[str]]:"",
            ""    return sources, []"",
            """",
            ""sources = ['source1', 'source2']"",
            """",
            ""class Changed(Enum):"",
            ""    CACHED = auto()"",
            ""    YES = auto()"",
            ""    NO = auto()"",
            """",
            ""class Report:"",
            ""    def done(self, src: str, status: Changed):"",
            ""        print(f\""Report done: {src}, {status}\"")"",
            ""    def failed(self, src: str, error: str):"",
            ""        print(f\""Report failed: {src}, {error}\"")"",
            """",
            ""report = Report()"",
            """",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def cancel(pending):"",
            ""    pass"",
            """",
            ""def write_cache(cache: Cache, sources_to_cache: list[str], mode: str):"",
            ""    pass"",
            """",
            ""executor = ProcessPoolExecutor()"",
            """",
            ""def format_file_in_place(src: str, fast: bool, mode: str, write_back: WriteBack, lock):"",
            ""    return True"",
            """",
            ""fast = True"",
            """",
            ""write_back = WriteBack.YES""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Cache(dict): pass"",
            """",
            ""class WriteBack(Enum):"",
            ""    DIFF = auto()"",
            ""    COLOR_DIFF = auto()"",
            ""    YES = auto()"",
            ""    CHECK = auto()"",
            """",
            ""def read_cache(mode: str) -> Cache:"",
            ""    return Cache()"",
            """",
            ""mode = 'default_mode'"",
            """",
            ""def filter_cached(cache: Cache, sources: list):"",
            ""    return sources, []"",
            """",
            ""sources = ['source1', 'source2']"",
            """",
            ""class Changed(Enum):"",
            ""    CACHED = auto()"",
            ""    YES = auto()"",
            ""    NO = auto()"",
            """",
            ""class MockReport:"",
            ""    def done(self, src, status): pass"",
            ""    def failed(self, src, exc): pass"",
            """",
            ""report = MockReport()"",
            """",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def cancel(pending): pass"",
            """",
            ""async def mock_format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return Changed.NO"",
            """",
            ""def write_cache(cache, sources_to_cache, mode): pass"",
            """",
            ""executor = ProcessPoolExecutor()"",
            """",
            ""fast = True"",
            """",
            ""write_back = WriteBack.DIFF""
        ]
    }
]","[
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = auto() # pragma: no cover"",
            ""    COLOR_DIFF = auto() # pragma: no cover"",
            ""    YES = auto() # pragma: no cover"",
            ""    CHECK = auto() # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode: str) -> Cache: # pragma: no cover"",
            ""    return Cache() # pragma: no cover"",
            "" # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache: Cache, sources): return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    CACHED = auto() # pragma: no cover"",
            ""    YES = auto() # pragma: no cover"",
            ""    NO = auto() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, change): pass # pragma: no cover"",
            ""    def failed(self, src, msg): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            "" # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Any, Dict, List, Tuple # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover"",
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = auto() # pragma: no cover"",
            ""    COLOR_DIFF = auto() # pragma: no cover"",
            ""    YES = auto() # pragma: no cover"",
            ""    CHECK = auto() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode: str) -> Cache: # pragma: no cover"",
            ""    return Cache() # pragma: no cover"",
            "" # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache: Cache, sources: List[str]) -> Tuple[List[str], List[str]]: # pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    CACHED = auto() # pragma: no cover"",
            ""    YES = auto() # pragma: no cover"",
            ""    NO = auto() # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = type('Mock', (object,), {'done': Mock(), 'failed': Mock()}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending: List[Any]): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache: Cache, sources_to_cache: List[str], mode: str): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def format_file_in_place(src: str, fast: bool, mode: str, write_back: WriteBack, lock: Any) -> bool: # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Any, Dict, List, Tuple # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover"",
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = auto() # pragma: no cover"",
            ""    COLOR_DIFF = auto() # pragma: no cover"",
            ""    YES = auto() # pragma: no cover"",
            ""    CHECK = auto() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode: str) -> Cache: # pragma: no cover"",
            ""    return Cache() # pragma: no cover"",
            "" # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache: Cache, sources: List[str]) -> Tuple[List[str], List[str]]: # pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    CACHED = auto() # pragma: no cover"",
            ""    YES = auto() # pragma: no cover"",
            ""    NO = auto() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src: str, status: Changed): # pragma: no cover"",
            ""        print(f'done: {src}, status: {status}') # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def failed(self, src: str, error: str): # pragma: no cover"",
            ""        print(f'failed: {src}, error: {error}') # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending: List[Any]): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache: Cache, sources_to_cache: List[str], mode: str): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def format_file_in_place(src: str, fast: bool, mode: str, write_back: WriteBack, lock: Any) -> bool: # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Any, Dict, List, Tuple # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover"",
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = auto() # pragma: no cover"",
            ""    COLOR_DIFF = auto() # pragma: no cover"",
            ""    YES = auto() # pragma: no cover"",
            ""    CHECK = auto() # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode: str) -> Cache: # pragma: no cover"",
            ""    return Cache() # pragma: no cover"",
            "" # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache: Cache, sources: list) -> tuple: # pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""sources = ['source1.py', 'source2.py'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    CACHED = auto() # pragma: no cover"",
            ""    YES = auto() # pragma: no cover"",
            ""    NO = auto() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f'done: {src}, status: {status}') # pragma: no cover"",
            ""    def failed(self, src, error): # pragma: no cover"",
            ""        print(f'failed: {src}, error: {error}') # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print('Cancelled') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache: Cache, sources_to_cache: list, mode: str): # pragma: no cover"",
            ""    print(f'Cache written for sources: {sources_to_cache} in mode: {mode}') # pragma: no cover"",
            "" # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def format_file_in_place(src: str, fast: bool, mode: str, write_back: WriteBack, lock=None) -> bool: # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""fast = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = auto() # pragma: no cover"",
            ""    COLOR_DIFF = auto() # pragma: no cover"",
            ""    YES = auto() # pragma: no cover"",
            ""    CHECK = auto() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode: str) -> Cache: # pragma: no cover"",
            ""    return Cache() # pragma: no cover"",
            "" # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache: Cache, sources: list) -> tuple: # pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    CACHED = auto() # pragma: no cover"",
            ""    YES = auto() # pragma: no cover"",
            ""    NO = auto() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, change): pass # pragma: no cover"",
            ""    def failed(self, src, error): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache: Cache, sources_to_cache: list, mode: str): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            "" # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            "" # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = auto() # pragma: no cover"",
            ""    COLOR_DIFF = auto() # pragma: no cover"",
            ""    YES = auto() # pragma: no cover"",
            ""    CHECK = auto() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode: str) -> Cache: # pragma: no cover"",
            ""    return Cache() # pragma: no cover"",
            "" # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache: Cache, sources: list) -> tuple: # pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    CACHED = auto() # pragma: no cover"",
            ""    YES = auto() # pragma: no cover"",
            ""    NO = auto() # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Mock() # pragma: no cover"",
            ""report.done = Mock() # pragma: no cover"",
            ""report.failed = Mock() # pragma: no cover"",
            "" # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache: Cache, sources_to_cache: list, mode: str): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src: str, fast: bool, mode: str, write_back: WriteBack, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 1 # pragma: no cover"",
            ""    COLOR_DIFF = 2 # pragma: no cover"",
            ""    YES = 3 # pragma: no cover"",
            ""    CHECK = 4 # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""sources = ['source1.py', 'source2.py'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, change): # pragma: no cover"",
            ""        print(f'done: {src}, {change}') # pragma: no cover"",
            ""    def failed(self, src, msg): # pragma: no cover"",
            ""        print(f'failed: {src}, {msg}') # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    CACHED = 1 # pragma: no cover"",
            ""    YES = 2 # pragma: no cover"",
            ""    NO = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""fast = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = auto() # pragma: no cover"",
            ""    COLOR_DIFF = auto() # pragma: no cover"",
            ""    YES = auto() # pragma: no cover"",
            ""    CHECK = auto() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode: str) -> Cache: # pragma: no cover"",
            ""    return Cache() # pragma: no cover"",
            "" # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            "" # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    CACHED = auto() # pragma: no cover"",
            ""    YES = auto() # pragma: no cover"",
            ""    NO = auto() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src: str, status: Changed): # pragma: no cover"",
            ""        print(f\""Report done: {src}, {status}\"") # pragma: no cover"",
            ""    def failed(self, src: str, error: str): # pragma: no cover"",
            ""        print(f\""Report failed: {src}, {error}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def format_file_in_place(src: str, fast: bool, mode: str, write_back: WriteBack, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Cache(dict): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = auto() # pragma: no cover"",
            ""    COLOR_DIFF = auto() # pragma: no cover"",
            ""    YES = auto() # pragma: no cover"",
            ""    CHECK = auto() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode: str) -> Cache: # pragma: no cover"",
            ""    return Cache() # pragma: no cover"",
            "" # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache: Cache, sources: list): # pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    CACHED = auto() # pragma: no cover"",
            ""    YES = auto() # pragma: no cover"",
            ""    NO = auto() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockReport: # pragma: no cover"",
            ""    def done(self, src, status): pass # pragma: no cover"",
            ""    def failed(self, src, exc): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = MockReport() # pragma: no cover"",
            "" # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def mock_format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return Changed.NO # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            "" # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover""
        ]
    }
]",2,6919,0.0034595,4512,0.006768,0.0102275
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Run formatting of `sources` in parallel using the provided `executor`.
    (Use ProcessPoolExecutors for actual parallelism.)
    `write_back`, `fast`, and `mode` options are passed to
    :func:`format_file_in_place`.
    """"""
cache: Cache = {} # uncovered
if write_back not in (WriteBack.DIFF, WriteBack.COLOR_DIFF): # uncovered
    cache = read_cache(mode) # uncovered
    sources, cached = filter_cached(cache, sources) # uncovered
    for src in sorted(cached): # uncovered
        report.done(src, Changed.CACHED) # uncovered
if not sources: # uncovered
    exit() # uncovered
cancelled = [] # uncovered
sources_to_cache = [] # uncovered
lock = None # uncovered
if write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF): # uncovered
    # For diff output, we need locks to ensure we don't interleave output
    # from different processes.
    manager = Manager() # uncovered
    lock = manager.Lock() # uncovered
tasks = { # uncovered
    asyncio.ensure_future( # uncovered
        loop.run_in_executor( # uncovered
            executor, format_file_in_place, src, fast, mode, write_back, lock # uncovered
        ) # uncovered
    ): src # uncovered
    for src in sorted(sources) # uncovered
} # uncovered
pending = tasks.keys() # uncovered
try: # uncovered
    loop.add_signal_handler(signal.SIGINT, cancel, pending) # uncovered
    loop.add_signal_handler(signal.SIGTERM, cancel, pending) # uncovered
except NotImplementedError: # uncovered
    # There are no good alternatives for these on Windows.
    pass # uncovered
while pending: # uncovered
    done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED) # uncovered
    for task in done: # uncovered
        src = tasks.pop(task) # uncovered
        if task.cancelled(): # uncovered
            cancelled.append(task) # uncovered
        elif task.exception(): # uncovered
            report.failed(src, str(task.exception())) # uncovered
        else: # uncovered
            changed = Changed.YES if task.result() else Changed.NO # uncovered
            # If the file was written back or was successfully checked as
            # well-formatted, store this information in the cache.
            if write_back is WriteBack.YES or ( # uncovered
                write_back is WriteBack.CHECK and changed is Changed.NO # uncovered
            ): # uncovered
                sources_to_cache.append(src) # uncovered
            report.done(src, changed) # uncovered
if cancelled: # uncovered
    await asyncio.gather(*cancelled, return_exceptions=True) # uncovered
if sources_to_cache: # uncovered
    write_cache(cache, sources_to_cache, mode) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""import async_timeout"",
            ""import asyncio"",
            ""import signal"",
            ""import os"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):\n    DIFF = 'diff'\n    COLOR_DIFF = 'color_diff'\n    YES = 'yes'\n    CHECK = 'check'\nclass Changed(Enum):\n    YES = 'yes'\n    NO = 'no'\n    CACHED = 'cached'"",
            ""write_back = WriteBack.DIFF"",
            ""sources = ['file1', 'file2']"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):\n    return Changed.YES"",
            ""def read_cache(mode):\n    return {}"",
            ""def filter_cached(cache, sources):\n    return sources, []"",
            ""class MockReport:\n    def done(self, src, status):\n        pass\n    def failed(self, src, msg):\n        pass"",
            ""report = MockReport()"",
            ""def cancel(pending):\n    pass"",
            ""def write_cache(cache, sources_to_cache, mode):\n    pass"",
            ""fast = False"",
            ""mode = 'mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):\n    DIFF = 'diff'\n    COLOR_DIFF = 'color_diff'\n    YES = 'yes'\n    CHECK = 'check'"",
            ""write_back = WriteBack.YES"",
            ""fast = False"",
            ""mode = 'sample_mode'"",
            ""sources = ['file1', 'file2']"",
            ""def format_file_in_place(src, fast, mode, write_back, lock):\n    return True"",
            ""def read_cache(mode):\n    return {}"",
            ""def filter_cached(cache, sources):\n    return sources, []"",
            ""def report_done(src, changed):\n    pass"",
            ""def report_failed(src, message):\n    pass"",
            ""def write_cache(cache, sources, mode):\n    pass"",
            ""class Cache(dict):\n    pass"",
            ""class Changed(Enum):\n    YES = 'yes'\n    NO = 'no'\n    CACHED = 'cached'"",
            ""def cancel(pending):\n    pass"",
            ""class MockLoop:\n    def run_in_executor(self, executor, func, *args):\n        async def inner():\n            return await func(*args)\n        return asyncio.create_task(inner())\n    def add_signal_handler(self, sig, handler, *args):\n        pass"",
            ""loop = MockLoop()"",
            ""executor = None""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""# Mock initialization for Cache"",
            ""Cache = dict"",
            """",
            ""# Initialize the mode required for formatting"",
            ""mode = 'some_mode'"",
            """",
            ""# Initialize write_back as WriteBack.COLOR_DIFF to ensure execution of the diff logic."",
            ""write_back = WriteBack.COLOR_DIFF"",
            """",
            ""# Initialize the sources list with some mock data"",
            ""sources = ['example1.py', 'example2.py']"",
            """",
            ""# Define report behavior"",
            ""class MockReport:"",
            ""    @staticmethod"",
            ""    def done(src, status):"",
            ""        print(f\""Done with {src}: {status}\"")"",
            ""    @staticmethod"",
            ""    def failed(src, error):"",
            ""        print(f\""Failed with {src}: {error}\"")"",
            """",
            ""report = MockReport()"",
            """",
            ""# Define the Changed Enum"",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""# Mock format_file_in_place function"",
            ""def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return []  # Implement as needed for logic"",
            """",
            ""# Mock read_cache function"",
            ""def read_cache(mode):"",
            ""    return {}"",
            """",
            ""# Mock filter_cached function"",
            ""def filter_cached(cache, sources):"",
            ""    return sources, []"",
            """",
            ""# Mock write_cache function"",
            ""def write_cache(cache, sources, mode):"",
            ""    pass"",
            """",
            ""# Mock cancel function"",
            ""def cancel(pending):"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""# Fast mode mock initialisation"",
            ""fast = False"",
            """",
            ""# Executor initialization"",
            ""executor = ProcessPoolExecutor()"",
            """",
            ""# Event loop initialization"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'DIFF'"",
            ""    COLOR_DIFF = 'COLOR_DIFF'"",
            ""    YES = 'YES'"",
            ""    CHECK = 'CHECK'"",
            """",
            ""class Changed(Enum):"",
            ""    CACHED = 'CACHED'"",
            ""    YES = 'YES'"",
            ""    NO = 'NO'"",
            """",
            ""write_back = WriteBack.YES"",
            """",
            ""def read_cache(mode):"",
            ""    return {}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    return sources, []"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def report_done(src, changed):"",
            ""    print(f\""{src} done with change status: {changed}\"")"",
            """",
            ""def report_failed(src, error):"",
            ""    print(f\""{src} failed with error: {error}\"")"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for sources: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""sources = ['file1.py', 'file2.py']"",
            ""mode = 'default'"",
            ""fast = True"",
            ""executor = type('MockProcessPoolExecutor', (object,), {'submit': lambda self, fn, *args: fn(*args)})()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""from typing import Dict, Any"",
            ""import os""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Report:"",
            ""    def done(self, src, changed):"",
            ""        pass"",
            ""    def failed(self, src, message):"",
            ""        pass"",
            """",
            ""def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return False"",
            """",
            ""def read_cache(mode) -> Dict[str, Any]:"",
            ""    return {}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    return sources, []"",
            """",
            ""def cancel(pending):"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    pass"",
            """",
            ""cache = {}"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = True"",
            ""mode = 'test_mode'"",
            ""write_back = WriteBack.CHECK"",
            ""executor = asyncio.get_event_loop().run_in_executor"",
            ""loop = asyncio.get_event_loop()"",
            ""report = Report()""
        ]
    },
    {
        ""imports"": [
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from typing import Dict, List""
        ],
        ""initialization"": [
            ""class WriteBack:\n    DIFF = 'diff'\n    COLOR_DIFF = 'color_diff'\n    YES = 'yes'\n    CHECK = 'check'"",
            ""class Changed:\n    CACHED = 'cached'\n    YES = 'yes'\n    NO = 'no'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""sources = ['file1.py', 'file2.py']"",
            ""write_back = WriteBack.CHECK"",
            ""fast = True"",
            ""mode = 'default'"",
            ""def read_cache(mode):\n    return {'file1.py': 'cached'}"",
            ""def filter_cached(cache, sources):\n    return ([s for s in sources if s not in cache], [s for s in sources if s in cache])"",
            ""def format_file_in_place(src, fast, mode, write_back, lock):\n    return True"",
            ""def report_done(src, change):\n    print(f'Processed {src} with change {change}')"",
            ""def report_failed(src, reason):\n    print(f'Failed processing {src} with reason: {reason}')"",
            ""def write_cache(cache, sources_to_cache, mode):\n    print(f'Cache updated for {sources_to_cache}')"",
            ""def cancel(tasks):\n    for task in tasks:\n        task.cancel()"",
            ""report = type('Mock', (object,), {'done': report_done, 'failed': report_failed})()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum, auto"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    YES = auto()"",
            ""    DIFF = auto()"",
            ""    COLOR_DIFF = auto()"",
            ""    CHECK = auto()"",
            """",
            ""class Changed(Enum):"",
            ""    YES = auto()"",
            ""    NO = auto()"",
            ""    CACHED = auto()"",
            """",
            ""write_back = WriteBack.YES"",
            ""fast = True"",
            ""mode = 'default'"",
            ""def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def read_cache(mode):"",
            ""    return {}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    return sources, []"",
            """",
            ""def report_done(src, status):"",
            ""    print(f'Done: {src} with status: {status.name}')"",
            ""report = type('Mock', (object,), {'done': report_done, 'failed': lambda src, msg: print(f'Failed: {src} with msg: {msg}')})()"",
            """",
            ""def write_cache(cache, sources, mode):"",
            ""    pass"",
            """",
            ""def cancel(pending):"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""sources = ['file1.py', 'file2.py']""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 1"",
            ""    COLOR_DIFF = 2"",
            ""    YES = 3"",
            ""    CHECK = 4"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 5"",
            ""    NO = 6"",
            ""    CACHED = 7"",
            """",
            ""class Report:"",
            ""    def done(self, src, changed):"",
            ""        pass"",
            ""    def failed(self, src, msg):"",
            ""        pass"",
            """",
            ""def format_file_in_place(src, fast, mode, write_back, lock=None):"",
            ""    return True"",
            """",
            ""def read_cache(mode):"",
            ""    return {}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    return sources, []"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    pass"",
            """",
            ""def cancel(pending):"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""sources = ['source1.py', 'source2.py']"",
            ""write_back = WriteBack.CHECK"",
            ""fast = True"",
            ""mode = 'default'"",
            ""report = Report()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""from enum import Enum, auto"",
            ""from multiprocessing import Manager"",
            ""import signal"",
            ""from typing import Callable, Dict, List, Tuple""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = auto()"",
            ""    COLOR_DIFF = auto()"",
            ""    YES = auto()"",
            ""    CHECK = auto()"",
            ""write_back = WriteBack.DIFF"",
            ""def read_cache(mode):"",
            ""    return {}"",
            ""def filter_cached(cache, sources):"",
            ""    return sources, []"",
            ""class Changed(Enum):"",
            ""    YES = auto()"",
            ""    NO = auto()"",
            ""    CACHED = auto()"",
            ""class Cache(dict):"",
            ""    pass"",
            ""class Report:"",
            ""    def done(self, src, changed):"",
            ""        pass"",
            ""    def failed(self, src, message):"",
            ""        pass"",
            ""report = Report()"",
            ""sources = ['source1', 'source2']"",
            ""fast = False"",
            ""mode = 'mode'"",
            ""executor = None"",
            ""loop = asyncio.get_event_loop()"",
            ""def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return False"",
            ""def exit():"",
            ""    pass"",
            ""def cancel(pending):"",
            ""    pass"",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""cache = {}"",
            ""write_back = WriteBack.DIFF"",
            ""fast = False"",
            ""mode = 'mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = type('Mock', (object,), {})()"",
            ""loop = asyncio.get_event_loop()"",
            ""report = type('Mock', (object,), {"",
            ""    'done': lambda self, src, changed: None,"",
            ""    'failed': lambda self, src, error: None"",
            ""})()"",
            ""format_file_in_place = lambda src, fast, mode, write_back, lock: True"",
            ""read_cache = lambda mode: {}"",
            ""filter_cached = lambda cache, sources: (sources, [])"",
            ""cancel = lambda pending: None"",
            ""write_cache = lambda cache, sources_to_cache, mode: None""
        ]
    }
]","[
    {
        ""imports"": [
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""import async_timeout # pragma: no cover"",
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""import os # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):# pragma: no cover"",
            ""    DIFF = 'diff'# pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff'# pragma: no cover"",
            ""    YES = 'yes'# pragma: no cover"",
            ""    CHECK = 'check'# pragma: no cover"",
            ""class Changed(Enum):# pragma: no cover"",
            ""    YES = 'yes'# pragma: no cover"",
            ""    NO = 'no'# pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""sources = ['file1', 'file2'] # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):# pragma: no cover"",
            ""    return Changed.YES # pragma: no cover"",
            ""def read_cache(mode):# pragma: no cover"",
            ""    return {} # pragma: no cover"",
            ""def filter_cached(cache, sources):# pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            ""class MockReport:# pragma: no cover"",
            ""    def done(self, src, status):# pragma: no cover"",
            ""        pass# pragma: no cover"",
            ""    def failed(self, src, msg):# pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""report = MockReport() # pragma: no cover"",
            ""def cancel(pending):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""fast = False # pragma: no cover"",
            ""mode = 'mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):# pragma: no cover"",
            ""    DIFF = 'diff'# pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff'# pragma: no cover"",
            ""    YES = 'yes'# pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""fast = False # pragma: no cover"",
            ""mode = 'sample_mode' # pragma: no cover"",
            ""sources = ['file1', 'file2'] # pragma: no cover"",
            ""def format_file_in_place(src, fast, mode, write_back, lock):# pragma: no cover"",
            ""    return True # pragma: no cover"",
            ""def read_cache(mode):# pragma: no cover"",
            ""    return {} # pragma: no cover"",
            ""def filter_cached(cache, sources):# pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            ""def report_done(src, changed):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""def report_failed(src, message):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""def write_cache(cache, sources, mode):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""class Cache(dict):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""class Changed(Enum):# pragma: no cover"",
            ""    YES = 'yes'# pragma: no cover"",
            ""    NO = 'no'# pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            ""def cancel(pending):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""class MockLoop:# pragma: no cover"",
            ""    def run_in_executor(self, executor, func, *args):# pragma: no cover"",
            ""        async def inner():# pragma: no cover"",
            ""            return await func(*args)# pragma: no cover"",
            ""        return asyncio.create_task(inner())# pragma: no cover"",
            ""    def add_signal_handler(self, sig, handler, *args):# pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""loop = MockLoop() # pragma: no cover"",
            ""executor = None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""# Mock initialization for Cache # pragma: no cover"",
            ""Cache = dict # pragma: no cover"",
            "" # pragma: no cover"",
            ""# Initialize the mode required for formatting # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            "" # pragma: no cover"",
            ""# Initialize write_back as WriteBack.COLOR_DIFF to ensure execution of the diff logic. # pragma: no cover"",
            ""write_back = WriteBack.COLOR_DIFF # pragma: no cover"",
            "" # pragma: no cover"",
            ""# Initialize the sources list with some mock data # pragma: no cover"",
            ""sources = ['example1.py', 'example2.py'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""# Define report behavior # pragma: no cover"",
            ""class MockReport: # pragma: no cover"",
            ""    @staticmethod # pragma: no cover"",
            ""    def done(src, status): # pragma: no cover"",
            ""        print(f\""Done with {src}: {status}\"") # pragma: no cover"",
            ""    @staticmethod # pragma: no cover"",
            ""    def failed(src, error): # pragma: no cover"",
            ""        print(f\""Failed with {src}: {error}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = MockReport() # pragma: no cover"",
            "" # pragma: no cover"",
            ""# Define the Changed Enum # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""# Mock format_file_in_place function # pragma: no cover"",
            ""def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return []  # Implement as needed for logic # pragma: no cover"",
            "" # pragma: no cover"",
            ""# Mock read_cache function # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""# Mock filter_cached function # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""# Mock write_cache function # pragma: no cover"",
            ""def write_cache(cache, sources, mode): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""# Mock cancel function # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""# Fast mode mock initialisation # pragma: no cover"",
            ""fast = False # pragma: no cover"",
            "" # pragma: no cover"",
            ""# Executor initialization # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            "" # pragma: no cover"",
            ""# Event loop initialization # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'DIFF' # pragma: no cover"",
            ""    COLOR_DIFF = 'COLOR_DIFF' # pragma: no cover"",
            ""    YES = 'YES' # pragma: no cover"",
            ""    CHECK = 'CHECK' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    CACHED = 'CACHED' # pragma: no cover"",
            ""    YES = 'YES' # pragma: no cover"",
            ""    NO = 'NO' # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def report_done(src, changed): # pragma: no cover"",
            ""    print(f\""{src} done with change status: {changed}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def report_failed(src, error): # pragma: no cover"",
            ""    print(f\""{src} failed with error: {error}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for sources: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""mode = 'default' # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""executor = type('MockProcessPoolExecutor', (object,), {'submit': lambda self, fn, *args: fn(*args)})() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""from typing import Dict, Any # pragma: no cover"",
            ""import os # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, changed): # pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode) -> Dict[str, Any]: # pragma: no cover"",
            ""    return {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = {} # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'test_mode' # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""executor = asyncio.get_event_loop().run_in_executor # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""report = Report() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from typing import Dict, List # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack:# pragma: no cover"",
            ""    DIFF = 'diff'# pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff'# pragma: no cover"",
            ""    YES = 'yes'# pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            ""class Changed:# pragma: no cover"",
            ""    CACHED = 'cached'# pragma: no cover"",
            ""    YES = 'yes'# pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'default' # pragma: no cover"",
            ""def read_cache(mode):# pragma: no cover"",
            ""    return {'file1.py': 'cached'} # pragma: no cover"",
            ""def filter_cached(cache, sources):# pragma: no cover"",
            ""    return ([s for s in sources if s not in cache], [s for s in sources if s in cache]) # pragma: no cover"",
            ""def format_file_in_place(src, fast, mode, write_back, lock):# pragma: no cover"",
            ""    return True # pragma: no cover"",
            ""def report_done(src, change):# pragma: no cover"",
            ""    print(f'Processed {src} with change {change}') # pragma: no cover"",
            ""def report_failed(src, reason):# pragma: no cover"",
            ""    print(f'Failed processing {src} with reason: {reason}') # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode):# pragma: no cover"",
            ""    print(f'Cache updated for {sources_to_cache}') # pragma: no cover"",
            ""def cancel(tasks):# pragma: no cover"",
            ""    for task in tasks:# pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            ""report = type('Mock', (object,), {'done': report_done, 'failed': report_failed})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    YES = auto() # pragma: no cover"",
            ""    DIFF = auto() # pragma: no cover"",
            ""    COLOR_DIFF = auto() # pragma: no cover"",
            ""    CHECK = auto() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = auto() # pragma: no cover"",
            ""    NO = auto() # pragma: no cover"",
            ""    CACHED = auto() # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'default' # pragma: no cover"",
            ""def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""def report_done(src, status): # pragma: no cover"",
            ""    print(f'Done: {src} with status: {status.name}') # pragma: no cover"",
            ""report = type('Mock', (object,), {'done': report_done, 'failed': lambda src, msg: print(f'Failed: {src} with msg: {msg}')})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources, mode): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 1 # pragma: no cover"",
            ""    COLOR_DIFF = 2 # pragma: no cover"",
            ""    YES = 3 # pragma: no cover"",
            ""    CHECK = 4 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 5 # pragma: no cover"",
            ""    NO = 6 # pragma: no cover"",
            ""    CACHED = 7 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, changed): # pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""    def failed(self, src, msg): # pragma: no cover"",
            ""        pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def format_file_in_place(src, fast, mode, write_back, lock=None): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""sources = ['source1.py', 'source2.py'] # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'default' # pragma: no cover"",
            ""report = Report() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from typing import Callable, Dict, List, Tuple # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = auto() # pragma: no cover"",
            ""    COLOR_DIFF = auto() # pragma: no cover"",
            ""    YES = auto() # pragma: no cover"",
            ""    CHECK = auto() # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {} # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = auto() # pragma: no cover"",
            ""    NO = auto() # pragma: no cover"",
            ""    CACHED = auto() # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, changed): # pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""sources = ['source1', 'source2'] # pragma: no cover"",
            ""fast = False # pragma: no cover"",
            ""mode = 'mode' # pragma: no cover"",
            ""executor = None # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = {} # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""fast = False # pragma: no cover"",
            ""mode = 'mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = type('Mock', (object,), {})() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""report = type('Mock', (object,), { # pragma: no cover"",
            ""    'done': lambda self, src, changed: None, # pragma: no cover"",
            ""    'failed': lambda self, src, error: None # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""format_file_in_place = lambda src, fast, mode, write_back, lock: True # pragma: no cover"",
            ""read_cache = lambda mode: {} # pragma: no cover"",
            ""filter_cached = lambda cache, sources: (sources, []) # pragma: no cover"",
            ""cancel = lambda pending: None # pragma: no cover"",
            ""write_cache = lambda cache, sources_to_cache, mode: None # pragma: no cover""
        ]
    }
]",3,890,0.000445,3753,0.0056295,0.0060745
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Run formatting of `sources` in parallel using the provided `executor`.
    (Use ProcessPoolExecutors for actual parallelism.)
    `write_back`, `fast`, and `mode` options are passed to
    :func:`format_file_in_place`.
    """"""
cache: Cache = {} # uncovered
if write_back not in (WriteBack.DIFF, WriteBack.COLOR_DIFF): # uncovered
    cache = read_cache(mode) # uncovered
    sources, cached = filter_cached(cache, sources) # uncovered
    for src in sorted(cached): # uncovered
        report.done(src, Changed.CACHED) # uncovered
if not sources: # uncovered
    exit() # uncovered
cancelled = [] # uncovered
sources_to_cache = [] # uncovered
lock = None # uncovered
if write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF): # uncovered
    # For diff output, we need locks to ensure we don't interleave output
    # from different processes.
    manager = Manager() # uncovered
    lock = manager.Lock() # uncovered
tasks = { # uncovered
    asyncio.ensure_future( # uncovered
        loop.run_in_executor( # uncovered
            executor, format_file_in_place, src, fast, mode, write_back, lock # uncovered
        ) # uncovered
    ): src # uncovered
    for src in sorted(sources) # uncovered
} # uncovered
pending = tasks.keys() # uncovered
try: # uncovered
    loop.add_signal_handler(signal.SIGINT, cancel, pending) # uncovered
    loop.add_signal_handler(signal.SIGTERM, cancel, pending) # uncovered
except NotImplementedError: # uncovered
    # There are no good alternatives for these on Windows.
    pass # uncovered
while pending: # uncovered
    done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED) # uncovered
    for task in done: # uncovered
        src = tasks.pop(task) # uncovered
        if task.cancelled(): # uncovered
            cancelled.append(task) # uncovered
        elif task.exception(): # uncovered
            report.failed(src, str(task.exception())) # uncovered
        else: # uncovered
            changed = Changed.YES if task.result() else Changed.NO # uncovered
            # If the file was written back or was successfully checked as
            # well-formatted, store this information in the cache.
            if write_back is WriteBack.YES or ( # uncovered
                write_back is WriteBack.CHECK and changed is Changed.NO # uncovered
            ): # uncovered
                sources_to_cache.append(src) # uncovered
            report.done(src, changed) # uncovered
if cancelled: # uncovered
    await asyncio.gather(*cancelled, return_exceptions=True) # uncovered
if sources_to_cache: # uncovered
    write_cache(cache, sources_to_cache, mode) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.CHECK"",
            ""mode = 'example_mode'"",
            ""sources = []"",
            ""fast = False"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""cancelled = []"",
            ""sources_to_cache = []"",
            ""lock = None"",
            ""def read_cache(mode):"",
            ""    return {}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    return sources, []"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, msg):"",
            ""        print(f\""Failed {src}, msg: {msg}\"")"",
            """",
            ""report = Report()"",
            """",
            ""def write_cache(cache, sources, mode):"",
            ""    print(f\""Writing cache for {sources}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in tasks:"",
            ""        task.cancel()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Report done: {src} with status {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Report failed: {src} with message {message}\"")"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.YES"",
            ""fast = False"",
            ""mode = 'default'"",
            ""sources = ['test1.py', 'test2.py']"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return False"",
            """",
            ""def read_cache(mode):"",
            ""    return {}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    return sources, []"",
            """",
            ""def write_cache(cache, sources, mode):"",
            ""    print(f\""Write cache for sources: {sources} with mode {mode}\"")"",
            """",
            ""def exit():"",
            ""    print(\""Exit called\"")"",
            """",
            ""def cancel(pending):"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""report = Report()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Report:"",
            ""    def done(self, src, changed):"",
            ""        print(f'(done) {src}: {changed}')"",
            ""    def failed(self, src, msg):"",
            ""        print(f'(failed) {src}: {msg}')"",
            """",
            ""def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return False"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    not_cached = [src for src in sources if src not in cache]"",
            ""    return not_cached, cached"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print('Cache written for:', sources_to_cache)"",
            """",
            ""def cancel(pending):"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""cache = {}"",
            ""write_back = WriteBack.YES"",
            ""fast = False"",
            ""mode = 'mode_test'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""report = Report()""
        ]
    },
    {
        ""imports"": [
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""import signal"",
            ""import asyncio"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1': 'cached'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, changed):"",
            ""        print(f\""Processed {src} with change {changed.name}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed to process {src} with error {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for {sources_to_cache}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""# Initialization values"",
            ""cache = Cache()"",
            ""write_back = WriteBack.CHECK"",
            ""sources = ['file1', 'file2']"",
            ""mode = 'test_mode'"",
            ""fast = True"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Report:"",
            ""    def done(self, src, changed):"",
            ""        print(f\""Done: {src}, {changed}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed: {src}, {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def read_cache(mode):"",
            ""    return {}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    return sources, []"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(\""Cache written.\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancel tasks.\"")"",
            """",
            ""sources = ['file1.py', 'file2.py']"",
            ""write_back = WriteBack.YES"",
            ""fast = True"",
            ""mode = 'default_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'DIFF'"",
            ""    COLOR_DIFF = 'COLOR_DIFF'"",
            ""    YES = 'YES'"",
            ""    CHECK = 'CHECK'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'YES'"",
            ""    NO = 'NO'"",
            ""    CACHED = 'CACHED'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""class Report:"",
            ""    @staticmethod"",
            ""    def done(src, changed):"",
            ""        print(f\""{src} done: {changed}\"")"",
            ""    @staticmethod"",
            ""    def failed(src, error):"",
            ""        print(f\""{src} failed: {error}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def read_cache(mode):"",
            ""    return {}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    return sources, []"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    pass"",
            """",
            ""def cancel(pending):"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""write_back = WriteBack.YES"",
            ""fast = True"",
            ""mode = 'default'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""sources = ['file1.py', 'file2.py']""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Report:"",
            ""    def done(self, src, changed):"",
            ""        print(f\""Done: {src} with status {changed}\"")"",
            ""    def failed(self, src, msg):"",
            ""        print(f\""Failed: {src} with message {msg}\"")"",
            """",
            ""def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def read_cache(mode):"",
            ""    print(f\""Cache read for mode {mode}\"")"",
            ""    return {}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    print(f\""Filtering cache {cache} for sources {sources}\"")"",
            ""    return sources, []"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Writing cache {cache} for sources {sources_to_cache} in mode {mode}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(f\""Cancelled pending tasks: {pending}\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""cache = {}"",
            ""write_back = WriteBack.CHECK"",
            ""fast = False"",
            ""mode = 'mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""report = Report()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""from concurrent.futures import ProcessPoolExecutor""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def read_cache(mode):"",
            ""    return {}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    return sources, []"",
            """",
            ""def report_done(src, status):"",
            ""    pass"",
            """",
            ""def report_failed(src, msg):"",
            ""    pass"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    pass"",
            """",
            ""def cancel(pending):"",
            ""    pass"",
            """",
            ""class Report:"",
            ""    def done(self, src, changed):"",
            ""        return report_done(src, changed)"",
            ""    def failed(self, src, msg):"",
            ""        return report_failed(src, msg)"",
            """",
            ""report = Report()"",
            """",
            ""sources = ['file1.py', 'file2.py']"",
            ""write_back = WriteBack.YES"",
            ""cache = {}"",
            ""fast = True"",
            ""mode = 'mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""cache = {}"",
            ""write_back = WriteBack.CHECK"",
            ""fast = True"",
            ""mode = 'mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""class Report:"",
            ""    def done(self, src, changed):"",
            ""        print(f'Done: {src} -> {changed}')"",
            ""    def failed(self, src, error):"",
            ""        print(f'Failed: {src} -> {error}')"",
            ""report = Report()"",
            """",
            ""def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return False"",
            """",
            ""def read_cache(mode):"",
            ""    return {}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    return sources, []"",
            """",
            ""def cancel(pending):"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f'Writing cache for: {sources_to_cache}')"",
            """",
            ""def exit():"",
            ""    print('Exiting...')""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""def read_cache(mode):"",
            ""    return {}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    return sources, []"",
            """",
            ""def cancel(pending):"",
            ""    pass"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    pass"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""class Report:"",
            ""    def done(self, src, changed):"",
            ""        print(f\""Report done: {src}, {changed}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Report failed: {src}, {message}\"")"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""sources = []"",
            ""write_back = WriteBack.COLOR_DIFF"",
            ""fast = True"",
            ""mode = 'some_mode'"",
            ""report = Report()"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    }
]","[
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = [] # pragma: no cover"",
            ""fast = False # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""cancelled = [] # pragma: no cover"",
            ""sources_to_cache = [] # pragma: no cover"",
            ""lock = None # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, msg): # pragma: no cover"",
            ""        print(f\""Failed {src}, msg: {msg}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources, mode): # pragma: no cover"",
            ""    print(f\""Writing cache for {sources}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Report done: {src} with status {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Report failed: {src} with message {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""fast = False # pragma: no cover"",
            ""mode = 'default' # pragma: no cover"",
            ""sources = ['test1.py', 'test2.py'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources, mode): # pragma: no cover"",
            ""    print(f\""Write cache for sources: {sources} with mode {mode}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exit called\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""report = Report() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, changed): # pragma: no cover"",
            ""        print(f'(done) {src}: {changed}') # pragma: no cover"",
            ""    def failed(self, src, msg): # pragma: no cover"",
            ""        print(f'(failed) {src}: {msg}') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    not_cached = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return not_cached, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print('Cache written for:', sources_to_cache) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = {} # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""fast = False # pragma: no cover"",
            ""mode = 'mode_test' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""report = Report() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""import asyncio # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1': 'cached'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, changed): # pragma: no cover"",
            ""        print(f\""Processed {src} with change {changed.name}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed to process {src} with error {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""# Initialization values # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""sources = ['file1', 'file2'] # pragma: no cover"",
            ""mode = 'test_mode' # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, changed): # pragma: no cover"",
            ""        print(f\""Done: {src}, {changed}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed: {src}, {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(\""Cache written.\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancel tasks.\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'DIFF' # pragma: no cover"",
            ""    COLOR_DIFF = 'COLOR_DIFF' # pragma: no cover"",
            ""    YES = 'YES' # pragma: no cover"",
            ""    CHECK = 'CHECK' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'YES' # pragma: no cover"",
            ""    NO = 'NO' # pragma: no cover"",
            ""    CACHED = 'CACHED' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    @staticmethod # pragma: no cover"",
            ""    def done(src, changed): # pragma: no cover"",
            ""        print(f\""{src} done: {changed}\"") # pragma: no cover"",
            ""    @staticmethod # pragma: no cover"",
            ""    def failed(src, error): # pragma: no cover"",
            ""        print(f\""{src} failed: {error}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'default' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, changed): # pragma: no cover"",
            ""        print(f\""Done: {src} with status {changed}\"") # pragma: no cover"",
            ""    def failed(self, src, msg): # pragma: no cover"",
            ""        print(f\""Failed: {src} with message {msg}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    print(f\""Cache read for mode {mode}\"") # pragma: no cover"",
            ""    return {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    print(f\""Filtering cache {cache} for sources {sources}\"") # pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Writing cache {cache} for sources {sources_to_cache} in mode {mode}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(f\""Cancelled pending tasks: {pending}\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = {} # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""fast = False # pragma: no cover"",
            ""mode = 'mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""report = Report() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""def report_done(src, status): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def report_failed(src, msg): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, changed): # pragma: no cover"",
            ""        return report_done(src, changed) # pragma: no cover"",
            ""    def failed(self, src, msg): # pragma: no cover"",
            ""        return report_failed(src, msg) # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""cache = {} # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = {} # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, changed): # pragma: no cover"",
            ""        print(f'Done: {src} -> {changed}') # pragma: no cover"",
            ""    def failed(self, src, error): # pragma: no cover"",
            ""        print(f'Failed: {src} -> {error}') # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f'Writing cache for: {sources_to_cache}') # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print('Exiting...') # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, changed): # pragma: no cover"",
            ""        print(f\""Report done: {src}, {changed}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Report failed: {src}, {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""sources = [] # pragma: no cover"",
            ""write_back = WriteBack.COLOR_DIFF # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'some_mode' # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    }
]",3,5510,0.002755,4138,0.006207,0.008962
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Run formatting of `sources` in parallel using the provided `executor`.
    (Use ProcessPoolExecutors for actual parallelism.)
    `write_back`, `fast`, and `mode` options are passed to
    :func:`format_file_in_place`.
    """"""
cache: Cache = {} # uncovered
if write_back not in (WriteBack.DIFF, WriteBack.COLOR_DIFF): # uncovered
    cache = read_cache(mode) # uncovered
    sources, cached = filter_cached(cache, sources) # uncovered
    for src in sorted(cached): # uncovered
        report.done(src, Changed.CACHED) # uncovered
if not sources: # uncovered
    exit() # uncovered
cancelled = [] # uncovered
sources_to_cache = [] # uncovered
lock = None # uncovered
if write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF): # uncovered
    # For diff output, we need locks to ensure we don't interleave output
    # from different processes.
    manager = Manager() # uncovered
    lock = manager.Lock() # uncovered
tasks = { # uncovered
    asyncio.ensure_future( # uncovered
        loop.run_in_executor( # uncovered
            executor, format_file_in_place, src, fast, mode, write_back, lock # uncovered
        ) # uncovered
    ): src # uncovered
    for src in sorted(sources) # uncovered
} # uncovered
pending = tasks.keys() # uncovered
try: # uncovered
    loop.add_signal_handler(signal.SIGINT, cancel, pending) # uncovered
    loop.add_signal_handler(signal.SIGTERM, cancel, pending) # uncovered
except NotImplementedError: # uncovered
    # There are no good alternatives for these on Windows.
    pass # uncovered
while pending: # uncovered
    done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED) # uncovered
    for task in done: # uncovered
        src = tasks.pop(task) # uncovered
        if task.cancelled(): # uncovered
            cancelled.append(task) # uncovered
        elif task.exception(): # uncovered
            report.failed(src, str(task.exception())) # uncovered
        else: # uncovered
            changed = Changed.YES if task.result() else Changed.NO # uncovered
            # If the file was written back or was successfully checked as
            # well-formatted, store this information in the cache.
            if write_back is WriteBack.YES or ( # uncovered
                write_back is WriteBack.CHECK and changed is Changed.NO # uncovered
            ): # uncovered
                sources_to_cache.append(src) # uncovered
            report.done(src, changed) # uncovered
if cancelled: # uncovered
    await asyncio.gather(*cancelled, return_exceptions=True) # uncovered
if sources_to_cache: # uncovered
    write_cache(cache, sources_to_cache, mode) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.YES"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = True"",
            ""mode = 'default_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'content1', 'file2.py': 'content2'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    uncached = [src for src in sources if src not in cache]"",
            ""    return uncached, cached"",
            """",
            ""class Report:"",
            ""    @staticmethod"",
            ""    def done(src, status):"",
            ""        print(f\""Report done: {src}, {status}\"")"",
            ""    @staticmethod"",
            ""    def failed(src, message):"",
            ""        print(f\""Report failed: {src}, {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancelled tasks.\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print(\""Exiting...\"")""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1': 'cached'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, changed):"",
            ""        print(f\""Done: {src} with status {changed}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed: {src} with message {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return False"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for {sources_to_cache}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.YES"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""sources = ['file1', 'file2']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.YES"",
            ""fast = False"",
            ""mode = 'example_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""class Report:"",
            ""    @staticmethod"",
            ""    def done(src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    @staticmethod"",
            ""    def failed(src, msg):"",
            ""        print(f\""Failed {src}, msg: {msg}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""def write_cache(cache, sources, mode):"",
            ""    print(f\""Writing cache for {sources}\"")"",
            """",
            ""def cancel(pending):"",
            ""    for task in pending:"",
            ""        task.cancel()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return False"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1': 'cached'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    cached_sources = [src for src in sources if src in cache]"",
            ""    return new_sources, cached_sources"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""write_back = WriteBack.CHECK"",
            ""fast = True"",
            ""mode = 'default'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""sources = ['file1', 'file2']"",
            ""report = Report()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""from typing import Dict, List""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""class Report:"",
            ""    def done(self, src, changed):"",
            ""        print(f'Done: {src} with status {changed}')"",
            ""    def failed(self, src, message):"",
            ""        print(f'Failed: {src} with message {message}')"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.YES"",
            ""fast = False"",
            ""mode = 'example_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""cache = {}"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""cancelled = []"",
            ""sources_to_cache = []"",
            ""lock = None"",
            ""report = Report()"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    not_cached = [src for src in sources if src not in cache]"",
            ""    return not_cached, cached"",
            """",
            ""def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return False"",
            """",
            ""def exit():"",
            ""    print(\""Exit called\"")"",
            """",
            ""def write_cache(cache, sources, mode):"",
            ""    print(f\""Write cache for sources: {sources}\"")"",
            """",
            ""def cancel(pending):"",
            ""    for task in pending:"",
            ""        task.cancel()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.YES"",
            ""mode = 'example_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = False"",
            ""cancelled = []"",
            ""sources_to_cache = []"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return False"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    not_cached = [src for src in sources if src not in cache]"",
            ""    return not_cached, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, msg):"",
            ""        print(f\""Failed {src}, msg: {msg}\"")"",
            """",
            ""report = Report()"",
            """",
            ""def write_cache(cache, sources, mode):"",
            ""    print(f\""Writing cache for {sources}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.YES"",
            ""fast = False"",
            ""mode = 'example_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    remaining = [src for src in sources if src not in cache]"",
            ""    return remaining, cached"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def report_done(src, status):"",
            ""    print(f\""Processed {src} with status {status}\"")"",
            """",
            ""def report_failed(src, msg):"",
            ""    print(f\""Failed {src} with message {msg}\"")"",
            """",
            ""def write_cache(cache, sources, mode):"",
            ""    print(f\""Writing cache for {sources}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    print(\""Cancel tasks\"")"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""report = type('Report', (object,), {"",
            ""    'done': report_done,"",
            ""    'failed': report_failed"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def read_cache(mode):"",
            ""    return {}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    return sources, []"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, error):"",
            ""        print(f\""Failed {src}, error: {error}\"")"",
            """",
            ""report = Report()"",
            """",
            ""def write_cache(cache, sources, mode):"",
            ""    print(f\""Writing cache for: {sources}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.CHECK"",
            ""mode = 'example_mode'"",
            ""sources = []"",
            ""fast = True"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.YES"",
            ""fast = False"",
            ""mode = 'example_mode'"",
            ""sources = ['file1', 'file2', 'file3']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""cancelled = []"",
            ""sources_to_cache = []"",
            ""lock = None"",
            ""def read_cache(mode):"",
            ""    return {'file1': 'cached'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    not_cached = [src for src in sources if src not in cache]"",
            ""    return not_cached, cached"",
            """",
            ""def report_done(src, status):"",
            ""    print(f\""Done processing {src} with status {status.name}\"")"",
            """",
            ""def report_failed(src, msg):"",
            ""    print(f\""Failed processing {src} with message {msg}\"")"",
            """",
            ""report = type('Mock', (object,), {"",
            ""    'done': report_done,"",
            ""    'failed': report_failed"",
            ""})()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources, mode):"",
            ""    print(f\""Cache updated for {sources}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    for task in tasks:"",
            ""        task.cancel()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    return sources, []"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src} with status {status}\"")"",
            ""    def failed(self, src, msg):"",
            ""        print(f\""Failed to process {src} with message {msg}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Writing cache for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.YES"",
            ""fast = True"",
            ""mode = 'test_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    }
]","[
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'content1', 'file2.py': 'content2'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    uncached = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return uncached, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    @staticmethod # pragma: no cover"",
            ""    def done(src, status): # pragma: no cover"",
            ""        print(f\""Report done: {src}, {status}\"") # pragma: no cover"",
            ""    @staticmethod # pragma: no cover"",
            ""    def failed(src, message): # pragma: no cover"",
            ""        print(f\""Report failed: {src}, {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancelled tasks.\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exiting...\"") # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1': 'cached'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, changed): # pragma: no cover"",
            ""        print(f\""Done: {src} with status {changed}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed: {src} with message {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1', 'file2'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""fast = False # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    @staticmethod # pragma: no cover"",
            ""    def done(src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    @staticmethod # pragma: no cover"",
            ""    def failed(src, msg): # pragma: no cover"",
            ""        print(f\""Failed {src}, msg: {msg}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources, mode): # pragma: no cover"",
            ""    print(f\""Writing cache for {sources}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1': 'cached'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    cached_sources = [src for src in sources if src in cache] # pragma: no cover"",
            ""    return new_sources, cached_sources # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'default' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""sources = ['file1', 'file2'] # pragma: no cover"",
            ""report = Report() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""from typing import Dict, List # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, changed): # pragma: no cover"",
            ""        print(f'Done: {src} with status {changed}') # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f'Failed: {src} with message {message}') # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""fast = False # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""cache = {} # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""cancelled = [] # pragma: no cover"",
            ""sources_to_cache = [] # pragma: no cover"",
            ""lock = None # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    not_cached = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return not_cached, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exit called\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources, mode): # pragma: no cover"",
            ""    print(f\""Write cache for sources: {sources}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = False # pragma: no cover"",
            ""cancelled = [] # pragma: no cover"",
            ""sources_to_cache = [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    not_cached = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return not_cached, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, msg): # pragma: no cover"",
            ""        print(f\""Failed {src}, msg: {msg}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources, mode): # pragma: no cover"",
            ""    print(f\""Writing cache for {sources}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""fast = False # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    remaining = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return remaining, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def report_done(src, status): # pragma: no cover"",
            ""    print(f\""Processed {src} with status {status}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def report_failed(src, msg): # pragma: no cover"",
            ""    print(f\""Failed {src} with message {msg}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources, mode): # pragma: no cover"",
            ""    print(f\""Writing cache for {sources}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    print(\""Cancel tasks\"") # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = type('Report', (object,), { # pragma: no cover"",
            ""    'done': report_done, # pragma: no cover"",
            ""    'failed': report_failed # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, error): # pragma: no cover"",
            ""        print(f\""Failed {src}, error: {error}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources, mode): # pragma: no cover"",
            ""    print(f\""Writing cache for: {sources}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = [] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""fast = False # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1', 'file2', 'file3'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""cancelled = [] # pragma: no cover"",
            ""sources_to_cache = [] # pragma: no cover"",
            ""lock = None # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1': 'cached'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    not_cached = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return not_cached, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""def report_done(src, status): # pragma: no cover"",
            ""    print(f\""Done processing {src} with status {status.name}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def report_failed(src, msg): # pragma: no cover"",
            ""    print(f\""Failed processing {src} with message {msg}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = type('Mock', (object,), { # pragma: no cover"",
            ""    'done': report_done, # pragma: no cover"",
            ""    'failed': report_failed # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources, mode): # pragma: no cover"",
            ""    print(f\""Cache updated for {sources}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    return sources, [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src} with status {status}\"") # pragma: no cover"",
            ""    def failed(self, src, msg): # pragma: no cover"",
            ""        print(f\""Failed to process {src} with message {msg}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Writing cache for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'test_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    }
]",3,10515,0.0052575,4630,0.006945,0.0122025
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Run formatting of `sources` in parallel using the provided `executor`.
    (Use ProcessPoolExecutors for actual parallelism.)
    `write_back`, `fast`, and `mode` options are passed to
    :func:`format_file_in_place`.
    """"""
cache: Cache = {} # uncovered
if write_back not in (WriteBack.DIFF, WriteBack.COLOR_DIFF): # uncovered
    cache = read_cache(mode) # uncovered
    sources, cached = filter_cached(cache, sources) # uncovered
    for src in sorted(cached): # uncovered
        report.done(src, Changed.CACHED) # uncovered
if not sources: # uncovered
    exit() # uncovered
cancelled = [] # uncovered
sources_to_cache = [] # uncovered
lock = None # uncovered
if write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF): # uncovered
    # For diff output, we need locks to ensure we don't interleave output
    # from different processes.
    manager = Manager() # uncovered
    lock = manager.Lock() # uncovered
tasks = { # uncovered
    asyncio.ensure_future( # uncovered
        loop.run_in_executor( # uncovered
            executor, format_file_in_place, src, fast, mode, write_back, lock # uncovered
        ) # uncovered
    ): src # uncovered
    for src in sorted(sources) # uncovered
} # uncovered
pending = tasks.keys() # uncovered
try: # uncovered
    loop.add_signal_handler(signal.SIGINT, cancel, pending) # uncovered
    loop.add_signal_handler(signal.SIGTERM, cancel, pending) # uncovered
except NotImplementedError: # uncovered
    # There are no good alternatives for these on Windows.
    pass # uncovered
while pending: # uncovered
    done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED) # uncovered
    for task in done: # uncovered
        src = tasks.pop(task) # uncovered
        if task.cancelled(): # uncovered
            cancelled.append(task) # uncovered
        elif task.exception(): # uncovered
            report.failed(src, str(task.exception())) # uncovered
        else: # uncovered
            changed = Changed.YES if task.result() else Changed.NO # uncovered
            # If the file was written back or was successfully checked as
            # well-formatted, store this information in the cache.
            if write_back is WriteBack.YES or ( # uncovered
                write_back is WriteBack.CHECK and changed is Changed.NO # uncovered
            ): # uncovered
                sources_to_cache.append(src) # uncovered
            report.done(src, changed) # uncovered
if cancelled: # uncovered
    await asyncio.gather(*cancelled, return_exceptions=True) # uncovered
if sources_to_cache: # uncovered
    write_cache(cache, sources_to_cache, mode) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, msg):"",
            ""        print(f\""Failed {src}, message: {msg}\"")"",
            """",
            ""report = Report()"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached', 'file2.py': 'cached'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return False"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print(\""Exiting...\"")"",
            ""    sys.exit(0)"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.YES"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from multiprocessing import Manager"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.YES"",
            ""fast = False"",
            ""mode = 'test_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_value'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    not_cached = [src for src in sources if src not in cache]"",
            ""    return not_cached, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, msg):"",
            ""        print(f\""Failed {src}, msg: {msg}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return False"",
            """",
            ""def write_cache(cache, sources, mode):"",
            ""    print(f\""Writing cache for: {sources}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancelling tasks...\"")"",
            ""    for task in pending:"",
            ""        task.cancel()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.CHECK"",
            ""fast = False"",
            ""mode = 'example_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    not_cached = [src for src in sources if src not in cache]"",
            ""    return not_cached, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Done processing {src} with status {status}\"")"",
            ""    def failed(self, src, msg):"",
            ""        print(f\""Failed processing {src} with message {msg}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return False"",
            """",
            ""def write_cache(cache, sources, mode):"",
            ""    print(f\""Writing cache for {sources}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print(\""Exiting...\"")""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file2.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, changed):"",
            ""        print(f\""Done: {src} -> {changed.name}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed: {src} -> {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.YES"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""def write_cache(cache, sources, mode):"",
            ""    print(f\""Writing cache for {sources}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            ""sources = ['file1.py', 'file2.py']"",
            ""write_back = WriteBack.CHECK"",
            ""fast = True"",
            ""mode = 'test_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.CHECK"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = True"",
            ""mode = 'default_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'content1', 'file2.py': 'content2'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    uncached = [src for src in sources if src not in cache]"",
            ""    return uncached, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Report done: {src}, {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Report failed: {src}, {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancelled tasks.\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print(\""Exiting...\"")""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""write_back = WriteBack.CHECK"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    not_cached = [src for src in sources if src not in cache]"",
            ""    return not_cached, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources, mode):"",
            ""    print(f\""Writing cache for {sources}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    for task in tasks:"",
            ""        task.cancel()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.CHECK"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""sources = ['file1', 'file2']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    uncached = [src for src in sources if src not in cache]"",
            ""    return uncached, cached"",
            """",
            ""def report_done(src, status):"",
            ""    print(f\""Processed {src} with status {status}\"")"",
            """",
            ""def report_failed(src, msg):"",
            ""    print(f\""Failed {src} with message {msg}\"")"",
            """",
            ""report = type('Report', (object,), {"",
            ""    'done': report_done,"",
            ""    'failed': report_failed"",
            ""})()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources, mode):"",
            ""    print(f\""Writing cache for {sources}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    print(\""Cancel tasks\"")"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print(\""Exiting...\"")"",
            ""    sys.exit()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.YES"",
            ""mode = 'example_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = False"",
            ""cancelled = []"",
            ""sources_to_cache = []"",
            ""lock = None"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    remaining = [src for src in sources if src not in cache]"",
            ""    return remaining, cached"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def report_done(src, status):"",
            ""    print(f\""Processed {src} with status {status}\"")"",
            """",
            ""def report_failed(src, msg):"",
            ""    print(f\""Failed {src} with message {msg}\"")"",
            """",
            ""def write_cache(cache, sources, mode):"",
            ""    print(f\""Writing cache for {sources}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    print(\""Cancel tasks\"")"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    sys.exit()"",
            """",
            ""report = type('Mock', (object,), {"",
            ""    'done': report_done,"",
            ""    'failed': report_failed"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    not_cached = [src for src in sources if src not in cache]"",
            ""    return not_cached, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, msg):"",
            ""        print(f\""Failed {src}, msg: {msg}\"")"",
            """",
            ""report = Report()"",
            """",
            ""def write_cache(cache, sources, mode):"",
            ""    print(f\""Writing cache for {sources}\"")"",
            """",
            ""def cancel(pending):"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.CHECK"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    }
]","[
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, msg): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {msg}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached', 'file2.py': 'cached'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exiting...\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""fast = False # pragma: no cover"",
            ""mode = 'test_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_value'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    not_cached = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return not_cached, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, msg): # pragma: no cover"",
            ""        print(f\""Failed {src}, msg: {msg}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources, mode): # pragma: no cover"",
            ""    print(f\""Writing cache for: {sources}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancelling tasks...\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""fast = False # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    not_cached = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return not_cached, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Done processing {src} with status {status}\"") # pragma: no cover"",
            ""    def failed(self, src, msg): # pragma: no cover"",
            ""        print(f\""Failed processing {src} with message {msg}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources, mode): # pragma: no cover"",
            ""    print(f\""Writing cache for {sources}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exiting...\"") # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file2.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, changed): # pragma: no cover"",
            ""        print(f\""Done: {src} -> {changed.name}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed: {src} -> {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources, mode): # pragma: no cover"",
            ""    print(f\""Writing cache for {sources}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'test_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'content1', 'file2.py': 'content2'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    uncached = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return uncached, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Report done: {src}, {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Report failed: {src}, {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancelled tasks.\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exiting...\"") # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    not_cached = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return not_cached, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources, mode): # pragma: no cover"",
            ""    print(f\""Writing cache for {sources}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1', 'file2'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    uncached = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return uncached, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""def report_done(src, status): # pragma: no cover"",
            ""    print(f\""Processed {src} with status {status}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def report_failed(src, msg): # pragma: no cover"",
            ""    print(f\""Failed {src} with message {msg}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = type('Report', (object,), { # pragma: no cover"",
            ""    'done': report_done, # pragma: no cover"",
            ""    'failed': report_failed # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources, mode): # pragma: no cover"",
            ""    print(f\""Writing cache for {sources}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    print(\""Cancel tasks\"") # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exiting...\"") # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = False # pragma: no cover"",
            ""cancelled = [] # pragma: no cover"",
            ""sources_to_cache = [] # pragma: no cover"",
            ""lock = None # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    remaining = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return remaining, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def report_done(src, status): # pragma: no cover"",
            ""    print(f\""Processed {src} with status {status}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def report_failed(src, msg): # pragma: no cover"",
            ""    print(f\""Failed {src} with message {msg}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources, mode): # pragma: no cover"",
            ""    print(f\""Writing cache for {sources}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    print(\""Cancel tasks\"") # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = type('Mock', (object,), { # pragma: no cover"",
            ""    'done': report_done, # pragma: no cover"",
            ""    'failed': report_failed # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    not_cached = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return not_cached, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, msg): # pragma: no cover"",
            ""        print(f\""Failed {src}, msg: {msg}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources, mode): # pragma: no cover"",
            ""    print(f\""Writing cache for {sources}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    }
]",3,11392,0.005696,4752,0.007128,0.0128239999999999
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Run formatting of `sources` in parallel using the provided `executor`.
    (Use ProcessPoolExecutors for actual parallelism.)
    `write_back`, `fast`, and `mode` options are passed to
    :func:`format_file_in_place`.
    """"""
cache: Cache = {} # uncovered
if write_back not in (WriteBack.DIFF, WriteBack.COLOR_DIFF): # uncovered
    cache = read_cache(mode) # uncovered
    sources, cached = filter_cached(cache, sources) # uncovered
    for src in sorted(cached): # uncovered
        report.done(src, Changed.CACHED) # uncovered
if not sources: # uncovered
    exit() # uncovered
cancelled = [] # uncovered
sources_to_cache = [] # uncovered
lock = None # uncovered
if write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF): # uncovered
    # For diff output, we need locks to ensure we don't interleave output
    # from different processes.
    manager = Manager() # uncovered
    lock = manager.Lock() # uncovered
tasks = { # uncovered
    asyncio.ensure_future( # uncovered
        loop.run_in_executor( # uncovered
            executor, format_file_in_place, src, fast, mode, write_back, lock # uncovered
        ) # uncovered
    ): src # uncovered
    for src in sorted(sources) # uncovered
} # uncovered
pending = tasks.keys() # uncovered
try: # uncovered
    loop.add_signal_handler(signal.SIGINT, cancel, pending) # uncovered
    loop.add_signal_handler(signal.SIGTERM, cancel, pending) # uncovered
except NotImplementedError: # uncovered
    # There are no good alternatives for these on Windows.
    pass # uncovered
while pending: # uncovered
    done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED) # uncovered
    for task in done: # uncovered
        src = tasks.pop(task) # uncovered
        if task.cancelled(): # uncovered
            cancelled.append(task) # uncovered
        elif task.exception(): # uncovered
            report.failed(src, str(task.exception())) # uncovered
        else: # uncovered
            changed = Changed.YES if task.result() else Changed.NO # uncovered
            # If the file was written back or was successfully checked as
            # well-formatted, store this information in the cache.
            if write_back is WriteBack.YES or ( # uncovered
                write_back is WriteBack.CHECK and changed is Changed.NO # uncovered
            ): # uncovered
                sources_to_cache.append(src) # uncovered
            report.done(src, changed) # uncovered
if cancelled: # uncovered
    await asyncio.gather(*cancelled, return_exceptions=True) # uncovered
if sources_to_cache: # uncovered
    write_cache(cache, sources_to_cache, mode) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""def write_cache(cache, sources, mode):"",
            ""    print(f\""Writing cache for {sources}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            ""sources = ['file1.py', 'file2.py']"",
            ""write_back = WriteBack.CHECK"",
            ""fast = True"",
            ""mode = 'test_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.CHECK"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = True"",
            ""mode = 'default_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'content1', 'file2.py': 'content2'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    uncached = [src for src in sources if src not in cache]"",
            ""    return uncached, cached"",
            """",
            ""class Report:"",
            ""    @staticmethod"",
            ""    def done(src, status):"",
            ""        print(f\""Report done: {src}, {status}\"")"",
            ""    @staticmethod"",
            ""    def failed(src, message):"",
            ""        print(f\""Report failed: {src}, {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancelled tasks.\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print(\""Exiting...\"")""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1': 'cached', 'file2': 'cached'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, msg):"",
            ""        print(f\""Failed {src}, message: {msg}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return False"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print(\""Exiting...\"")"",
            ""    sys.exit(0)"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.YES"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""sources = ['file1', 'file2']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    remaining = [src for src in sources if src not in cache]"",
            ""    return remaining, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, msg):"",
            ""        print(f\""Failed {src}, message: {msg}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources, mode):"",
            ""    print(f\""Writing cache for {sources}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            ""write_back = WriteBack.YES"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = True"",
            ""mode = 'test_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""def write_cache(cache, sources, mode):"",
            ""    print(f\""Writing cache for {sources}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print(\""Exiting...\"")"",
            ""    sys.exit(0)"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.CHECK"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.CHECK"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    not_cached = [src for src in sources if src not in cache]"",
            ""    return not_cached, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return False"",
            """",
            ""def write_cache(cache, sources, mode):"",
            ""    print(f\""Write cache for sources: {sources}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print(\""Exiting program...\"")""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print(\""Exiting...\"")"",
            ""    sys.exit(0)"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.YES"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return False"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print(\""Exiting...\"")"",
            ""    sys.exit(0)"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.CHECK"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, changed):"",
            ""        print(f\""Done: {src} -> {changed.name}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed: {src} -> {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print(\""Exiting...\"")"",
            ""    sys.exit(0)"",
            """",
            ""write_back = WriteBack.CHECK"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""cache = Cache()"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    uncached = [src for src in sources if src not in cache]"",
            ""    return uncached, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Done: {src} with status {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed: {src} with message {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources, mode):"",
            ""    print(f\""Writing cache for {sources}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print(\""Exit called\"")"",
            ""    sys.exit()"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.CHECK"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""sources = ['file1', 'file2']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    }
]","[
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources, mode): # pragma: no cover"",
            ""    print(f\""Writing cache for {sources}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'test_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'default_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'content1', 'file2.py': 'content2'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    uncached = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return uncached, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    @staticmethod # pragma: no cover"",
            ""    def done(src, status): # pragma: no cover"",
            ""        print(f\""Report done: {src}, {status}\"") # pragma: no cover"",
            ""    @staticmethod # pragma: no cover"",
            ""    def failed(src, message): # pragma: no cover"",
            ""        print(f\""Report failed: {src}, {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancelled tasks.\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exiting...\"") # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1': 'cached', 'file2': 'cached'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, msg): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {msg}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exiting...\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1', 'file2'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    remaining = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return remaining, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, msg): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {msg}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources, mode): # pragma: no cover"",
            ""    print(f\""Writing cache for {sources}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'test_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources, mode): # pragma: no cover"",
            ""    print(f\""Writing cache for {sources}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exiting...\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    not_cached = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return not_cached, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources, mode): # pragma: no cover"",
            ""    print(f\""Write cache for sources: {sources}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exiting program...\"") # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exiting...\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exiting...\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, changed): # pragma: no cover"",
            ""        print(f\""Done: {src} -> {changed.name}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed: {src} -> {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exiting...\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    uncached = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return uncached, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Done: {src} with status {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed: {src} with message {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources, mode): # pragma: no cover"",
            ""    print(f\""Writing cache for {sources}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exit called\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1', 'file2'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    }
]",3,12006,0.006003,4809,0.0072135,0.0132164999999999
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Run formatting of `sources` in parallel using the provided `executor`.
    (Use ProcessPoolExecutors for actual parallelism.)
    `write_back`, `fast`, and `mode` options are passed to
    :func:`format_file_in_place`.
    """"""
cache: Cache = {} # uncovered
if write_back not in (WriteBack.DIFF, WriteBack.COLOR_DIFF): # uncovered
    cache = read_cache(mode) # uncovered
    sources, cached = filter_cached(cache, sources) # uncovered
    for src in sorted(cached): # uncovered
        report.done(src, Changed.CACHED) # uncovered
if not sources: # uncovered
    exit() # uncovered
cancelled = [] # uncovered
sources_to_cache = [] # uncovered
lock = None # uncovered
if write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF): # uncovered
    # For diff output, we need locks to ensure we don't interleave output
    # from different processes.
    manager = Manager() # uncovered
    lock = manager.Lock() # uncovered
tasks = { # uncovered
    asyncio.ensure_future( # uncovered
        loop.run_in_executor( # uncovered
            executor, format_file_in_place, src, fast, mode, write_back, lock # uncovered
        ) # uncovered
    ): src # uncovered
    for src in sorted(sources) # uncovered
} # uncovered
pending = tasks.keys() # uncovered
try: # uncovered
    loop.add_signal_handler(signal.SIGINT, cancel, pending) # uncovered
    loop.add_signal_handler(signal.SIGTERM, cancel, pending) # uncovered
except NotImplementedError: # uncovered
    # There are no good alternatives for these on Windows.
    pass # uncovered
while pending: # uncovered
    done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED) # uncovered
    for task in done: # uncovered
        src = tasks.pop(task) # uncovered
        if task.cancelled(): # uncovered
            cancelled.append(task) # uncovered
        elif task.exception(): # uncovered
            report.failed(src, str(task.exception())) # uncovered
        else: # uncovered
            changed = Changed.YES if task.result() else Changed.NO # uncovered
            # If the file was written back or was successfully checked as
            # well-formatted, store this information in the cache.
            if write_back is WriteBack.YES or ( # uncovered
                write_back is WriteBack.CHECK and changed is Changed.NO # uncovered
            ): # uncovered
                sources_to_cache.append(src) # uncovered
            report.done(src, changed) # uncovered
if cancelled: # uncovered
    await asyncio.gather(*cancelled, return_exceptions=True) # uncovered
if sources_to_cache: # uncovered
    write_cache(cache, sources_to_cache, mode) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_value', 'file2.py': 'cached_value'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    not_cached = [src for src in sources if src not in cache]"",
            ""    return not_cached, cached"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src} with status {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src} with message {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""def write_cache(cache, sources, mode):"",
            ""    print(f\""Writing cache for sources: {sources}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""write_back = WriteBack.DIFF"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""cancelled = []"",
            ""sources_to_cache = []"",
            ""lock = None"",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit(0)""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print(\""Exiting...\"")"",
            ""    sys.exit(0)"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.DIFF"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources, mode):"",
            ""    print(f\""Writing cache for {sources}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            ""write_back = WriteBack.YES"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = True"",
            ""mode = 'test_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""def exit():"",
            ""    sys.exit(0)""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print(\""Exiting...\"")"",
            ""    sys.exit(0)"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.DIFF"",
            ""fast = True"",
            ""mode = 'test_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = []"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return False"",
            """",
            ""def write_cache(cache, sources, mode):"",
            ""    print(f\""Writing cache for {sources}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""write_back = WriteBack.DIFF"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit(0)""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    uncached = [src for src in sources if src not in cache]"",
            ""    return uncached, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Done: {src} with status {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed: {src} with message {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources, mode):"",
            ""    print(f\""Writing cache for {sources}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print(\""Exit called\"")"",
            ""    sys.exit()"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.YES"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""sources = ['file1', 'file2']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print(\""Exiting...\"")"",
            ""    sys.exit(0)"",
            """",
            ""write_back = WriteBack.YE"",
            ""fast = False"",
            ""mode = 'test_mode'"",
            ""sources = ['file1.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached', 'file2.py': 'cached'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, msg):"",
            ""        print(f\""Failed {src}, message: {msg}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return False"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print(\""Exiting...\"")"",
            ""    sys.exit(0)"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.YES"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print(\""Exiting...\"")"",
            ""    sys.exit(0)"",
            """",
            ""write_back = WriteBack.YES"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""cache = Cache()"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""def write_cache(cache, sources, mode):"",
            ""    print(f\""Writing cache for {sources}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print(\""Exiting...\"")"",
            ""    sys.exit(0)"",
            """",
            ""write_back = WriteBack.YES"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""cache = Cache()"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    }
]","[
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_value', 'file2.py': 'cached_value'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    not_cached = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return not_cached, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src} with status {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src} with message {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources, mode): # pragma: no cover"",
            ""    print(f\""Writing cache for sources: {sources}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""cancelled = [] # pragma: no cover"",
            ""sources_to_cache = [] # pragma: no cover"",
            ""lock = None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exiting...\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources, mode): # pragma: no cover"",
            ""    print(f\""Writing cache for {sources}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'test_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exiting...\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'test_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources, mode): # pragma: no cover"",
            ""    print(f\""Writing cache for {sources}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    uncached = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return uncached, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Done: {src} with status {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed: {src} with message {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources, mode): # pragma: no cover"",
            ""    print(f\""Writing cache for {sources}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exit called\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1', 'file2'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exiting...\"") # pragma: no cover"",
            ""fast = False # pragma: no cover"",
            ""mode = 'test_mode' # pragma: no cover"",
            ""sources = ['file1.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached', 'file2.py': 'cached'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, msg): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {msg}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exiting...\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exiting...\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources, mode): # pragma: no cover"",
            ""    print(f\""Writing cache for {sources}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exiting...\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    }
]",3,12185,0.0060925,4838,0.007257,0.0133495
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Run formatting of `sources` in parallel using the provided `executor`.
    (Use ProcessPoolExecutors for actual parallelism.)
    `write_back`, `fast`, and `mode` options are passed to
    :func:`format_file_in_place`.
    """"""
cache: Cache = {} # uncovered
if write_back not in (WriteBack.DIFF, WriteBack.COLOR_DIFF): # uncovered
    cache = read_cache(mode) # uncovered
    sources, cached = filter_cached(cache, sources) # uncovered
    for src in sorted(cached): # uncovered
        report.done(src, Changed.CACHED) # uncovered
if not sources: # uncovered
    exit() # uncovered
cancelled = [] # uncovered
sources_to_cache = [] # uncovered
lock = None # uncovered
if write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF): # uncovered
    # For diff output, we need locks to ensure we don't interleave output
    # from different processes.
    manager = Manager() # uncovered
    lock = manager.Lock() # uncovered
tasks = { # uncovered
    asyncio.ensure_future( # uncovered
        loop.run_in_executor( # uncovered
            executor, format_file_in_place, src, fast, mode, write_back, lock # uncovered
        ) # uncovered
    ): src # uncovered
    for src in sorted(sources) # uncovered
} # uncovered
pending = tasks.keys() # uncovered
try: # uncovered
    loop.add_signal_handler(signal.SIGINT, cancel, pending) # uncovered
    loop.add_signal_handler(signal.SIGTERM, cancel, pending) # uncovered
except NotImplementedError: # uncovered
    # There are no good alternatives for these on Windows.
    pass # uncovered
while pending: # uncovered
    done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED) # uncovered
    for task in done: # uncovered
        src = tasks.pop(task) # uncovered
        if task.cancelled(): # uncovered
            cancelled.append(task) # uncovered
        elif task.exception(): # uncovered
            report.failed(src, str(task.exception())) # uncovered
        else: # uncovered
            changed = Changed.YES if task.result() else Changed.NO # uncovered
            # If the file was written back or was successfully checked as
            # well-formatted, store this information in the cache.
            if write_back is WriteBack.YES or ( # uncovered
                write_back is WriteBack.CHECK and changed is Changed.NO # uncovered
            ): # uncovered
                sources_to_cache.append(src) # uncovered
            report.done(src, changed) # uncovered
if cancelled: # uncovered
    await asyncio.gather(*cancelled, return_exceptions=True) # uncovered
if sources_to_cache: # uncovered
    write_cache(cache, sources_to_cache, mode) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_value'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    not_cached = [src for src in sources if src not in cache]"",
            ""    return not_cached, cached"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src} with status {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src} with message {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Writing cache for: {sources_to_cache}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""write_back = WriteBack.YES"",
            ""sources = ['file1.py']"",
            ""fast = True"",
            ""mode = 'test_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""cancelled = []"",
            ""sources_to_cache = []"",
            ""lock = None"",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit(0)""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print(\""Exiting...\"")"",
            ""    sys.exit(0)"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.CHECK"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return False"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print(\""Exiting...\"")"",
            ""    sys.exit(0)"",
            """",
            ""write_back = WriteBack.DIFF"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""cache = Cache()"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""cancelled = []"",
            ""sources_to_cache = []"",
            ""lock = None""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    remaining = [src for src in sources if src not in cache]"",
            ""    return remaining, cached"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""def write_cache(cache, sources, mode):"",
            ""    print(f\""Writing cache for {sources}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""write_back = WriteBack.CHECK"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""cache = Cache()"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""cancelled = []"",
            ""sources_to_cache = []"",
            ""lock = None"",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit(0)""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    not_cached = [src for src in sources if src not in cache]"",
            ""    return not_cached, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print(\""Exiting...\"")"",
            ""    sys.exit(0)"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.CHECK"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""sources = ['file1.py', 'file3.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    uncached = [src for src in sources if src not in cache]"",
            ""    return uncached, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.CHECK"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit(0)""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print(\""Exiting...\"")"",
            ""    sys.exit(0)"",
            """",
            ""write_back = WriteBack.DIFF"",
            ""fast = True"",
            ""mode = 'test_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""cache = Cache()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""cache = Cache()"",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return False"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src} with status {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src} with message {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""write_back = WriteBack.CHECK"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""def exit():"",
            ""    sys.exit(0)""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    not_cached = [src for src in sources if src not in cache]"",
            ""    return not_cached, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Writing cache for {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print(\""Exiting...\"")"",
            ""    sys.exit(0)"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.COLOR_DIFF"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""cancelled = []"",
            ""sources_to_cache = []"",
            ""lock = None""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content', 'file2.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print(\""Exiting...\"")"",
            ""    sys.exit(0)"",
            """",
            ""write_back = WriteBack.CHECK"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""cache = Cache()"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    }
]","[
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_value'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    not_cached = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return not_cached, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src} with status {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src} with message {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Writing cache for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""sources = ['file1.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'test_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""cancelled = [] # pragma: no cover"",
            ""sources_to_cache = [] # pragma: no cover"",
            ""lock = None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exiting...\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exiting...\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""cancelled = [] # pragma: no cover"",
            ""sources_to_cache = [] # pragma: no cover"",
            ""lock = None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    remaining = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return remaining, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources, mode): # pragma: no cover"",
            ""    print(f\""Writing cache for {sources}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""cancelled = [] # pragma: no cover"",
            ""sources_to_cache = [] # pragma: no cover"",
            ""lock = None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    not_cached = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return not_cached, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exiting...\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file3.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    uncached = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return uncached, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exiting...\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'test_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""cache = Cache() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src} with status {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src} with message {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    not_cached = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return not_cached, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Writing cache for {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exiting...\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.COLOR_DIFF # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""cancelled = [] # pragma: no cover"",
            ""sources_to_cache = [] # pragma: no cover"",
            ""lock = None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content', 'file2.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exiting...\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    }
]",3,12271,0.0061355,4987,0.0074805,0.013616
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Run formatting of `sources` in parallel using the provided `executor`.
    (Use ProcessPoolExecutors for actual parallelism.)
    `write_back`, `fast`, and `mode` options are passed to
    :func:`format_file_in_place`.
    """"""
cache: Cache = {} # uncovered
if write_back not in (WriteBack.DIFF, WriteBack.COLOR_DIFF): # uncovered
    cache = read_cache(mode) # uncovered
    sources, cached = filter_cached(cache, sources) # uncovered
    for src in sorted(cached): # uncovered
        report.done(src, Changed.CACHED) # uncovered
if not sources: # uncovered
    exit() # uncovered
cancelled = [] # uncovered
sources_to_cache = [] # uncovered
lock = None # uncovered
if write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF): # uncovered
    # For diff output, we need locks to ensure we don't interleave output
    # from different processes.
    manager = Manager() # uncovered
    lock = manager.Lock() # uncovered
tasks = { # uncovered
    asyncio.ensure_future( # uncovered
        loop.run_in_executor( # uncovered
            executor, format_file_in_place, src, fast, mode, write_back, lock # uncovered
        ) # uncovered
    ): src # uncovered
    for src in sorted(sources) # uncovered
} # uncovered
pending = tasks.keys() # uncovered
try: # uncovered
    loop.add_signal_handler(signal.SIGINT, cancel, pending) # uncovered
    loop.add_signal_handler(signal.SIGTERM, cancel, pending) # uncovered
except NotImplementedError: # uncovered
    # There are no good alternatives for these on Windows.
    pass # uncovered
while pending: # uncovered
    done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED) # uncovered
    for task in done: # uncovered
        src = tasks.pop(task) # uncovered
        if task.cancelled(): # uncovered
            cancelled.append(task) # uncovered
        elif task.exception(): # uncovered
            report.failed(src, str(task.exception())) # uncovered
        else: # uncovered
            changed = Changed.YES if task.result() else Changed.NO # uncovered
            # If the file was written back or was successfully checked as
            # well-formatted, store this information in the cache.
            if write_back is WriteBack.YES or ( # uncovered
                write_back is WriteBack.CHECK and changed is Changed.NO # uncovered
            ): # uncovered
                sources_to_cache.append(src) # uncovered
            report.done(src, changed) # uncovered
if cancelled: # uncovered
    await asyncio.gather(*cancelled, return_exceptions=True) # uncovered
if sources_to_cache: # uncovered
    write_cache(cache, sources_to_cache, mode) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    uncached = [src for src in sources if src not in cache]"",
            ""    return uncached, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""write_back = WriteBack.YES"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit(0)""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return False"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print(\""Exiting...\"")"",
            ""    sys.exit(0)"",
            """",
            ""write_back = WriteBack.YES"",
            ""sources = ['file1.py']"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""cache = Cache()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""write_back = WriteBack.CHECK"",
            ""sources = ['file1.py']"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit(0)""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    uncached = [src for src in sources if src not in cache]"",
            ""    return uncached, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Writing cache for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print(\""Exiting...\"")"",
            ""    sys.exit(0)"",
            """",
            ""write_back = WriteBack.YES"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = False"",
            ""mode = 'example_mode'"",
            ""cache = Cache()"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    remaining = [src for src in sources if src not in cache]"",
            ""    return remaining, cached"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return False"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""write_back = WriteBack.YES"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit(0)""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return False"",
            """",
            ""report = Report()"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""write_back = WriteBack.YES"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""def exit():"",
            ""    sys.exit(0)""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print(\""Exiting...\"")"",
            ""    sys.exit(0)"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.YES"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = False"",
            ""mode = 'test_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return False"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit(0)"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.YES"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit(0)"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.DIFF"",
            ""fast = True"",
            ""mode = 'test_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    not_cached = [src for src in sources if src not in cache]"",
            ""    return not_cached, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""write_back = WriteBack.YES"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit(0)""
        ]
    }
]","[
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    uncached = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return uncached, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exiting...\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""sources = ['file1.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""cache = Cache() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""sources = ['file1.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    uncached = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return uncached, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Writing cache for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exiting...\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = False # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    remaining = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return remaining, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exiting...\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = False # pragma: no cover"",
            ""mode = 'test_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print('Exiting...') # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print('Exiting...') # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'test_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    not_cached = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return not_cached, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    }
]",3,6744,0.003372,4860,0.00729,0.010662
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Run formatting of `sources` in parallel using the provided `executor`.
    (Use ProcessPoolExecutors for actual parallelism.)
    `write_back`, `fast`, and `mode` options are passed to
    :func:`format_file_in_place`.
    """"""
cache: Cache = {} # uncovered
if write_back not in (WriteBack.DIFF, WriteBack.COLOR_DIFF): # uncovered
    cache = read_cache(mode) # uncovered
    sources, cached = filter_cached(cache, sources) # uncovered
    for src in sorted(cached): # uncovered
        report.done(src, Changed.CACHED) # uncovered
if not sources: # uncovered
    exit() # uncovered
cancelled = [] # uncovered
sources_to_cache = [] # uncovered
lock = None # uncovered
if write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF): # uncovered
    # For diff output, we need locks to ensure we don't interleave output
    # from different processes.
    manager = Manager() # uncovered
    lock = manager.Lock() # uncovered
tasks = { # uncovered
    asyncio.ensure_future( # uncovered
        loop.run_in_executor( # uncovered
            executor, format_file_in_place, src, fast, mode, write_back, lock # uncovered
        ) # uncovered
    ): src # uncovered
    for src in sorted(sources) # uncovered
} # uncovered
pending = tasks.keys() # uncovered
try: # uncovered
    loop.add_signal_handler(signal.SIGINT, cancel, pending) # uncovered
    loop.add_signal_handler(signal.SIGTERM, cancel, pending) # uncovered
except NotImplementedError: # uncovered
    # There are no good alternatives for these on Windows.
    pass # uncovered
while pending: # uncovered
    done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED) # uncovered
    for task in done: # uncovered
        src = tasks.pop(task) # uncovered
        if task.cancelled(): # uncovered
            cancelled.append(task) # uncovered
        elif task.exception(): # uncovered
            report.failed(src, str(task.exception())) # uncovered
        else: # uncovered
            changed = Changed.YES if task.result() else Changed.NO # uncovered
            # If the file was written back or was successfully checked as
            # well-formatted, store this information in the cache.
            if write_back is WriteBack.YES or ( # uncovered
                write_back is WriteBack.CHECK and changed is Changed.NO # uncovered
            ): # uncovered
                sources_to_cache.append(src) # uncovered
            report.done(src, changed) # uncovered
if cancelled: # uncovered
    await asyncio.gather(*cancelled, return_exceptions=True) # uncovered
if sources_to_cache: # uncovered
    write_cache(cache, sources_to_cache, mode) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    uncached = [src for src in sources if src not in cache]"",
            ""    return uncached, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit(0)"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.YES"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    uncached = [src for src in sources if src not in cache]"",
            ""    return uncached, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print(\""Exiting...\"")"",
            ""    sys.exit(0)"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.CHECK"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    uncached = [src for src in sources if src not in cache]"",
            ""    return uncached, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit(0)"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.YES"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    return [src for src in sources if src not in cache], cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return False"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit()"",
            """",
            ""write_back = WriteBack.YES"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return False"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""write_back = WriteBack.YES"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""sources = ['file3.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit(0)""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    remaining = [src for src in sources if src not in cache]"",
            ""    return remaining, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit(0)"",
            """",
            ""write_back = WriteBack.CHECK"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""cache = Cache()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return False"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""write_back = WriteBack.YES"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""cache = Cache()"",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit(0)""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    remaining = [src for src in sources if src not in cache]"",
            ""    return remaining, cached"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return False"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit(0)"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.YES"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit(0)"",
            """",
            ""write_back = WriteBack.DIFF"",
            ""sources = ['file1.py']"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""cache = Cache()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    # Mock implementation of the function with lock handling"",
            ""    if lock:"",
            ""        # Simulate some work done while holding a lock"",
            ""        with lock:"",
            ""            return True"",
            ""    return False"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit(0)"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.DIFF"",
            ""fast = True"",
            ""mode = 'test_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    }
]","[
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    uncached = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return uncached, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print('Exiting...') # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    uncached = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return uncached, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(\""Exiting...\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    uncached = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return uncached, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print('Exiting...') # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    return [src for src in sources if src not in cache], cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print('Exiting...') # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file3.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    remaining = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return remaining, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print('Exiting...') # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""cache = Cache() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""cache = Cache() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    remaining = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return remaining, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print('Exiting...') # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print('Exiting...') # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""sources = ['file1.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""cache = Cache() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    # Mock implementation of the function with lock handling # pragma: no cover"",
            ""    if lock: # pragma: no cover"",
            ""        # Simulate some work done while holding a lock # pragma: no cover"",
            ""        with lock: # pragma: no cover"",
            ""            return True # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print('Exiting...') # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.DIFF # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'test_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    }
]",3,6617,0.0033085,4939,0.0074085,0.010717
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Run formatting of `sources` in parallel using the provided `executor`.
    (Use ProcessPoolExecutors for actual parallelism.)
    `write_back`, `fast`, and `mode` options are passed to
    :func:`format_file_in_place`.
    """"""
cache: Cache = {} # uncovered
if write_back not in (WriteBack.DIFF, WriteBack.COLOR_DIFF): # uncovered
    cache = read_cache(mode) # uncovered
    sources, cached = filter_cached(cache, sources) # uncovered
    for src in sorted(cached): # uncovered
        report.done(src, Changed.CACHED) # uncovered
if not sources: # uncovered
    exit() # uncovered
cancelled = [] # uncovered
sources_to_cache = [] # uncovered
lock = None # uncovered
if write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF): # uncovered
    # For diff output, we need locks to ensure we don't interleave output
    # from different processes.
    manager = Manager() # uncovered
    lock = manager.Lock() # uncovered
tasks = { # uncovered
    asyncio.ensure_future( # uncovered
        loop.run_in_executor( # uncovered
            executor, format_file_in_place, src, fast, mode, write_back, lock # uncovered
        ) # uncovered
    ): src # uncovered
    for src in sorted(sources) # uncovered
} # uncovered
pending = tasks.keys() # uncovered
try: # uncovered
    loop.add_signal_handler(signal.SIGINT, cancel, pending) # uncovered
    loop.add_signal_handler(signal.SIGTERM, cancel, pending) # uncovered
except NotImplementedError: # uncovered
    # There are no good alternatives for these on Windows.
    pass # uncovered
while pending: # uncovered
    done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED) # uncovered
    for task in done: # uncovered
        src = tasks.pop(task) # uncovered
        if task.cancelled(): # uncovered
            cancelled.append(task) # uncovered
        elif task.exception(): # uncovered
            report.failed(src, str(task.exception())) # uncovered
        else: # uncovered
            changed = Changed.YES if task.result() else Changed.NO # uncovered
            # If the file was written back or was successfully checked as
            # well-formatted, store this information in the cache.
            if write_back is WriteBack.YES or ( # uncovered
                write_back is WriteBack.CHECK and changed is Changed.NO # uncovered
            ): # uncovered
                sources_to_cache.append(src) # uncovered
            report.done(src, changed) # uncovered
if cancelled: # uncovered
    await asyncio.gather(*cancelled, return_exceptions=True) # uncovered
if sources_to_cache: # uncovered
    write_cache(cache, sources_to_cache, mode) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    remaining = [src for src in sources if src not in cache]"",
            ""    return remaining, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit(0)"",
            """",
            ""write_back = WriteBack.CHECK"",
            ""sources = ['file3.py', 'file2.py', 'file1.py']"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""cache = Cache()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""write_back = WriteBack.YES"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""sources = ['file3.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""cache = Cache()"",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit(0)""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    remaining = [src for src in sources if src not in cache]"",
            ""    return remaining, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit(0)"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.YES"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    remaining = [src for src in sources if src not in cache]"",
            ""    return remaining, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit(0)"",
            """",
            ""write_back = WriteBack.CHECK"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""cache = Cache()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    remaining = [src for src in sources if src not in cache]"",
            ""    return remaining, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return False"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit(0)"",
            """",
            ""write_back = WriteBack.YES"",
            ""sources = ['file3.py', 'file2.py']"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""cache = Cache()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit(0)"",
            """",
            ""cache = Cache()"",
            ""write_back = WriteBack.CHECK"",
            ""fast = True"",
            ""mode = 'test_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    remaining = [src for src in sources if src not in cache]"",
            ""    return remaining, cached"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit(0)"",
            """",
            ""write_back = WriteBack.YES"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""cache = Cache()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    uncached = [src for src in sources if src not in cache]"",
            ""    return uncached, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(tasks):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in tasks:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit(0)"",
            """",
            ""write_back = WriteBack.CHECK"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""cache = Cache()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    new_sources = [src for src in sources if src not in cache]"",
            ""    return new_sources, cached"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return False"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit(0)"",
            """",
            ""write_back = WriteBack.YES"",
            ""sources = ['file1.py', 'file2.py']"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()"",
            ""cache = Cache()""
        ]
    },
    {
        ""imports"": [
            ""import asyncio"",
            ""import signal"",
            ""from concurrent.futures import ProcessPoolExecutor"",
            ""from multiprocessing import Manager"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class WriteBack(Enum):"",
            ""    DIFF = 'diff'"",
            ""    COLOR_DIFF = 'color_diff'"",
            ""    YES = 'yes'"",
            ""    CHECK = 'check'"",
            """",
            ""class Changed(Enum):"",
            ""    YES = 'yes'"",
            ""    NO = 'no'"",
            ""    CACHED = 'cached'"",
            """",
            ""class Cache(dict):"",
            ""    pass"",
            """",
            ""def read_cache(mode):"",
            ""    return {'file1.py': 'cached_content'}"",
            """",
            ""def filter_cached(cache, sources):"",
            ""    cached = [src for src in sources if src in cache]"",
            ""    remaining = [src for src in sources if src not in cache]"",
            ""    return remaining, cached"",
            """",
            ""async def format_file_in_place(src, fast, mode, write_back, lock):"",
            ""    return True"",
            """",
            ""class Report:"",
            ""    def done(self, src, status):"",
            ""        print(f\""Processed {src}, status: {status}\"")"",
            ""    def failed(self, src, message):"",
            ""        print(f\""Failed {src}, message: {message}\"")"",
            """",
            ""report = Report()"",
            """",
            ""def write_cache(cache, sources_to_cache, mode):"",
            ""    print(f\""Cache written for: {sources_to_cache}\"")"",
            """",
            ""def cancel(pending):"",
            ""    print(\""Cancellation requested\"")"",
            ""    for task in pending:"",
            ""        task.cancel()"",
            """",
            ""def exit():"",
            ""    print('Exiting...')"",
            ""    sys.exit(0)"",
            """",
            ""write_back = WriteBack.COLOR_DIFF"",
            ""fast = True"",
            ""mode = 'example_mode'"",
            ""sources = ['file1.py', 'file2.py']"",
            ""executor = ProcessPoolExecutor()"",
            ""loop = asyncio.get_event_loop()""
        ]
    }
]","[
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    remaining = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return remaining, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print('Exiting...') # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""sources = ['file3.py', 'file2.py', 'file1.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""cache = Cache() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file3.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""cache = Cache() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    remaining = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return remaining, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print('Exiting...') # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    remaining = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return remaining, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print('Exiting...') # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""cache = Cache() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    remaining = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return remaining, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print('Exiting...') # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""sources = ['file3.py', 'file2.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""cache = Cache() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print('Exiting...') # pragma: no cover"",
            "" # pragma: no cover"",
            ""cache = Cache() # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'test_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    remaining = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return remaining, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print('Exiting...') # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""cache = Cache() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    uncached = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return uncached, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(tasks): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in tasks: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print('Exiting...') # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.CHECK # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""cache = Cache() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    new_sources = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return new_sources, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print('Exiting...') # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.YES # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover"",
            ""cache = Cache() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import asyncio # pragma: no cover"",
            ""import signal # pragma: no cover"",
            ""from concurrent.futures import ProcessPoolExecutor # pragma: no cover"",
            ""from multiprocessing import Manager # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class WriteBack(Enum): # pragma: no cover"",
            ""    DIFF = 'diff' # pragma: no cover"",
            ""    COLOR_DIFF = 'color_diff' # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    CHECK = 'check' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Changed(Enum): # pragma: no cover"",
            ""    YES = 'yes' # pragma: no cover"",
            ""    NO = 'no' # pragma: no cover"",
            ""    CACHED = 'cached' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Cache(dict): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def read_cache(mode): # pragma: no cover"",
            ""    return {'file1.py': 'cached_content'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def filter_cached(cache, sources): # pragma: no cover"",
            ""    cached = [src for src in sources if src in cache] # pragma: no cover"",
            ""    remaining = [src for src in sources if src not in cache] # pragma: no cover"",
            ""    return remaining, cached # pragma: no cover"",
            "" # pragma: no cover"",
            ""async def format_file_in_place(src, fast, mode, write_back, lock): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Report: # pragma: no cover"",
            ""    def done(self, src, status): # pragma: no cover"",
            ""        print(f\""Processed {src}, status: {status}\"") # pragma: no cover"",
            ""    def failed(self, src, message): # pragma: no cover"",
            ""        print(f\""Failed {src}, message: {message}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""report = Report() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def write_cache(cache, sources_to_cache, mode): # pragma: no cover"",
            ""    print(f\""Cache written for: {sources_to_cache}\"") # pragma: no cover"",
            "" # pragma: no cover"",
            ""def cancel(pending): # pragma: no cover"",
            ""    print(\""Cancellation requested\"") # pragma: no cover"",
            ""    for task in pending: # pragma: no cover"",
            ""        task.cancel() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print('Exiting...') # pragma: no cover"",
            "" # pragma: no cover"",
            ""write_back = WriteBack.COLOR_DIFF # pragma: no cover"",
            ""fast = True # pragma: no cover"",
            ""mode = 'example_mode' # pragma: no cover"",
            ""sources = ['file1.py', 'file2.py'] # pragma: no cover"",
            ""executor = ProcessPoolExecutor() # pragma: no cover"",
            ""loop = asyncio.get_event_loop() # pragma: no cover""
        ]
    }
]",3,6696,0.003348,4917,0.0073755,0.0107235
