prompt,raw_predictions,predictions,prompt_type,input_size,input_price,output_size,output_price,total_price
"Provide self-contained and concrete Python values to initialize the undefined variables in the code snippet.

# begin code snippet
""""""Return whitespace prefix if needed for the given `leaf`.

    `complex_subscript` signals whether the given leaf is part of a subscription
    which has non-trivial arguments, like arithmetic expressions or function calls.
    """"""
NO: Final = """"
SPACE: Final = "" ""
DOUBLESPACE: Final = ""  ""
t = leaf.type
p = leaf.parent
v = leaf.value
if t in ALWAYS_NO_SPACE:
    exit(NO)

if t == token.COMMENT:
    exit(DOUBLESPACE)

assert p is not None, f""INTERNAL ERROR: hand-made leaf without parent: {leaf!r}""
if t == token.COLON and p.type not in {
    syms.subscript,
    syms.subscriptlist,
    syms.sliceop,
}:
    exit(NO)

prev = leaf.prev_sibling
if not prev:
    prevp = preceding_leaf(p)
    if not prevp or prevp.type in OPENING_BRACKETS:
        exit(NO)

    if t == token.COLON:
        if prevp.type == token.COLON:
            exit(NO)

        elif prevp.type != token.COMMA and not complex_subscript:
            exit(NO)

        exit(SPACE)

    if prevp.type == token.EQUAL:
        if prevp.parent:
            if prevp.parent.type in {
                syms.arglist,
                syms.argument,
                syms.parameters,
                syms.varargslist,
            }:
                exit(NO)

            elif prevp.parent.type == syms.typedargslist:
                # A bit hacky: if the equal sign has whitespace, it means we
                # previously found it's a typed argument.  So, we're using
                # that, too.
                exit(prevp.prefix)

    elif (
        prevp.type == token.STAR
        and parent_type(prevp) == syms.star_expr
        and parent_type(prevp.parent) == syms.subscriptlist
    ):
        # No space between typevar tuples.
        exit(NO)

    elif prevp.type in VARARGS_SPECIALS:
        if is_vararg(prevp, within=VARARGS_PARENTS | UNPACKING_PARENTS):
            exit(NO)

    elif prevp.type == token.COLON:
        if prevp.parent and prevp.parent.type in {syms.subscript, syms.sliceop}:
            exit(SPACE if complex_subscript else NO)

    elif (
        prevp.parent
        and prevp.parent.type == syms.factor
        and prevp.type in MATH_OPERATORS
    ):
        exit(NO)

    elif prevp.type == token.AT and p.parent and p.parent.type == syms.decorator:
        # no space in decorators
        exit(NO)

elif prev.type in OPENING_BRACKETS:
    exit(NO)

if p.type in {syms.parameters, syms.arglist}:
    # untyped function signatures or calls
    if not prev or prev.type != token.COMMA:
        exit(NO)

elif p.type == syms.varargslist:
    # lambdas
    if prev and prev.type != token.COMMA:
        exit(NO)

elif p.type == syms.typedargslist:
    # typed function signatures
    if not prev:
        exit(NO)

    if t == token.EQUAL:
        if prev.type not in TYPED_NAMES:
            exit(NO)

    elif prev.type == token.EQUAL:
        # A bit hacky: if the equal sign has whitespace, it means we
        # previously found it's a typed argument.  So, we're using that, too.
        exit(prev.prefix)

    elif prev.type != token.COMMA:
        exit(NO)

elif p.type in TYPED_NAMES:
    # type names
    if not prev:
        prevp = preceding_leaf(p)
        if not prevp or prevp.type != token.COMMA:
            exit(NO)

elif p.type == syms.trailer:
    # attributes and calls
    if t == token.LPAR or t == token.RPAR:
        exit(NO)

    if not prev:
        if t == token.DOT or t == token.LSQB:
            exit(NO)

    elif prev.type != token.COMMA:
        exit(NO)

elif p.type == syms.argument:
    # single argument
    if t == token.EQUAL:
        exit(NO)

    if not prev:
        prevp = preceding_leaf(p)
        if not prevp or prevp.type == token.LPAR:
            exit(NO)

    elif prev.type in {token.EQUAL} | VARARGS_SPECIALS:
        exit(NO)

elif p.type == syms.decorator:
    # decorators
    exit(NO)

elif p.type == syms.dotted_name:
    if prev:
        exit(NO)

    prevp = preceding_leaf(p)
    if not prevp or prevp.type == token.AT or prevp.type == token.DOT:
        exit(NO)

elif p.type == syms.classdef:
    if t == token.LPAR:
        exit(NO)

    if prev and prev.type == token.LPAR:
        exit(NO)

elif p.type in {syms.subscript, syms.sliceop}:
    # indexing
    if not prev:
        assert p.parent is not None, ""subscripts are always parented""
        if p.parent.type == syms.subscriptlist:
            exit(SPACE)

        exit(NO)

    elif not complex_subscript:
        exit(NO)

elif p.type == syms.atom:
    if prev and t == token.DOT:
        # dots, but not the first one.
        exit(NO)

elif p.type == syms.dictsetmaker:
    # dict unpacking
    if prev and prev.type == token.DOUBLESTAR:
        exit(NO)

elif p.type in {syms.factor, syms.star_expr}:
    # unary ops
    if not prev:
        prevp = preceding_leaf(p)
        if not prevp or prevp.type in OPENING_BRACKETS:
            exit(NO)

        prevp_parent = prevp.parent
        assert prevp_parent is not None
        if prevp.type == token.COLON and prevp_parent.type in {
            syms.subscript,
            syms.sliceop,
        }:
            exit(NO)

        elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument:
            exit(NO)

    elif t in {token.NAME, token.NUMBER, token.STRING}:
        exit(NO)

elif p.type == syms.import_from:
    if t == token.DOT:
        if prev and prev.type == token.DOT:
            exit(NO)

    elif t == token.NAME:
        if v == ""import"":
            exit(SPACE)

        if prev and prev.type == token.DOT:
            exit(NO)

elif p.type == syms.sliceop:
    exit(NO)

elif p.type == syms.except_clause:
    if t == token.STAR:
        exit(NO)

exit(SPACE)

# end code snippet

# begin undefined variables
Final
leaf
ALWAYS_NO_SPACE
token
syms
preceding_leaf
OPENING_BRACKETS
complex_subscript
parent_type
VARARGS_SPECIALS
is_vararg
VARARGS_PARENTS
UNPACKING_PARENTS
MATH_OPERATORS
TYPED_NAMES
# end undefined variables

# begin undefined attributes and methods
leaf.type
leaf.parent
leaf.value
token.COMMENT
token.COLON
syms.subscript
syms.subscriptlist
syms.sliceop
leaf.prev_sibling
token.COMMA
token.EQUAL
syms.arglist
syms.argument
syms.parameters
syms.varargslist
syms.typedargslist
token.STAR
syms.star_expr
syms.factor
token.AT
syms.decorator
syms.trailer
token.LPAR
token.RPAR
token.DOT
token.LSQB
syms.dotted_name
syms.classdef
syms.atom
syms.dictsetmaker
token.DOUBLESTAR
token.NAME
token.NUMBER
token.STRING
syms.import_from
syms.except_clause
# end undefined attributes and methods

Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': None, 'parent': None, 'value': None, 'prev_sibling': None})()"",
            ""ALWAYS_NO_SPACE = set()"",
            ""token = type('MockToken', (object,), {'COMMENT': 1, 'COLON': 2, 'COMMA': 3, 'EQUAL': 4, 'STAR': 5, 'AT': 6, 'LPAR': 7, 'RPAR': 8, 'DOT': 9, 'LSQB': 10, 'DOUBLESTAR': 11, 'NAME': 12, 'NUMBER': 13, 'STRING': 14})"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, 'dotted_name': 13, 'classdef': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = set()"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = set()"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = set()"",
            ""TYPED_NAMES = set()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': 'MOCK_DEFAULT', 'parent': None, 'value': 'MOCK_DEFAULT', 'prev_sibling': None, 'prefix': ''})()"",
            ""ALWAYS_NO_SPACE = {0}"",
            ""token = type('MockToken', (object,), {'COMMENT': 'COMMENT', 'COLON': 'COLON', 'COMMA': 'COMMA', 'EQUAL': 'EQUAL', 'STAR': 'STAR', 'AT': 'AT', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'DOT': 'DOT', 'LSQB': 'LSQB', 'DOUBLESTAR': 'DOUBLESTAR', 'NAME': 'NAME', 'NUMBER': 'NUMBER', 'STRING': 'STRING'})"",
            ""syms = type('MockSyms', (object,), {'subscript': 'subscript', 'subscriptlist': 'subscriptlist', 'sliceop': 'sliceop', 'arglist': 'arglist', 'argument': 'argument', 'parameters': 'parameters', 'varargslist': 'varargslist', 'typedargslist': 'typedargslist', 'star_expr': 'star_expr', 'factor': 'factor', 'decorator': 'decorator', 'trailer': 'trailer', 'dotted_name': 'dotted_name', 'classdef': 'classdef', 'atom': 'atom', 'dictsetmaker': 'dictsetmaker', 'import_from': 'import_from', 'except_clause': 'except_clause'})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: 'MOCK_DEFAULT'"",
            ""VARARGS_SPECIALS = {token.STAR}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {'MOCK_PARENT'}"",
            ""UNPACKING_PARENTS = {'MOCK_PARENT'}"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '//', '=', '%'}"",
            ""TYPED_NAMES = {'int', 'float', 'str', 'list', 'dict'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""from collections import namedtuple""
        ],
        ""initialization"": [
            ""class MockToken:"",
            ""    COMMENT = 'COMMENT'"",
            ""    COLON = 'COLON'"",
            ""    COMMA = 'COMMA'"",
            ""    EQUAL = 'EQUAL'"",
            ""    STAR = 'STAR'"",
            ""    AT = 'AT'"",
            ""    LPAR = 'LPAR'"",
            ""    RPAR = 'RPAR'"",
            ""    DOT = 'DOT'"",
            ""    LSQB = 'LSQB'"",
            ""    NAME = 'NAME'"",
            ""    NUMBER = 'NUMBER'"",
            ""    STRING = 'STRING'"",
            ""    DOUBLESTAR = 'DOUBLESTAR'"",
            ""token = MockToken()"",
            """",
            ""class MockSyms:"",
            ""    subscript = 'subscript'"",
            ""    subscriptlist = 'subscriptlist'"",
            ""    sliceop = 'sliceop'"",
            ""    arglist = 'arglist'"",
            ""    argument = 'argument'"",
            ""    parameters = 'parameters'"",
            ""    varargslist = 'varargslist'"",
            ""    typedargslist = 'typedargslist'"",
            ""    star_expr = 'star_expr'"",
            ""    factor = 'factor'"",
            ""    decorator = 'decorator'"",
            ""    trailer = 'trailer'"",
            ""    dotted_name = 'dotted_name'"",
            ""    classdef = 'classdef'"",
            ""    atom = 'atom'"",
            ""    dictsetmaker = 'dictsetmaker'"",
            ""    import_from = 'import_from'"",
            ""    except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            """",
            ""Leaf = namedtuple('Leaf', ['type', 'parent', 'value', 'prev_sibling'])"",
            ""leaf = Leaf(type='type', parent='parent', value='value', prev_sibling=None)"",
            """",
            ""ALWAYS_NO_SPACE: Final = {'type1', 'type2'}"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS: Final = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: 'parent_type'"",
            ""VARARGS_SPECIALS: Final = {'*', '**'}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS: Final = {'type1', 'type2'}"",
            ""UNPACKING_PARENTS: Final = {'type1', 'type2'}"",
            ""MATH_OPERATORS: Final = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES: Final = {'type1', 'type2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import sys"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""leaf = SimpleNamespace(type=token.NAME, parent=None, value='', prev_sibling=None)"",
            ""ALWAYS_NO_SPACE = set([token.COMMA, token.COLON])"",
            ""syms = SimpleNamespace(subscript=1, subscriptlist=2, sliceop=3, arglist=4, argument=5, parameters=6, varargslist=7, typedargslist=8, star_expr=9, factor=10, decorator=11, trailer=12, dotted_name=13, classdef=14, atom=15, dictsetmaker=16, import_from=17, except_clause=18)"",
            ""def preceding_leaf(node): return None"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB])"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR])"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist])"",
            ""UNPACKING_PARENTS = set([syms.argument])"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH])"",
            ""TYPED_NAMES = set([syms.typedargslist, syms.argument])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import symtable as syms""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None})()"",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.EQUAL])"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB])"",
            ""VARARGS_SPECIALS = set([token.STAR])"",
            ""VARARGS_PARENTS = set([syms.argument, syms.parameters])"",
            ""UNPACKING_PARENTS = set([syms.dictsetmaker, syms.argument])"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH])"",
            ""TYPED_NAMES = set([token.NAME])"",
            ""preceding_leaf = lambda x: None"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""is_vararg = lambda x, within: False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import symtable as syms""
        ],
        ""initialization"": [
            ""leaf = type(\""MockLeaf\"", (object,), {\""type\"": token.NAME, \""parent\"": None, \""value\"": \""\"", \""prev_sibling\"": None})()"",
            ""ALWAYS_NO_SPACE = set()"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = set()"",
            ""is_vararg = lambda x, within=None: False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = set()"",
            ""TYPED_NAMES = set()"",
            ""leaf.prev_sibling = type(\""MockLeaf\"", (object,), {\""type\"": token.NAME, \""parent\"": None, \""value\"": \""\""})()"",
            ""leaf.parent = type(\""MockParent\"", (object,), {\""type\"": syms.argument})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""from collections import namedtuple"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None})"",
            ""ALWAYS_NO_SPACE = set()"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, 'dotted_name': 13, 'classdef': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18})"",
            ""preceding_leaf = lambda leaf: None"",
            ""OPENING_BRACKETS = set()"",
            ""complex_subscript = False"",
            ""parent_type = lambda leaf: None"",
            ""VARARGS_SPECIALS = set()"",
            ""is_vararg = lambda leaf, within: False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = set()"",
            ""TYPED_NAMES = set()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None})()"",
            ""ALWAYS_NO_SPACE = {token.NEWLINE, token.ENDMARKER}"",
            ""preceding_leaf = lambda x: None  # Simplified placeholder function"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""complex_subscript = False  # Example boolean value"",
            ""parent_type = lambda x: syms.factor  # Simplified placeholder function"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""is_vararg = lambda x, within: False  # Simplified placeholder function"",
            ""VARARGS_PARENTS = {syms.parameters, syms.varargslist}"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.atom}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {syms.argument, syms.parameters}"",
            ""token.COMMENT = 1"",
            ""token.COLON = 2"",
            ""syms.subscript = 100"",
            ""syms.subscriptlist = 101"",
            ""syms.sliceop = 102"",
            ""token.COMMA = 3"",
            ""token.EQUAL = 4"",
            ""syms.arglist = 103"",
            ""syms.argument = 104"",
            ""syms.parameters = 105"",
            ""syms.varargslist = 106"",
            ""syms.typedargslist = 107"",
            ""token.STAR = 5"",
            ""syms.star_expr = 108"",
            ""syms.factor = 109"",
            ""token.AT = 6"",
            ""syms.decorator = 110"",
            ""syms.trailer = 111"",
            ""token.LPAR = 7"",
            ""token.RPAR = 8"",
            ""token.DOT = 9"",
            ""token.LSQB = 10"",
            ""syms.dotted_name = 112"",
            ""syms.classdef = 113"",
            ""syms.atom = 114"",
            ""syms.dictsetmaker = 115"",
            ""token.DOUBLESTAR = 11"",
            ""token.NAME = 12"",
            ""token.NUMBER = 13"",
            ""token.STRING = 14"",
            ""syms.import_from = 116"",
            ""syms.except_clause = 117""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""from collections import namedtuple""
        ],
        ""initialization"": [
            ""Mock = type('Mock', (object,), {})"",
            ""leaf = Mock()"",
            ""leaf.type = token.NAME"",
            ""leaf.parent = Mock()"",
            ""leaf.parent.type = None"",
            ""leaf.value = ''"",
            ""leaf.prev_sibling = None"",
            ""leaf.prev_sibling = Mock()"",
            ""ALWAYS_NO_SPACE = set()"",
            ""syms = Mock()"",
            ""syms.subscript = 1"",
            ""syms.subscriptlist = 2"",
            ""syms.sliceop = 3"",
            ""syms.arglist = 4"",
            ""syms.argument = 5"",
            ""syms.parameters = 6"",
            ""syms.varargslist = 7"",
            ""syms.typedargslist = 8"",
            ""syms.star_expr = 9"",
            ""syms.factor = 10"",
            ""syms.decorator = 11"",
            ""syms.trailer = 12"",
            ""syms.dotted_name = 13"",
            ""syms.classdef = 14"",
            ""syms.atom = 15"",
            ""syms.dictsetmaker = 16"",
            ""syms.import_from = 17"",
            ""syms.except_clause = 18"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = set()"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = set()"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = set()"",
            ""TYPED_NAMES = set()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import types""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {token.STRING, token.NUMBER}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {types.FunctionType}"",
            ""UNPACKING_PARENTS = {types.GeneratorType}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('Mock', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'factor': 9, 'decorator': 10, 'trailer': 11, 'dotted_name': 12, 'classdef': 13, 'atom': 14, 'dictsetmaker': 15, 'import_from': 16, 'except_clause': 17})"",
            ""leaf = type('Mock', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None})()"",
            ""def preceding_leaf(leaf): return None"",
            ""def parent_type(leaf): return None"",
            ""def is_vararg(leaf, within=None): return False""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': None, 'parent': None, 'value': None, 'prev_sibling': None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMENT': 1, 'COLON': 2, 'COMMA': 3, 'EQUAL': 4, 'STAR': 5, 'AT': 6, 'LPAR': 7, 'RPAR': 8, 'DOT': 9, 'LSQB': 10, 'DOUBLESTAR': 11, 'NAME': 12, 'NUMBER': 13, 'STRING': 14}) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = set() # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = set() # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = set() # pragma: no cover"",
            ""TYPED_NAMES = set() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': 'MOCK_DEFAULT', 'parent': None, 'value': 'MOCK_DEFAULT', 'prev_sibling': None, 'prefix': ''})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {0} # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMENT': 'COMMENT', 'COLON': 'COLON', 'COMMA': 'COMMA', 'EQUAL': 'EQUAL', 'STAR': 'STAR', 'AT': 'AT', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'DOT': 'DOT', 'LSQB': 'LSQB', 'DOUBLESTAR': 'DOUBLESTAR', 'NAME': 'NAME', 'NUMBER': 'NUMBER', 'STRING': 'STRING'}) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: 'MOCK_DEFAULT' # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {'MOCK_PARENT'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'MOCK_PARENT'} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '//', '=', '%'} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'float', 'str', 'list', 'dict'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockToken: # pragma: no cover"",
            ""    COMMENT = 'COMMENT' # pragma: no cover"",
            ""    COLON = 'COLON' # pragma: no cover"",
            ""    COMMA = 'COMMA' # pragma: no cover"",
            ""    EQUAL = 'EQUAL' # pragma: no cover"",
            ""    STAR = 'STAR' # pragma: no cover"",
            ""    AT = 'AT' # pragma: no cover"",
            ""    LPAR = 'LPAR' # pragma: no cover"",
            ""    RPAR = 'RPAR' # pragma: no cover"",
            ""    DOT = 'DOT' # pragma: no cover"",
            ""    LSQB = 'LSQB' # pragma: no cover"",
            ""    NAME = 'NAME' # pragma: no cover"",
            ""    NUMBER = 'NUMBER' # pragma: no cover"",
            ""    STRING = 'STRING' # pragma: no cover"",
            ""    DOUBLESTAR = 'DOUBLESTAR' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockSyms: # pragma: no cover"",
            ""    subscript = 'subscript' # pragma: no cover"",
            ""    subscriptlist = 'subscriptlist' # pragma: no cover"",
            ""    sliceop = 'sliceop' # pragma: no cover"",
            ""    arglist = 'arglist' # pragma: no cover"",
            ""    argument = 'argument' # pragma: no cover"",
            ""    parameters = 'parameters' # pragma: no cover"",
            ""    varargslist = 'varargslist' # pragma: no cover"",
            ""    typedargslist = 'typedargslist' # pragma: no cover"",
            ""    star_expr = 'star_expr' # pragma: no cover"",
            ""    factor = 'factor' # pragma: no cover"",
            ""    decorator = 'decorator' # pragma: no cover"",
            ""    trailer = 'trailer' # pragma: no cover"",
            ""    dotted_name = 'dotted_name' # pragma: no cover"",
            ""    classdef = 'classdef' # pragma: no cover"",
            ""    atom = 'atom' # pragma: no cover"",
            ""    dictsetmaker = 'dictsetmaker' # pragma: no cover"",
            ""    except_clause = 'except_clause' # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            "" # pragma: no cover"",
            ""Leaf = namedtuple('Leaf', ['type', 'parent', 'value', 'prev_sibling']) # pragma: no cover"",
            ""leaf = Leaf(type='type', parent='parent', value='value', prev_sibling=None) # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE: Final = {'type1', 'type2'} # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS: Final = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: 'parent_type' # pragma: no cover"",
            ""VARARGS_SPECIALS: Final = {'*', '**'} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS: Final = {'type1', 'type2'} # pragma: no cover"",
            ""UNPACKING_PARENTS: Final = {'type1', 'type2'} # pragma: no cover"",
            ""MATH_OPERATORS: Final = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES: Final = {'type1', 'type2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = SimpleNamespace(type=token.NAME, parent=None, value='', prev_sibling=None) # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set([token.COMMA, token.COLON]) # pragma: no cover"",
            ""def preceding_leaf(node): return None # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB]) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR]) # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist]) # pragma: no cover"",
            ""UNPACKING_PARENTS = set([syms.argument]) # pragma: no cover"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH]) # pragma: no cover"",
            ""TYPED_NAMES = set([syms.typedargslist, syms.argument]) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import symtable as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.EQUAL]) # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB]) # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR]) # pragma: no cover"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH]) # pragma: no cover"",
            ""TYPED_NAMES = set([token.NAME]) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import symtable as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = type(\""MockLeaf\"", (object,), {\""type\"": token.NAME, \""parent\"": None, \""value\"": \""\"", \""prev_sibling\"": None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = set() # pragma: no cover"",
            ""is_vararg = lambda x, within=None: False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = set() # pragma: no cover"",
            ""TYPED_NAMES = set() # pragma: no cover"",
            ""leaf.prev_sibling = type(\""MockLeaf\"", (object,), {\""type\"": token.NAME, \""parent\"": None, \""value\"": \""\""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None}) # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""preceding_leaf = lambda leaf: None # pragma: no cover"",
            ""OPENING_BRACKETS = set() # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda leaf: None # pragma: no cover"",
            ""VARARGS_SPECIALS = set() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = set() # pragma: no cover"",
            ""TYPED_NAMES = set() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NEWLINE, token.ENDMARKER} # pragma: no cover"",
            ""preceding_leaf = lambda x: None  # Simplified placeholder function # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""complex_subscript = False  # Example boolean value # pragma: no cover"",
            ""parent_type = lambda x: syms.factor  # Simplified placeholder function # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False  # Simplified placeholder function # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""token.COMMENT = 1 # pragma: no cover"",
            ""token.COLON = 2 # pragma: no cover"",
            ""token.COMMA = 3 # pragma: no cover"",
            ""token.EQUAL = 4 # pragma: no cover"",
            ""token.STAR = 5 # pragma: no cover"",
            ""token.AT = 6 # pragma: no cover"",
            ""token.LPAR = 7 # pragma: no cover"",
            ""token.RPAR = 8 # pragma: no cover"",
            ""token.DOT = 9 # pragma: no cover"",
            ""token.LSQB = 10 # pragma: no cover"",
            ""token.DOUBLESTAR = 11 # pragma: no cover"",
            ""token.NAME = 12 # pragma: no cover"",
            ""token.NUMBER = 13 # pragma: no cover"",
            ""token.STRING = 14 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover""
        ],
        ""initialization"": [
            ""Mock = type('Mock', (object,), {}) # pragma: no cover"",
            ""leaf = Mock() # pragma: no cover"",
            ""leaf.type = token.NAME # pragma: no cover"",
            ""leaf.parent = Mock() # pragma: no cover"",
            ""leaf.parent.type = None # pragma: no cover"",
            ""leaf.value = '' # pragma: no cover"",
            ""leaf.prev_sibling = None # pragma: no cover"",
            ""leaf.prev_sibling = Mock() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""syms = Mock() # pragma: no cover"",
            ""syms.subscript = 1 # pragma: no cover"",
            ""syms.subscriptlist = 2 # pragma: no cover"",
            ""syms.sliceop = 3 # pragma: no cover"",
            ""syms.arglist = 4 # pragma: no cover"",
            ""syms.argument = 5 # pragma: no cover"",
            ""syms.parameters = 6 # pragma: no cover"",
            ""syms.varargslist = 7 # pragma: no cover"",
            ""syms.typedargslist = 8 # pragma: no cover"",
            ""syms.star_expr = 9 # pragma: no cover"",
            ""syms.factor = 10 # pragma: no cover"",
            ""syms.decorator = 11 # pragma: no cover"",
            ""syms.trailer = 12 # pragma: no cover"",
            ""syms.dotted_name = 13 # pragma: no cover"",
            ""syms.classdef = 14 # pragma: no cover"",
            ""syms.atom = 15 # pragma: no cover"",
            ""syms.dictsetmaker = 16 # pragma: no cover"",
            ""syms.except_clause = 18 # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = set() # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = set() # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = set() # pragma: no cover"",
            ""TYPED_NAMES = set() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import types # pragma: no cover""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {token.STRING, token.NUMBER} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = {types.FunctionType} # pragma: no cover"",
            ""UNPACKING_PARENTS = {types.GeneratorType} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""leaf = type('Mock', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None})() # pragma: no cover"",
            ""def preceding_leaf(leaf): return None # pragma: no cover"",
            ""def parent_type(leaf): return None # pragma: no cover"",
            ""def is_vararg(leaf, within=None): return False # pragma: no cover""
        ]
    }
]",1,1963,0.0009815,4111,0.0061665,0.007148
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 35:
    assert p is not None, f""INTERNAL ERROR: hand-made leaf without parent: {leaf!r}""
AssertionError: INTERNAL ERROR: hand-made leaf without parent: <__main__.MockLeaf object at 0x7fecf5b3ae80>
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockNode: pass"",
            ""leaf = type('MockLeaf', (object,), {'type': None, 'parent': MockNode(), 'value': None, 'prev_sibling': None})()"",
            ""ALWAYS_NO_SPACE = set()"",
            ""token = type('MockToken', (object,), {'COMMENT': 1, 'COLON': 2, 'COMMA': 3, 'EQUAL': 4, 'STAR': 5, 'AT': 6, 'LPAR': 7, 'RPAR': 8, 'DOT': 9, 'LSQB': 10, 'DOUBLESTAR': 11, 'NAME': 12, 'NUMBER': 13, 'STRING': 14})"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, 'dotted_name': 13, 'classdef': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = set()"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = set()"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = set()"",
            ""TYPED_NAMES = set()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    type = None"",
            ""    value = None"",
            ""    def __init__(self, parent=None, prev_sibling=None):"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""leaf = MockLeaf(parent=type('MockParent', (object,), {'type': 0, 'parent': None})())"",
            ""ALWAYS_NO_SPACE = set()"",
            ""token = type('MockToken', (object,), {'COMMENT': 1, 'COLON': 2, 'COMMA': 3, 'EQUAL': 4, 'STAR': 5, 'AT': 6, 'LPAR': 7, 'RPAR': 8, 'DOT': 9, 'LSQB': 10, 'DOUBLESTAR': 11, 'NAME': 12, 'NUMBER': 13, 'STRING': 14})"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, 'dotted_name': 13, 'classdef': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = set()"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = set()"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = set()"",
            ""TYPED_NAMES = set()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""leaf_parent = type('MockParent', (object,), {'type': None, 'parent': None})()"",
            ""leaf = type('MockLeaf', (object,), {'type': None, 'parent': leaf_parent, 'value': None, 'prev_sibling': None})()"",
            ""ALWAYS_NO_SPACE = set()"",
            ""token = type('MockToken', (object,), {'COMMENT': 1, 'COLON': 2, 'COMMA': 3, 'EQUAL': 4, 'STAR': 5, 'AT': 6, 'LPAR': 7, 'RPAR': 8, 'DOT': 9, 'LSQB': 10, 'DOUBLESTAR': 11, 'NAME': 12, 'NUMBER': 13, 'STRING': 14})"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, 'dotted_name': 13, 'classdef': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = set()"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = set()"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = set()"",
            ""TYPED_NAMES = set()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""leaf_parent = type('MockParent', (object,), {'type': None, 'parent': None})()"",
            ""leaf = type('MockLeaf', (object,), {'type': None, 'parent': leaf_parent, 'value': None, 'prev_sibling': None})()"",
            ""ALWAYS_NO_SPACE = set()"",
            ""token = type('MockToken', (object,), {'COMMENT': 1, 'COLON': 2, 'COMMA': 3, 'EQUAL': 4, 'STAR': 5, 'AT': 6, 'LPAR': 7, 'RPAR': 8, 'DOT': 9, 'LSQB': 10, 'DOUBLESTAR': 11, 'NAME': 12, 'NUMBER': 13, 'STRING': 14})"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, 'dotted_name': 13, 'classdef': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = set()"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = set()"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = set()"",
            ""TYPED_NAMES = set()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self):"",
            ""        self.type = None"",
            ""        self.parent = MockParent()"",
            ""        self.value = None"",
            ""        self.prev_sibling = None"",
            """",
            ""class MockParent:"",
            ""    def __init__(self):"",
            ""        self.type = None"",
            ""        self.parent = None"",
            """",
            ""leaf = MockLeaf()"",
            ""ALWAYS_NO_SPACE = {1, 2, 3}"",
            ""token = type('MockToken', (object,), {'COMMENT': 1, 'COLON': 2, 'COMMA': 3, 'EQUAL': 4, 'STAR': 5, 'AT': 6, 'LPAR': 7, 'RPAR': 8, 'DOT': 9, 'LSQB': 10, 'DOUBLESTAR': 11, 'NAME': 12, 'NUMBER': 13, 'STRING': 14})"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, 'dotted_name': 13, 'classdef': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {7, 8, 9, 10}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: 1"",
            ""VARARGS_SPECIALS = {4, 5}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {7}"",
            ""UNPACKING_PARENTS = {7}"",
            ""MATH_OPERATORS = {12, 13, 14}"",
            ""TYPED_NAMES = {12}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""leaf_parent = type('MockLeafParent', (object,), {'type': None, 'parent': None})()"",
            ""leaf = type('MockLeaf', (object,), {'type': None, 'parent': leaf_parent, 'value': None, 'prev_sibling': None})()"",
            ""ALWAYS_NO_SPACE = set()"",
            ""token = type('MockToken', (object,), {'COMMENT': 1, 'COLON': 2, 'COMMA': 3, 'EQUAL': 4, 'STAR': 5, 'AT': 6, 'LPAR': 7, 'RPAR': 8, 'DOT': 9, 'LSQB': 10, 'DOUBLESTAR': 11, 'NAME': 12, 'NUMBER': 13, 'STRING': 14})"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, 'dotted_name': 13, 'classdef': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = set()"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = set()"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = set()"",
            ""TYPED_NAMES = set()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': None, 'parent': None, 'value': None, 'prev_sibling': None})()"",
            ""leaf.parent = type('MockParent', (object,), {'type': None, 'parent': None})()"",
            ""ALWAYS_NO_SPACE = set()"",
            ""token = type('MockToken', (object,), {'COMMENT': 1, 'COLON': 2, 'COMMA': 3, 'EQUAL': 4, 'STAR': 5, 'AT': 6, 'LPAR': 7, 'RPAR': 8, 'DOT': 9, 'LSQB': 10, 'DOUBLESTAR': 11, 'NAME': 12, 'NUMBER': 13, 'STRING': 14})"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, 'dotted_name': 13, 'classdef': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = set()"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = set()"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = set()"",
            ""TYPED_NAMES = set()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""leaf_parent = type('MockParent', (object,), {'type': None, 'parent': None})()"",
            ""leaf = type('MockLeaf', (object,), {'type': None, 'parent': leaf_parent, 'value': None, 'prev_sibling': None})()"",
            ""ALWAYS_NO_SPACE = set()"",
            ""token = type('MockToken', (object,), {'COMMENT': 1, 'COLON': 2, 'COMMA': 3, 'EQUAL': 4, 'STAR': 5, 'AT': 6, 'LPAR': 7, 'RPAR': 8, 'DOT': 9, 'LSQB': 10, 'DOUBLESTAR': 11, 'NAME': 12, 'NUMBER': 13, 'STRING': 14})"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, 'dotted_name': 13, 'classdef': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = set()"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = set()"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = set()"",
            ""TYPED_NAMES = set()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\nleaf = MockLeaf(type='some_type', parent='some_parent', value='some_value')"",
            ""ALWAYS_NO_SPACE = {'some_type'}"",
            ""token = type('MockToken', (object,), {'COMMENT': 1, 'COLON': 2, 'COMMA': 3, 'EQUAL': 4, 'STAR': 5, 'AT': 6, 'LPAR': 7, 'RPAR': 8, 'DOT': 9, 'LSQB': 10, 'DOUBLESTAR': 11, 'NAME': 12, 'NUMBER': 13, 'STRING': 14})"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, 'dotted_name': 13, 'classdef': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {'some_bracket'}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = {'some_special'}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {'some_parent'}"",
            ""UNPACKING_PARENTS = {'some_unpacking_parent'}"",
            ""MATH_OPERATORS = {'some_operator'}"",
            ""TYPED_NAMES = {'some_typed_name'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': 1, 'parent': None, 'value': '', 'prev_sibling': None})()"",
            ""leaf.parent = type('MockParent', (object,), {'type': 1})()"",
            ""ALWAYS_NO_SPACE = {1}"",
            ""token = type('MockToken', (object,), {'COMMENT': 1, 'COLON': 2, 'COMMA': 3, 'EQUAL': 4, 'STAR': 5, 'AT': 6, 'LPAR': 7, 'RPAR': 8, 'DOT': 9, 'LSQB': 10, 'DOUBLESTAR': 11, 'NAME': 12, 'NUMBER': 13, 'STRING': 14})"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, 'dotted_name': 13, 'classdef': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {7, 10}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: 3"",
            ""VARARGS_SPECIALS = {5}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {1, 2}"",
            ""UNPACKING_PARENTS = {3, 4}"",
            ""MATH_OPERATORS = {5}"",
            ""TYPED_NAMES = {6, 12}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockNode: pass # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': None, 'parent': MockNode(), 'value': None, 'prev_sibling': None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMENT': 1, 'COLON': 2, 'COMMA': 3, 'EQUAL': 4, 'STAR': 5, 'AT': 6, 'LPAR': 7, 'RPAR': 8, 'DOT': 9, 'LSQB': 10, 'DOUBLESTAR': 11, 'NAME': 12, 'NUMBER': 13, 'STRING': 14}) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = set() # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = set() # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = set() # pragma: no cover"",
            ""TYPED_NAMES = set() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    type = None # pragma: no cover"",
            ""    value = None # pragma: no cover"",
            ""    def __init__(self, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""leaf = MockLeaf(parent=type('MockParent', (object,), {'type': 0, 'parent': None})()) # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMENT': 1, 'COLON': 2, 'COMMA': 3, 'EQUAL': 4, 'STAR': 5, 'AT': 6, 'LPAR': 7, 'RPAR': 8, 'DOT': 9, 'LSQB': 10, 'DOUBLESTAR': 11, 'NAME': 12, 'NUMBER': 13, 'STRING': 14}) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = set() # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = set() # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = set() # pragma: no cover"",
            ""TYPED_NAMES = set() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf_parent = type('MockParent', (object,), {'type': None, 'parent': None})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': None, 'parent': leaf_parent, 'value': None, 'prev_sibling': None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMENT': 1, 'COLON': 2, 'COMMA': 3, 'EQUAL': 4, 'STAR': 5, 'AT': 6, 'LPAR': 7, 'RPAR': 8, 'DOT': 9, 'LSQB': 10, 'DOUBLESTAR': 11, 'NAME': 12, 'NUMBER': 13, 'STRING': 14}) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = set() # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = set() # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = set() # pragma: no cover"",
            ""TYPED_NAMES = set() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf_parent = type('MockParent', (object,), {'type': None, 'parent': None})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': None, 'parent': leaf_parent, 'value': None, 'prev_sibling': None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMENT': 1, 'COLON': 2, 'COMMA': 3, 'EQUAL': 4, 'STAR': 5, 'AT': 6, 'LPAR': 7, 'RPAR': 8, 'DOT': 9, 'LSQB': 10, 'DOUBLESTAR': 11, 'NAME': 12, 'NUMBER': 13, 'STRING': 14}) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = set() # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = set() # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = set() # pragma: no cover"",
            ""TYPED_NAMES = set() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.type = None # pragma: no cover"",
            ""        self.parent = MockParent() # pragma: no cover"",
            ""        self.value = None # pragma: no cover"",
            ""        self.prev_sibling = None # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.type = None # pragma: no cover"",
            ""        self.parent = None # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {1, 2, 3} # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMENT': 1, 'COLON': 2, 'COMMA': 3, 'EQUAL': 4, 'STAR': 5, 'AT': 6, 'LPAR': 7, 'RPAR': 8, 'DOT': 9, 'LSQB': 10, 'DOUBLESTAR': 11, 'NAME': 12, 'NUMBER': 13, 'STRING': 14}) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {7, 8, 9, 10} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: 1 # pragma: no cover"",
            ""VARARGS_SPECIALS = {4, 5} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {7} # pragma: no cover"",
            ""UNPACKING_PARENTS = {7} # pragma: no cover"",
            ""MATH_OPERATORS = {12, 13, 14} # pragma: no cover"",
            ""TYPED_NAMES = {12} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf_parent = type('MockLeafParent', (object,), {'type': None, 'parent': None})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': None, 'parent': leaf_parent, 'value': None, 'prev_sibling': None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMENT': 1, 'COLON': 2, 'COMMA': 3, 'EQUAL': 4, 'STAR': 5, 'AT': 6, 'LPAR': 7, 'RPAR': 8, 'DOT': 9, 'LSQB': 10, 'DOUBLESTAR': 11, 'NAME': 12, 'NUMBER': 13, 'STRING': 14}) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = set() # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = set() # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = set() # pragma: no cover"",
            ""TYPED_NAMES = set() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': None, 'parent': None, 'value': None, 'prev_sibling': None})() # pragma: no cover"",
            ""leaf.parent = type('MockParent', (object,), {'type': None, 'parent': None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMENT': 1, 'COLON': 2, 'COMMA': 3, 'EQUAL': 4, 'STAR': 5, 'AT': 6, 'LPAR': 7, 'RPAR': 8, 'DOT': 9, 'LSQB': 10, 'DOUBLESTAR': 11, 'NAME': 12, 'NUMBER': 13, 'STRING': 14}) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = set() # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = set() # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = set() # pragma: no cover"",
            ""TYPED_NAMES = set() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf_parent = type('MockParent', (object,), {'type': None, 'parent': None})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': None, 'parent': leaf_parent, 'value': None, 'prev_sibling': None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMENT': 1, 'COLON': 2, 'COMMA': 3, 'EQUAL': 4, 'STAR': 5, 'AT': 6, 'LPAR': 7, 'RPAR': 8, 'DOT': 9, 'LSQB': 10, 'DOUBLESTAR': 11, 'NAME': 12, 'NUMBER': 13, 'STRING': 14}) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = set() # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = set() # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = set() # pragma: no cover"",
            ""TYPED_NAMES = set() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            ""leaf = MockLeaf(type='some_type', parent='some_parent', value='some_value') # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'some_type'} # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMENT': 1, 'COLON': 2, 'COMMA': 3, 'EQUAL': 4, 'STAR': 5, 'AT': 6, 'LPAR': 7, 'RPAR': 8, 'DOT': 9, 'LSQB': 10, 'DOUBLESTAR': 11, 'NAME': 12, 'NUMBER': 13, 'STRING': 14}) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {'some_bracket'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'some_special'} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {'some_parent'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'some_unpacking_parent'} # pragma: no cover"",
            ""MATH_OPERATORS = {'some_operator'} # pragma: no cover"",
            ""TYPED_NAMES = {'some_typed_name'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': 1, 'parent': None, 'value': '', 'prev_sibling': None})() # pragma: no cover"",
            ""leaf.parent = type('MockParent', (object,), {'type': 1})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {1} # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMENT': 1, 'COLON': 2, 'COMMA': 3, 'EQUAL': 4, 'STAR': 5, 'AT': 6, 'LPAR': 7, 'RPAR': 8, 'DOT': 9, 'LSQB': 10, 'DOUBLESTAR': 11, 'NAME': 12, 'NUMBER': 13, 'STRING': 14}) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {7, 10} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: 3 # pragma: no cover"",
            ""VARARGS_SPECIALS = {5} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {1, 2} # pragma: no cover"",
            ""UNPACKING_PARENTS = {3, 4} # pragma: no cover"",
            ""MATH_OPERATORS = {5} # pragma: no cover"",
            ""TYPED_NAMES = {6, 12} # pragma: no cover""
        ]
    }
]",2,2719,0.0013595,4637,0.0069555,0.008315
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 35:
    assert p is not None, f""INTERNAL ERROR: hand-made leaf without parent: {leaf!r}""
AssertionError: INTERNAL ERROR: hand-made leaf without parent: <__main__.MockLeaf object at 0x7f450d0e9e80>
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""MockParent = type('MockParent', (object,), {'type': 'MOCK_DEFAULT'})"",
            ""leaf = type('MockLeaf', (object,), {'type': 'MOCK_DEFAULT', 'parent': MockParent(), 'value': 'MOCK_DEFAULT', 'prev_sibling': None, 'prefix': ''})()"",
            ""ALWAYS_NO_SPACE = {0}"",
            ""token = type('MockToken', (object,), {'COMMENT': 'COMMENT', 'COLON': 'COLON', 'COMMA': 'COMMA', 'EQUAL': 'EQUAL', 'STAR': 'STAR', 'AT': 'AT', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'DOT': 'DOT', 'LSQB': 'LSQB', 'DOUBLESTAR': 'DOUBLESTAR', 'NAME': 'NAME', 'NUMBER': 'NUMBER', 'STRING': 'STRING'})"",
            ""syms = type('MockSyms', (object,), {'subscript': 'subscript', 'subscriptlist': 'subscriptlist', 'sliceop': 'sliceop', 'arglist': 'arglist', 'argument': 'argument', 'parameters': 'parameters', 'varargslist': 'varargslist', 'typedargslist': 'typedargslist', 'star_expr': 'star_expr', 'factor': 'factor', 'decorator': 'decorator', 'trailer': 'trailer', 'dotted_name': 'dotted_name', 'classdef': 'classdef', 'atom': 'atom', 'dictsetmaker': 'dictsetmaker', 'import_from': 'import_from', 'except_clause': 'except_clause'})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: 'MOCK_DEFAULT'"",
            ""VARARGS_SPECIALS = {token.STAR}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {'MOCK_PARENT'}"",
            ""UNPACKING_PARENTS = {'MOCK_PARENT'}"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '//', '=', '%'}"",
            ""TYPED_NAMES = {'int', 'float', 'str', 'list', 'dict'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""MockParent = type('MockParent', (object,), {'type': 'MOCK_PARENT'})"",
            ""leaf = type('MockLeaf', (object,), {'type': 'MOCK_DEFAULT', 'parent': MockParent(), 'value': 'MOCK_DEFAULT', 'prev_sibling': None, 'prefix': ''})()"",
            ""ALWAYS_NO_SPACE = {0}"",
            ""token = type('MockToken', (object,), {'COMMENT': 'COMMENT', 'COLON': 'COLON', 'COMMA': 'COMMA', 'EQUAL': 'EQUAL', 'STAR': 'STAR', 'AT': 'AT', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'DOT': 'DOT', 'LSQB': 'LSQB', 'DOUBLESTAR': 'DOUBLESTAR', 'NAME': 'NAME', 'NUMBER': 'NUMBER', 'STRING': 'STRING'})"",
            ""syms = type('MockSyms', (object,), {'subscript': 'subscript', 'subscriptlist': 'subscriptlist', 'sliceop': 'sliceop', 'arglist': 'arglist', 'argument': 'argument', 'parameters': 'parameters', 'varargslist': 'varargslist', 'typedargslist': 'typedargslist', 'star_expr': 'star_expr', 'factor': 'factor', 'decorator': 'decorator', 'trailer': 'trailer', 'dotted_name': 'dotted_name', 'classdef': 'classdef', 'atom': 'atom', 'dictsetmaker': 'dictsetmaker', 'import_from': 'import_from', 'except_clause': 'except_clause'})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB'}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: 'MOCK_DEFAULT'"",
            ""VARARGS_SPECIALS = {'STAR'}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {'MOCK_PARENT'}"",
            ""UNPACKING_PARENTS = {'MOCK_PARENT'}"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '//', '=', '%'}"",
            ""TYPED_NAMES = {'int', 'float', 'str', 'list', 'dict'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""MockParent = type('MockParent', (object,), {'type': 'MOCK_PARENT_TYPE'})"",
            ""MockLeaf = type('MockLeaf', (object,), {'type': 'MOCK_DEFAULT', 'parent': MockParent(), 'value': 'MOCK_DEFAULT', 'prev_sibling': None, 'prefix': ''})"",
            ""leaf = MockLeaf()"",
            ""ALWAYS_NO_SPACE = {0}"",
            ""token = type('MockToken', (object,), {'COMMENT': 'COMMENT', 'COLON': 'COLON', 'COMMA': 'COMMA', 'EQUAL': 'EQUAL', 'STAR': 'STAR', 'AT': 'AT', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'DOT': 'DOT', 'LSQB': 'LSQB', 'DOUBLESTAR': 'DOUBLESTAR', 'NAME': 'NAME', 'NUMBER': 'NUMBER', 'STRING': 'STRING'})"",
            ""syms = type('MockSyms', (object,), {'subscript': 'subscript', 'subscriptlist': 'subscriptlist', 'sliceop': 'sliceop', 'arglist': 'arglist', 'argument': 'argument', 'parameters': 'parameters', 'varargslist': 'varargslist', 'typedargslist': 'typedargslist', 'star_expr': 'star_expr', 'factor': 'factor', 'decorator': 'decorator', 'trailer': 'trailer', 'dotted_name': 'dotted_name', 'classdef': 'classdef', 'atom': 'atom', 'dictsetmaker': 'dictsetmaker', 'import_from': 'import_from', 'except_clause': 'except_clause'})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: 'MOCK_DEFAULT'"",
            ""VARARGS_SPECIALS = {token.STAR}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {'MOCK_PARENT'}"",
            ""UNPACKING_PARENTS = {'MOCK_PARENT'}"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '//', '=', '%'}"",
            ""TYPED_NAMES = {'int', 'float', 'str', 'list', 'dict'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""MockParent = type('MockParent', (object,), {'type': 'parent_type'})"",
            ""leaf = type('MockLeaf', (object,), {'type': 'MOCK_DEFAULT', 'parent': MockParent(), 'value': 'MOCK_DEFAULT', 'prev_sibling': None, 'prefix': ''})()"",
            ""ALWAYS_NO_SPACE = {0}"",
            ""token = type('MockToken', (object,), {'COMMENT': 'COMMENT', 'COLON': 'COLON', 'COMMA': 'COMMA', 'EQUAL': 'EQUAL', 'STAR': 'STAR', 'AT': 'AT', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'DOT': 'DOT', 'LSQB': 'LSQB', 'DOUBLESTAR': 'DOUBLESTAR', 'NAME': 'NAME', 'NUMBER': 'NUMBER', 'STRING': 'STRING'})"",
            ""syms = type('MockSyms', (object,), {'subscript': 'subscript', 'subscriptlist': 'subscriptlist', 'sliceop': 'sliceop', 'arglist': 'arglist', 'argument': 'argument', 'parameters': 'parameters', 'varargslist': 'varargslist', 'typedargslist': 'typedargslist', 'star_expr': 'star_expr', 'factor': 'factor', 'decorator': 'decorator', 'trailer': 'trailer', 'dotted_name': 'dotted_name', 'classdef': 'classdef', 'atom': 'atom', 'dictsetmaker': 'dictsetmaker', 'import_from': 'import_from', 'except_clause': 'except_clause'})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: 'MOCK_DEFAULT'"",
            ""VARARGS_SPECIALS = {token.STAR}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {'MOCK_PARENT'}"",
            ""UNPACKING_PARENTS = {'MOCK_PARENT'}"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '//', '=', '%'}"",
            ""TYPED_NAMES = {'int', 'float', 'str', 'list', 'dict'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""leaf_parent = type('MockParent', (object,), {'type': 'MOCK_PARENT_TYPE', 'parent': None})()"",
            ""leaf = type('MockLeaf', (object,), {'type': 'MOCK_DEFAULT', 'parent': leaf_parent, 'value': 'MOCK_DEFAULT', 'prev_sibling': None, 'prefix': ''})()"",
            ""ALWAYS_NO_SPACE = {0}"",
            ""token = type('MockToken', (object,), {'COMMENT': 'COMMENT', 'COLON': 'COLON', 'COMMA': 'COMMA', 'EQUAL': 'EQUAL', 'STAR': 'STAR', 'AT': 'AT', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'DOT': 'DOT', 'LSQB': 'LSQB', 'DOUBLESTAR': 'DOUBLESTAR', 'NAME': 'NAME', 'NUMBER': 'NUMBER', 'STRING': 'STRING'})"",
            ""syms = type('MockSyms', (object,), {'subscript': 'subscript', 'subscriptlist': 'subscriptlist', 'sliceop': 'sliceop', 'arglist': 'arglist', 'argument': 'argument', 'parameters': 'parameters', 'varargslist': 'varargslist', 'typedargslist': 'typedargslist', 'star_expr': 'star_expr', 'factor': 'factor', 'decorator': 'decorator', 'trailer': 'trailer', 'dotted_name': 'dotted_name', 'classdef': 'classdef', 'atom': 'atom', 'dictsetmaker': 'dictsetmaker', 'import_from': 'import_from', 'except_clause': 'except_clause'})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: 'MOCK_DEFAULT'"",
            ""VARARGS_SPECIALS = {token.STAR}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {'MOCK_PARENT'}"",
            ""UNPACKING_PARENTS = {'MOCK_PARENT'}"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '//', '=', '%'}"",
            ""TYPED_NAMES = {'int', 'float', 'str', 'list', 'dict'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""parent = type('MockParent', (object,), {'type': 'MOCK_PARENT'})()"",
            ""leaf = type('MockLeaf', (object,), {'type': 'MOCK_DEFAULT', 'parent': parent, 'value': 'MOCK_DEFAULT', 'prev_sibling': None, 'prefix': ''})()"",
            ""ALWAYS_NO_SPACE = {0}"",
            ""token = type('MockToken', (object,), {'COMMENT': 'COMMENT', 'COLON': 'COLON', 'COMMA': 'COMMA', 'EQUAL': 'EQUAL', 'STAR': 'STAR', 'AT': 'AT', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'DOT': 'DOT', 'LSQB': 'LSQB', 'DOUBLESTAR': 'DOUBLESTAR', 'NAME': 'NAME', 'NUMBER': 'NUMBER', 'STRING': 'STRING'})"",
            ""syms = type('MockSyms', (object,), {'subscript': 'subscript', 'subscriptlist': 'subscriptlist', 'sliceop': 'sliceop', 'arglist': 'arglist', 'argument': 'argument', 'parameters': 'parameters', 'varargslist': 'varargslist', 'typedargslist': 'typedargslist', 'star_expr': 'star_expr', 'factor': 'factor', 'decorator': 'decorator', 'trailer': 'trailer', 'dotted_name': 'dotted_name', 'classdef': 'classdef', 'atom': 'atom', 'dictsetmaker': 'dictsetmaker', 'import_from': 'import_from', 'except_clause': 'except_clause'})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: 'MOCK_DEFAULT'"",
            ""VARARGS_SPECIALS = {token.STAR}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {'MOCK_PARENT'}"",
            ""UNPACKING_PARENTS = {'MOCK_PARENT'}"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '//', '=', '%'}"",
            ""TYPED_NAMES = {'int', 'float', 'str', 'list', 'dict'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""leaf_parent = type('MockParent', (object,), {'type': 'MOCK_PARENT_TYPE'})()"",
            ""leaf = type('MockLeaf', (object,), {'type': 'MOCK_DEFAULT', 'parent': leaf_parent, 'value': 'MOCK_DEFAULT', 'prev_sibling': None, 'prefix': ''})()"",
            ""ALWAYS_NO_SPACE = {0}"",
            ""token = type('MockToken', (object,), {'COMMENT': 'COMMENT', 'COLON': 'COLON', 'COMMA': 'COMMA', 'EQUAL': 'EQUAL', 'STAR': 'STAR', 'AT': 'AT', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'DOT': 'DOT', 'LSQB': 'LSQB', 'DOUBLESTAR': 'DOUBLESTAR', 'NAME': 'NAME', 'NUMBER': 'NUMBER', 'STRING': 'STRING'})"",
            ""syms = type('MockSyms', (object,), {'subscript': 'subscript', 'subscriptlist': 'subscriptlist', 'sliceop': 'sliceop', 'arglist': 'arglist', 'argument': 'argument', 'parameters': 'parameters', 'varargslist': 'varargslist', 'typedargslist': 'typedargslist', 'star_expr': 'star_expr', 'factor': 'factor', 'decorator': 'decorator', 'trailer': 'trailer', 'dotted_name': 'dotted_name', 'classdef': 'classdef', 'atom': 'atom', 'dictsetmaker': 'dictsetmaker', 'import_from': 'import_from', 'except_clause': 'except_clause'})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB'}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: 'MOCK_DEFAULT'"",
            ""VARARGS_SPECIALS = {'STAR'}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {'MOCK_PARENT'}"",
            ""UNPACKING_PARENTS = {'MOCK_PARENT'}"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '//', '=', '%'}"",
            ""TYPED_NAMES = {'int', 'float', 'str', 'list', 'dict'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""mock_parent = type('MockParent', (object,), {'type': 'MOCK_DEFAULT'})()"",
            ""leaf = type('MockLeaf', (object,), {'type': 'MOCK_DEFAULT', 'parent': mock_parent, 'value': 'MOCK_DEFAULT', 'prev_sibling': None, 'prefix': ''})()"",
            ""ALWAYS_NO_SPACE = {0}"",
            ""token = type('MockToken', (object,), {'COMMENT': 'COMMENT', 'COLON': 'COLON', 'COMMA': 'COMMA', 'EQUAL': 'EQUAL', 'STAR': 'STAR', 'AT': 'AT', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'DOT': 'DOT', 'LSQB': 'LSQB', 'DOUBLESTAR': 'DOUBLESTAR', 'NAME': 'NAME', 'NUMBER': 'NUMBER', 'STRING': 'STRING'})"",
            ""syms = type('MockSyms', (object,), {'subscript': 'subscript', 'subscriptlist': 'subscriptlist', 'sliceop': 'sliceop', 'arglist': 'arglist', 'argument': 'argument', 'parameters': 'parameters', 'varargslist': 'varargslist', 'typedargslist': 'typedargslist', 'star_expr': 'star_expr', 'factor': 'factor', 'decorator': 'decorator', 'trailer': 'trailer', 'dotted_name': 'dotted_name', 'classdef': 'classdef', 'atom': 'atom', 'dictsetmaker': 'dictsetmaker', 'import_from': 'import_from', 'except_clause': 'except_clause'})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: 'MOCK_DEFAULT'"",
            ""VARARGS_SPECIALS = {token.STAR}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {'MOCK_PARENT'}"",
            ""UNPACKING_PARENTS = {'MOCK_PARENT'}"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '//', '=', '%'}"",
            ""TYPED_NAMES = {'int', 'float', 'str', 'list', 'dict'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""leaf_parent = type('MockLeafParent', (object,), {'type': 'MOCK_PARENT', 'parent': None})()"",
            ""leaf = type('MockLeaf', (object,), {'type': 'MOCK_DEFAULT', 'parent': leaf_parent, 'value': 'MOCK_DEFAULT', 'prev_sibling': None, 'prefix': ''})()"",
            ""ALWAYS_NO_SPACE = {0}"",
            ""token = type('MockToken', (object,), {'COMMENT': 'COMMENT', 'COLON': 'COLON', 'COMMA': 'COMMA', 'EQUAL': 'EQUAL', 'STAR': 'STAR', 'AT': 'AT', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'DOT': 'DOT', 'LSQB': 'LSQB', 'DOUBLESTAR': 'DOUBLESTAR', 'NAME': 'NAME', 'NUMBER': 'NUMBER', 'STRING': 'STRING'})"",
            ""syms = type('MockSyms', (object,), {'subscript': 'subscript', 'subscriptlist': 'subscriptlist', 'sliceop': 'sliceop', 'arglist': 'arglist', 'argument': 'argument', 'parameters': 'parameters', 'varargslist': 'varargslist', 'typedargslist': 'typedargslist', 'star_expr': 'star_expr', 'factor': 'factor', 'decorator': 'decorator', 'trailer': 'trailer', 'dotted_name': 'dotted_name', 'classdef': 'classdef', 'atom': 'atom', 'dictsetmaker': 'dictsetmaker', 'import_from': 'import_from', 'except_clause': 'except_clause'})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: 'MOCK_DEFAULT'"",
            ""VARARGS_SPECIALS = {token.STAR}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {'MOCK_PARENT'}"",
            ""UNPACKING_PARENTS = {'MOCK_PARENT'}"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '//', '=', '%'}"",
            ""TYPED_NAMES = {'int', 'float', 'str', 'list', 'dict'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""MockParent = type('MockParent', (object,), {'type': 'MOCK_PARENT'})"",
            ""leaf = type('MockLeaf', (object,), {'type': 'MOCK_DEFAULT', 'parent': MockParent(), 'value': 'MOCK_DEFAULT', 'prev_sibling': None, 'prefix': ''})()"",
            ""ALWAYS_NO_SPACE = {'MOCK_DEFAULT'}"",
            ""token = type('MockToken', (object,), {'COMMENT': 'COMMENT', 'COLON': 'COLON', 'COMMA': 'COMMA', 'EQUAL': 'EQUAL', 'STAR': 'STAR', 'AT': 'AT', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'DOT': 'DOT', 'LSQB': 'LSQB', 'DOUBLESTAR': 'DOUBLESTAR', 'NAME': 'NAME', 'NUMBER': 'NUMBER', 'STRING': 'STRING'})"",
            ""syms = type('MockSyms', (object,), {'subscript': 'subscript', 'subscriptlist': 'subscriptlist', 'sliceop': 'sliceop', 'arglist': 'arglist', 'argument': 'argument', 'parameters': 'parameters', 'varargslist': 'varargslist', 'typedargslist': 'typedargslist', 'star_expr': 'star_expr', 'factor': 'factor', 'decorator': 'decorator', 'trailer': 'trailer', 'dotted_name': 'dotted_name', 'classdef': 'classdef', 'atom': 'atom', 'dictsetmaker': 'dictsetmaker', 'import_from': 'import_from', 'except_clause': 'except_clause'})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB'}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: 'MOCK_DEFAULT'"",
            ""VARARGS_SPECIALS = {'STAR'}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {'MOCK_PARENT'}"",
            ""UNPACKING_PARENTS = {'MOCK_PARENT'}"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '//', '=', '%'}"",
            ""TYPED_NAMES = {'int', 'float', 'str', 'list', 'dict'}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""MockParent = type('MockParent', (object,), {'type': 'MOCK_DEFAULT'}) # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': 'MOCK_DEFAULT', 'parent': MockParent(), 'value': 'MOCK_DEFAULT', 'prev_sibling': None, 'prefix': ''})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {0} # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMENT': 'COMMENT', 'COLON': 'COLON', 'COMMA': 'COMMA', 'EQUAL': 'EQUAL', 'STAR': 'STAR', 'AT': 'AT', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'DOT': 'DOT', 'LSQB': 'LSQB', 'DOUBLESTAR': 'DOUBLESTAR', 'NAME': 'NAME', 'NUMBER': 'NUMBER', 'STRING': 'STRING'}) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: 'MOCK_DEFAULT' # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {'MOCK_PARENT'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'MOCK_PARENT'} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '//', '=', '%'} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'float', 'str', 'list', 'dict'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""MockParent = type('MockParent', (object,), {'type': 'MOCK_PARENT'}) # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': 'MOCK_DEFAULT', 'parent': MockParent(), 'value': 'MOCK_DEFAULT', 'prev_sibling': None, 'prefix': ''})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {0} # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMENT': 'COMMENT', 'COLON': 'COLON', 'COMMA': 'COMMA', 'EQUAL': 'EQUAL', 'STAR': 'STAR', 'AT': 'AT', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'DOT': 'DOT', 'LSQB': 'LSQB', 'DOUBLESTAR': 'DOUBLESTAR', 'NAME': 'NAME', 'NUMBER': 'NUMBER', 'STRING': 'STRING'}) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: 'MOCK_DEFAULT' # pragma: no cover"",
            ""VARARGS_SPECIALS = {'STAR'} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {'MOCK_PARENT'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'MOCK_PARENT'} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '//', '=', '%'} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'float', 'str', 'list', 'dict'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""MockParent = type('MockParent', (object,), {'type': 'MOCK_PARENT_TYPE'}) # pragma: no cover"",
            ""MockLeaf = type('MockLeaf', (object,), {'type': 'MOCK_DEFAULT', 'parent': MockParent(), 'value': 'MOCK_DEFAULT', 'prev_sibling': None, 'prefix': ''}) # pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {0} # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMENT': 'COMMENT', 'COLON': 'COLON', 'COMMA': 'COMMA', 'EQUAL': 'EQUAL', 'STAR': 'STAR', 'AT': 'AT', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'DOT': 'DOT', 'LSQB': 'LSQB', 'DOUBLESTAR': 'DOUBLESTAR', 'NAME': 'NAME', 'NUMBER': 'NUMBER', 'STRING': 'STRING'}) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: 'MOCK_DEFAULT' # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {'MOCK_PARENT'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'MOCK_PARENT'} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '//', '=', '%'} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'float', 'str', 'list', 'dict'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""MockParent = type('MockParent', (object,), {'type': 'parent_type'}) # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': 'MOCK_DEFAULT', 'parent': MockParent(), 'value': 'MOCK_DEFAULT', 'prev_sibling': None, 'prefix': ''})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {0} # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMENT': 'COMMENT', 'COLON': 'COLON', 'COMMA': 'COMMA', 'EQUAL': 'EQUAL', 'STAR': 'STAR', 'AT': 'AT', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'DOT': 'DOT', 'LSQB': 'LSQB', 'DOUBLESTAR': 'DOUBLESTAR', 'NAME': 'NAME', 'NUMBER': 'NUMBER', 'STRING': 'STRING'}) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: 'MOCK_DEFAULT' # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {'MOCK_PARENT'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'MOCK_PARENT'} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '//', '=', '%'} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'float', 'str', 'list', 'dict'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf_parent = type('MockParent', (object,), {'type': 'MOCK_PARENT_TYPE', 'parent': None})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': 'MOCK_DEFAULT', 'parent': leaf_parent, 'value': 'MOCK_DEFAULT', 'prev_sibling': None, 'prefix': ''})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {0} # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMENT': 'COMMENT', 'COLON': 'COLON', 'COMMA': 'COMMA', 'EQUAL': 'EQUAL', 'STAR': 'STAR', 'AT': 'AT', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'DOT': 'DOT', 'LSQB': 'LSQB', 'DOUBLESTAR': 'DOUBLESTAR', 'NAME': 'NAME', 'NUMBER': 'NUMBER', 'STRING': 'STRING'}) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: 'MOCK_DEFAULT' # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {'MOCK_PARENT'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'MOCK_PARENT'} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '//', '=', '%'} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'float', 'str', 'list', 'dict'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""parent = type('MockParent', (object,), {'type': 'MOCK_PARENT'})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': 'MOCK_DEFAULT', 'parent': parent, 'value': 'MOCK_DEFAULT', 'prev_sibling': None, 'prefix': ''})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {0} # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMENT': 'COMMENT', 'COLON': 'COLON', 'COMMA': 'COMMA', 'EQUAL': 'EQUAL', 'STAR': 'STAR', 'AT': 'AT', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'DOT': 'DOT', 'LSQB': 'LSQB', 'DOUBLESTAR': 'DOUBLESTAR', 'NAME': 'NAME', 'NUMBER': 'NUMBER', 'STRING': 'STRING'}) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: 'MOCK_DEFAULT' # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {'MOCK_PARENT'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'MOCK_PARENT'} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '//', '=', '%'} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'float', 'str', 'list', 'dict'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf_parent = type('MockParent', (object,), {'type': 'MOCK_PARENT_TYPE'})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': 'MOCK_DEFAULT', 'parent': leaf_parent, 'value': 'MOCK_DEFAULT', 'prev_sibling': None, 'prefix': ''})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {0} # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMENT': 'COMMENT', 'COLON': 'COLON', 'COMMA': 'COMMA', 'EQUAL': 'EQUAL', 'STAR': 'STAR', 'AT': 'AT', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'DOT': 'DOT', 'LSQB': 'LSQB', 'DOUBLESTAR': 'DOUBLESTAR', 'NAME': 'NAME', 'NUMBER': 'NUMBER', 'STRING': 'STRING'}) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: 'MOCK_DEFAULT' # pragma: no cover"",
            ""VARARGS_SPECIALS = {'STAR'} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {'MOCK_PARENT'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'MOCK_PARENT'} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '//', '=', '%'} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'float', 'str', 'list', 'dict'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""mock_parent = type('MockParent', (object,), {'type': 'MOCK_DEFAULT'})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': 'MOCK_DEFAULT', 'parent': mock_parent, 'value': 'MOCK_DEFAULT', 'prev_sibling': None, 'prefix': ''})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {0} # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMENT': 'COMMENT', 'COLON': 'COLON', 'COMMA': 'COMMA', 'EQUAL': 'EQUAL', 'STAR': 'STAR', 'AT': 'AT', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'DOT': 'DOT', 'LSQB': 'LSQB', 'DOUBLESTAR': 'DOUBLESTAR', 'NAME': 'NAME', 'NUMBER': 'NUMBER', 'STRING': 'STRING'}) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: 'MOCK_DEFAULT' # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {'MOCK_PARENT'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'MOCK_PARENT'} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '//', '=', '%'} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'float', 'str', 'list', 'dict'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf_parent = type('MockLeafParent', (object,), {'type': 'MOCK_PARENT', 'parent': None})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': 'MOCK_DEFAULT', 'parent': leaf_parent, 'value': 'MOCK_DEFAULT', 'prev_sibling': None, 'prefix': ''})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {0} # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMENT': 'COMMENT', 'COLON': 'COLON', 'COMMA': 'COMMA', 'EQUAL': 'EQUAL', 'STAR': 'STAR', 'AT': 'AT', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'DOT': 'DOT', 'LSQB': 'LSQB', 'DOUBLESTAR': 'DOUBLESTAR', 'NAME': 'NAME', 'NUMBER': 'NUMBER', 'STRING': 'STRING'}) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: 'MOCK_DEFAULT' # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {'MOCK_PARENT'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'MOCK_PARENT'} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '//', '=', '%'} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'float', 'str', 'list', 'dict'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""MockParent = type('MockParent', (object,), {'type': 'MOCK_PARENT'}) # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': 'MOCK_DEFAULT', 'parent': MockParent(), 'value': 'MOCK_DEFAULT', 'prev_sibling': None, 'prefix': ''})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'MOCK_DEFAULT'} # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMENT': 'COMMENT', 'COLON': 'COLON', 'COMMA': 'COMMA', 'EQUAL': 'EQUAL', 'STAR': 'STAR', 'AT': 'AT', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'DOT': 'DOT', 'LSQB': 'LSQB', 'DOUBLESTAR': 'DOUBLESTAR', 'NAME': 'NAME', 'NUMBER': 'NUMBER', 'STRING': 'STRING'}) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: 'MOCK_DEFAULT' # pragma: no cover"",
            ""VARARGS_SPECIALS = {'STAR'} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {'MOCK_PARENT'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'MOCK_PARENT'} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '//', '=', '%'} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'float', 'str', 'list', 'dict'} # pragma: no cover""
        ]
    }
]",2,3553,0.0017765,5291,0.0079365,0.009713
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line :

# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockToken:"",
            ""    COMMENT = 1"",
            ""    COLON = 2"",
            ""    COMMA = 3"",
            ""    EQUAL = 4"",
            ""    STAR = 5"",
            ""    AT = 6"",
            ""    LPAR = 7"",
            ""    RPAR = 8"",
            ""    DOT = 9"",
            ""    LSQB = 10"",
            ""    DOUBLESTAR = 11"",
            ""    NAME = 12"",
            ""    NUMBER = 13"",
            ""    STRING = 14"",
            ""token = MockToken()"",
            """",
            ""class MockSyms:"",
            ""    subscript = 1"",
            ""    subscriptlist = 2"",
            ""    sliceop = 3"",
            ""    arglist = 4"",
            ""    argument = 5"",
            ""    parameters = 6"",
            ""    varargslist = 7"",
            ""    typedargslist = 8"",
            ""    star_expr = 9"",
            ""    factor = 10"",
            ""    decorator = 11"",
            ""    trailer = 12"",
            ""    dotted_name = 13"",
            ""    classdef = 14"",
            ""    atom = 15"",
            ""    dictsetmaker = 16"",
            ""    import_from = 17"",
            ""    except_clause = 18"",
            ""syms = MockSyms()"",
            """",
            ""class MockParent:"",
            ""    type = None"",
            ""    parent = None"",
            ""leaf = type('MockLeaf', (object,), {'type': token.COMMENT, 'parent': MockParent(), 'value': 'mock_value', 'prev_sibling': None, 'prefix': ''})()"",
            """",
            ""ALWAYS_NO_SPACE = {0}"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = {token.STAR}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {'MOCK_PARENT'}"",
            ""UNPACKING_PARENTS = {'MOCK_PARENT'}"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '//', '=', '%'}"",
            ""TYPED_NAMES = {'int', 'float', 'str', 'list', 'dict'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockToken:"",
            ""    COMMENT = 'COMMENT'"",
            ""    COLON = 'COLON'"",
            ""    COMMA = 'COMMA'"",
            ""    EQUAL = 'EQUAL'"",
            ""    STAR = 'STAR'"",
            ""    AT = 'AT'"",
            ""    LPAR = 'LPAR'"",
            ""    RPAR = 'RPAR'"",
            ""    DOT = 'DOT'"",
            ""    LSQB = 'LSQB'"",
            ""    NAME = 'NAME'"",
            ""    NUMBER = 'NUMBER'"",
            ""    STRING = 'STRING'"",
            ""    DOUBLESTAR = 'DOUBLESTAR'"",
            ""token = MockToken()"",
            """",
            ""class MockSyms:"",
            ""    subscript = 'subscript'"",
            ""    subscriptlist = 'subscriptlist'"",
            ""    sliceop = 'sliceop'"",
            ""    arglist = 'arglist'"",
            ""    argument = 'argument'"",
            ""    parameters = 'parameters'"",
            ""    varargslist = 'varargslist'"",
            ""    typedargslist = 'typedargslist'"",
            ""    star_expr = 'star_expr'"",
            ""    factor = 'factor'"",
            ""    decorator = 'decorator'"",
            ""    trailer = 'trailer'"",
            ""    dotted_name = 'dotted_name'"",
            ""    classdef = 'classdef'"",
            ""    atom = 'atom'"",
            ""    dictsetmaker = 'dictsetmaker'"",
            ""    import_from = 'import_from'"",
            ""    except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type):"",
            ""        self.type = type"",
            ""        self.parent = None"",
            ""leaf = type('MockLeaf', (object,), {'type': token.COMMENT, 'parent': MockParent(syms.argument), 'value': 'MOCK_VALUE', 'prev_sibling': None, 'prefix': ''})()"",
            """",
            ""ALWAYS_NO_SPACE = {token.COMMENT}"",
            ""preceding_leaf = lambda x: leaf"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: syms.argument"",
            ""VARARGS_SPECIALS = {token.STAR}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {syms.argument}"",
            ""UNPACKING_PARENTS = {syms.argument}"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'int', 'float', 'str'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockToken:"",
            ""    COMMENT = 'COMMENT'"",
            ""    COLON = 'COLON'"",
            ""    COMMA = 'COMMA'"",
            ""    EQUAL = 'EQUAL'"",
            ""    STAR = 'STAR'"",
            ""    AT = 'AT'"",
            ""    LPAR = 'LPAR'"",
            ""    RPAR = 'RPAR'"",
            ""    DOT = 'DOT'"",
            ""    LSQB = 'LSQB'"",
            ""    NAME = 'NAME'"",
            ""    NUMBER = 'NUMBER'"",
            ""    STRING = 'STRING'"",
            ""    DOUBLESTAR = 'DOUBLESTAR'"",
            ""token = MockToken()"",
            """",
            ""class MockSyms:"",
            ""    subscript = 'subscript'"",
            ""    subscriptlist = 'subscriptlist'"",
            ""    sliceop = 'sliceop'"",
            ""    arglist = 'arglist'"",
            ""    argument = 'argument'"",
            ""    parameters = 'parameters'"",
            ""    varargslist = 'varargslist'"",
            ""    typedargslist = 'typedargslist'"",
            ""    star_expr = 'star_expr'"",
            ""    factor = 'factor'"",
            ""    decorator = 'decorator'"",
            ""    trailer = 'trailer'"",
            ""    dotted_name = 'dotted_name'"",
            ""    classdef = 'classdef'"",
            ""    atom = 'atom'"",
            ""    dictsetmaker = 'dictsetmaker'"",
            ""    import_from = 'import_from'"",
            ""    except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            """",
            ""class MockLeaf:"",
            ""    def __init__(self, type, parent, value, prev_sibling, prefix=''):"",
            ""        self.type = type"",
            ""        self.parent = parent"",
            ""        self.value = value"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = prefix"",
            ""leaf = MockLeaf('type', 'parent', 'value', None)"",
            """",
            ""ALWAYS_NO_SPACE = {'MOCK_TYPE'}"",
            ""preceding_leaf = lambda x: MockLeaf('prev_type', MockLeaf(None, 'grand_parent', None, None), None, None)"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: 'parent_type'"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""is_vararg = lambda x, within: x in within"",
            ""VARARGS_PARENTS = {'MOCK_VARARG_PARENT'}"",
            ""UNPACKING_PARENTS = {'MOCK_UNPACKING_PARENT'}"",
            ""MATH_OPERATORS = {'+', '-', '*', '//', '%'}"",
            ""TYPED_NAMES = {'MOCK_TYPED_NAME'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockToken:"",
            ""    COMMENT = 1"",
            ""    COLON = 2"",
            ""    COMMA = 3"",
            ""    EQUAL = 4"",
            ""    STAR = 5"",
            ""    AT = 6"",
            ""    LPAR = 7"",
            ""    RPAR = 8"",
            ""    DOT = 9"",
            ""    LSQB = 10"",
            ""    DOUBLESTAR = 11"",
            ""    NAME = 12"",
            ""    NUMBER = 13"",
            ""    STRING = 14"",
            ""token = MockToken()"",
            """",
            ""class MockSyms:"",
            ""    subscript = 1"",
            ""    subscriptlist = 2"",
            ""    sliceop = 3"",
            ""    arglist = 4"",
            ""    argument = 5"",
            ""    parameters = 6"",
            ""    varargslist = 7"",
            ""    typedargslist = 8"",
            ""    star_expr = 9"",
            ""    factor = 10"",
            ""    decorator = 11"",
            ""    trailer = 12"",
            ""    dotted_name = 13"",
            ""    classdef = 14"",
            ""    atom = 15"",
            ""    dictsetmaker = 16"",
            ""    import_from = 17"",
            ""    except_clause = 18"",
            ""syms = MockSyms()"",
            """",
            ""class MockLeaf:"",
            ""    def __init__(self, type, parent=None, value=None, prev_sibling=None, prefix=''):"",
            ""        self.type = type"",
            ""        self.parent = parent"",
            ""        self.value = value"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = prefix"",
            ""leaf = MockLeaf(type=token.COMMENT, parent='parent', value='value')"",
            """",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON}"",
            ""preceding_leaf = lambda x: MockLeaf(type=token.COMMENT)"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: syms.argument"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""is_vararg = lambda x, within: x.type in VARARGS_SPECIALS and within"",
            ""VARARGS_PARENTS = {syms.arglist, syms.parameters}"",
            ""UNPACKING_PARENTS = {syms.trailer}"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '//', '%', '**'}"",
            ""TYPED_NAMES = {token.NAME}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockToken:"",
            ""    COMMENT = 'COMMENT'"",
            ""    COLON = 'COLON'"",
            ""    COMMA = 'COMMA'"",
            ""    EQUAL = 'EQUAL'"",
            ""    STAR = 'STAR'"",
            ""    AT = 'AT'"",
            ""    LPAR = 'LPAR'"",
            ""    RPAR = 'RPAR'"",
            ""    DOT = 'DOT'"",
            ""    LSQB = 'LSQB'"",
            ""    NAME = 'NAME'"",
            ""    NUMBER = 'NUMBER'"",
            ""    STRING = 'STRING'"",
            ""    DOUBLESTAR = 'DOUBLESTAR'"",
            ""token = MockToken()"",
            """",
            ""class MockSyms:"",
            ""    subscript = 'subscript'"",
            ""    subscriptlist = 'subscriptlist'"",
            ""    sliceop = 'sliceop'"",
            ""    arglist = 'arglist'"",
            ""    argument = 'argument'"",
            ""    parameters = 'parameters'"",
            ""    varargslist = 'varargslist'"",
            ""    typedargslist = 'typedargslist'"",
            ""    star_expr = 'star_expr'"",
            ""    factor = 'factor'"",
            ""    decorator = 'decorator'"",
            ""    trailer = 'trailer'"",
            ""    dotted_name = 'dotted_name'"",
            ""    classdef = 'classdef'"",
            ""    atom = 'atom'"",
            ""    dictsetmaker = 'dictsetmaker'"",
            ""    import_from = 'import_from'"",
            ""    except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            """",
            ""class MockLeaf:"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):"",
            ""        self.type = type"",
            ""        self.parent = parent"",
            ""        self.value = value"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            ""parent_leaf = MockLeaf('parent_type', None, 'parent_value')"",
            ""leaf = MockLeaf('MOCK_DEFAULT', parent_leaf, 'MOCK_DEFAULT')"",
            """",
            ""ALWAYS_NO_SPACE = {token.COMMENT}"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: 'parent_type'"",
            ""VARARGS_SPECIALS = {token.STAR}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {'MOCK_PARENT'}"",
            ""UNPACKING_PARENTS = {'MOCK_PARENT'}"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'int', 'float', 'str', 'list', 'dict'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockParent:"",
            ""    type = 'mock_type'"",
            ""leaf = type('MockLeaf', (object,), {'type': 'mock_type', 'parent': MockParent(), 'value': 'mock_value', 'prev_sibling': None, 'prefix': ''})()"",
            ""ALWAYS_NO_SPACE = {'mock_type'}"",
            ""token = type('MockToken', (object,), {'COMMENT': 'COMMENT', 'COLON': 'COLON', 'COMMA': 'COMMA', 'EQUAL': 'EQUAL', 'STAR': 'STAR', 'AT': 'AT', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'DOT': 'DOT', 'LSQB': 'LSQB', 'DOUBLESTAR': 'DOUBLESTAR', 'NAME': 'NAME', 'NUMBER': 'NUMBER', 'STRING': 'STRING'})"",
            ""syms = type('MockSyms', (object,), {'subscript': 'subscript', 'subscriptlist': 'subscriptlist', 'sliceop': 'sliceop', 'arglist': 'arglist', 'argument': 'argument', 'parameters': 'parameters', 'varargslist': 'varargslist', 'typedargslist': 'typedargslist', 'star_expr': 'star_expr', 'factor': 'factor', 'decorator': 'decorator', 'trailer': 'trailer', 'dotted_name': 'dotted_name', 'classdef': 'classdef', 'atom': 'atom', 'dictsetmaker': 'dictsetmaker', 'import_from': 'import_from', 'except_clause': 'except_clause'})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB', 'LBRACE'}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: 'mock_parent_type'"",
            ""VARARGS_SPECIALS = {'STAR', 'DOUBLESTAR'}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {'varargs_parent'}"",
            ""UNPACKING_PARENTS = {'unpacking_parent'}"",
            ""MATH_OPERATORS = {'PLUS', 'MINUS', 'STAR', 'SLASH'}"",
            ""TYPED_NAMES = {'mock_type_name'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""from collections import namedtuple""
        ],
        ""initialization"": [
            ""class MockToken:"",
            ""    COMMENT = 'COMMENT'"",
            ""    COLON = 'COLON'"",
            ""    COMMA = 'COMMA'"",
            ""    EQUAL = 'EQUAL'"",
            ""    STAR = 'STAR'"",
            ""    AT = 'AT'"",
            ""    LPAR = 'LPAR'"",
            ""    RPAR = 'RPAR'"",
            ""    DOT = 'DOT'"",
            ""    LSQB = 'LSQB'"",
            ""    NAME = 'NAME'"",
            ""    NUMBER = 'NUMBER'"",
            ""    STRING = 'STRING'"",
            ""    DOUBLESTAR = 'DOUBLESTAR'"",
            ""token = MockToken()"",
            """",
            ""class MockSyms:"",
            ""    subscript = 'subscript'"",
            ""    subscriptlist = 'subscriptlist'"",
            ""    sliceop = 'sliceop'"",
            ""    arglist = 'arglist'"",
            ""    argument = 'argument'"",
            ""    parameters = 'parameters'"",
            ""    varargslist = 'varargslist'"",
            ""    typedargslist = 'typedargslist'"",
            ""    star_expr = 'star_expr'"",
            ""    factor = 'factor'"",
            ""    decorator = 'decorator'"",
            ""    trailer = 'trailer'"",
            ""    dotted_name = 'dotted_name'"",
            ""    classdef = 'classdef'"",
            ""    atom = 'atom'"",
            ""    dictsetmaker = 'dictsetmaker'"",
            ""    import_from = 'import_from'"",
            ""    except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            """",
            ""Node = namedtuple('Node', ['type', 'parent'])"",
            ""ParentNode = Node(type='type', parent=None)"",
            ""Leaf = namedtuple('Leaf', ['type', 'parent', 'value', 'prev_sibling'])"",
            ""leaf = Leaf(type='type', parent=ParentNode, value='value', prev_sibling=None)"",
            """",
            ""ALWAYS_NO_SPACE: Final = {'type1', 'type2'}"",
            ""preceding_leaf = lambda x: leaf if x == ParentNode else None"",
            ""OPENING_BRACKETS: Final = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: 'parent_type'"",
            ""VARARGS_SPECIALS: Final = {'*', '**'}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS: Final = {'type1', 'type2'}"",
            ""UNPACKING_PARENTS: Final = {'type1', 'type2'}"",
            ""MATH_OPERATORS: Final = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES: Final = {'type1', 'type2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, parent, value, prev_sibling):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            ""        self.value = value"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            ""class MockParent:"",
            ""    def __init__(self, type_):"",
            ""        self.type = type_"",
            ""ALWAYS_NO_SPACE = {'MOCK_TYPE1', 'MOCK_TYPE2'}"",
            ""token = type('MockToken', (object,), {"",
            ""    'COMMENT': 'COMMENT', 'COLON': 'COLON', 'COMMA': 'COMMA', 'EQUAL': 'EQUAL',"",
            ""    'STAR': 'STAR', 'AT': 'AT', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'DOT': 'DOT',"",
            ""    'LSQB': 'LSQB', 'DOUBLESTAR': 'DOUBLESTAR', 'NAME': 'NAME', 'NUMBER': 'NUMBER', 'STRING': 'STRING'"",
            ""})"",
            ""syms = type('MockSyms', (object,), {"",
            ""    'subscript': 'subscript', 'subscriptlist': 'subscriptlist', 'sliceop': 'sliceop',"",
            ""    'arglist': 'arglist', 'argument': 'argument', 'parameters': 'parameters', 'varargslist': 'varargslist',"",
            ""    'typedargslist': 'typedargslist', 'star_expr': 'star_expr', 'factor': 'factor', 'decorator': 'decorator',"",
            ""    'trailer': 'trailer', 'dotted_name': 'dotted_name', 'classdef': 'classdef', 'atom': 'atom', 'dictsetmaker': 'dictsetmaker',"",
            ""    'import_from': 'import_from', 'except_clause': 'except_clause'"",
            ""})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB', 'LCURLY'}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: 'default_parent'"",
            ""VARARGS_SPECIALS = {'STAR', 'DOUBLESTAR'}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {'MOCK_PARENT_TYPE1', 'MOCK_PARENT_TYPE2'}"",
            ""UNPACKING_PARENTS = {'MOCK_UNPACK_TYPE1', 'MOCK_UNPACK_TYPE2'}"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'MOCK_TYPE1', 'MOCK_TYPE2'}"",
            ""parent_leaf = MockParent(type_='default_parent')"",
            ""leaf = MockLeaf(type_='MOCK_TYPE', parent=parent_leaf, value='MOCK_VALUE', prev_sibling=None)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""from collections import namedtuple""
        ],
        ""initialization"": [
            ""class MockToken:"",
            ""    COMMENT = 'COMMENT'"",
            ""    COLON = 'COLON'"",
            ""    COMMA = 'COMMA'"",
            ""    EQUAL = 'EQUAL'"",
            ""    STAR = 'STAR'"",
            ""    AT = 'AT'"",
            ""    LPAR = 'LPAR'"",
            ""    RPAR = 'RPAR'"",
            ""    DOT = 'DOT'"",
            ""    LSQB = 'LSQB'"",
            ""    NAME = 'NAME'"",
            ""    NUMBER = 'NUMBER'"",
            ""    STRING = 'STRING'"",
            ""    DOUBLESTAR = 'DOUBLESTAR'"",
            ""token = MockToken()"",
            """",
            ""class MockSyms:"",
            ""    subscript = 'subscript'"",
            ""    subscriptlist = 'subscriptlist'"",
            ""    sliceop = 'sliceop'"",
            ""    arglist = 'arglist'"",
            ""    argument = 'argument'"",
            ""    parameters = 'parameters'"",
            ""    varargslist = 'varargslist'"",
            ""    typedargslist = 'typedargslist'"",
            ""    star_expr = 'star_expr'"",
            ""    factor = 'factor'"",
            ""    decorator = 'decorator'"",
            ""    trailer = 'trailer'"",
            ""    dotted_name = 'dotted_name'"",
            ""    classdef = 'classdef'"",
            ""    atom = 'atom'"",
            ""    dictsetmaker = 'dictsetmaker'"",
            ""    import_from = 'import_from'"",
            ""    except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            """",
            ""Leaf = namedtuple('Leaf', ['type', 'parent', 'value', 'prev_sibling', 'prefix'])"",
            ""Parent = namedtuple('Parent', ['type'])"",
            ""parent_instance = Parent(type='parent_type')"",
            ""leaf = Leaf(type=token.COMMENT, parent=parent_instance, value='value', prev_sibling=None, prefix='')"",
            """",
            ""ALWAYS_NO_SPACE: Final = {token.COMMENT, token.COLON}"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS: Final = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: 'parent_type'"",
            ""VARARGS_SPECIALS: Final = {token.STAR, token.DOUBLESTAR}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS: Final = {'parent_type'}"",
            ""UNPACKING_PARENTS: Final = {'parent_type'}"",
            ""MATH_OPERATORS: Final = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES: Final = {'int', 'float', 'str', 'list', 'dict'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""from collections import namedtuple""
        ],
        ""initialization"": [
            ""class MockToken:"",
            ""    COMMENT = 'COMMENT'"",
            ""    COLON = 'COLON'"",
            ""    COMMA = 'COMMA'"",
            ""    EQUAL = 'EQUAL'"",
            ""    STAR = 'STAR'"",
            ""    AT = 'AT'"",
            ""    LPAR = 'LPAR'"",
            ""    RPAR = 'RPAR'"",
            ""    DOT = 'DOT'"",
            ""    LSQB = 'LSQB'"",
            ""    NAME = 'NAME'"",
            ""    NUMBER = 'NUMBER'"",
            ""    STRING = 'STRING'"",
            ""    DOUBLESTAR = 'DOUBLESTAR'"",
            ""token = MockToken()"",
            """",
            ""class MockSyms:"",
            ""    subscript = 'subscript'"",
            ""    subscriptlist = 'subscriptlist'"",
            ""    sliceop = 'sliceop'"",
            ""    arglist = 'arglist'"",
            ""    argument = 'argument'"",
            ""    parameters = 'parameters'"",
            ""    varargslist = 'varargslist'"",
            ""    typedargslist = 'typedargslist'"",
            ""    star_expr = 'star_expr'"",
            ""    factor = 'factor'"",
            ""    decorator = 'decorator'"",
            ""    trailer = 'trailer'"",
            ""    dotted_name = 'dotted_name'"",
            ""    classdef = 'classdef'"",
            ""    atom = 'atom'"",
            ""    dictsetmaker = 'dictsetmaker'"",
            ""    import_from = 'import_from'"",
            ""    except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            """",
            ""Parent = namedtuple('Parent', ['type', 'parent'])"",
            ""parent = Parent(type='type', parent=None)"",
            ""Leaf = namedtuple('Leaf', ['type', 'parent', 'value', 'prev_sibling'])"",
            ""leaf = Leaf(type='type', parent=parent, value='value', prev_sibling=None)"",
            """",
            ""ALWAYS_NO_SPACE: Final = {'type1', 'type2'}"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS: Final = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: 'parent_type'"",
            ""VARARGS_SPECIALS: Final = {'*', '**'}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS: Final = {'type1', 'type2'}"",
            ""UNPACKING_PARENTS: Final = {'type1', 'type2'}"",
            ""MATH_OPERATORS: Final = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES: Final = {'type1', 'type2'}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockToken: # pragma: no cover"",
            ""    COMMENT = 1 # pragma: no cover"",
            ""    COLON = 2 # pragma: no cover"",
            ""    COMMA = 3 # pragma: no cover"",
            ""    EQUAL = 4 # pragma: no cover"",
            ""    STAR = 5 # pragma: no cover"",
            ""    AT = 6 # pragma: no cover"",
            ""    LPAR = 7 # pragma: no cover"",
            ""    RPAR = 8 # pragma: no cover"",
            ""    DOT = 9 # pragma: no cover"",
            ""    LSQB = 10 # pragma: no cover"",
            ""    DOUBLESTAR = 11 # pragma: no cover"",
            ""    NAME = 12 # pragma: no cover"",
            ""    NUMBER = 13 # pragma: no cover"",
            ""    STRING = 14 # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockSyms: # pragma: no cover"",
            ""    subscript = 1 # pragma: no cover"",
            ""    subscriptlist = 2 # pragma: no cover"",
            ""    sliceop = 3 # pragma: no cover"",
            ""    arglist = 4 # pragma: no cover"",
            ""    argument = 5 # pragma: no cover"",
            ""    parameters = 6 # pragma: no cover"",
            ""    varargslist = 7 # pragma: no cover"",
            ""    typedargslist = 8 # pragma: no cover"",
            ""    star_expr = 9 # pragma: no cover"",
            ""    factor = 10 # pragma: no cover"",
            ""    decorator = 11 # pragma: no cover"",
            ""    trailer = 12 # pragma: no cover"",
            ""    dotted_name = 13 # pragma: no cover"",
            ""    classdef = 14 # pragma: no cover"",
            ""    atom = 15 # pragma: no cover"",
            ""    dictsetmaker = 16 # pragma: no cover"",
            ""    except_clause = 18 # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    type = None # pragma: no cover"",
            ""    parent = None # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': token.COMMENT, 'parent': MockParent(), 'value': 'mock_value', 'prev_sibling': None, 'prefix': ''})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {0} # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {'MOCK_PARENT'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'MOCK_PARENT'} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '//', '=', '%'} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'float', 'str', 'list', 'dict'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockToken: # pragma: no cover"",
            ""    COMMENT = 'COMMENT' # pragma: no cover"",
            ""    COLON = 'COLON' # pragma: no cover"",
            ""    COMMA = 'COMMA' # pragma: no cover"",
            ""    EQUAL = 'EQUAL' # pragma: no cover"",
            ""    STAR = 'STAR' # pragma: no cover"",
            ""    AT = 'AT' # pragma: no cover"",
            ""    LPAR = 'LPAR' # pragma: no cover"",
            ""    RPAR = 'RPAR' # pragma: no cover"",
            ""    DOT = 'DOT' # pragma: no cover"",
            ""    LSQB = 'LSQB' # pragma: no cover"",
            ""    NAME = 'NAME' # pragma: no cover"",
            ""    NUMBER = 'NUMBER' # pragma: no cover"",
            ""    STRING = 'STRING' # pragma: no cover"",
            ""    DOUBLESTAR = 'DOUBLESTAR' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockSyms: # pragma: no cover"",
            ""    subscript = 'subscript' # pragma: no cover"",
            ""    subscriptlist = 'subscriptlist' # pragma: no cover"",
            ""    sliceop = 'sliceop' # pragma: no cover"",
            ""    arglist = 'arglist' # pragma: no cover"",
            ""    argument = 'argument' # pragma: no cover"",
            ""    parameters = 'parameters' # pragma: no cover"",
            ""    varargslist = 'varargslist' # pragma: no cover"",
            ""    typedargslist = 'typedargslist' # pragma: no cover"",
            ""    star_expr = 'star_expr' # pragma: no cover"",
            ""    factor = 'factor' # pragma: no cover"",
            ""    decorator = 'decorator' # pragma: no cover"",
            ""    trailer = 'trailer' # pragma: no cover"",
            ""    dotted_name = 'dotted_name' # pragma: no cover"",
            ""    classdef = 'classdef' # pragma: no cover"",
            ""    atom = 'atom' # pragma: no cover"",
            ""    dictsetmaker = 'dictsetmaker' # pragma: no cover"",
            ""    except_clause = 'except_clause' # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.parent = None # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': token.COMMENT, 'parent': MockParent(syms.argument), 'value': 'MOCK_VALUE', 'prev_sibling': None, 'prefix': ''})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT} # pragma: no cover"",
            ""preceding_leaf = lambda x: leaf # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: syms.argument # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {syms.argument} # pragma: no cover"",
            ""UNPACKING_PARENTS = {syms.argument} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'float', 'str'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockToken: # pragma: no cover"",
            ""    COMMENT = 'COMMENT' # pragma: no cover"",
            ""    COLON = 'COLON' # pragma: no cover"",
            ""    COMMA = 'COMMA' # pragma: no cover"",
            ""    EQUAL = 'EQUAL' # pragma: no cover"",
            ""    STAR = 'STAR' # pragma: no cover"",
            ""    AT = 'AT' # pragma: no cover"",
            ""    LPAR = 'LPAR' # pragma: no cover"",
            ""    RPAR = 'RPAR' # pragma: no cover"",
            ""    DOT = 'DOT' # pragma: no cover"",
            ""    LSQB = 'LSQB' # pragma: no cover"",
            ""    NAME = 'NAME' # pragma: no cover"",
            ""    NUMBER = 'NUMBER' # pragma: no cover"",
            ""    STRING = 'STRING' # pragma: no cover"",
            ""    DOUBLESTAR = 'DOUBLESTAR' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockSyms: # pragma: no cover"",
            ""    subscript = 'subscript' # pragma: no cover"",
            ""    subscriptlist = 'subscriptlist' # pragma: no cover"",
            ""    sliceop = 'sliceop' # pragma: no cover"",
            ""    arglist = 'arglist' # pragma: no cover"",
            ""    argument = 'argument' # pragma: no cover"",
            ""    parameters = 'parameters' # pragma: no cover"",
            ""    varargslist = 'varargslist' # pragma: no cover"",
            ""    typedargslist = 'typedargslist' # pragma: no cover"",
            ""    star_expr = 'star_expr' # pragma: no cover"",
            ""    factor = 'factor' # pragma: no cover"",
            ""    decorator = 'decorator' # pragma: no cover"",
            ""    trailer = 'trailer' # pragma: no cover"",
            ""    dotted_name = 'dotted_name' # pragma: no cover"",
            ""    classdef = 'classdef' # pragma: no cover"",
            ""    atom = 'atom' # pragma: no cover"",
            ""    dictsetmaker = 'dictsetmaker' # pragma: no cover"",
            ""    except_clause = 'except_clause' # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling, prefix=''): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = prefix # pragma: no cover"",
            ""leaf = MockLeaf('type', 'parent', 'value', None) # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'MOCK_TYPE'} # pragma: no cover"",
            ""preceding_leaf = lambda x: MockLeaf('prev_type', MockLeaf(None, 'grand_parent', None, None), None, None) # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: 'parent_type' # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""is_vararg = lambda x, within: x in within # pragma: no cover"",
            ""VARARGS_PARENTS = {'MOCK_VARARG_PARENT'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'MOCK_UNPACKING_PARENT'} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '//', '%'} # pragma: no cover"",
            ""TYPED_NAMES = {'MOCK_TYPED_NAME'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockToken: # pragma: no cover"",
            ""    COMMENT = 1 # pragma: no cover"",
            ""    COLON = 2 # pragma: no cover"",
            ""    COMMA = 3 # pragma: no cover"",
            ""    EQUAL = 4 # pragma: no cover"",
            ""    STAR = 5 # pragma: no cover"",
            ""    AT = 6 # pragma: no cover"",
            ""    LPAR = 7 # pragma: no cover"",
            ""    RPAR = 8 # pragma: no cover"",
            ""    DOT = 9 # pragma: no cover"",
            ""    LSQB = 10 # pragma: no cover"",
            ""    DOUBLESTAR = 11 # pragma: no cover"",
            ""    NAME = 12 # pragma: no cover"",
            ""    NUMBER = 13 # pragma: no cover"",
            ""    STRING = 14 # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockSyms: # pragma: no cover"",
            ""    subscript = 1 # pragma: no cover"",
            ""    subscriptlist = 2 # pragma: no cover"",
            ""    sliceop = 3 # pragma: no cover"",
            ""    arglist = 4 # pragma: no cover"",
            ""    argument = 5 # pragma: no cover"",
            ""    parameters = 6 # pragma: no cover"",
            ""    varargslist = 7 # pragma: no cover"",
            ""    typedargslist = 8 # pragma: no cover"",
            ""    star_expr = 9 # pragma: no cover"",
            ""    factor = 10 # pragma: no cover"",
            ""    decorator = 11 # pragma: no cover"",
            ""    trailer = 12 # pragma: no cover"",
            ""    dotted_name = 13 # pragma: no cover"",
            ""    classdef = 14 # pragma: no cover"",
            ""    atom = 15 # pragma: no cover"",
            ""    dictsetmaker = 16 # pragma: no cover"",
            ""    except_clause = 18 # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type, parent=None, value=None, prev_sibling=None, prefix=''): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = prefix # pragma: no cover"",
            ""leaf = MockLeaf(type=token.COMMENT, parent='parent', value='value') # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON} # pragma: no cover"",
            ""preceding_leaf = lambda x: MockLeaf(type=token.COMMENT) # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: syms.argument # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: x.type in VARARGS_SPECIALS and within # pragma: no cover"",
            ""VARARGS_PARENTS = {syms.arglist, syms.parameters} # pragma: no cover"",
            ""UNPACKING_PARENTS = {syms.trailer} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '//', '%', '**'} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockToken: # pragma: no cover"",
            ""    COMMENT = 'COMMENT' # pragma: no cover"",
            ""    COLON = 'COLON' # pragma: no cover"",
            ""    COMMA = 'COMMA' # pragma: no cover"",
            ""    EQUAL = 'EQUAL' # pragma: no cover"",
            ""    STAR = 'STAR' # pragma: no cover"",
            ""    AT = 'AT' # pragma: no cover"",
            ""    LPAR = 'LPAR' # pragma: no cover"",
            ""    RPAR = 'RPAR' # pragma: no cover"",
            ""    DOT = 'DOT' # pragma: no cover"",
            ""    LSQB = 'LSQB' # pragma: no cover"",
            ""    NAME = 'NAME' # pragma: no cover"",
            ""    NUMBER = 'NUMBER' # pragma: no cover"",
            ""    STRING = 'STRING' # pragma: no cover"",
            ""    DOUBLESTAR = 'DOUBLESTAR' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockSyms: # pragma: no cover"",
            ""    subscript = 'subscript' # pragma: no cover"",
            ""    subscriptlist = 'subscriptlist' # pragma: no cover"",
            ""    sliceop = 'sliceop' # pragma: no cover"",
            ""    arglist = 'arglist' # pragma: no cover"",
            ""    argument = 'argument' # pragma: no cover"",
            ""    parameters = 'parameters' # pragma: no cover"",
            ""    varargslist = 'varargslist' # pragma: no cover"",
            ""    typedargslist = 'typedargslist' # pragma: no cover"",
            ""    star_expr = 'star_expr' # pragma: no cover"",
            ""    factor = 'factor' # pragma: no cover"",
            ""    decorator = 'decorator' # pragma: no cover"",
            ""    trailer = 'trailer' # pragma: no cover"",
            ""    dotted_name = 'dotted_name' # pragma: no cover"",
            ""    classdef = 'classdef' # pragma: no cover"",
            ""    atom = 'atom' # pragma: no cover"",
            ""    dictsetmaker = 'dictsetmaker' # pragma: no cover"",
            ""    except_clause = 'except_clause' # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            ""parent_leaf = MockLeaf('parent_type', None, 'parent_value') # pragma: no cover"",
            ""leaf = MockLeaf('MOCK_DEFAULT', parent_leaf, 'MOCK_DEFAULT') # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT} # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: 'parent_type' # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {'MOCK_PARENT'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'MOCK_PARENT'} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'float', 'str', 'list', 'dict'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockParent: # pragma: no cover"",
            ""    type = 'mock_type' # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': 'mock_type', 'parent': MockParent(), 'value': 'mock_value', 'prev_sibling': None, 'prefix': ''})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'mock_type'} # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMENT': 'COMMENT', 'COLON': 'COLON', 'COMMA': 'COMMA', 'EQUAL': 'EQUAL', 'STAR': 'STAR', 'AT': 'AT', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'DOT': 'DOT', 'LSQB': 'LSQB', 'DOUBLESTAR': 'DOUBLESTAR', 'NAME': 'NAME', 'NUMBER': 'NUMBER', 'STRING': 'STRING'}) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB', 'LBRACE'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: 'mock_parent_type' # pragma: no cover"",
            ""VARARGS_SPECIALS = {'STAR', 'DOUBLESTAR'} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {'varargs_parent'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'unpacking_parent'} # pragma: no cover"",
            ""MATH_OPERATORS = {'PLUS', 'MINUS', 'STAR', 'SLASH'} # pragma: no cover"",
            ""TYPED_NAMES = {'mock_type_name'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockToken: # pragma: no cover"",
            ""    COMMENT = 'COMMENT' # pragma: no cover"",
            ""    COLON = 'COLON' # pragma: no cover"",
            ""    COMMA = 'COMMA' # pragma: no cover"",
            ""    EQUAL = 'EQUAL' # pragma: no cover"",
            ""    STAR = 'STAR' # pragma: no cover"",
            ""    AT = 'AT' # pragma: no cover"",
            ""    LPAR = 'LPAR' # pragma: no cover"",
            ""    RPAR = 'RPAR' # pragma: no cover"",
            ""    DOT = 'DOT' # pragma: no cover"",
            ""    LSQB = 'LSQB' # pragma: no cover"",
            ""    NAME = 'NAME' # pragma: no cover"",
            ""    NUMBER = 'NUMBER' # pragma: no cover"",
            ""    STRING = 'STRING' # pragma: no cover"",
            ""    DOUBLESTAR = 'DOUBLESTAR' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockSyms: # pragma: no cover"",
            ""    subscript = 'subscript' # pragma: no cover"",
            ""    subscriptlist = 'subscriptlist' # pragma: no cover"",
            ""    sliceop = 'sliceop' # pragma: no cover"",
            ""    arglist = 'arglist' # pragma: no cover"",
            ""    argument = 'argument' # pragma: no cover"",
            ""    parameters = 'parameters' # pragma: no cover"",
            ""    varargslist = 'varargslist' # pragma: no cover"",
            ""    typedargslist = 'typedargslist' # pragma: no cover"",
            ""    star_expr = 'star_expr' # pragma: no cover"",
            ""    factor = 'factor' # pragma: no cover"",
            ""    decorator = 'decorator' # pragma: no cover"",
            ""    trailer = 'trailer' # pragma: no cover"",
            ""    dotted_name = 'dotted_name' # pragma: no cover"",
            ""    classdef = 'classdef' # pragma: no cover"",
            ""    atom = 'atom' # pragma: no cover"",
            ""    dictsetmaker = 'dictsetmaker' # pragma: no cover"",
            ""    except_clause = 'except_clause' # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            "" # pragma: no cover"",
            ""Node = namedtuple('Node', ['type', 'parent']) # pragma: no cover"",
            ""ParentNode = Node(type='type', parent=None) # pragma: no cover"",
            ""Leaf = namedtuple('Leaf', ['type', 'parent', 'value', 'prev_sibling']) # pragma: no cover"",
            ""leaf = Leaf(type='type', parent=ParentNode, value='value', prev_sibling=None) # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE: Final = {'type1', 'type2'} # pragma: no cover"",
            ""preceding_leaf = lambda x: leaf if x == ParentNode else None # pragma: no cover"",
            ""OPENING_BRACKETS: Final = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: 'parent_type' # pragma: no cover"",
            ""VARARGS_SPECIALS: Final = {'*', '**'} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS: Final = {'type1', 'type2'} # pragma: no cover"",
            ""UNPACKING_PARENTS: Final = {'type1', 'type2'} # pragma: no cover"",
            ""MATH_OPERATORS: Final = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES: Final = {'type1', 'type2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, parent, value, prev_sibling): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'MOCK_TYPE1', 'MOCK_TYPE2'} # pragma: no cover"",
            ""token = type('MockToken', (object,), { # pragma: no cover"",
            ""    'COMMENT': 'COMMENT', 'COLON': 'COLON', 'COMMA': 'COMMA', 'EQUAL': 'EQUAL', # pragma: no cover"",
            ""    'STAR': 'STAR', 'AT': 'AT', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'DOT': 'DOT', # pragma: no cover"",
            ""    'LSQB': 'LSQB', 'DOUBLESTAR': 'DOUBLESTAR', 'NAME': 'NAME', 'NUMBER': 'NUMBER', 'STRING': 'STRING' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'subscript': 'subscript', 'subscriptlist': 'subscriptlist', 'sliceop': 'sliceop', # pragma: no cover"",
            ""    'arglist': 'arglist', 'argument': 'argument', 'parameters': 'parameters', 'varargslist': 'varargslist', # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', 'star_expr': 'star_expr', 'factor': 'factor', 'decorator': 'decorator', # pragma: no cover"",
            ""    'trailer': 'trailer', 'dotted_name': 'dotted_name', 'classdef': 'classdef', 'atom': 'atom', 'dictsetmaker': 'dictsetmaker', # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB', 'LCURLY'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: 'default_parent' # pragma: no cover"",
            ""VARARGS_SPECIALS = {'STAR', 'DOUBLESTAR'} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {'MOCK_PARENT_TYPE1', 'MOCK_PARENT_TYPE2'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'MOCK_UNPACK_TYPE1', 'MOCK_UNPACK_TYPE2'} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'MOCK_TYPE1', 'MOCK_TYPE2'} # pragma: no cover"",
            ""parent_leaf = MockParent(type_='default_parent') # pragma: no cover"",
            ""leaf = MockLeaf(type_='MOCK_TYPE', parent=parent_leaf, value='MOCK_VALUE', prev_sibling=None) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockToken: # pragma: no cover"",
            ""    COMMENT = 'COMMENT' # pragma: no cover"",
            ""    COLON = 'COLON' # pragma: no cover"",
            ""    COMMA = 'COMMA' # pragma: no cover"",
            ""    EQUAL = 'EQUAL' # pragma: no cover"",
            ""    STAR = 'STAR' # pragma: no cover"",
            ""    AT = 'AT' # pragma: no cover"",
            ""    LPAR = 'LPAR' # pragma: no cover"",
            ""    RPAR = 'RPAR' # pragma: no cover"",
            ""    DOT = 'DOT' # pragma: no cover"",
            ""    LSQB = 'LSQB' # pragma: no cover"",
            ""    NAME = 'NAME' # pragma: no cover"",
            ""    NUMBER = 'NUMBER' # pragma: no cover"",
            ""    STRING = 'STRING' # pragma: no cover"",
            ""    DOUBLESTAR = 'DOUBLESTAR' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockSyms: # pragma: no cover"",
            ""    subscript = 'subscript' # pragma: no cover"",
            ""    subscriptlist = 'subscriptlist' # pragma: no cover"",
            ""    sliceop = 'sliceop' # pragma: no cover"",
            ""    arglist = 'arglist' # pragma: no cover"",
            ""    argument = 'argument' # pragma: no cover"",
            ""    parameters = 'parameters' # pragma: no cover"",
            ""    varargslist = 'varargslist' # pragma: no cover"",
            ""    typedargslist = 'typedargslist' # pragma: no cover"",
            ""    star_expr = 'star_expr' # pragma: no cover"",
            ""    factor = 'factor' # pragma: no cover"",
            ""    decorator = 'decorator' # pragma: no cover"",
            ""    trailer = 'trailer' # pragma: no cover"",
            ""    dotted_name = 'dotted_name' # pragma: no cover"",
            ""    classdef = 'classdef' # pragma: no cover"",
            ""    atom = 'atom' # pragma: no cover"",
            ""    dictsetmaker = 'dictsetmaker' # pragma: no cover"",
            ""    except_clause = 'except_clause' # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            "" # pragma: no cover"",
            ""Leaf = namedtuple('Leaf', ['type', 'parent', 'value', 'prev_sibling', 'prefix']) # pragma: no cover"",
            ""Parent = namedtuple('Parent', ['type']) # pragma: no cover"",
            ""parent_instance = Parent(type='parent_type') # pragma: no cover"",
            ""leaf = Leaf(type=token.COMMENT, parent=parent_instance, value='value', prev_sibling=None, prefix='') # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE: Final = {token.COMMENT, token.COLON} # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS: Final = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: 'parent_type' # pragma: no cover"",
            ""VARARGS_SPECIALS: Final = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS: Final = {'parent_type'} # pragma: no cover"",
            ""UNPACKING_PARENTS: Final = {'parent_type'} # pragma: no cover"",
            ""MATH_OPERATORS: Final = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES: Final = {'int', 'float', 'str', 'list', 'dict'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockToken: # pragma: no cover"",
            ""    COMMENT = 'COMMENT' # pragma: no cover"",
            ""    COLON = 'COLON' # pragma: no cover"",
            ""    COMMA = 'COMMA' # pragma: no cover"",
            ""    EQUAL = 'EQUAL' # pragma: no cover"",
            ""    STAR = 'STAR' # pragma: no cover"",
            ""    AT = 'AT' # pragma: no cover"",
            ""    LPAR = 'LPAR' # pragma: no cover"",
            ""    RPAR = 'RPAR' # pragma: no cover"",
            ""    DOT = 'DOT' # pragma: no cover"",
            ""    LSQB = 'LSQB' # pragma: no cover"",
            ""    NAME = 'NAME' # pragma: no cover"",
            ""    NUMBER = 'NUMBER' # pragma: no cover"",
            ""    STRING = 'STRING' # pragma: no cover"",
            ""    DOUBLESTAR = 'DOUBLESTAR' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockSyms: # pragma: no cover"",
            ""    subscript = 'subscript' # pragma: no cover"",
            ""    subscriptlist = 'subscriptlist' # pragma: no cover"",
            ""    sliceop = 'sliceop' # pragma: no cover"",
            ""    arglist = 'arglist' # pragma: no cover"",
            ""    argument = 'argument' # pragma: no cover"",
            ""    parameters = 'parameters' # pragma: no cover"",
            ""    varargslist = 'varargslist' # pragma: no cover"",
            ""    typedargslist = 'typedargslist' # pragma: no cover"",
            ""    star_expr = 'star_expr' # pragma: no cover"",
            ""    factor = 'factor' # pragma: no cover"",
            ""    decorator = 'decorator' # pragma: no cover"",
            ""    trailer = 'trailer' # pragma: no cover"",
            ""    dotted_name = 'dotted_name' # pragma: no cover"",
            ""    classdef = 'classdef' # pragma: no cover"",
            ""    atom = 'atom' # pragma: no cover"",
            ""    dictsetmaker = 'dictsetmaker' # pragma: no cover"",
            ""    except_clause = 'except_clause' # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            "" # pragma: no cover"",
            ""Parent = namedtuple('Parent', ['type', 'parent']) # pragma: no cover"",
            ""parent = Parent(type='type', parent=None) # pragma: no cover"",
            ""Leaf = namedtuple('Leaf', ['type', 'parent', 'value', 'prev_sibling']) # pragma: no cover"",
            ""leaf = Leaf(type='type', parent=parent, value='value', prev_sibling=None) # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE: Final = {'type1', 'type2'} # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS: Final = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: 'parent_type' # pragma: no cover"",
            ""VARARGS_SPECIALS: Final = {'*', '**'} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS: Final = {'type1', 'type2'} # pragma: no cover"",
            ""UNPACKING_PARENTS: Final = {'type1', 'type2'} # pragma: no cover"",
            ""MATH_OPERATORS: Final = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES: Final = {'type1', 'type2'} # pragma: no cover""
        ]
    }
]",2,4417,0.0022085,6119,0.0091785,0.011387
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 14:
    VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist]) # pragma: no cover
NameError: name 'syms' is not defined
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import sys"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""leaf = SimpleNamespace(type=token.NAME, parent=SimpleNamespace(type=1, parent=None), value='', prev_sibling=None)"",
            ""ALWAYS_NO_SPACE = set([token.COMMA, token.COLON])"",
            ""syms = SimpleNamespace(subscript=1, subscriptlist=2, sliceop=3, arglist=4, argument=5, parameters=6, varargslist=7, typedargslist=8, star_expr=9, factor=10, decorator=11, trailer=12, dotted_name=13, classdef=14, atom=15, dictsetmaker=16, import_from=17, except_clause=18)"",
            ""def preceding_leaf(node): return None"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB])"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR])"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist])"",
            ""UNPACKING_PARENTS = set([syms.argument])"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH])"",
            ""TYPED_NAMES = set([syms.typedargslist, syms.argument])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import sys"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""syms = SimpleNamespace(subscript=1, subscriptlist=2, sliceop=3, arglist=4, argument=5, parameters=6, varargslist=7, typedargslist=8, star_expr=9, factor=10, decorator=11, trailer=12, dotted_name=13, classdef=14, atom=15, dictsetmaker=16, import_from=17, except_clause=18)"",
            ""leaf = SimpleNamespace(type=token.NAME, parent=SimpleNamespace(type=syms.argument), value='', prev_sibling=None)"",
            ""ALWAYS_NO_SPACE = set([token.COMMA, token.COLON])"",
            ""def preceding_leaf(node): return None"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB])"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR])"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist])"",
            ""UNPACKING_PARENTS = set([syms.argument])"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH])"",
            ""TYPED_NAMES = set([syms.typedargslist, syms.argument])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""leaf = SimpleNamespace(type=token.NAME, parent=SimpleNamespace(type=token.NAME), value='', prev_sibling=None)"",
            ""ALWAYS_NO_SPACE = set([token.COMMA, token.COLON])"",
            ""syms = SimpleNamespace(subscript=1, subscriptlist=2, sliceop=3, arglist=4, argument=5, parameters=6, varargslist=7, typedargslist=8, star_expr=9, factor=10, decorator=11, trailer=12, dotted_name=13, classdef=14, atom=15, dictsetmaker=16, import_from=17, except_clause=18)"",
            ""def preceding_leaf(node): return None"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB])"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR])"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist])"",
            ""UNPACKING_PARENTS = set([syms.argument])"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH])"",
            ""TYPED_NAMES = set([syms.typedargslist, syms.argument])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import sys"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""syms = SimpleNamespace(subscript=1, subscriptlist=2, sliceop=3, arglist=4, argument=5, parameters=6, varargslist=7, typedargslist=8, star_expr=9, factor=10, decorator=11, trailer=12, dotted_name=13, classdef=14, atom=15, dictsetmaker=16, import_from=17, except_clause=18)"",
            ""leaf = SimpleNamespace(type=token.NAME, parent=SimpleNamespace(type=syms.argument), value='', prev_sibling=None)"",
            ""ALWAYS_NO_SPACE = set([token.COMMA, token.COLON])"",
            ""def preceding_leaf(node): return None"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB])"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR])"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist])"",
            ""UNPACKING_PARENTS = set([syms.argument])"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH])"",
            ""TYPED_NAMES = set([syms.typedargslist, syms.argument])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""leaf = SimpleNamespace(type=token.NAME, parent=SimpleNamespace(type='parent_type', parent=None), value='', prev_sibling=None, prefix=' ')"",
            ""ALWAYS_NO_SPACE = {token.COMMA, token.COLON}"",
            ""syms = SimpleNamespace(subscript=1, subscriptlist=2, sliceop=3, arglist=4, argument=5, parameters=6, varargslist=7, typedargslist=8, star_expr=9, factor=10, decorator=11, trailer=12, dotted_name=13, classdef=14, atom=15, dictsetmaker=16, import_from=17, except_clause=18)"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {syms.arglist, syms.parameters, syms.varargslist}"",
            ""UNPACKING_PARENTS = {syms.argument}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {syms.typedargslist, syms.argument}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import sys"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""leaf = SimpleNamespace(type=token.NAME, parent=SimpleNamespace(type=None, parent=None), value='', prev_sibling=None)"",
            ""ALWAYS_NO_SPACE = set([token.COMMA, token.COLON])"",
            ""syms = SimpleNamespace(subscript=1, subscriptlist=2, sliceop=3, arglist=4, argument=5, parameters=6, varargslist=7, typedargslist=8, star_expr=9, factor=10, decorator=11, trailer=12, dotted_name=13, classdef=14, atom=15, dictsetmaker=16, import_from=17, except_clause=18)"",
            ""def preceding_leaf(node): return None"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB])"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR])"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = set([4, 6, 7])"",
            ""UNPACKING_PARENTS = set([5])"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH])"",
            ""TYPED_NAMES = set([8, 5])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import sys"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""leaf = SimpleNamespace(type=token.NAME, parent=SimpleNamespace(type=1, parent=None), value='', prev_sibling=None)"",
            ""ALWAYS_NO_SPACE = set([token.COMMA, token.COLON])"",
            ""syms = SimpleNamespace(subscript=1, subscriptlist=2, sliceop=3, arglist=4, argument=5, parameters=6, varargslist=7, typedargslist=8, star_expr=9, factor=10, decorator=11, trailer=12, dotted_name=13, classdef=14, atom=15, dictsetmaker=16, import_from=17, except_clause=18)"",
            ""def preceding_leaf(node): return None"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB])"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR])"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = set([4, 6, 7])"",
            ""UNPACKING_PARENTS = set([5])"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH])"",
            ""TYPED_NAMES = set([8, 5])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import sys"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""syms = SimpleNamespace(subscript=1, subscriptlist=2, sliceop=3, arglist=4, argument=5, parameters=6, varargslist=7, typedargslist=8, star_expr=9, factor=10, decorator=11, trailer=12, dotted_name=13, classdef=14, atom=15, dictsetmaker=16, import_from=17, except_clause=18)"",
            ""leaf = SimpleNamespace(type=token.NAME, parent=SimpleNamespace(type=syms.argument), value='', prev_sibling=None)"",
            ""ALWAYS_NO_SPACE = set([token.COMMA, token.COLON])"",
            ""def preceding_leaf(node): return None"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB])"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR])"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist])"",
            ""UNPACKING_PARENTS = set([syms.argument])"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH])"",
            ""TYPED_NAMES = set([syms.typedargslist, syms.argument])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""leaf_parent = SimpleNamespace(type=1)"",
            ""leaf = SimpleNamespace(type=token.NAME, parent=leaf_parent, value='', prev_sibling=None, prefix='')"",
            ""ALWAYS_NO_SPACE = set([token.COMMA, token.COLON])"",
            ""syms = SimpleNamespace(subscript=1, subscriptlist=2, sliceop=3, arglist=4, argument=5, parameters=6, varargslist=7, typedargslist=8, star_expr=9, factor=10, decorator=11, trailer=12, dotted_name=13, classdef=14, atom=15, dictsetmaker=16, import_from=17, except_clause=18)"",
            ""def preceding_leaf(node): return None"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB])"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR])"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist])"",
            ""UNPACKING_PARENTS = set([syms.argument])"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH])"",
            ""TYPED_NAMES = set([token.NAME, token.NUMBER])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import sys"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""syms = SimpleNamespace(subscript=1, subscriptlist=2, sliceop=3, arglist=4, argument=5, parameters=6, varargslist=7, typedargslist=8, star_expr=9, factor=10, decorator=11, trailer=12, dotted_name=13, classdef=14, atom=15, dictsetmaker=16, import_from=17, except_clause=18)"",
            ""leaf = SimpleNamespace(type=token.NAME, parent=SimpleNamespace(type=syms.argument), value='', prev_sibling=None)"",
            ""ALWAYS_NO_SPACE = {token.COMMA, token.COLON}"",
            ""def preceding_leaf(node): return None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = {syms.arglist, syms.parameters, syms.varargslist}"",
            ""UNPACKING_PARENTS = {syms.argument}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {syms.typedargslist, syms.argument}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = SimpleNamespace(type=token.NAME, parent=SimpleNamespace(type=1, parent=None), value='', prev_sibling=None) # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set([token.COMMA, token.COLON]) # pragma: no cover"",
            ""def preceding_leaf(node): return None # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB]) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR]) # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist]) # pragma: no cover"",
            ""UNPACKING_PARENTS = set([syms.argument]) # pragma: no cover"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH]) # pragma: no cover"",
            ""TYPED_NAMES = set([syms.typedargslist, syms.argument]) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = SimpleNamespace(type=token.NAME, parent=SimpleNamespace(type=syms.argument), value='', prev_sibling=None) # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set([token.COMMA, token.COLON]) # pragma: no cover"",
            ""def preceding_leaf(node): return None # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB]) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR]) # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist]) # pragma: no cover"",
            ""UNPACKING_PARENTS = set([syms.argument]) # pragma: no cover"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH]) # pragma: no cover"",
            ""TYPED_NAMES = set([syms.typedargslist, syms.argument]) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = SimpleNamespace(type=token.NAME, parent=SimpleNamespace(type=token.NAME), value='', prev_sibling=None) # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set([token.COMMA, token.COLON]) # pragma: no cover"",
            ""def preceding_leaf(node): return None # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB]) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR]) # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist]) # pragma: no cover"",
            ""UNPACKING_PARENTS = set([syms.argument]) # pragma: no cover"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH]) # pragma: no cover"",
            ""TYPED_NAMES = set([syms.typedargslist, syms.argument]) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = SimpleNamespace(type=token.NAME, parent=SimpleNamespace(type=syms.argument), value='', prev_sibling=None) # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set([token.COMMA, token.COLON]) # pragma: no cover"",
            ""def preceding_leaf(node): return None # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB]) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR]) # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist]) # pragma: no cover"",
            ""UNPACKING_PARENTS = set([syms.argument]) # pragma: no cover"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH]) # pragma: no cover"",
            ""TYPED_NAMES = set([syms.typedargslist, syms.argument]) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = SimpleNamespace(type=token.NAME, parent=SimpleNamespace(type='parent_type', parent=None), value='', prev_sibling=None, prefix=' ') # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMA, token.COLON} # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {syms.arglist, syms.parameters, syms.varargslist} # pragma: no cover"",
            ""UNPACKING_PARENTS = {syms.argument} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {syms.typedargslist, syms.argument} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = SimpleNamespace(type=token.NAME, parent=SimpleNamespace(type=None, parent=None), value='', prev_sibling=None) # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set([token.COMMA, token.COLON]) # pragma: no cover"",
            ""def preceding_leaf(node): return None # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB]) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR]) # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set([4, 6, 7]) # pragma: no cover"",
            ""UNPACKING_PARENTS = set([5]) # pragma: no cover"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH]) # pragma: no cover"",
            ""TYPED_NAMES = set([8, 5]) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = SimpleNamespace(type=token.NAME, parent=SimpleNamespace(type=1, parent=None), value='', prev_sibling=None) # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set([token.COMMA, token.COLON]) # pragma: no cover"",
            ""def preceding_leaf(node): return None # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB]) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR]) # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set([4, 6, 7]) # pragma: no cover"",
            ""UNPACKING_PARENTS = set([5]) # pragma: no cover"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH]) # pragma: no cover"",
            ""TYPED_NAMES = set([8, 5]) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = SimpleNamespace(type=token.NAME, parent=SimpleNamespace(type=syms.argument), value='', prev_sibling=None) # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set([token.COMMA, token.COLON]) # pragma: no cover"",
            ""def preceding_leaf(node): return None # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB]) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR]) # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist]) # pragma: no cover"",
            ""UNPACKING_PARENTS = set([syms.argument]) # pragma: no cover"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH]) # pragma: no cover"",
            ""TYPED_NAMES = set([syms.typedargslist, syms.argument]) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf_parent = SimpleNamespace(type=1) # pragma: no cover"",
            ""leaf = SimpleNamespace(type=token.NAME, parent=leaf_parent, value='', prev_sibling=None, prefix='') # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set([token.COMMA, token.COLON]) # pragma: no cover"",
            ""def preceding_leaf(node): return None # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB]) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR]) # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist]) # pragma: no cover"",
            ""UNPACKING_PARENTS = set([syms.argument]) # pragma: no cover"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH]) # pragma: no cover"",
            ""TYPED_NAMES = set([token.NAME, token.NUMBER]) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = SimpleNamespace(type=token.NAME, parent=SimpleNamespace(type=syms.argument), value='', prev_sibling=None) # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMA, token.COLON} # pragma: no cover"",
            ""def preceding_leaf(node): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = {syms.arglist, syms.parameters, syms.varargslist} # pragma: no cover"",
            ""UNPACKING_PARENTS = {syms.argument} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {syms.typedargslist, syms.argument} # pragma: no cover""
        ]
    }
]",2,5083,0.0025415,3521,0.0052815,0.007823
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 34:
    assert p is not None, f""INTERNAL ERROR: hand-made leaf without parent: {leaf!r}""
AssertionError: INTERNAL ERROR: hand-made leaf without parent: <__main__.MockLeaf object at 0x7f77c74f6e80>
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockParent: pass"",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': MockParent(), 'value': '', 'prev_sibling': None})()"",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.EQUAL])"",
            ""class MockSyms:"",
            ""    subscript = 'subscript'"",
            ""    subscriptlist = 'subscriptlist'"",
            ""    sliceop = 'sliceop'"",
            ""    arglist = 'arglist'"",
            ""    argument = 'argument'"",
            ""    parameters = 'parameters'"",
            ""    varargslist = 'varargslist'"",
            ""    typedargslist = 'typedargslist'"",
            ""    star_expr = 'star_expr'"",
            ""    factor = 'factor'"",
            ""    decorator = 'decorator'"",
            ""    trailer = 'trailer'"",
            ""    dotted_name = 'dotted_name'"",
            ""    classdef = 'classdef'"",
            ""    atom = 'atom'"",
            ""    dictsetmaker = 'dictsetmaker'"",
            ""    import_from = 'import_from'"",
            ""    except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(node): return None"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB])"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = set([token.STAR])"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters])"",
            ""UNPACKING_PARENTS = set([syms.dictsetmaker, syms.argument])"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH])"",
            ""TYPED_NAMES = set([token.NAME])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockParent:"",
            ""    def __init__(self, type):"",
            ""        self.type = type"",
            ""        self.parent = None"",
            """",
            ""class MockLeaf:"",
            ""    def __init__(self, type, parent, value, prev_sibling):"",
            ""        self.type = type"",
            ""        self.parent = parent"",
            ""        self.value = value"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""leaf = MockLeaf(type=token.NAME, parent=MockParent(syms.argument), value='value', prev_sibling=None)"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON}"",
            ""syms = type('MockSyms', (object,), {"",
            ""    'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6,"",
            ""    'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12,"",
            ""    'dotted_name': 13, 'classdef': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18"",
            ""})"",
            ""def preceding_leaf(node): return None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = {syms.argument, syms.parameters, syms.varargslist}"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.argument}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME, token.NUMBER, token.STRING}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""MockParent = type('MockParent', (object,), {'type': None, 'parent': None})"",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': MockParent(), 'value': '', 'prev_sibling': None})()"",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.EQUAL])"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB])"",
            ""VARARGS_SPECIALS = set([token.STAR])"",
            ""VARARGS_PARENTS = set([MockParent()])"",
            ""UNPACKING_PARENTS = set([MockParent()])"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH])"",
            ""TYPED_NAMES = set([token.NAME])"",
            ""preceding_leaf = lambda x: None"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""is_vararg = lambda x, within: False"",
            ""syms = type('MockSyms', (object,), {'subscript': 'subscript', 'subscriptlist': 'subscriptlist', 'sliceop': 'sliceop', 'arglist': 'arglist', 'argument': 'argument', 'parameters': 'parameters', 'varargslist': 'varargslist', 'typedargslist': 'typedargslist', 'star_expr': 'star_expr', 'factor': 'factor', 'decorator': 'decorator', 'trailer': 'trailer', 'dotted_name': 'dotted_name', 'classdef': 'classdef', 'atom': 'atom', 'dictsetmaker': 'dictsetmaker', 'import_from': 'import_from', 'except_clause': 'except_clause'})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockParent:"",
            ""    def __init__(self, type, parent=None):"",
            ""        self.type = type"",
            ""        self.parent = parent"",
            """",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': MockParent('parent_type', MockParent('grandparent_type')), 'value': '', 'prev_sibling': None})()"",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.COLON])"",
            ""syms = type('MockSyms', (object,), {"",
            ""    'subscript': 'subscript',"",
            ""    'subscriptlist': 'subscriptlist',"",
            ""    'sliceop': 'sliceop',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument',"",
            ""    'parameters': 'parameters',"",
            ""    'varargslist': 'varargslist',"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'star_expr': 'star_expr',"",
            ""    'factor': 'factor',"",
            ""    'decorator': 'decorator',"",
            ""    'trailer': 'trailer',"",
            ""    'dotted_name': 'dotted_name',"",
            ""    'classdef': 'classdef',"",
            ""    'atom': 'atom',"",
            ""    'dictsetmaker': 'dictsetmaker',"",
            ""    'import_from': 'import_from',"",
            ""    'except_clause': 'except_clause'})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB])"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = set([token.STAR])"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = set(['parent_arglist', 'parent_parameters'])"",
            ""UNPACKING_PARENTS = set(['parent_dictsetmaker', 'parent_argument'])"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH])"",
            ""TYPED_NAMES = set([token.NAME])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""leaf = SimpleNamespace(type=token.NAME, parent=SimpleNamespace(type='parent_type'), value='', prev_sibling=None)"",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.EQUAL])"",
            ""syms = SimpleNamespace(subscript=1, subscriptlist=2, sliceop=3, arglist=4, argument=5, parameters=6, varargslist=7, typedargslist=8, star_expr=9, factor=10, decorator=11, trailer=12, dotted_name=13, classdef=14, atom=15, dictsetmaker=16, import_from=17, except_clause=18)"",
            ""def preceding_leaf(node): return None"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB])"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR])"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist])"",
            ""UNPACKING_PARENTS = set([syms.argument])"",
            ""MATH_OPERATORS = set([token.STAR, token.SLASH])"",
            ""TYPED_NAMES = set([token.NAME])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockSyms:"",
            ""    subscript = 'subscript'"",
            ""    subscriptlist = 'subscriptlist'"",
            ""    sliceop = 'sliceop'"",
            ""    arglist = 'arglist'"",
            ""    argument = 'argument'"",
            ""    parameters = 'parameters'"",
            ""    varargslist = 'varargslist'"",
            ""    typedargslist = 'typedargslist'"",
            ""    star_expr = 'star_expr'"",
            ""    factor = 'factor'"",
            ""    decorator = 'decorator'"",
            ""    trailer = 'trailer'"",
            ""    dotted_name = 'dotted_name'"",
            ""    classdef = 'classdef'"",
            ""    atom = 'atom'"",
            ""    dictsetmaker = 'dictsetmaker'"",
            ""    import_from = 'import_from'"",
            ""    except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type):"",
            ""        self.type = type"",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': MockParent(syms.argument), 'value': 'value', 'prev_sibling': None})()"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON, token.COMMA}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {syms.arglist, syms.parameters, syms.varargslist, syms.argument}"",
            ""UNPACKING_PARENTS = {syms.arglist, syms.dictsetmaker}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH, token.DOUBLESTAR}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""preceding_leaf = lambda x: None"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: x.parent.type if x and x.parent else None"",
            ""is_vararg = lambda x, within: x.type in VARARGS_SPECIALS and within"",
            ""def exit(code):"",
            ""    raise SystemExit(code)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockToken:"",
            ""    COMMENT = token.COMMENT"",
            ""    COLON = token.COLON"",
            ""    COMMA = token.COMMA"",
            ""    EQUAL = token.EQUAL"",
            ""    STAR = token.STAR"",
            ""    AT = token.AT"",
            ""    LPAR = token.LPAR"",
            ""    RPAR = token.RPAR"",
            ""    DOT = token.DOT"",
            ""    LSQB = token.LSQB"",
            ""    NAME = token.NAME"",
            ""    NUMBER = token.NUMBER"",
            ""    STRING = token.STRING"",
            ""    DOUBLESTAR = token.DOUBLESTAR"",
            ""token = MockToken()"",
            """",
            ""class MockSyms:"",
            ""    subscript = 'subscript'"",
            ""    subscriptlist = 'subscriptlist'"",
            ""    sliceop = 'sliceop'"",
            ""    arglist = 'arglist'"",
            ""    argument = 'argument'"",
            ""    parameters = 'parameters'"",
            ""    varargslist = 'varargslist'"",
            ""    typedargslist = 'typedargslist'"",
            ""    star_expr = 'star_expr'"",
            ""    factor = 'factor'"",
            ""    decorator = 'decorator'"",
            ""    trailer = 'trailer'"",
            ""    dotted_name = 'dotted_name'"",
            ""    classdef = 'classdef'"",
            ""    atom = 'atom'"",
            ""    dictsetmaker = 'dictsetmaker'"",
            ""    import_from = 'import_from'"",
            ""    except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            """",
            ""class MockParent:"",
            ""    type = syms.parameters"",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': MockParent(), 'value': '', 'prev_sibling': None})()"",
            """",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.EQUAL}"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {syms.arglist, syms.parameters, syms.varargslist}"",
            ""UNPACKING_PARENTS = {syms.argument}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):"",
            ""        self.type = type"",
            ""        self.parent = parent"",
            ""        self.value = value"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""    def __repr__(self):"",
            ""        return f'<MockLeaf type={self.type} parent={self.parent} value={self.value}>'"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type):"",
            ""        self.type = type"",
            """",
            ""leaf = MockLeaf(type=token.NAME, parent=MockParent(type='parent_type'), value='name')"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.EQUAL}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {'arglist', 'parameters', 'varargslist'}"",
            ""UNPACKING_PARENTS = {'dictsetmaker', 'argument'}"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'type1', 'type2'}"",
            ""preceding_leaf = lambda x: None"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: 'parent_type'"",
            ""is_vararg = lambda x, within: False"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, 'dotted_name': 13, 'classdef': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockParent:"",
            ""    type = 'MOCK_PARENT_TYPE'"",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': MockParent(), 'value': '', 'prev_sibling': None})()"",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.EQUAL])"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB])"",
            ""VARARGS_SPECIALS = set([token.STAR])"",
            ""VARARGS_PARENTS = set(['MOCK_PARENT_TYPE'])"",
            ""UNPACKING_PARENTS = set(['MOCK_PARENT_TYPE'])"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH])"",
            ""TYPED_NAMES = set(['MOCK_PARENT_TYPE'])"",
            ""preceding_leaf = lambda x: None"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: 'MOCK_PARENT_TYPE'"",
            ""is_vararg = lambda x, within: False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import symtable as syms""
        ],
        ""initialization"": [
            ""MockParent = type('MockParent', (object,), {'type': 'MOCK_PARENT_TYPE'})"",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': MockParent(), 'value': '', 'prev_sibling': None, 'prefix': ''})()"",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.EQUAL])"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB])"",
            ""VARARGS_SPECIALS = set([token.STAR])"",
            ""VARARGS_PARENTS = set([syms.argument, syms.parameters])"",
            ""UNPACKING_PARENTS = set([syms.dictsetmaker, syms.argument])"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH])"",
            ""TYPED_NAMES = set([token.NAME])"",
            ""preceding_leaf = lambda x: None"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""is_vararg = lambda x, within: False""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockParent: pass # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': MockParent(), 'value': '', 'prev_sibling': None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.EQUAL]) # pragma: no cover"",
            ""class MockSyms: # pragma: no cover"",
            ""    subscript = 'subscript' # pragma: no cover"",
            ""    subscriptlist = 'subscriptlist' # pragma: no cover"",
            ""    sliceop = 'sliceop' # pragma: no cover"",
            ""    arglist = 'arglist' # pragma: no cover"",
            ""    argument = 'argument' # pragma: no cover"",
            ""    parameters = 'parameters' # pragma: no cover"",
            ""    varargslist = 'varargslist' # pragma: no cover"",
            ""    typedargslist = 'typedargslist' # pragma: no cover"",
            ""    star_expr = 'star_expr' # pragma: no cover"",
            ""    factor = 'factor' # pragma: no cover"",
            ""    decorator = 'decorator' # pragma: no cover"",
            ""    trailer = 'trailer' # pragma: no cover"",
            ""    dotted_name = 'dotted_name' # pragma: no cover"",
            ""    classdef = 'classdef' # pragma: no cover"",
            ""    atom = 'atom' # pragma: no cover"",
            ""    dictsetmaker = 'dictsetmaker' # pragma: no cover"",
            ""    except_clause = 'except_clause' # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(node): return None # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB]) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR]) # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters]) # pragma: no cover"",
            ""UNPACKING_PARENTS = set([syms.dictsetmaker, syms.argument]) # pragma: no cover"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH]) # pragma: no cover"",
            ""TYPED_NAMES = set([token.NAME]) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.parent = None # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON} # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""def preceding_leaf(node): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = {syms.argument, syms.parameters, syms.varargslist} # pragma: no cover"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.argument} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME, token.NUMBER, token.STRING} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""MockParent = type('MockParent', (object,), {'type': None, 'parent': None}) # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': MockParent(), 'value': '', 'prev_sibling': None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.EQUAL]) # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB]) # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR]) # pragma: no cover"",
            ""VARARGS_PARENTS = set([MockParent()]) # pragma: no cover"",
            ""UNPACKING_PARENTS = set([MockParent()]) # pragma: no cover"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH]) # pragma: no cover"",
            ""TYPED_NAMES = set([token.NAME]) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type, parent=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': MockParent('parent_type', MockParent('grandparent_type')), 'value': '', 'prev_sibling': None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.COLON]) # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'subscript': 'subscript', # pragma: no cover"",
            ""    'subscriptlist': 'subscriptlist', # pragma: no cover"",
            ""    'sliceop': 'sliceop', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'argument': 'argument', # pragma: no cover"",
            ""    'parameters': 'parameters', # pragma: no cover"",
            ""    'varargslist': 'varargslist', # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'star_expr': 'star_expr', # pragma: no cover"",
            ""    'factor': 'factor', # pragma: no cover"",
            ""    'decorator': 'decorator', # pragma: no cover"",
            ""    'trailer': 'trailer', # pragma: no cover"",
            ""    'dotted_name': 'dotted_name', # pragma: no cover"",
            ""    'classdef': 'classdef', # pragma: no cover"",
            ""    'atom': 'atom', # pragma: no cover"",
            ""    'dictsetmaker': 'dictsetmaker', # pragma: no cover"",
            ""    'except_clause': 'except_clause'}) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB]) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR]) # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = set(['parent_arglist', 'parent_parameters']) # pragma: no cover"",
            ""UNPACKING_PARENTS = set(['parent_dictsetmaker', 'parent_argument']) # pragma: no cover"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH]) # pragma: no cover"",
            ""TYPED_NAMES = set([token.NAME]) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = SimpleNamespace(type=token.NAME, parent=SimpleNamespace(type='parent_type'), value='', prev_sibling=None) # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.EQUAL]) # pragma: no cover"",
            ""def preceding_leaf(node): return None # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB]) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR]) # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist]) # pragma: no cover"",
            ""UNPACKING_PARENTS = set([syms.argument]) # pragma: no cover"",
            ""MATH_OPERATORS = set([token.STAR, token.SLASH]) # pragma: no cover"",
            ""TYPED_NAMES = set([token.NAME]) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockSyms: # pragma: no cover"",
            ""    subscript = 'subscript' # pragma: no cover"",
            ""    subscriptlist = 'subscriptlist' # pragma: no cover"",
            ""    sliceop = 'sliceop' # pragma: no cover"",
            ""    arglist = 'arglist' # pragma: no cover"",
            ""    argument = 'argument' # pragma: no cover"",
            ""    parameters = 'parameters' # pragma: no cover"",
            ""    varargslist = 'varargslist' # pragma: no cover"",
            ""    typedargslist = 'typedargslist' # pragma: no cover"",
            ""    star_expr = 'star_expr' # pragma: no cover"",
            ""    factor = 'factor' # pragma: no cover"",
            ""    decorator = 'decorator' # pragma: no cover"",
            ""    trailer = 'trailer' # pragma: no cover"",
            ""    dotted_name = 'dotted_name' # pragma: no cover"",
            ""    classdef = 'classdef' # pragma: no cover"",
            ""    atom = 'atom' # pragma: no cover"",
            ""    dictsetmaker = 'dictsetmaker' # pragma: no cover"",
            ""    except_clause = 'except_clause' # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': MockParent(syms.argument), 'value': 'value', 'prev_sibling': None})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON, token.COMMA} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = {syms.arglist, syms.parameters, syms.varargslist, syms.argument} # pragma: no cover"",
            ""UNPACKING_PARENTS = {syms.arglist, syms.dictsetmaker} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH, token.DOUBLESTAR} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: x.parent.type if x and x.parent else None # pragma: no cover"",
            ""is_vararg = lambda x, within: x.type in VARARGS_SPECIALS and within # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockToken: # pragma: no cover"",
            ""    COMMENT = token.COMMENT # pragma: no cover"",
            ""    COLON = token.COLON # pragma: no cover"",
            ""    COMMA = token.COMMA # pragma: no cover"",
            ""    EQUAL = token.EQUAL # pragma: no cover"",
            ""    STAR = token.STAR # pragma: no cover"",
            ""    AT = token.AT # pragma: no cover"",
            ""    LPAR = token.LPAR # pragma: no cover"",
            ""    RPAR = token.RPAR # pragma: no cover"",
            ""    DOT = token.DOT # pragma: no cover"",
            ""    LSQB = token.LSQB # pragma: no cover"",
            ""    NAME = token.NAME # pragma: no cover"",
            ""    NUMBER = token.NUMBER # pragma: no cover"",
            ""    STRING = token.STRING # pragma: no cover"",
            ""    DOUBLESTAR = token.DOUBLESTAR # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockSyms: # pragma: no cover"",
            ""    subscript = 'subscript' # pragma: no cover"",
            ""    subscriptlist = 'subscriptlist' # pragma: no cover"",
            ""    sliceop = 'sliceop' # pragma: no cover"",
            ""    arglist = 'arglist' # pragma: no cover"",
            ""    argument = 'argument' # pragma: no cover"",
            ""    parameters = 'parameters' # pragma: no cover"",
            ""    varargslist = 'varargslist' # pragma: no cover"",
            ""    typedargslist = 'typedargslist' # pragma: no cover"",
            ""    star_expr = 'star_expr' # pragma: no cover"",
            ""    factor = 'factor' # pragma: no cover"",
            ""    decorator = 'decorator' # pragma: no cover"",
            ""    trailer = 'trailer' # pragma: no cover"",
            ""    dotted_name = 'dotted_name' # pragma: no cover"",
            ""    classdef = 'classdef' # pragma: no cover"",
            ""    atom = 'atom' # pragma: no cover"",
            ""    dictsetmaker = 'dictsetmaker' # pragma: no cover"",
            ""    except_clause = 'except_clause' # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    type = syms.parameters # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': MockParent(), 'value': '', 'prev_sibling': None})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.EQUAL} # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {syms.arglist, syms.parameters, syms.varargslist} # pragma: no cover"",
            ""UNPACKING_PARENTS = {syms.argument} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def __repr__(self): # pragma: no cover"",
            ""        return f'<MockLeaf type={self.type} parent={self.parent} value={self.value}>' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = MockLeaf(type=token.NAME, parent=MockParent(type='parent_type'), value='name') # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.EQUAL} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = {'arglist', 'parameters', 'varargslist'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'dictsetmaker', 'argument'} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'type1', 'type2'} # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: 'parent_type' # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockParent: # pragma: no cover"",
            ""    type = 'MOCK_PARENT_TYPE' # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': MockParent(), 'value': '', 'prev_sibling': None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.EQUAL]) # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB]) # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR]) # pragma: no cover"",
            ""VARARGS_PARENTS = set(['MOCK_PARENT_TYPE']) # pragma: no cover"",
            ""UNPACKING_PARENTS = set(['MOCK_PARENT_TYPE']) # pragma: no cover"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH]) # pragma: no cover"",
            ""TYPED_NAMES = set(['MOCK_PARENT_TYPE']) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: 'MOCK_PARENT_TYPE' # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import symtable as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""MockParent = type('MockParent', (object,), {'type': 'MOCK_PARENT_TYPE'}) # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': MockParent(), 'value': '', 'prev_sibling': None, 'prefix': ''})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.EQUAL]) # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB]) # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR]) # pragma: no cover"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH]) # pragma: no cover"",
            ""TYPED_NAMES = set([token.NAME]) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover""
        ]
    }
]",2,5667,0.0028335,4415,0.0066225,0.0094559999999999
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 37:
    assert p is not None, f""INTERNAL ERROR: hand-made leaf without parent: {leaf!r}""
AssertionError: INTERNAL ERROR: hand-made leaf without parent: <__main__.MockLeaf object at 0x7f895f734e80>
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.NEWLINE}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = set()"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '%'}"",
            ""TYPED_NAMES = set()"",
            ""preceding_leaf = lambda x: None"",
            ""parent_type = lambda x: None"",
            ""class MockSyms:"",
            ""    subscript = 1"",
            ""    subscriptlist = 2"",
            ""    sliceop = 3"",
            ""    arglist = 4"",
            ""    argument = 5"",
            ""    parameters = 6"",
            ""    varargslist = 7"",
            ""    typedargslist = 8"",
            ""    star_expr = 9"",
            ""    factor = 10"",
            ""    decorator = 11"",
            ""    trailer = 12"",
            ""    dotted_name = 13"",
            ""    classdef = 14"",
            ""    atom = 15"",
            ""    dictsetmaker = 16"",
            ""    import_from = 17"",
            ""    except_clause = 18"",
            ""syms = MockSyms()"",
            ""class MockLeaf:"",
            ""    def __init__(self, type, value, parent=None, prev_sibling=None):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            ""parent = MockLeaf(token.NAME, 'parent')"",
            ""leaf = MockLeaf(token.NAME, 'value', parent=parent)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import symtable as syms""
        ],
        ""initialization"": [
            ""class MockParent:"",
            ""    def __init__(self, type):"",
            ""        self.type = type"",
            ""        self.parent = None"",
            """",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': MockParent(syms.arglist), 'value': '', 'prev_sibling': None})()"",
            """",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.EQUAL])"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB])"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR])"",
            ""VARARGS_PARENTS = set([syms.parameters, syms.varargslist])"",
            ""UNPACKING_PARENTS = set([syms.arglist])"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH])"",
            ""TYPED_NAMES = set([token.NAME, token.STRING, token.NUMBER])"",
            """",
            ""preceding_leaf = lambda x: None"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""is_vararg = lambda x, within=None: False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import symtable as syms""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, parent=None, value='', prev_sibling=None):"",
            ""        self.type = type"",
            ""        self.parent = parent"",
            ""        self.value = value"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class Node:"",
            ""    def __init__(self, type):"",
            ""        self.type = type"",
            """",
            ""leaf = Leaf(type=token.NAME, parent=Node(syms.argument), value='', prev_sibling=None)"",
            ""ALWAYS_NO_SPACE = set()"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = set()"",
            ""is_vararg = lambda x, within=None: False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = set()"",
            ""TYPED_NAMES = set()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import symtable""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type, parent, value, prev_sibling):"",
            ""        self.type = type"",
            ""        self.parent = parent"",
            ""        self.value = value"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""parent_leaf = MockLeaf(type='MOCK_TYPE', parent=None, value='MOCK_VALUE', prev_sibling=None)"",
            ""leaf = MockLeaf(type=token.NAME, parent=parent_leaf, value='value', prev_sibling=None)"",
            ""parent_leaf.parent = leaf # Set parent reference"",
            """",
            ""ALWAYS_NO_SPACE = set([token.COMMA, token.COLON])"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB])"",
            ""VARARGS_SPECIALS = set([token.STAR])"",
            ""VARARGS_PARENTS = set([symtable.STMT, symtable.PARAM])"",
            ""UNPACKING_PARENTS = set([symtable.STMT, symtable.EXPR])"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH])"",
            ""TYPED_NAMES = set([token.NAME])"",
            ""preceding_leaf = lambda x: None"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: 'parent_type'"",
            ""is_vararg = lambda x, within: False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""leaf_parent = type('MockParent', (object,), {'type': 'MOCK_TYPE'})()"",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': leaf_parent, 'value': '', 'prev_sibling': None, 'prefix': ''})()"",
            ""ALWAYS_NO_SPACE = set([token.COMMA, token.COLON])"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, 'dotted_name': 13, 'classdef': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB])"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: 'MOCK_PARENT_TYPE'"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR])"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist])"",
            ""UNPACKING_PARENTS = set([syms.argument])"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH])"",
            ""TYPED_NAMES = set([syms.typedargslist, syms.argument])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': 'value', 'prev_sibling': None})()"",
            ""leaf.parent = type('MockParent', (object,), {'type': 'parent_type', 'parent': None})()"",
            ""ALWAYS_NO_SPACE = set(['type1', 'type2'])"",
            ""syms = type('MockSyms', (object,), {'subscript': 'subscript', 'subscriptlist': 'subscriptlist', 'sliceop': 'sliceop', 'arglist': 'arglist', 'argument': 'argument', 'parameters': 'parameters', 'varargslist': 'varargslist', 'typedargslist': 'typedargslist', 'star_expr': 'star_expr', 'factor': 'factor', 'decorator': 'decorator', 'trailer': 'trailer', 'dotted_name': 'dotted_name', 'classdef': 'classdef', 'atom': 'atom', 'dictsetmaker': 'dictsetmaker', 'import_from': 'import_from', 'except_clause': 'except_clause'})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = set(['(', '[', '{'])"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: 'parent_type'"",
            ""VARARGS_SPECIALS = set(['*', '**'])"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = set(['type1', 'type2'])"",
            ""UNPACKING_PARENTS = set(['type1', 'type2'])"",
            ""MATH_OPERATORS = set(['+', '-', '*', '/'])"",
            ""TYPED_NAMES = set(['type1', 'type2'])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""syms = type('MockSyms', (object,), {"",
            ""    'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5,"",
            ""    'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10,"",
            ""    'decorator': 11, 'trailer': 12, 'dotted_name': 13, 'classdef': 14, 'atom': 15,"",
            ""    'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18"",
            ""})"",
            """",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None, 'prefix': ''"",
            ""})()"",
            """",
            ""leaf.parent = type('MockParent', (object,), { 'type': syms.argument })()"",
            """",
            ""ALWAYS_NO_SPACE = {token.COMMA, token.COLON}"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: 'MOCK_DEFAULT'"",
            ""VARARGS_SPECIALS = {token.STAR}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {syms.arglist, syms.parameters, syms.varargslist}"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.argument}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""MockLeaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None, 'prefix': ''})"",
            ""leaf = MockLeaf()"",
            ""MockParent = type('MockParent', (object,), {'type': 'MOCK_PARENT'})"",
            ""leaf.parent = MockParent()"",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.EQUAL])"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, 'dotted_name': 13, 'classdef': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB])"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: 'MOCK_PARENT'"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR])"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = set(['MOCK_PARENT'])"",
            ""UNPACKING_PARENTS = set(['MOCK_PARENT'])"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH])"",
            ""TYPED_NAMES = set(['int', 'float', 'str', 'list', 'dict'])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""MockLeafParent = type('MockLeafParent', (object,), {'type': 1})"",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': MockLeafParent(), 'value': '', 'prev_sibling': None})()"",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.EQUAL])"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, 'dotted_name': 13, 'classdef': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB, token.LBRACE])"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR])"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist])"",
            ""UNPACKING_PARENTS = set([syms.argument])"",
            ""MATH_OPERATORS = set([token.STAR, token.SLASH, token.PLUS, token.MINUS])"",
            ""TYPED_NAMES = set([token.NAME])"",
            ""leaf.prev_sibling = type('MockPrevLeaf', (object,), {'type': token.COMMA, 'parent': MockLeafParent(), 'value': ''})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""leaf = SimpleNamespace(type=token.NAME, parent=None, value='', prev_sibling=None)"",
            ""ALWAYS_NO_SPACE = set()"",
            ""syms = SimpleNamespace(subscript=1, subscriptlist=2, sliceop=3, arglist=4, argument=5, parameters=6, varargslist=7, typedargslist=8, star_expr=9, factor=10, decorator=11, trailer=12, dotted_name=13, classdef=14, atom=15, dictsetmaker=16, import_from=17, except_clause=18)"",
            ""def preceding_leaf(node): return None"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB])"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR])"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist])"",
            ""UNPACKING_PARENTS = set([syms.argument])"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH])"",
            ""TYPED_NAMES = set([token.NAME, token.NUMBER])"",
            ""leaf.parent = SimpleNamespace(type=syms.arglist, parent=None)""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.NEWLINE} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""VARARGS_SPECIALS = set() # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '%'} # pragma: no cover"",
            ""TYPED_NAMES = set() # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""class MockSyms: # pragma: no cover"",
            ""    subscript = 1 # pragma: no cover"",
            ""    subscriptlist = 2 # pragma: no cover"",
            ""    sliceop = 3 # pragma: no cover"",
            ""    arglist = 4 # pragma: no cover"",
            ""    argument = 5 # pragma: no cover"",
            ""    parameters = 6 # pragma: no cover"",
            ""    varargslist = 7 # pragma: no cover"",
            ""    typedargslist = 8 # pragma: no cover"",
            ""    star_expr = 9 # pragma: no cover"",
            ""    factor = 10 # pragma: no cover"",
            ""    decorator = 11 # pragma: no cover"",
            ""    trailer = 12 # pragma: no cover"",
            ""    dotted_name = 13 # pragma: no cover"",
            ""    classdef = 14 # pragma: no cover"",
            ""    atom = 15 # pragma: no cover"",
            ""    dictsetmaker = 16 # pragma: no cover"",
            ""    except_clause = 18 # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            ""parent = MockLeaf(token.NAME, 'parent') # pragma: no cover"",
            ""leaf = MockLeaf(token.NAME, 'value', parent=parent) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import symtable as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.parent = None # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.EQUAL]) # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB]) # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR]) # pragma: no cover"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH]) # pragma: no cover"",
            ""TYPED_NAMES = set([token.NAME, token.STRING, token.NUMBER]) # pragma: no cover"",
            "" # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""is_vararg = lambda x, within=None: False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import symtable as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, parent=None, value='', prev_sibling=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Node: # pragma: no cover"",
            ""    def __init__(self, type): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = set() # pragma: no cover"",
            ""is_vararg = lambda x, within=None: False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = set() # pragma: no cover"",
            ""TYPED_NAMES = set() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import symtable # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""parent_leaf = MockLeaf(type='MOCK_TYPE', parent=None, value='MOCK_VALUE', prev_sibling=None) # pragma: no cover"",
            ""leaf = MockLeaf(type=token.NAME, parent=parent_leaf, value='value', prev_sibling=None) # pragma: no cover"",
            ""parent_leaf.parent = leaf # Set parent reference # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set([token.COMMA, token.COLON]) # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB]) # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR]) # pragma: no cover"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH]) # pragma: no cover"",
            ""TYPED_NAMES = set([token.NAME]) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: 'parent_type' # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf_parent = type('MockParent', (object,), {'type': 'MOCK_TYPE'})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': leaf_parent, 'value': '', 'prev_sibling': None, 'prefix': ''})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set([token.COMMA, token.COLON]) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB]) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: 'MOCK_PARENT_TYPE' # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR]) # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist]) # pragma: no cover"",
            ""UNPACKING_PARENTS = set([syms.argument]) # pragma: no cover"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH]) # pragma: no cover"",
            ""TYPED_NAMES = set([syms.typedargslist, syms.argument]) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': 'value', 'prev_sibling': None})() # pragma: no cover"",
            ""leaf.parent = type('MockParent', (object,), {'type': 'parent_type', 'parent': None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set(['type1', 'type2']) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = set(['(', '[', '{']) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: 'parent_type' # pragma: no cover"",
            ""VARARGS_SPECIALS = set(['*', '**']) # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = set(['type1', 'type2']) # pragma: no cover"",
            ""UNPACKING_PARENTS = set(['type1', 'type2']) # pragma: no cover"",
            ""MATH_OPERATORS = set(['+', '-', '*', '/']) # pragma: no cover"",
            ""TYPED_NAMES = set(['type1', 'type2']) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, # pragma: no cover"",
            ""    'decorator': 11, 'trailer': 12, 'dotted_name': 13, 'classdef': 14, 'atom': 15, # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None, 'prefix': '' # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf.parent = type('MockParent', (object,), { 'type': syms.argument })() # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMA, token.COLON} # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: 'MOCK_DEFAULT' # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {syms.arglist, syms.parameters, syms.varargslist} # pragma: no cover"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.argument} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""MockLeaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None, 'prefix': ''}) # pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""MockParent = type('MockParent', (object,), {'type': 'MOCK_PARENT'}) # pragma: no cover"",
            ""leaf.parent = MockParent() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.EQUAL]) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB]) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: 'MOCK_PARENT' # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR]) # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = set(['MOCK_PARENT']) # pragma: no cover"",
            ""UNPACKING_PARENTS = set(['MOCK_PARENT']) # pragma: no cover"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH]) # pragma: no cover"",
            ""TYPED_NAMES = set(['int', 'float', 'str', 'list', 'dict']) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""MockLeafParent = type('MockLeafParent', (object,), {'type': 1}) # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': MockLeafParent(), 'value': '', 'prev_sibling': None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.EQUAL]) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB, token.LBRACE]) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR]) # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist]) # pragma: no cover"",
            ""UNPACKING_PARENTS = set([syms.argument]) # pragma: no cover"",
            ""MATH_OPERATORS = set([token.STAR, token.SLASH, token.PLUS, token.MINUS]) # pragma: no cover"",
            ""TYPED_NAMES = set([token.NAME]) # pragma: no cover"",
            ""leaf.prev_sibling = type('MockPrevLeaf', (object,), {'type': token.COMMA, 'parent': MockLeafParent(), 'value': ''})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = SimpleNamespace(type=token.NAME, parent=None, value='', prev_sibling=None) # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""def preceding_leaf(node): return None # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB]) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR]) # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist]) # pragma: no cover"",
            ""UNPACKING_PARENTS = set([syms.argument]) # pragma: no cover"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH]) # pragma: no cover"",
            ""TYPED_NAMES = set([token.NAME, token.NUMBER]) # pragma: no cover"",
            ""leaf.parent = SimpleNamespace(type=syms.arglist, parent=None) # pragma: no cover""
        ]
    }
]",2,6258,0.003129,3955,0.0059325,0.0090615
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 37:
    assert p is not None, f""INTERNAL ERROR: hand-made leaf without parent: {leaf!r}""
AssertionError: INTERNAL ERROR: hand-made leaf without parent: <class '__main__.MockLeaf'>
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None, 'prefix': ''})()"",
            ""ALWAYS_NO_SPACE = set()"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, 'dotted_name': 13, 'classdef': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18})"",
            ""preceding_leaf = lambda leaf: None"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB, token.LBRACE])"",
            ""complex_subscript = False"",
            ""parent_type = lambda leaf: None"",
            ""VARARGS_SPECIALS = set()"",
            ""is_vararg = lambda leaf, within: False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH, token.VBAR, token.AMPE, token.CIRCUMFLEX, token.PERCENT])"",
            ""TYPED_NAMES = set()"",
            ""leaf.parent = type('MockParent', (object,), {'type': syms.argument})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockNode:"",
            ""    def __init__(self, type, parent=None, value='', prev_sibling=None):"",
            ""        self.type = type"",
            ""        self.parent = parent"",
            ""        self.value = value"",
            ""        self.prev_sibling = prev_sibling"",
            ""leaf = MockNode(type=token.NAME, parent=MockNode(type=token.NAME), value='', prev_sibling=None)"",
            ""ALWAYS_NO_SPACE = set()"",
            ""class MockSyms:"",
            ""    subscript = 1"",
            ""    subscriptlist = 2"",
            ""    sliceop = 3"",
            ""    arglist = 4"",
            ""    argument = 5"",
            ""    parameters = 6"",
            ""    varargslist = 7"",
            ""    typedargslist = 8"",
            ""    star_expr = 9"",
            ""    factor = 10"",
            ""    decorator = 11"",
            ""    trailer = 12"",
            ""    dotted_name = 13"",
            ""    classdef = 14"",
            ""    atom = 15"",
            ""    dictsetmaker = 16"",
            ""    import_from = 17"",
            ""    except_clause = 18"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(node): return None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(node, within=None): return False"",
            ""VARARGS_PARENTS = {syms.arglist, syms.parameters, syms.varargslist}"",
            ""UNPACKING_PARENTS = {syms.argument}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None, 'prefix': ''})()"",
            ""leaf.parent = type('MockParent', (object,), {'type': 'parent_type', 'parent': None})()"",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.EQUAL])"",
            ""syms = type('MockSyms', (object,), {'subscript': 'subscript', 'subscriptlist': 'subscriptlist', 'sliceop': 'sliceop', 'arglist': 'arglist', 'argument': 'argument', 'parameters': 'parameters', 'varargslist': 'varargslist', 'typedargslist': 'typedargslist', 'star_expr': 'star_expr', 'factor': 'factor', 'decorator': 'decorator', 'trailer': 'trailer', 'dotted_name': 'dotted_name', 'classdef': 'classdef', 'atom': 'atom', 'dictsetmaker': 'dictsetmaker', 'import_from': 'import_from', 'except_clause': 'except_clause'})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {syms.arglist, syms.parameters, syms.varargslist}"",
            ""UNPACKING_PARENTS = {syms.argument}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type, parent=None, value='', prev_sibling=None):"",
            ""        self.type = type"",
            ""        self.parent = parent"",
            ""        self.value = value"",
            ""        self.prev_sibling = prev_sibling"",
            """",
            ""leaf = MockLeaf(type=token.NAME)"",
            """",
            ""leaf_parent = type('MockParent', (object,), {'type': 'mock_type'})()"",
            ""leaf.parent = leaf_parent"",
            """",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON}"",
            ""syms = type('MockSyms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'star_expr': 9,"",
            ""    'factor': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'except_clause': 18"",
            ""})"",
            ""def preceding_leaf(node): return None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = {token.STAR}"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = {syms.arglist, syms.parameters, syms.varargslist}"",
            ""UNPACKING_PARENTS = {syms.argument}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type, parent, value, prev_sibling):"",
            ""        self.type = type"",
            ""        self.parent = parent"",
            ""        self.value = value"",
            ""        self.prev_sibling = prev_sibling"",
            """",
            ""leaf = MockLeaf(token.NAME, None, '', None)"",
            ""leaf.parent = MockLeaf(token.NAME, None, '', None)"",
            """",
            ""ALWAYS_NO_SPACE = set()"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, 'dotted_name': 13, 'classdef': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18})"",
            ""preceding_leaf = lambda leaf: None"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB])"",
            ""complex_subscript = False"",
            ""parent_type = lambda leaf: None"",
            ""VARARGS_SPECIALS = set([token.STAR])"",
            ""is_vararg = lambda leaf, within: False"",
            ""VARARGS_PARENTS = set([syms.arguments, syms.parameters])"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH])"",
            ""TYPED_NAMES = set([token.NAME])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type, parent, value, prev_sibling=None, prefix=''):"",
            ""        self.type = type"",
            ""        self.parent = parent"",
            ""        self.value = value"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = prefix"",
            """",
            ""class MockSyms:"",
            ""    subscript = 'subscript'"",
            ""    subscriptlist = 'subscriptlist'"",
            ""    sliceop = 'sliceop'"",
            ""    arglist = 'arglist'"",
            ""    argument = 'argument'"",
            ""    parameters = 'parameters'"",
            ""    varargslist = 'varargslist'"",
            ""    typedargslist = 'typedargslist'"",
            ""    star_expr = 'star_expr'"",
            ""    factor = 'factor'"",
            ""    decorator = 'decorator'"",
            ""    trailer = 'trailer'"",
            ""    dotted_name = 'dotted_name'"",
            ""    classdef = 'classdef'"",
            ""    atom = 'atom'"",
            ""    dictsetmaker = 'dictsetmaker'"",
            ""    import_from = 'import_from'"",
            ""    except_clause = 'except_clause'"",
            """",
            ""leaf = MockLeaf(type=token.NAME, parent=MockLeaf(type=token.COMMA, parent=None, value='test'), value='test')"",
            ""ALWAYS_NO_SPACE = {token.COMMA, token.COLON}"",
            ""syms = MockSyms()"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = {token.STAR}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {syms.parameters, syms.varargslist, syms.typedargslist}"",
            ""UNPACKING_PARENTS = {syms.argument}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type, parent, value, prev_sibling):"",
            ""        self.type = type"",
            ""        self.parent = parent"",
            ""        self.value = value"",
            ""        self.prev_sibling = prev_sibling"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type):"",
            ""        self.type = type"",
            """",
            ""leaf = MockLeaf(type=token.NAME, parent=MockParent(type='argument'), value='', prev_sibling=None)"",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.EQUAL])"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, 'dotted_name': 13, 'classdef': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB])"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR])"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist])"",
            ""UNPACKING_PARENTS = set([syms.argument])"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH])"",
            ""TYPED_NAMES = set([token.NAME])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import symtable as syms""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None})()"",
            ""ALWAYS_NO_SPACE = set()"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = set()"",
            ""is_vararg = lambda x, within=None: False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = set()"",
            ""TYPED_NAMES = set()"",
            ""leaf.parent = type('MockParent', (object,), {'type': syms.argument})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockParent:"",
            ""    def __init__(self):"",
            ""        self.type = None"",
            """",
            ""class MockLeaf:"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):"",
            ""        self.type = type"",
            ""        self.parent = parent"",
            ""        self.value = value"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''  # Added as per original snippet usage"",
            """",
            ""leaf_parent = MockParent()"",
            ""leaf_parent.type = 'argument'"",
            ""leaf = MockLeaf(token.NAME, leaf_parent, '')"",
            """",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.EQUAL])"",
            ""syms = type('MockSyms', (object,), {"",
            ""    'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4,"",
            ""    'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8,"",
            ""    'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, 'dotted_name': 13,"",
            ""    'classdef': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18"",
            ""})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR])"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist])"",
            ""UNPACKING_PARENTS = set([syms.argument])"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH])"",
            ""TYPED_NAMES = set([syms.typedargslist, syms.argument])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""from collections import namedtuple"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""LeafParent = namedtuple('LeafParent', ['type', 'parent'])"",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': LeafParent(type=1, parent=None), 'value': '', 'prev_sibling': None})()"",
            ""ALWAYS_NO_SPACE = {token.COMMA, token.COLON}"",
            ""syms = type('MockSyms', (object,), {'subscript': 'subscript', 'subscriptlist': 'subscriptlist', 'sliceop': 'sliceop', 'arglist': 'arglist', 'argument': 'argument', 'parameters': 'parameters', 'varargslist': 'varargslist', 'typedargslist': 'typedargslist', 'star_expr': 'star_expr', 'factor': 'factor', 'decorator': 'decorator', 'trailer': 'trailer', 'dotted_name': 'dotted_name', 'classdef': 'classdef', 'atom': 'atom', 'dictsetmaker': 'dictsetmaker', 'import_from': 'import_from', 'except_clause': 'except_clause'})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {syms.arglist, syms.parameters, syms.varargslist}"",
            ""UNPACKING_PARENTS = {syms.argument}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None, 'prefix': ''})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""preceding_leaf = lambda leaf: None # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB, token.LBRACE]) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda leaf: None # pragma: no cover"",
            ""VARARGS_SPECIALS = set() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""TYPED_NAMES = set() # pragma: no cover"",
            ""leaf.parent = type('MockParent', (object,), {'type': syms.argument})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, type, parent=None, value='', prev_sibling=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""leaf = MockNode(type=token.NAME, parent=MockNode(type=token.NAME), value='', prev_sibling=None) # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""class MockSyms: # pragma: no cover"",
            ""    subscript = 1 # pragma: no cover"",
            ""    subscriptlist = 2 # pragma: no cover"",
            ""    sliceop = 3 # pragma: no cover"",
            ""    arglist = 4 # pragma: no cover"",
            ""    argument = 5 # pragma: no cover"",
            ""    parameters = 6 # pragma: no cover"",
            ""    varargslist = 7 # pragma: no cover"",
            ""    typedargslist = 8 # pragma: no cover"",
            ""    star_expr = 9 # pragma: no cover"",
            ""    factor = 10 # pragma: no cover"",
            ""    decorator = 11 # pragma: no cover"",
            ""    trailer = 12 # pragma: no cover"",
            ""    dotted_name = 13 # pragma: no cover"",
            ""    classdef = 14 # pragma: no cover"",
            ""    atom = 15 # pragma: no cover"",
            ""    dictsetmaker = 16 # pragma: no cover"",
            ""    except_clause = 18 # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(node): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""def is_vararg(node, within=None): return False # pragma: no cover"",
            ""VARARGS_PARENTS = {syms.arglist, syms.parameters, syms.varargslist} # pragma: no cover"",
            ""UNPACKING_PARENTS = {syms.argument} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None, 'prefix': ''})() # pragma: no cover"",
            ""leaf.parent = type('MockParent', (object,), {'type': 'parent_type', 'parent': None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.EQUAL]) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {syms.arglist, syms.parameters, syms.varargslist} # pragma: no cover"",
            ""UNPACKING_PARENTS = {syms.argument} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type, parent=None, value='', prev_sibling=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = MockLeaf(type=token.NAME) # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf_parent = type('MockParent', (object,), {'type': 'mock_type'})() # pragma: no cover"",
            ""leaf.parent = leaf_parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON} # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'star_expr': 9, # pragma: no cover"",
            ""    'factor': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'except_clause': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""def preceding_leaf(node): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR} # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = {syms.arglist, syms.parameters, syms.varargslist} # pragma: no cover"",
            ""UNPACKING_PARENTS = {syms.argument} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = MockLeaf(token.NAME, None, '', None) # pragma: no cover"",
            ""leaf.parent = MockLeaf(token.NAME, None, '', None) # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""preceding_leaf = lambda leaf: None # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB]) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda leaf: None # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR]) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH]) # pragma: no cover"",
            ""TYPED_NAMES = set([token.NAME]) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None, prefix=''): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = prefix # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockSyms: # pragma: no cover"",
            ""    subscript = 'subscript' # pragma: no cover"",
            ""    subscriptlist = 'subscriptlist' # pragma: no cover"",
            ""    sliceop = 'sliceop' # pragma: no cover"",
            ""    arglist = 'arglist' # pragma: no cover"",
            ""    argument = 'argument' # pragma: no cover"",
            ""    parameters = 'parameters' # pragma: no cover"",
            ""    varargslist = 'varargslist' # pragma: no cover"",
            ""    typedargslist = 'typedargslist' # pragma: no cover"",
            ""    star_expr = 'star_expr' # pragma: no cover"",
            ""    factor = 'factor' # pragma: no cover"",
            ""    decorator = 'decorator' # pragma: no cover"",
            ""    trailer = 'trailer' # pragma: no cover"",
            ""    dotted_name = 'dotted_name' # pragma: no cover"",
            ""    classdef = 'classdef' # pragma: no cover"",
            ""    atom = 'atom' # pragma: no cover"",
            ""    dictsetmaker = 'dictsetmaker' # pragma: no cover"",
            ""    except_clause = 'except_clause' # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = MockLeaf(type=token.NAME, parent=MockLeaf(type=token.COMMA, parent=None, value='test'), value='test') # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMA, token.COLON} # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {syms.parameters, syms.varargslist, syms.typedargslist} # pragma: no cover"",
            ""UNPACKING_PARENTS = {syms.argument} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = MockLeaf(type=token.NAME, parent=MockParent(type='argument'), value='', prev_sibling=None) # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.EQUAL]) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB]) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR]) # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist]) # pragma: no cover"",
            ""UNPACKING_PARENTS = set([syms.argument]) # pragma: no cover"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH]) # pragma: no cover"",
            ""TYPED_NAMES = set([token.NAME]) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import symtable as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = set() # pragma: no cover"",
            ""is_vararg = lambda x, within=None: False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = set() # pragma: no cover"",
            ""TYPED_NAMES = set() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.type = None # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = ''  # Added as per original snippet usage # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf_parent = MockParent() # pragma: no cover"",
            ""leaf_parent.type = 'argument' # pragma: no cover"",
            ""leaf = MockLeaf(token.NAME, leaf_parent, '') # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.EQUAL]) # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, # pragma: no cover"",
            ""    'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, 'dotted_name': 13, # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR]) # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist]) # pragma: no cover"",
            ""UNPACKING_PARENTS = set([syms.argument]) # pragma: no cover"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH]) # pragma: no cover"",
            ""TYPED_NAMES = set([syms.typedargslist, syms.argument]) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""LeafParent = namedtuple('LeafParent', ['type', 'parent']) # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': LeafParent(type=1, parent=None), 'value': '', 'prev_sibling': None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMA, token.COLON} # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {syms.arglist, syms.parameters, syms.varargslist} # pragma: no cover"",
            ""UNPACKING_PARENTS = {syms.argument} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover""
        ]
    }
]",2,6915,0.0034575,4423,0.0066345,0.010092
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line :
  
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {token.NEWLINE, token.ENDMARKER}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {'parameters', 'varargslist'}"",
            ""UNPACKING_PARENTS = {'dictsetmaker', 'atom'}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {'argument', 'parameters'}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(node): return None"",
            ""def parent_type(node): return 'parent_type'"",
            ""def is_vararg(node, within): return False"",
            ""syms = type('MockSyms', (object,), {"",
            ""    'subscript': 'subscript',"",
            ""    'subscriptlist': 'subscriptlist',"",
            ""    'sliceop': 'sliceop',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument',"",
            ""    'parameters': 'parameters',"",
            ""    'varargslist': 'varargslist',"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'star_expr': 'star_expr',"",
            ""    'factor': 'factor',"",
            ""    'decorator': 'decorator',"",
            ""    'trailer': 'trailer',"",
            ""    'dotted_name': 'dotted_name',"",
            ""    'classdef': 'classdef',"",
            ""    'atom': 'atom',"",
            ""    'dictsetmaker': 'dictsetmaker',"",
            ""    'import_from': 'import_from',"",
            ""    'except_clause': 'except_clause'"",
            ""})"",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'type': token.NAME,"",
            ""    'parent': 'parent',"",
            ""    'value': '',"",
            ""    'prev_sibling': None"",
            ""})()"",
            ""parent = type('MockParent', (object,), {"",
            ""    'type': syms.argument"",
            ""})()"",
            ""leaf.parent = parent""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockSyms:"",
            ""    subscript = 100"",
            ""    subscriptlist = 101"",
            ""    sliceop = 102"",
            ""    arglist = 103"",
            ""    argument = 104"",
            ""    parameters = 105"",
            ""    varargslist = 106"",
            ""    typedargslist = 107"",
            ""    star_expr = 108"",
            ""    factor = 109"",
            ""    decorator = 110"",
            ""    trailer = 111"",
            ""    dotted_name = 112"",
            ""    classdef = 113"",
            ""    atom = 114"",
            ""    dictsetmaker = 115"",
            ""    import_from = 116"",
            ""    except_clause = 117"",
            ""syms = MockSyms()"",
            """",
            ""class MockLeaf:"",
            ""    def __init__(self, type, parent, value, prev_sibling):"",
            ""        self.type = type"",
            ""        self.parent = parent"",
            ""        self.value = value"",
            ""        self.prev_sibling = prev_sibling"",
            ""leaf = MockLeaf(token.NAME, None, '', None)"",
            ""ALWAYS_NO_SPACE = set([token.NEWLINE, token.ENDMARKER])"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB, token.LBRACE])"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: syms.factor"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR])"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = set([syms.parameters, syms.varargslist])"",
            ""UNPACKING_PARENTS = set([syms.dictsetmaker, syms.atom])"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH])"",
            ""TYPED_NAMES = set([syms.argument, syms.parameters])"",
            ""leaf.parent = MockLeaf(syms.argument, None, '', None)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockSyms:"",
            ""    subscript = 1"",
            ""    subscriptlist = 2"",
            ""    sliceop = 3"",
            ""    arglist = 4"",
            ""    argument = 5"",
            ""    parameters = 6"",
            ""    varargslist = 7"",
            ""    typedargslist = 8"",
            ""    star_expr = 9"",
            ""    factor = 10"",
            ""    decorator = 11"",
            ""    trailer = 12"",
            ""    dotted_name = 13"",
            ""    classdef = 14"",
            ""    atom = 15"",
            ""    dictsetmaker = 16"",
            ""    import_from = 17"",
            ""    except_clause = 18"",
            ""syms = MockSyms()"",
            """",
            ""class MockLeaf:"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):"",
            ""        self.type = type"",
            ""        self.parent = parent"",
            ""        self.value = value"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            ""leaf = MockLeaf(token.NAME, None, 'value')"",
            """",
            ""ALWAYS_NO_SPACE = set()"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {syms.parameters, syms.varargslist}"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.atom}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {syms.argument, syms.parameters}"",
            ""leaf.parent = MockLeaf(token.LPAR, None, 'parent', leaf)"",
            ""leaf.prev_sibling = MockLeaf(token.LPAR, leaf.parent, 'sibling')""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.STRING}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME, token.NUMBER, token.STRING}"",
            ""preceding_leaf = lambda x: None"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""is_vararg = lambda x, within: False"",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': type('MockParent', (object,), {'type': 5})(), 'value': '', 'prev_sibling': None})()"",
            ""class syms:"",
            ""    subscript = 1"",
            ""    subscriptlist = 2"",
            ""    sliceop = 3"",
            ""    arglist = 4"",
            ""    argument = 5"",
            ""    parameters = 6"",
            ""    varargslist = 7"",
            ""    typedargslist = 8"",
            ""    star_expr = 9"",
            ""    factor = 10"",
            ""    decorator = 11"",
            ""    trailer = 12"",
            ""    dotted_name = 13"",
            ""    classdef = 14"",
            ""    atom = 15"",
            ""    dictsetmaker = 16"",
            ""    import_from = 17"",
            ""    except_clause = 18"",
            ""VARARGS_PARENTS = {syms.parameters, syms.varargslist}"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.atom}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import types""
        ],
        ""initialization"": [
            ""# Create mock classes to simulate the leaf and its parent"",
            ""class MockLeaf:"",
            ""    def __init__(self, type, parent=None, value='', prev_sibling=None, prefix=''):"",
            ""        self.type = type"",
            ""        self.parent = parent"",
            ""        self.value = value"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = prefix"",
            """",
            ""class MockSyms:"",
            ""    subscript = 1"",
            ""    subscriptlist = 2"",
            ""    sliceop = 3"",
            ""    arglist = 4"",
            ""    argument = 5"",
            ""    parameters = 6"",
            ""    varargslist = 7"",
            ""    typedargslist = 8"",
            ""    star_expr = 9"",
            ""    factor = 10"",
            ""    decorator = 11"",
            ""    trailer = 12"",
            ""    dotted_name = 13"",
            ""    classdef = 14"",
            ""    atom = 15"",
            ""    dictsetmaker = 16"",
            ""    import_from = 17"",
            ""    except_clause = 18"",
            """",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {syms.arglist, syms.parameters, syms.varargslist}"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.argument}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {syms.argument, syms.parameters}"",
            ""preceding_leaf = lambda x: None"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""is_vararg = lambda x, within=None: False"",
            """",
            ""# Initialize the leaf and its parent to avoid the assertion error"",
            ""parent = MockLeaf(type=syms.argument)"",
            ""leaf = MockLeaf(type=token.NAME, parent=parent, value='', prev_sibling=None)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""leaf = SimpleNamespace(type=token.NAME, parent=SimpleNamespace(type='parent_type'), value='', prev_sibling=None)"",
            ""ALWAYS_NO_SPACE = set([token.COMMA, token.COLON])"",
            ""syms = SimpleNamespace(subscript=1, subscriptlist=2, sliceop=3, arglist=4, argument=5, parameters=6, varargslist=7, typedargslist=8, star_expr=9, factor=10, decorator=11, trailer=12, dotted_name=13, classdef=14, atom=15, dictsetmaker=16, import_from=17, except_clause=18)"",
            ""def preceding_leaf(node): return None"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB])"",
            ""complex_subscript = False"",
            ""def parent_type(node): return 'parent_type'"",
            ""VARARGS_SPECIALS = set([token.STAR])"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist])"",
            ""UNPACKING_PARENTS = set([syms.argument])"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH])"",
            ""TYPED_NAMES = set([syms.typedargslist, syms.argument])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None})()"",
            ""ALWAYS_NO_SPACE = {token.NEWLINE, token.ENDMARKER}"",
            ""syms = type('MockSyms', (object,), {'subscript': 100, 'subscriptlist': 101, 'sliceop': 102, 'arglist': 103, 'argument': 104, 'parameters': 105, 'varargslist': 106, 'typedargslist': 107, 'star_expr': 108, 'factor': 109, 'decorator': 110, 'trailer': 111, 'dotted_name': 112, 'classdef': 113, 'atom': 114, 'dictsetmaker': 115, 'import_from': 116, 'except_clause': 117})"",
            ""preceding_leaf = lambda x: None  # Simplified placeholder function"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""complex_subscript = False  # Example boolean value"",
            ""parent_type = lambda x: syms.factor  # Simplified placeholder function"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""is_vararg = lambda x, within: False  # Simplified placeholder function"",
            ""VARARGS_PARENTS = {syms.parameters, syms.varargslist}"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.atom}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {syms.argument, syms.parameters}"",
            ""leaf.parent = type('MockParent', (object,), {'type': syms.argument})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.EQUAL}"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {ast.arguments, ast.arg}"",
            ""UNPACKING_PARENTS = {ast.DictComp, ast.SetComp, ast.ListComp}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {ast.Name, ast.arg}"",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None, 'prefix': ''})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""syms = type('MockSyms', (object,), {'subscript': 100, 'subscriptlist': 101, 'sliceop': 102, 'arglist': 103, 'argument': 104, 'parameters': 105, 'varargslist': 106, 'typedargslist': 107, 'star_expr': 108, 'factor': 109, 'decorator': 110, 'trailer': 111, 'dotted_name': 112, 'classdef': 113, 'atom': 114, 'dictsetmaker': 115, 'import_from': 116, 'except_clause': 117})"",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None, 'prefix': ''})()"",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.NEWLINE])"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB, token.LBRACE])"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR])"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = set([syms.parameters, syms.varargslist])"",
            ""UNPACKING_PARENTS = set([syms.dictsetmaker, syms.argument])"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH])"",
            ""TYPED_NAMES = set([syms.argument, syms.parameters])"",
            ""leaf.parent = type('MockParent', (object,), {'type': syms.argument})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None})()"",
            ""ALWAYS_NO_SPACE = set()"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, 'dotted_name': 13, 'classdef': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = set()"",
            ""is_vararg = lambda x, within=None: False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = set()"",
            ""TYPED_NAMES = set()"",
            ""leaf.prev_sibling = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': ''})()"",
            ""leaf.parent = type('MockParent', (object,), {'type': syms.argument})()""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {token.NEWLINE, token.ENDMARKER} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = {'parameters', 'varargslist'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'dictsetmaker', 'atom'} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {'argument', 'parameters'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(node): return None # pragma: no cover"",
            ""def parent_type(node): return 'parent_type' # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'subscript': 'subscript', # pragma: no cover"",
            ""    'subscriptlist': 'subscriptlist', # pragma: no cover"",
            ""    'sliceop': 'sliceop', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'argument': 'argument', # pragma: no cover"",
            ""    'parameters': 'parameters', # pragma: no cover"",
            ""    'varargslist': 'varargslist', # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'star_expr': 'star_expr', # pragma: no cover"",
            ""    'factor': 'factor', # pragma: no cover"",
            ""    'decorator': 'decorator', # pragma: no cover"",
            ""    'trailer': 'trailer', # pragma: no cover"",
            ""    'dotted_name': 'dotted_name', # pragma: no cover"",
            ""    'classdef': 'classdef', # pragma: no cover"",
            ""    'atom': 'atom', # pragma: no cover"",
            ""    'dictsetmaker': 'dictsetmaker', # pragma: no cover"",
            ""    'except_clause': 'except_clause' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'type': token.NAME, # pragma: no cover"",
            ""    'parent': 'parent', # pragma: no cover"",
            ""    'value': '', # pragma: no cover"",
            ""    'prev_sibling': None # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""parent = type('MockParent', (object,), { # pragma: no cover"",
            ""    'type': syms.argument # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""leaf.parent = parent # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockSyms: # pragma: no cover"",
            ""    subscript = 100 # pragma: no cover"",
            ""    subscriptlist = 101 # pragma: no cover"",
            ""    sliceop = 102 # pragma: no cover"",
            ""    arglist = 103 # pragma: no cover"",
            ""    argument = 104 # pragma: no cover"",
            ""    parameters = 105 # pragma: no cover"",
            ""    varargslist = 106 # pragma: no cover"",
            ""    typedargslist = 107 # pragma: no cover"",
            ""    star_expr = 108 # pragma: no cover"",
            ""    factor = 109 # pragma: no cover"",
            ""    decorator = 110 # pragma: no cover"",
            ""    trailer = 111 # pragma: no cover"",
            ""    dotted_name = 112 # pragma: no cover"",
            ""    classdef = 113 # pragma: no cover"",
            ""    atom = 114 # pragma: no cover"",
            ""    dictsetmaker = 115 # pragma: no cover"",
            ""    except_clause = 117 # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""leaf = MockLeaf(token.NAME, None, '', None) # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set([token.NEWLINE, token.ENDMARKER]) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB, token.LBRACE]) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: syms.factor # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR]) # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = set([syms.parameters, syms.varargslist]) # pragma: no cover"",
            ""UNPACKING_PARENTS = set([syms.dictsetmaker, syms.atom]) # pragma: no cover"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH]) # pragma: no cover"",
            ""TYPED_NAMES = set([syms.argument, syms.parameters]) # pragma: no cover"",
            ""leaf.parent = MockLeaf(syms.argument, None, '', None) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockSyms: # pragma: no cover"",
            ""    subscript = 1 # pragma: no cover"",
            ""    subscriptlist = 2 # pragma: no cover"",
            ""    sliceop = 3 # pragma: no cover"",
            ""    arglist = 4 # pragma: no cover"",
            ""    argument = 5 # pragma: no cover"",
            ""    parameters = 6 # pragma: no cover"",
            ""    varargslist = 7 # pragma: no cover"",
            ""    typedargslist = 8 # pragma: no cover"",
            ""    star_expr = 9 # pragma: no cover"",
            ""    factor = 10 # pragma: no cover"",
            ""    decorator = 11 # pragma: no cover"",
            ""    trailer = 12 # pragma: no cover"",
            ""    dotted_name = 13 # pragma: no cover"",
            ""    classdef = 14 # pragma: no cover"",
            ""    atom = 15 # pragma: no cover"",
            ""    dictsetmaker = 16 # pragma: no cover"",
            ""    except_clause = 18 # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            ""leaf = MockLeaf(token.NAME, None, 'value') # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {syms.parameters, syms.varargslist} # pragma: no cover"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.atom} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {syms.argument, syms.parameters} # pragma: no cover"",
            ""leaf.parent = MockLeaf(token.LPAR, None, 'parent', leaf) # pragma: no cover"",
            ""leaf.prev_sibling = MockLeaf(token.LPAR, leaf.parent, 'sibling') # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.STRING} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME, token.NUMBER, token.STRING} # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': type('MockParent', (object,), {'type': 5})(), 'value': '', 'prev_sibling': None})() # pragma: no cover"",
            ""class syms: # pragma: no cover"",
            ""    subscript = 1 # pragma: no cover"",
            ""    subscriptlist = 2 # pragma: no cover"",
            ""    sliceop = 3 # pragma: no cover"",
            ""    arglist = 4 # pragma: no cover"",
            ""    argument = 5 # pragma: no cover"",
            ""    parameters = 6 # pragma: no cover"",
            ""    varargslist = 7 # pragma: no cover"",
            ""    typedargslist = 8 # pragma: no cover"",
            ""    star_expr = 9 # pragma: no cover"",
            ""    factor = 10 # pragma: no cover"",
            ""    decorator = 11 # pragma: no cover"",
            ""    trailer = 12 # pragma: no cover"",
            ""    dotted_name = 13 # pragma: no cover"",
            ""    classdef = 14 # pragma: no cover"",
            ""    atom = 15 # pragma: no cover"",
            ""    dictsetmaker = 16 # pragma: no cover"",
            ""    except_clause = 18 # pragma: no cover"",
            ""VARARGS_PARENTS = {syms.parameters, syms.varargslist} # pragma: no cover"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.atom} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import types # pragma: no cover""
        ],
        ""initialization"": [
            ""# Create mock classes to simulate the leaf and its parent # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type, parent=None, value='', prev_sibling=None, prefix=''): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = prefix # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockSyms: # pragma: no cover"",
            ""    subscript = 1 # pragma: no cover"",
            ""    subscriptlist = 2 # pragma: no cover"",
            ""    sliceop = 3 # pragma: no cover"",
            ""    arglist = 4 # pragma: no cover"",
            ""    argument = 5 # pragma: no cover"",
            ""    parameters = 6 # pragma: no cover"",
            ""    varargslist = 7 # pragma: no cover"",
            ""    typedargslist = 8 # pragma: no cover"",
            ""    star_expr = 9 # pragma: no cover"",
            ""    factor = 10 # pragma: no cover"",
            ""    decorator = 11 # pragma: no cover"",
            ""    trailer = 12 # pragma: no cover"",
            ""    dotted_name = 13 # pragma: no cover"",
            ""    classdef = 14 # pragma: no cover"",
            ""    atom = 15 # pragma: no cover"",
            ""    dictsetmaker = 16 # pragma: no cover"",
            ""    except_clause = 18 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = {syms.arglist, syms.parameters, syms.varargslist} # pragma: no cover"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.argument} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {syms.argument, syms.parameters} # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""is_vararg = lambda x, within=None: False # pragma: no cover"",
            "" # pragma: no cover"",
            ""# Initialize the leaf and its parent to avoid the assertion error # pragma: no cover"",
            ""parent = MockLeaf(type=syms.argument) # pragma: no cover"",
            ""leaf = MockLeaf(type=token.NAME, parent=parent, value='', prev_sibling=None) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = SimpleNamespace(type=token.NAME, parent=SimpleNamespace(type='parent_type'), value='', prev_sibling=None) # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set([token.COMMA, token.COLON]) # pragma: no cover"",
            ""def preceding_leaf(node): return None # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB]) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return 'parent_type' # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR]) # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist]) # pragma: no cover"",
            ""UNPACKING_PARENTS = set([syms.argument]) # pragma: no cover"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH]) # pragma: no cover"",
            ""TYPED_NAMES = set([syms.typedargslist, syms.argument]) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NEWLINE, token.ENDMARKER} # pragma: no cover"",
            ""preceding_leaf = lambda x: None  # Simplified placeholder function # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""complex_subscript = False  # Example boolean value # pragma: no cover"",
            ""parent_type = lambda x: syms.factor  # Simplified placeholder function # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False  # Simplified placeholder function # pragma: no cover"",
            ""VARARGS_PARENTS = {syms.parameters, syms.varargslist} # pragma: no cover"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.atom} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {syms.argument, syms.parameters} # pragma: no cover"",
            ""leaf.parent = type('MockParent', (object,), {'type': syms.argument})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.EQUAL} # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {ast.arguments, ast.arg} # pragma: no cover"",
            ""UNPACKING_PARENTS = {ast.DictComp, ast.SetComp, ast.ListComp} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {ast.Name, ast.arg} # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None, 'prefix': ''})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None, 'prefix': ''})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.NEWLINE]) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB, token.LBRACE]) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR]) # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = set([syms.parameters, syms.varargslist]) # pragma: no cover"",
            ""UNPACKING_PARENTS = set([syms.dictsetmaker, syms.argument]) # pragma: no cover"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH]) # pragma: no cover"",
            ""TYPED_NAMES = set([syms.argument, syms.parameters]) # pragma: no cover"",
            ""leaf.parent = type('MockParent', (object,), {'type': syms.argument})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = set() # pragma: no cover"",
            ""is_vararg = lambda x, within=None: False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = set() # pragma: no cover"",
            ""TYPED_NAMES = set() # pragma: no cover"",
            ""leaf.prev_sibling = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': ''})() # pragma: no cover"",
            ""leaf.parent = type('MockParent', (object,), {'type': syms.argument})() # pragma: no cover""
        ]
    }
]",2,7776,0.003888,4379,0.0065685,0.0104565
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 127:
    elif prev.type in OPENING_BRACKETS:
AttributeError: 'Mock' object has no attribute 'type'
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""from collections import namedtuple""
        ],
        ""initialization"": [
            ""Mock = type('Mock', (object,), {})"",
            ""leaf = namedtuple('Leaf', ['type', 'parent', 'value', 'prev_sibling'])"",
            ""leaf_instance = leaf(type=token.NAME, parent=Mock(), value='', prev_sibling=None)"",
            ""ALWAYS_NO_SPACE = set()"",
            ""syms = Mock()"",
            ""syms.subscript = 1"",
            ""syms.subscriptlist = 2"",
            ""syms.sliceop = 3"",
            ""syms.arglist = 4"",
            ""syms.argument = 5"",
            ""syms.parameters = 6"",
            ""syms.varargslist = 7"",
            ""syms.typedargslist = 8"",
            ""syms.star_expr = 9"",
            ""syms.factor = 10"",
            ""syms.decorator = 11"",
            ""syms.trailer = 12"",
            ""syms.dotted_name = 13"",
            ""syms.classdef = 14"",
            ""syms.atom = 15"",
            ""syms.dictsetmaker = 16"",
            ""syms.import_from = 17"",
            ""syms.except_clause = 18"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {syms.parameters, syms.varargslist}"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.atom}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {syms.argument, syms.parameters}"",
            ""leaf_instance.prev_sibling = namedtuple('Leaf', ['type', 'parent', 'value'])(type=token.NAME, parent=None, value='')"",
            ""leaf_instance.parent = namedtuple('Parent', ['type'])(type=syms.argument)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""MockLeaf = type('MockLeaf', (object,), {'type': None, 'parent': None, 'value': None, 'prev_sibling': None, 'prefix': ''})"",
            ""leaf = MockLeaf()"",
            ""leaf.type = token.NAME"",
            ""leaf.parent = MockLeaf()"",
            ""leaf.parent.type = token.COLON"",
            ""leaf.value = ''"",
            ""leaf.prev_sibling = MockLeaf()"",
            ""leaf.prev_sibling.type = token.LPAR"",
            ""ALWAYS_NO_SPACE = set()"",
            ""syms = type('syms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, 'dotted_name': 13, 'classdef': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {syms.parameters, syms.varargslist}"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.argument}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""from collections import namedtuple""
        ],
        ""initialization"": [
            ""MockLeaf = namedtuple('MockLeaf', ['type', 'parent', 'value', 'prev_sibling', 'prefix'])"",
            ""leaf = MockLeaf(type=token.NAME, parent=None, value='', prev_sibling=None, prefix='')"",
            ""ALWAYS_NO_SPACE = set()"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, 'dotted_name': 13, 'classdef': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""is_vararg = lambda x, within=None: False"",
            ""VARARGS_PARENTS = {syms.parameters, syms.varargslist}"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.atom}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {syms.argument, syms.parameters}"",
            ""leaf.parent = type('MockParent', (object,), {'type': syms.argument, 'parent': None})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None})()"",
            ""ALWAYS_NO_SPACE = set()"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, 'dotted_name': 13, 'classdef': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18})()"",
            ""preceding_leaf = lambda x: type('MockLeaf', (object,), {'type': token.LPAR, 'parent': None, 'value': '', 'prev_sibling': None})()"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: type('MockParentType', (object,), {'type': syms.factor})()"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {syms.parameters, syms.varargslist}"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.atom}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {syms.argument, syms.parameters}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""from collections import namedtuple""
        ],
        ""initialization"": [
            ""MockLeaf = namedtuple('MockLeaf', ['type', 'parent', 'value', 'prev_sibling', 'prefix'])"",
            ""leaf = MockLeaf(type=token.NAME, parent=None, value='', prev_sibling=None, prefix=' ')"",
            ""ALWAYS_NO_SPACE = set()"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, 'dotted_name': 13, 'classdef': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18})"",
            ""preceding_leaf = lambda leaf: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""complex_subscript = False"",
            ""parent_type = lambda leaf: None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""is_vararg = lambda leaf, within: False"",
            ""VARARGS_PARENTS = {syms.parameters, syms.varargslist}"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.atom}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {syms.argument, syms.parameters}"",
            ""token.COMMENT = 1"",
            ""token.COLON = 2"",
            ""token.COMMA = 3"",
            ""token.EQUAL = 4"",
            ""token.STAR = 5"",
            ""token.AT = 6"",
            ""token.LPAR = 7"",
            ""token.RPAR = 8"",
            ""token.DOT = 9"",
            ""token.LSQB = 10"",
            ""token.DOUBLESTAR = 11"",
            ""token.NAME = 12"",
            ""token.NUMBER = 13"",
            ""token.STRING = 14""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""from collections import namedtuple""
        ],
        ""initialization"": [
            ""Mock = type('Mock', (object,), {})"",
            ""leaf_parent = Mock()"",
            ""leaf = namedtuple('Leaf', ['type', 'parent', 'value', 'prev_sibling'])"",
            ""leaf = leaf(type=token.NAME, parent=leaf_parent, value='', prev_sibling=None)"",
            ""ALWAYS_NO_SPACE = set()"",
            ""syms = Mock()"",
            ""syms.subscript = 1"",
            ""syms.subscriptlist = 2"",
            ""syms.sliceop = 3"",
            ""syms.arglist = 4"",
            ""syms.argument = 5"",
            ""syms.parameters = 6"",
            ""syms.varargslist = 7"",
            ""syms.typedargslist = 8"",
            ""syms.star_expr = 9"",
            ""syms.factor = 10"",
            ""syms.decorator = 11"",
            ""syms.trailer = 12"",
            ""syms.dotted_name = 13"",
            ""syms.classdef = 14"",
            ""syms.atom = 15"",
            ""syms.dictsetmaker = 16"",
            ""syms.import_from = 17"",
            ""syms.except_clause = 18"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {syms.parameters, syms.varargslist}"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.atom}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {syms.argument, syms.parameters}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""from collections import namedtuple""
        ],
        ""initialization"": [
            ""Mock = namedtuple('Mock', 'type parent value prev_sibling prefix')"",
            ""leaf = Mock(type=token.NAME, parent=None, value='', prev_sibling=None, prefix='')"",
            ""ALWAYS_NO_SPACE = set()"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, 'dotted_name': 13, 'classdef': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18})()"",
            ""preceding_leaf = lambda x: None  # Simplified placeholder function"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""complex_subscript = False  # Example boolean value"",
            ""parent_type = lambda x: syms.factor  # Simplified placeholder function"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""is_vararg = lambda x, within: False  # Simplified placeholder function"",
            ""VARARGS_PARENTS = {syms.parameters, syms.varargslist}"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.atom}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {syms.argument, syms.parameters}"",
            ""leaf.prev_sibling = Mock(type=token.COMMA, parent=None, value='', prev_sibling=None, prefix='')"",
            ""leaf.parent = Mock(type=syms.argument, parent=None, value='', prev_sibling=None, prefix='')""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""from collections import namedtuple""
        ],
        ""initialization"": [
            ""MockToken = type('MockToken', (object,), {"",
            ""    'COMMENT': 1,"",
            ""    'COLON': 2,"",
            ""    'COMMA': 3,"",
            ""    'EQUAL': 4,"",
            ""    'STAR': 5,"",
            ""    'AT': 6,"",
            ""    'LPAR': 7,"",
            ""    'RPAR': 8,"",
            ""    'DOT': 9,"",
            ""    'LSQB': 10,"",
            ""    'DOUBLESTAR': 11,"",
            ""    'NAME': 12,"",
            ""    'NUMBER': 13,"",
            ""    'STRING': 14"",
            ""})"",
            ""token = MockToken()"",
            """",
            ""MockSyms = type('MockSyms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'star_expr': 9,"",
            ""    'factor': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'except_clause': 18"",
            ""})"",
            ""syms = MockSyms()"",
            """",
            ""Leaf = namedtuple('Leaf', ['type', 'parent', 'value', 'prev_sibling', 'prefix'])"",
            ""leaf = Leaf(type=token.NAME, parent=None, value='', prev_sibling=None, prefix='')"",
            """",
            ""Parent = namedtuple('Parent', ['type', 'parent'])"",
            ""leaf = leaf._replace(parent=Parent(type=syms.argument, parent=None))"",
            """",
            ""ALWAYS_NO_SPACE: Final = {token.COMMA, token.COLON}"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS: Final = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: 'parent_type'"",
            ""VARARGS_SPECIALS: Final = {token.STAR, token.DOUBLESTAR}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS: Final = {syms.parameters, syms.varargslist}"",
            ""UNPACKING_PARENTS: Final = {syms.argument}"",
            ""MATH_OPERATORS: Final = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES: Final = {syms.argument, syms.parameters}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""Mock = type('Mock', (object,), {})"",
            ""leaf = Mock()"",
            ""leaf.type = token.NAME"",
            ""leaf.parent = Mock()"",
            ""leaf.parent.type = None"",
            ""leaf.parent.parent = Mock()"",
            ""leaf.value = ''"",
            ""leaf.prev_sibling = Mock()"",
            ""leaf.prev_sibling.type = token.NAME"",
            ""leaf.prefix = ''"",
            ""ALWAYS_NO_SPACE = set()"",
            ""syms = Mock()"",
            ""syms.subscript = 1"",
            ""syms.subscriptlist = 2"",
            ""syms.sliceop = 3"",
            ""syms.arglist = 4"",
            ""syms.argument = 5"",
            ""syms.parameters = 6"",
            ""syms.varargslist = 7"",
            ""syms.typedargslist = 8"",
            ""syms.star_expr = 9"",
            ""syms.factor = 10"",
            ""syms.decorator = 11"",
            ""syms.trailer = 12"",
            ""syms.dotted_name = 13"",
            ""syms.classdef = 14"",
            ""syms.atom = 15"",
            ""syms.dictsetmaker = 16"",
            ""syms.import_from = 17"",
            ""syms.except_clause = 18"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {syms.arglist, syms.parameters}"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.atom}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""MockLeaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None, 'prefix': ''})"",
            ""leaf = MockLeaf()"",
            ""leaf.parent = type('MockParent', (object,), {'type': None, 'parent': None})()"",
            ""leaf.prev_sibling = MockLeaf()"",
            ""leaf.prev_sibling.type = token.LPAR"",
            ""ALWAYS_NO_SPACE = set()"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, 'dotted_name': 13, 'classdef': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {syms.parameters, syms.varargslist}"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.atom}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {syms.argument, syms.parameters}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover""
        ],
        ""initialization"": [
            ""Mock = type('Mock', (object,), {}) # pragma: no cover"",
            ""leaf = namedtuple('Leaf', ['type', 'parent', 'value', 'prev_sibling']) # pragma: no cover"",
            ""leaf_instance = leaf(type=token.NAME, parent=Mock(), value='', prev_sibling=None) # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""syms = Mock() # pragma: no cover"",
            ""syms.subscript = 1 # pragma: no cover"",
            ""syms.subscriptlist = 2 # pragma: no cover"",
            ""syms.sliceop = 3 # pragma: no cover"",
            ""syms.arglist = 4 # pragma: no cover"",
            ""syms.argument = 5 # pragma: no cover"",
            ""syms.parameters = 6 # pragma: no cover"",
            ""syms.varargslist = 7 # pragma: no cover"",
            ""syms.typedargslist = 8 # pragma: no cover"",
            ""syms.star_expr = 9 # pragma: no cover"",
            ""syms.factor = 10 # pragma: no cover"",
            ""syms.decorator = 11 # pragma: no cover"",
            ""syms.trailer = 12 # pragma: no cover"",
            ""syms.dotted_name = 13 # pragma: no cover"",
            ""syms.classdef = 14 # pragma: no cover"",
            ""syms.atom = 15 # pragma: no cover"",
            ""syms.dictsetmaker = 16 # pragma: no cover"",
            ""syms.except_clause = 18 # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {syms.parameters, syms.varargslist} # pragma: no cover"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.atom} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {syms.argument, syms.parameters} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""MockLeaf = type('MockLeaf', (object,), {'type': None, 'parent': None, 'value': None, 'prev_sibling': None, 'prefix': ''}) # pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = token.NAME # pragma: no cover"",
            ""leaf.parent = MockLeaf() # pragma: no cover"",
            ""leaf.parent.type = token.COLON # pragma: no cover"",
            ""leaf.value = '' # pragma: no cover"",
            ""leaf.prev_sibling = MockLeaf() # pragma: no cover"",
            ""leaf.prev_sibling.type = token.LPAR # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {syms.parameters, syms.varargslist} # pragma: no cover"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.argument} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover""
        ],
        ""initialization"": [
            ""MockLeaf = namedtuple('MockLeaf', ['type', 'parent', 'value', 'prev_sibling', 'prefix']) # pragma: no cover"",
            ""leaf = MockLeaf(type=token.NAME, parent=None, value='', prev_sibling=None, prefix='') # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""is_vararg = lambda x, within=None: False # pragma: no cover"",
            ""VARARGS_PARENTS = {syms.parameters, syms.varargslist} # pragma: no cover"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.atom} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {syms.argument, syms.parameters} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""preceding_leaf = lambda x: type('MockLeaf', (object,), {'type': token.LPAR, 'parent': None, 'value': '', 'prev_sibling': None})() # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: type('MockParentType', (object,), {'type': syms.factor})() # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {syms.parameters, syms.varargslist} # pragma: no cover"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.atom} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {syms.argument, syms.parameters} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover""
        ],
        ""initialization"": [
            ""MockLeaf = namedtuple('MockLeaf', ['type', 'parent', 'value', 'prev_sibling', 'prefix']) # pragma: no cover"",
            ""leaf = MockLeaf(type=token.NAME, parent=None, value='', prev_sibling=None, prefix=' ') # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""preceding_leaf = lambda leaf: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda leaf: None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {syms.parameters, syms.varargslist} # pragma: no cover"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.atom} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {syms.argument, syms.parameters} # pragma: no cover"",
            ""token.COMMENT = 1 # pragma: no cover"",
            ""token.COLON = 2 # pragma: no cover"",
            ""token.COMMA = 3 # pragma: no cover"",
            ""token.EQUAL = 4 # pragma: no cover"",
            ""token.STAR = 5 # pragma: no cover"",
            ""token.AT = 6 # pragma: no cover"",
            ""token.LPAR = 7 # pragma: no cover"",
            ""token.RPAR = 8 # pragma: no cover"",
            ""token.DOT = 9 # pragma: no cover"",
            ""token.LSQB = 10 # pragma: no cover"",
            ""token.DOUBLESTAR = 11 # pragma: no cover"",
            ""token.NAME = 12 # pragma: no cover"",
            ""token.NUMBER = 13 # pragma: no cover"",
            ""token.STRING = 14 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover""
        ],
        ""initialization"": [
            ""Mock = type('Mock', (object,), {}) # pragma: no cover"",
            ""leaf_parent = Mock() # pragma: no cover"",
            ""leaf = namedtuple('Leaf', ['type', 'parent', 'value', 'prev_sibling']) # pragma: no cover"",
            ""leaf = leaf(type=token.NAME, parent=leaf_parent, value='', prev_sibling=None) # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""syms = Mock() # pragma: no cover"",
            ""syms.subscript = 1 # pragma: no cover"",
            ""syms.subscriptlist = 2 # pragma: no cover"",
            ""syms.sliceop = 3 # pragma: no cover"",
            ""syms.arglist = 4 # pragma: no cover"",
            ""syms.argument = 5 # pragma: no cover"",
            ""syms.parameters = 6 # pragma: no cover"",
            ""syms.varargslist = 7 # pragma: no cover"",
            ""syms.typedargslist = 8 # pragma: no cover"",
            ""syms.star_expr = 9 # pragma: no cover"",
            ""syms.factor = 10 # pragma: no cover"",
            ""syms.decorator = 11 # pragma: no cover"",
            ""syms.trailer = 12 # pragma: no cover"",
            ""syms.dotted_name = 13 # pragma: no cover"",
            ""syms.classdef = 14 # pragma: no cover"",
            ""syms.atom = 15 # pragma: no cover"",
            ""syms.dictsetmaker = 16 # pragma: no cover"",
            ""syms.except_clause = 18 # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {syms.parameters, syms.varargslist} # pragma: no cover"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.atom} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {syms.argument, syms.parameters} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover""
        ],
        ""initialization"": [
            ""Mock = namedtuple('Mock', 'type parent value prev_sibling prefix') # pragma: no cover"",
            ""leaf = Mock(type=token.NAME, parent=None, value='', prev_sibling=None, prefix='') # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""preceding_leaf = lambda x: None  # Simplified placeholder function # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""complex_subscript = False  # Example boolean value # pragma: no cover"",
            ""parent_type = lambda x: syms.factor  # Simplified placeholder function # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False  # Simplified placeholder function # pragma: no cover"",
            ""VARARGS_PARENTS = {syms.parameters, syms.varargslist} # pragma: no cover"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.atom} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {syms.argument, syms.parameters} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover""
        ],
        ""initialization"": [
            ""MockToken = type('MockToken', (object,), { # pragma: no cover"",
            ""    'COMMENT': 1, # pragma: no cover"",
            ""    'COLON': 2, # pragma: no cover"",
            ""    'COMMA': 3, # pragma: no cover"",
            ""    'EQUAL': 4, # pragma: no cover"",
            ""    'STAR': 5, # pragma: no cover"",
            ""    'AT': 6, # pragma: no cover"",
            ""    'LPAR': 7, # pragma: no cover"",
            ""    'RPAR': 8, # pragma: no cover"",
            ""    'DOT': 9, # pragma: no cover"",
            ""    'LSQB': 10, # pragma: no cover"",
            ""    'DOUBLESTAR': 11, # pragma: no cover"",
            ""    'NAME': 12, # pragma: no cover"",
            ""    'NUMBER': 13, # pragma: no cover"",
            ""    'STRING': 14 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            "" # pragma: no cover"",
            ""MockSyms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'star_expr': 9, # pragma: no cover"",
            ""    'factor': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'except_clause': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            "" # pragma: no cover"",
            ""Leaf = namedtuple('Leaf', ['type', 'parent', 'value', 'prev_sibling', 'prefix']) # pragma: no cover"",
            ""leaf = Leaf(type=token.NAME, parent=None, value='', prev_sibling=None, prefix='') # pragma: no cover"",
            "" # pragma: no cover"",
            ""Parent = namedtuple('Parent', ['type', 'parent']) # pragma: no cover"",
            ""leaf = leaf._replace(parent=Parent(type=syms.argument, parent=None)) # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE: Final = {token.COMMA, token.COLON} # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: 'parent_type' # pragma: no cover"",
            ""VARARGS_SPECIALS: Final = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS: Final = {syms.parameters, syms.varargslist} # pragma: no cover"",
            ""UNPACKING_PARENTS: Final = {syms.argument} # pragma: no cover"",
            ""TYPED_NAMES: Final = {syms.argument, syms.parameters} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""Mock = type('Mock', (object,), {}) # pragma: no cover"",
            ""leaf = Mock() # pragma: no cover"",
            ""leaf.type = token.NAME # pragma: no cover"",
            ""leaf.parent = Mock() # pragma: no cover"",
            ""leaf.parent.type = None # pragma: no cover"",
            ""leaf.parent.parent = Mock() # pragma: no cover"",
            ""leaf.value = '' # pragma: no cover"",
            ""leaf.prev_sibling = Mock() # pragma: no cover"",
            ""leaf.prev_sibling.type = token.NAME # pragma: no cover"",
            ""leaf.prefix = '' # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""syms = Mock() # pragma: no cover"",
            ""syms.subscript = 1 # pragma: no cover"",
            ""syms.subscriptlist = 2 # pragma: no cover"",
            ""syms.sliceop = 3 # pragma: no cover"",
            ""syms.arglist = 4 # pragma: no cover"",
            ""syms.argument = 5 # pragma: no cover"",
            ""syms.parameters = 6 # pragma: no cover"",
            ""syms.varargslist = 7 # pragma: no cover"",
            ""syms.typedargslist = 8 # pragma: no cover"",
            ""syms.star_expr = 9 # pragma: no cover"",
            ""syms.factor = 10 # pragma: no cover"",
            ""syms.decorator = 11 # pragma: no cover"",
            ""syms.trailer = 12 # pragma: no cover"",
            ""syms.dotted_name = 13 # pragma: no cover"",
            ""syms.classdef = 14 # pragma: no cover"",
            ""syms.atom = 15 # pragma: no cover"",
            ""syms.dictsetmaker = 16 # pragma: no cover"",
            ""syms.except_clause = 18 # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {syms.arglist, syms.parameters} # pragma: no cover"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.atom} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""MockLeaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None, 'prefix': ''}) # pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.parent = type('MockParent', (object,), {'type': None, 'parent': None})() # pragma: no cover"",
            ""leaf.prev_sibling = MockLeaf() # pragma: no cover"",
            ""leaf.prev_sibling.type = token.LPAR # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {syms.parameters, syms.varargslist} # pragma: no cover"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.atom} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {syms.argument, syms.parameters} # pragma: no cover""
        ]
    }
]",2,8492,0.004246,4971,0.0074565,0.0117025
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 36:
    assert p is not None, f""INTERNAL ERROR: hand-made leaf without parent: {leaf!r}""
AssertionError: INTERNAL ERROR: hand-made leaf without parent: <__main__.Mock object at 0x7f9aec758e80>
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):"",
            ""        self.type = type"",
            ""        self.parent = parent"",
            ""        self.value = value"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockSyms:"",
            ""    subscript = 1"",
            ""    subscriptlist = 2"",
            ""    sliceop = 3"",
            ""    arglist = 4"",
            ""    argument = 5"",
            ""    parameters = 6"",
            ""    varargslist = 7"",
            ""    typedargslist = 8"",
            ""    star_expr = 9"",
            ""    factor = 10"",
            ""    decorator = 11"",
            ""    trailer = 12"",
            ""    dotted_name = 13"",
            ""    classdef = 14"",
            ""    atom = 15"",
            ""    dictsetmaker = 16"",
            ""    import_from = 17"",
            ""    except_clause = 18"",
            """",
            ""def preceding_leaf(leaf):"",
            ""    return None"",
            """",
            ""def parent_type(leaf):"",
            ""    return None"",
            """",
            ""def is_vararg(leaf, within=None):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.STRING, token.NUMBER}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {MockSyms.parameters, MockSyms.varargslist}"",
            ""UNPACKING_PARENTS = {MockSyms.dictsetmaker, MockSyms.atom}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = MockSyms()"",
            """",
            ""leaf = MockLeaf(token.NAME, MockLeaf(token.COLON, None, ''), '')""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""leaf = SimpleNamespace(type=token.NAME, parent=SimpleNamespace(type=None), value='', prev_sibling=None)"",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.EQUAL])"",
            ""syms = SimpleNamespace(subscript=1, subscriptlist=2, sliceop=3, arglist=4, argument=5, parameters=6, varargslist=7, typedargslist=8, star_expr=9, factor=10, decorator=11, trailer=12, dotted_name=13, classdef=14, atom=15, dictsetmaker=16, import_from=17, except_clause=18)"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB])"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR])"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = set([syms.parameters, syms.varargslist])"",
            ""UNPACKING_PARENTS = set([syms.atom])"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH])"",
            ""TYPED_NAMES = set([token.NAME])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import types""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {token.STRING, token.NUMBER}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {types.FunctionType}"",
            ""UNPACKING_PARENTS = {types.GeneratorType}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'factor': 9, 'decorator': 10, 'trailer': 11, 'dotted_name': 12, 'classdef': 13, 'atom': 14, 'dictsetmaker': 15, 'import_from': 16, 'except_clause': 17})"",
            ""MockLeaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None})"",
            ""leaf = MockLeaf()"",
            ""Parent = type('Parent', (object,), {'type': syms.argument})"",
            ""leaf.parent = Parent()"",
            ""def preceding_leaf(leaf): return None"",
            ""def parent_type(leaf): return None"",
            ""def is_vararg(leaf, within=None): return False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import types""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {token.STRING, token.NUMBER}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {types.FunctionType}"",
            ""UNPACKING_PARENTS = {types.GeneratorType}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'factor': 9, 'decorator': 10, 'trailer': 11, 'dotted_name': 12, 'classdef': 13, 'atom': 14, 'dictsetmaker': 15, 'import_from': 16, 'except_clause': 17})()"",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None})()"",
            ""leaf.parent = type('MockParent', (object,), {'type': syms.argument})()"",
            ""preceding_leaf = lambda leaf: None"",
            ""parent_type = lambda leaf: None"",
            ""is_vararg = lambda leaf, within=None: False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""Mock = type('Mock', (object,), {})"",
            ""leaf = Mock()"",
            ""leaf.type = token.NAME"",
            ""leaf.parent = Mock()"",
            ""leaf.parent.type = None"",
            ""leaf.value = ''"",
            ""leaf.prev_sibling = None"",
            ""ALWAYS_NO_SPACE = {token.NEWLINE, token.ENDMARKER}"",
            ""syms = type('MockSyms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'star_expr': 9,"",
            ""    'factor': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'except_clause': 18"",
            ""})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {syms.parameters, syms.varargslist}"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.argument}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""leaf = SimpleNamespace(type=token.NAME, parent=SimpleNamespace(type=None), value='', prev_sibling=SimpleNamespace(type=None))"",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.COLON])"",
            ""syms = SimpleNamespace(subscript=1, subscriptlist=2, sliceop=3, arglist=4, argument=5, parameters=6, varargslist=7, typedargslist=8, star_expr=9, factor=10, decorator=11, trailer=12, dotted_name=13, classdef=14, atom=15, dictsetmaker=16, import_from=17, except_clause=18)"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB])"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR])"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist])"",
            ""UNPACKING_PARENTS = set([syms.argument])"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH])"",
            ""TYPED_NAMES = set([token.NAME])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import types""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {token.COMMENT}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {types.FunctionType}"",
            ""UNPACKING_PARENTS = {types.GeneratorType}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME, token.STRING}"",
            ""syms = type('Mock', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'factor': 9, 'decorator': 10, 'trailer': 11, 'dotted_name': 12, 'classdef': 13, 'atom': 14, 'dictsetmaker': 15, 'import_from': 16, 'except_clause': 17})"",
            ""leaf = type('Mock', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None, 'prefix': ''})()"",
            ""leaf.parent = type('Mock', (object,), {'type': syms.argument, 'parent': None})()"",
            ""def preceding_leaf(leaf): return None"",
            ""def parent_type(leaf): return syms.argument"",
            ""def is_vararg(leaf, within=None): return False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""from collections import namedtuple""
        ],
        ""initialization"": [
            ""MockLeaf = namedtuple('MockLeaf', ['type', 'parent', 'value', 'prev_sibling'])"",
            ""mock_parent = type('MockParent', (object,), {'type': None})()"",
            ""leaf = MockLeaf(type=token.NAME, parent=mock_parent, value='', prev_sibling=None)"",
            ""ALWAYS_NO_SPACE = set([token.STRING, token.NUMBER])"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, 'dotted_name': 13, 'classdef': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = {syms.argument, syms.parameters}"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.atom}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockNode:"",
            ""    def __init__(self, type=None, parent=None, value=None, prev_sibling=None):"",
            ""        self.type = type"",
            ""        self.parent = parent"",
            ""        self.value = value"",
            ""        self.prev_sibling = prev_sibling"",
            """",
            ""root = MockNode(type=token.NAME)"",
            ""leaf = MockNode(type=token.NAME, parent=root, value='', prev_sibling=None)"",
            ""root.type = syms.argument"",
            ""ALWAYS_NO_SPACE = set()"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'star_expr': 9, 'factor': 10, 'decorator': 11, 'trailer': 12, 'dotted_name': 13, 'classdef': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'except_clause': 18})"",
            ""preceding_leaf = lambda x: None"",
            ""OPENING_BRACKETS = set()"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = set()"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = set()"",
            ""TYPED_NAMES = set()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {token.STRING, token.NUMBER}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {'MOCK_PARENT'}"",
            ""UNPACKING_PARENTS = {'MOCK_PARENT'}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {'int', 'float', 'str', 'list', 'dict'}"",
            ""syms = SimpleNamespace(subscript=1, subscriptlist=2, sliceop=3, arglist=4, argument=5, parameters=6, varargslist=7, typedargslist=8, star_expr=9, factor=10, decorator=11, trailer=12, dotted_name=13, classdef=14, atom=15, dictsetmaker=16, import_from=17, except_clause=18)"",
            ""leaf = SimpleNamespace(type=token.NAME, parent=SimpleNamespace(type=syms.argument), value='', prev_sibling=None)"",
            ""def preceding_leaf(x): return None"",
            ""def parent_type(x): return None"",
            ""def is_vararg(x, within): return False""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockSyms: # pragma: no cover"",
            ""    subscript = 1 # pragma: no cover"",
            ""    subscriptlist = 2 # pragma: no cover"",
            ""    sliceop = 3 # pragma: no cover"",
            ""    arglist = 4 # pragma: no cover"",
            ""    argument = 5 # pragma: no cover"",
            ""    parameters = 6 # pragma: no cover"",
            ""    varargslist = 7 # pragma: no cover"",
            ""    typedargslist = 8 # pragma: no cover"",
            ""    star_expr = 9 # pragma: no cover"",
            ""    factor = 10 # pragma: no cover"",
            ""    decorator = 11 # pragma: no cover"",
            ""    trailer = 12 # pragma: no cover"",
            ""    dotted_name = 13 # pragma: no cover"",
            ""    classdef = 14 # pragma: no cover"",
            ""    atom = 15 # pragma: no cover"",
            ""    dictsetmaker = 16 # pragma: no cover"",
            ""    except_clause = 18 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(leaf): # pragma: no cover"",
            ""    return None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): # pragma: no cover"",
            ""    return None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within=None): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.STRING, token.NUMBER} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = {MockSyms.parameters, MockSyms.varargslist} # pragma: no cover"",
            ""UNPACKING_PARENTS = {MockSyms.dictsetmaker, MockSyms.atom} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = MockLeaf(token.NAME, MockLeaf(token.COLON, None, ''), '') # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = SimpleNamespace(type=token.NAME, parent=SimpleNamespace(type=None), value='', prev_sibling=None) # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.EQUAL]) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB]) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR]) # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = set([syms.parameters, syms.varargslist]) # pragma: no cover"",
            ""UNPACKING_PARENTS = set([syms.atom]) # pragma: no cover"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH]) # pragma: no cover"",
            ""TYPED_NAMES = set([token.NAME]) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import types # pragma: no cover""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {token.STRING, token.NUMBER} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = {types.FunctionType} # pragma: no cover"",
            ""UNPACKING_PARENTS = {types.GeneratorType} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""MockLeaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None}) # pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""Parent = type('Parent', (object,), {'type': syms.argument}) # pragma: no cover"",
            ""leaf.parent = Parent() # pragma: no cover"",
            ""def preceding_leaf(leaf): return None # pragma: no cover"",
            ""def parent_type(leaf): return None # pragma: no cover"",
            ""def is_vararg(leaf, within=None): return False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import types # pragma: no cover""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {token.STRING, token.NUMBER} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = {types.FunctionType} # pragma: no cover"",
            ""UNPACKING_PARENTS = {types.GeneratorType} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None})() # pragma: no cover"",
            ""leaf.parent = type('MockParent', (object,), {'type': syms.argument})() # pragma: no cover"",
            ""preceding_leaf = lambda leaf: None # pragma: no cover"",
            ""parent_type = lambda leaf: None # pragma: no cover"",
            ""is_vararg = lambda leaf, within=None: False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""Mock = type('Mock', (object,), {}) # pragma: no cover"",
            ""leaf = Mock() # pragma: no cover"",
            ""leaf.type = token.NAME # pragma: no cover"",
            ""leaf.parent = Mock() # pragma: no cover"",
            ""leaf.parent.type = None # pragma: no cover"",
            ""leaf.value = '' # pragma: no cover"",
            ""leaf.prev_sibling = None # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NEWLINE, token.ENDMARKER} # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'star_expr': 9, # pragma: no cover"",
            ""    'factor': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'except_clause': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {syms.parameters, syms.varargslist} # pragma: no cover"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.argument} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = SimpleNamespace(type=token.NAME, parent=SimpleNamespace(type=None), value='', prev_sibling=SimpleNamespace(type=None)) # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set([token.COMMENT, token.COLON]) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB]) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR]) # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = set([syms.arglist, syms.parameters, syms.varargslist]) # pragma: no cover"",
            ""UNPACKING_PARENTS = set([syms.argument]) # pragma: no cover"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS, token.STAR, token.SLASH]) # pragma: no cover"",
            ""TYPED_NAMES = set([token.NAME]) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import types # pragma: no cover""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {token.COMMENT} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = {types.FunctionType} # pragma: no cover"",
            ""UNPACKING_PARENTS = {types.GeneratorType} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME, token.STRING} # pragma: no cover"",
            ""leaf = type('Mock', (object,), {'type': token.NAME, 'parent': None, 'value': '', 'prev_sibling': None, 'prefix': ''})() # pragma: no cover"",
            ""leaf.parent = type('Mock', (object,), {'type': syms.argument, 'parent': None})() # pragma: no cover"",
            ""def preceding_leaf(leaf): return None # pragma: no cover"",
            ""def parent_type(leaf): return syms.argument # pragma: no cover"",
            ""def is_vararg(leaf, within=None): return False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover""
        ],
        ""initialization"": [
            ""MockLeaf = namedtuple('MockLeaf', ['type', 'parent', 'value', 'prev_sibling']) # pragma: no cover"",
            ""mock_parent = type('MockParent', (object,), {'type': None})() # pragma: no cover"",
            ""leaf = MockLeaf(type=token.NAME, parent=mock_parent, value='', prev_sibling=None) # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set([token.STRING, token.NUMBER]) # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = {syms.argument, syms.parameters} # pragma: no cover"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker, syms.atom} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, type=None, parent=None, value=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            "" # pragma: no cover"",
            ""root = MockNode(type=token.NAME) # pragma: no cover"",
            ""leaf = MockNode(type=token.NAME, parent=root, value='', prev_sibling=None) # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""preceding_leaf = lambda x: None # pragma: no cover"",
            ""OPENING_BRACKETS = set() # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = set() # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = set() # pragma: no cover"",
            ""TYPED_NAMES = set() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {token.STRING, token.NUMBER} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = {'MOCK_PARENT'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'MOCK_PARENT'} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'float', 'str', 'list', 'dict'} # pragma: no cover"",
            ""leaf = SimpleNamespace(type=token.NAME, parent=SimpleNamespace(type=syms.argument), value='', prev_sibling=None) # pragma: no cover"",
            ""def preceding_leaf(x): return None # pragma: no cover"",
            ""def parent_type(x): return None # pragma: no cover"",
            ""def is_vararg(x, within): return False # pragma: no cover""
        ]
    }
]",2,9190,0.004595,4050,0.006075,0.0106699999999999
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return whitespace prefix if needed for the given `leaf`.
    `complex_subscript` signals whether the given leaf is part of a subscription
    which has non-trivial arguments, like arithmetic expressions or function calls.
    """"""
NO: Final = """"
SPACE: Final = "" ""
DOUBLESPACE: Final = ""  ""
t = leaf.type
p = leaf.parent
v = leaf.value
if t in ALWAYS_NO_SPACE:
    aux = NO
    exit(aux) # uncovered
if t == token.COMMENT:
    aux = DOUBLESPACE
    exit(aux) # uncovered
assert p is not None, f""INTERNAL ERROR: hand-made leaf without parent: {leaf!r}""
if t == token.COLON and p.type not in { # uncovered
    syms.subscript, # uncovered
    syms.subscriptlist, # uncovered
    syms.sliceop, # uncovered
}: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
prev = leaf.prev_sibling
if not prev:
    prevp = preceding_leaf(p)
    if not prevp or prevp.type in OPENING_BRACKETS:
        aux = NO
        exit(aux) # uncovered
    if t == token.COLON: # uncovered
        if prevp.type == token.COLON: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type != token.COMMA and not complex_subscript: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        aux = SPACE # uncovered
        exit(aux) # uncovered
    if prevp.type == token.EQUAL: # uncovered
        if prevp.parent: # uncovered
            if prevp.parent.type in { # uncovered
                syms.arglist, # uncovered
                syms.argument, # uncovered
                syms.parameters, # uncovered
                syms.varargslist, # uncovered
            }: # uncovered
                aux = NO # uncovered
                exit(aux) # uncovered
            elif prevp.parent.type == syms.typedargslist: # uncovered
                aux = prevp.prefix # uncovered
                # A bit hacky: if the equal sign has whitespace, it means we
                # previously found it's a typed argument.  So, we're using
                # that, too.
                exit(aux) # uncovered
    elif ( # uncovered
        prevp.type == token.STAR # uncovered
        and parent_type(prevp) == syms.star_expr # uncovered
        and parent_type(prevp.parent) == syms.subscriptlist # uncovered
    ): # uncovered
        aux = NO # uncovered
        # No space between typevar tuples.
        exit(aux) # uncovered
    elif prevp.type in VARARGS_SPECIALS: # uncovered
        if is_vararg(prevp, within=VARARGS_PARENTS | UNPACKING_PARENTS): # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prevp.type == token.COLON: # uncovered
        if prevp.parent and prevp.parent.type in {syms.subscript, syms.sliceop}: # uncovered
            aux = SPACE if complex_subscript else NO # uncovered
            exit(aux) # uncovered
    elif ( # uncovered
        prevp.parent # uncovered
        and prevp.parent.type == syms.factor # uncovered
        and prevp.type in MATH_OPERATORS # uncovered
    ): # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif prevp.type == token.AT and p.parent and p.parent.type == syms.decorator: # uncovered
        aux = NO # uncovered
        # no space in decorators
        exit(aux) # uncovered
elif prev.type in OPENING_BRACKETS:
    aux = NO
    exit(aux) # uncovered
if p.type in {syms.parameters, syms.arglist}: # uncovered
    # untyped function signatures or calls
    if not prev or prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.varargslist: # uncovered
    # lambdas
    if prev and prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.typedargslist: # uncovered
    # typed function signatures
    if not prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if t == token.EQUAL: # uncovered
        if prev.type not in TYPED_NAMES: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type == token.EQUAL: # uncovered
        aux = prev.prefix # uncovered
        # A bit hacky: if the equal sign has whitespace, it means we
        # previously found it's a typed argument.  So, we're using that, too.
        exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in TYPED_NAMES: # uncovered
    # type names
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type != token.COMMA: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.trailer: # uncovered
    # attributes and calls
    if t == token.LPAR or t == token.RPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        if t == token.DOT or t == token.LSQB: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.argument: # uncovered
    # single argument
    if t == token.EQUAL: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type == token.LPAR: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type in {token.EQUAL} | VARARGS_SPECIALS: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.decorator: # uncovered
    aux = NO # uncovered
    # decorators
    exit(aux) # uncovered
elif p.type == syms.dotted_name: # uncovered
    if prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    prevp = preceding_leaf(p) # uncovered
    if not prevp or prevp.type == token.AT or prevp.type == token.DOT: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.classdef: # uncovered
    if t == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if prev and prev.type == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.subscript, syms.sliceop}: # uncovered
    # indexing
    if not prev: # uncovered
        assert p.parent is not None, ""subscripts are always parented"" # uncovered
        if p.parent.type == syms.subscriptlist: # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif not complex_subscript: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.atom: # uncovered
    if prev and t == token.DOT: # uncovered
        aux = NO # uncovered
        # dots, but not the first one.
        exit(aux) # uncovered
elif p.type == syms.dictsetmaker: # uncovered
    # dict unpacking
    if prev and prev.type == token.DOUBLESTAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.factor, syms.star_expr}: # uncovered
    # unary ops
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type in OPENING_BRACKETS: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        prevp_parent = prevp.parent # uncovered
        assert prevp_parent is not None # uncovered
        if prevp.type == token.COLON and prevp_parent.type in { # uncovered
            syms.subscript, # uncovered
            syms.sliceop, # uncovered
        }: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t in {token.NAME, token.NUMBER, token.STRING}: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.import_from: # uncovered
    if t == token.DOT: # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t == token.NAME: # uncovered
        if v == ""import"": # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.sliceop: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
elif p.type == syms.except_clause: # uncovered
    if t == token.STAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
aux = SPACE # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import ast"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'factor': 9, 'star_expr': 10, 'decorator': 11, 'dotted_name': 12, 'classdef': 13, 'trailer': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'sliceop': 18, 'except_clause': 19})"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""VARARGS_PARENTS = {syms.parameters, syms.arglist}"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker}""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': token.COLON, 'parent': type('MockParent', (object,), {'type': syms.sliceop, 'parent': None}), 'value': '', 'prev_sibling': None})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import sys"",
            ""from ast import Node"",
            ""from collections import namedtuple""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = set([token.NAME, token.NUMBER, token.STRING])"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB, token.LBRACE])"",
            ""TYPED_NAMES = set([token.NAME, token.NUMBER])"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR])"",
            ""VARARGS_PARENTS = set([token.COLON, token.COMMA])"",
            ""UNPACKING_PARENTS = set([token.COLON, token.COMMA])"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS])"",
            ""syms = namedtuple('syms', 'subscript subscriptlist sliceop typedargslist varargslist parameters arglist argument factor star_expr decorator dotted_name classdef trailer atom import_from dictsetmaker except_clause')("",
            ""    subscript=1, subscriptlist=2, sliceop=3, typedargslist=4, varargslist=5, parameters=6, arglist=7, argument=8, factor=9, star_expr=10, decorator=11,"",
            ""    dotted_name=12, classdef=13, trailer=14, atom=15, import_from=16, dictsetmaker=17, except_clause=18)"",
            ""def preceding_leaf(node):"",
            ""    return None"",
            ""def parent_type(node):"",
            ""    return None"",
            ""def is_vararg(node, within):"",
            ""    return False"",
            ""MockLeaf = type('MockLeaf', (object,), {'type': token.COLON, 'parent': None, 'value': ':', 'prev_sibling': None})"",
            ""leaf = MockLeaf()"",
            ""leaf.parent = type('MockParent', (object,), {'type': syms.subscript, 'parent': None})()"",
            ""complex_subscript = False"",
            ""def exit(aux): pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import sys"",
            ""import collections""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type, value, parent=None, prev_sibling=None):"",
            ""        self.type = type"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.value = value"",
            ""class MockSyntaxTree:"",
            ""    def __init__(self, type, parent=None):"",
            ""        self.type = type"",
            ""        self.parent = parent"",
            ""def preceding_leaf(node):"",
            ""    return None"",
            ""def parent_type(node):"",
            ""    return None"",
            ""def is_vararg(node, within):"",
            ""    return False"",
            ""ALWAYS_NO_SPACE = {token.DOT}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {MockSyntaxTree, MockSyntaxTree}"",
            ""UNPACKING_PARENTS = {MockSyntaxTree, MockSyntaxTree}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS}"",
            ""TYPED_NAMES = {MockSyntaxTree, MockSyntaxTree}"",
            ""leaf = MockLeaf(token.COMMENT, '# comment')"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'star_expr': 9,"",
            ""    'factor': 10,"",
            ""    'trailer': 11,"",
            ""    'dotted_name': 12,"",
            ""    'classdef': 13,"",
            ""    'atom': 14,"",
            ""    'dictsetmaker': 15,"",
            ""    'import_from': 16,"",
            ""    'sliceop': 17,"",
            ""    'except_clause': 18"",
            ""})"",
            ""complex_subscript = False"",
            ""exit = sys.exit""
        ]
    },
    {
        ""imports"": [
            ""import token"",
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type, value, parent=None, prev_sibling=None):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type):"",
            ""        self.type = type"",
            """",
            ""leaf = MockLeaf(token.COMMENT, 'comment text', parent=MockParent('parent_type'))"",
            ""syms = type('syms', (object,), {'subscript': 'subscript'})"",
            ""ALWAYS_NO_SPACE = set()"",
            ""ALWAYS_NO_SPACE.add(token.NEWLINE)"",
            ""complex_subscript = False"",
            ""def preceding_leaf(node): return None"",
            ""def parent_type(node): return 'parent_type'"",
            ""OPENING_BRACKETS = set()"",
            ""VARARGS_SPECIALS = set()"",
            ""VARARGS_PARENTS = set(['parent_type'])"",
            ""UNPACKING_PARENTS = set(['parent_type'])"",
            ""MATH_OPERATORS = set(['+', '-', '*', '/'])"",
            ""TYPED_NAMES = set(['typed_name'])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""from unittest.mock import Mock"",
            ""import token""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = set()"",
            ""OPENING_BRACKETS = set()"",
            ""VARARGS_SPECIALS = set()"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = set()"",
            ""TYPED_NAMES = set()"",
            ""syms = Mock(arglist='arglist', argument='argument', parameters='parameters', varargslist='varargslist', typedargslist='typedargslist', subscript='subscript', subscriptlist='subscriptlist', sliceop='sliceop', factor='factor', decorator='decorator', dotted_name='dotted_name', classdef='classdef', atom='atom', dictsetmaker='dictsetmaker', star_expr='star_expr', import_from='import_from', except_clause='except_clause')"",
            ""leaf = Mock(type=token.COLON, parent=Mock(type='unknown'))"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(leaf): return leaf.type""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""from unittest.mock import Mock""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {token.COMMA, token.DOT}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {kwargs.get('VARARGS_PARENTS', [])}"",
            ""UNPACKING_PARENTS = {kwargs.get('UNPACKING_PARENTS', [])}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH, token.VBAR}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = Mock(subscript=1, subscriptlist=2, sliceop=3, arglist=4, argument=5, parameters=6, varargslist=7, typedargslist=8, decorator=9, trailer=10, dotted_name=11, classdef=12, atom=13, dictsetmaker=14, factor=15, star_expr=16, import_from=17, slice=18, except_clause=19)"",
            ""leaf = Mock(type=token.COLON, parent=Mock(type=syms.subscriptlist))"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(node): return getattr(node, 'type', None)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {token.INDENT, token.DEDENT, token.NEWLINE}"",
            ""OPENING_BRACKETS = {'[', '(', '{'}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""VARARGS_PARENTS = {None}"",
            ""UNPACKING_PARENTS = {None}"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '//', '%', '**'}"",
            ""syms = type('Mock', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'factor': 9, 'trailer': 10, 'dotted_name': 11, 'decorator': 12, 'classdef': 13, 'atom': 14, 'dictsetmaker': 15, 'star_expr': 16, 'import_from': 17, 'except_clause': 18})"",
            ""class LeafMock: def __init__(self, type, value, parent=None, prev_sibling=None): self.type = type; self.value = value; self.parent = parent; self.prev_sibling = prev_sibling; self.prefix = '';"",
            ""leaf = LeafMock(token.classdef, 'test', parent=LeafMock(syms.classdef, 'classdef'), prev_sibling=LeafMock(token.LPAR, '('))"",
            ""complex_subscript = False"",
            ""def preceding_leaf(leaf): return None"",
            ""def parent_type(node): return None"",
            ""def is_vararg(node, within): return False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""class MockLeaf:"",
            ""    def __init__(self, type_, parent=None, value=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            ""        self.value = value"",
            ""        self.prev_sibling = prev_sibling"",
            ""class MockParent:"",
            ""    def __init__(self, type_):"",
            ""        self.type = type_"",
            ""class MockSym:"",
            ""    subscript = 'subscript'"",
            ""    subscriptlist = 'subscriptlist'"",
            ""    sliceop = 'sliceop'""
        ],
        ""initialization"": [
            ""syms = MockSym()"",
            ""ALWAYS_NO_SPACE = {token.COMMA, token.COLON}"",
            ""leaf = MockLeaf(type_=token.COLON, parent=MockParent(type_=syms.subscript))"",
            ""complex_subscript= False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import sys"",
            ""type Mock""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type, value, parent=None, prev_sibling=None):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type, parent=None):"",
            ""        self.type = type"",
            ""        self.parent = parent"",
            """",
            ""syms = type('Mock', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            """",
            ""ALWAYS_NO_SPACE = [token.COLON]"",
            ""OPENING_BRACKETS = []"",
            ""VARARGS_SPECIALS = []"",
            ""TYPED_NAMES = []"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = set()"",
            """",
            ""leaf = MockLeaf(token.COLON, ':', prev_sibling=MockLeaf(token.COLON, ':'))"",
            ""parent = MockParent(syms.subscript)"",
            ""leaf.parent = parent"",
            ""complex_subscript = False"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':')"",
            """",
            ""def parent_type(node):"",
            ""    return syms.star_expr"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            ""class MockParent:"",
            ""    def __init__(self, type_):"",
            ""        self.type = type_"",
            ""complex_subscript = False"",
            ""leaf = MockLeaf(token.COLON, ':', MockParent('some_parent_type'), None)"",
            ""ALWAYS_NO_SPACE = set()"",
            ""OPENING_BRACKETS = set()"",
            ""TYPED_NAMES = set()"",
            ""VARARGS_SPECIALS = set()"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""syms = type('Mock', (object,), {"",
            ""    'subscript': 'subscript',"",
            ""    'subscriptlist': 'subscriptlist',"",
            ""    'sliceop': 'sliceop',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument',"",
            ""    'parameters': 'parameters',"",
            ""    'varargslist': 'varargslist',"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'factor': 'factor',"",
            ""    'decorator': 'decorator',"",
            ""    'trailer': 'trailer',"",
            ""    'dotted_name': 'dotted_name',"",
            ""    'classdef': 'classdef',"",
            ""    'atom': 'atom',"",
            ""    'dictsetmaker': 'dictsetmaker',"",
            ""    'star_expr': 'star_expr',"",
            ""    'import_from': 'import_from',"",
            ""    'except_clause': 'except_clause',"",
            ""})"",
            ""MATH_OPERATORS = set()"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'subscript': 1, 'subscriptlist': 2, 'sliceop': 3, 'arglist': 4, 'argument': 5, 'parameters': 6, 'varargslist': 7, 'typedargslist': 8, 'factor': 9, 'star_expr': 10, 'decorator': 11, 'dotted_name': 12, 'classdef': 13, 'trailer': 14, 'atom': 15, 'dictsetmaker': 16, 'import_from': 17, 'sliceop': 18, 'except_clause': 19}) # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""VARARGS_PARENTS = {syms.parameters, syms.arglist} # pragma: no cover"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker} # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': token.COLON, 'parent': type('MockParent', (object,), {'type': syms.sliceop, 'parent': None}), 'value': '', 'prev_sibling': None}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = set([token.NAME, token.NUMBER, token.STRING]) # pragma: no cover"",
            ""OPENING_BRACKETS = set([token.LPAR, token.LSQB, token.LBRACE]) # pragma: no cover"",
            ""TYPED_NAMES = set([token.NAME, token.NUMBER]) # pragma: no cover"",
            ""VARARGS_SPECIALS = set([token.STAR, token.DOUBLESTAR]) # pragma: no cover"",
            ""VARARGS_PARENTS = set([token.COLON, token.COMMA]) # pragma: no cover"",
            ""UNPACKING_PARENTS = set([token.COLON, token.COMMA]) # pragma: no cover"",
            ""MATH_OPERATORS = set([token.PLUS, token.MINUS]) # pragma: no cover"",
            ""    subscript=1, subscriptlist=2, sliceop=3, typedargslist=4, varargslist=5, parameters=6, arglist=7, argument=8, factor=9, star_expr=10, decorator=11, # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return None # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return None # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""MockLeaf = type('MockLeaf', (object,), {'type': token.COLON, 'parent': None, 'value': ':', 'prev_sibling': None}) # pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.parent = type('MockParent', (object,), {'type': syms.subscript, 'parent': None})() # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import collections # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""class MockSyntaxTree: # pragma: no cover"",
            ""    def __init__(self, type, parent=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return None # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return None # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.DOT} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = {MockSyntaxTree, MockSyntaxTree} # pragma: no cover"",
            ""UNPACKING_PARENTS = {MockSyntaxTree, MockSyntaxTree} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS} # pragma: no cover"",
            ""TYPED_NAMES = {MockSyntaxTree, MockSyntaxTree} # pragma: no cover"",
            ""leaf = MockLeaf(token.COMMENT, '# comment') # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'star_expr': 9, # pragma: no cover"",
            ""    'factor': 10, # pragma: no cover"",
            ""    'trailer': 11, # pragma: no cover"",
            ""    'dotted_name': 12, # pragma: no cover"",
            ""    'classdef': 13, # pragma: no cover"",
            ""    'atom': 14, # pragma: no cover"",
            ""    'dictsetmaker': 15, # pragma: no cover"",
            ""    'sliceop': 17, # pragma: no cover"",
            ""    'except_clause': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""exit = sys.exit # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import token # pragma: no cover"",
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = MockLeaf(token.COMMENT, 'comment text', parent=MockParent('parent_type')) # pragma: no cover"",
            ""syms = type('syms', (object,), {'subscript': 'subscript'}) # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""ALWAYS_NO_SPACE.add(token.NEWLINE) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(node): return None # pragma: no cover"",
            ""def parent_type(node): return 'parent_type' # pragma: no cover"",
            ""OPENING_BRACKETS = set() # pragma: no cover"",
            ""VARARGS_SPECIALS = set() # pragma: no cover"",
            ""VARARGS_PARENTS = set(['parent_type']) # pragma: no cover"",
            ""UNPACKING_PARENTS = set(['parent_type']) # pragma: no cover"",
            ""MATH_OPERATORS = set(['+', '-', '*', '/']) # pragma: no cover"",
            ""TYPED_NAMES = set(['typed_name']) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""OPENING_BRACKETS = set() # pragma: no cover"",
            ""VARARGS_SPECIALS = set() # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = set() # pragma: no cover"",
            ""TYPED_NAMES = set() # pragma: no cover"",
            ""leaf = Mock(type=token.COLON, parent=Mock(type='unknown')) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def parent_type(leaf): return leaf.type # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {token.COMMA, token.DOT} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH, token.VBAR} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""leaf = Mock(type=token.COLON, parent=Mock(type=syms.subscriptlist)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def parent_type(node): return getattr(node, 'type', None) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {token.INDENT, token.DEDENT, token.NEWLINE} # pragma: no cover"",
            ""OPENING_BRACKETS = {'[', '(', '{'} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""VARARGS_PARENTS = {None} # pragma: no cover"",
            ""UNPACKING_PARENTS = {None} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '//', '%', '**'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None, value=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""class MockSym: # pragma: no cover"",
            ""    subscript = 'subscript' # pragma: no cover"",
            ""    subscriptlist = 'subscriptlist' # pragma: no cover"",
            ""    sliceop = 'sliceop' # pragma: no cover""
        ],
        ""initialization"": [
            ""syms = MockSym() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMA, token.COLON} # pragma: no cover"",
            ""leaf = MockLeaf(type_=token.COLON, parent=MockParent(type_=syms.subscript)) # pragma: no cover"",
            ""complex_subscript= False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type, parent=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('Mock', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = [token.COLON] # pragma: no cover"",
            ""OPENING_BRACKETS = [] # pragma: no cover"",
            ""VARARGS_SPECIALS = [] # pragma: no cover"",
            ""TYPED_NAMES = [] # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = set() # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', prev_sibling=MockLeaf(token.COLON, ':')) # pragma: no cover"",
            ""parent = MockParent(syms.subscript) # pragma: no cover"",
            ""leaf.parent = parent # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return syms.star_expr # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', MockParent('some_parent_type'), None) # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""OPENING_BRACKETS = set() # pragma: no cover"",
            ""TYPED_NAMES = set() # pragma: no cover"",
            ""VARARGS_SPECIALS = set() # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""syms = type('Mock', (object,), { # pragma: no cover"",
            ""    'subscript': 'subscript', # pragma: no cover"",
            ""    'subscriptlist': 'subscriptlist', # pragma: no cover"",
            ""    'sliceop': 'sliceop', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'argument': 'argument', # pragma: no cover"",
            ""    'parameters': 'parameters', # pragma: no cover"",
            ""    'varargslist': 'varargslist', # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'factor': 'factor', # pragma: no cover"",
            ""    'decorator': 'decorator', # pragma: no cover"",
            ""    'trailer': 'trailer', # pragma: no cover"",
            ""    'dotted_name': 'dotted_name', # pragma: no cover"",
            ""    'classdef': 'classdef', # pragma: no cover"",
            ""    'atom': 'atom', # pragma: no cover"",
            ""    'dictsetmaker': 'dictsetmaker', # pragma: no cover"",
            ""    'star_expr': 'star_expr', # pragma: no cover"",
            ""    'except_clause': 'except_clause', # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""MATH_OPERATORS = set() # pragma: no cover""
        ]
    }
]",3,2479,0.0012395,3990,0.005985,0.0072245
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return whitespace prefix if needed for the given `leaf`.
    `complex_subscript` signals whether the given leaf is part of a subscription
    which has non-trivial arguments, like arithmetic expressions or function calls.
    """"""
NO: Final = """"
SPACE: Final = "" ""
DOUBLESPACE: Final = ""  ""
t = leaf.type
p = leaf.parent
v = leaf.value
if t in ALWAYS_NO_SPACE:
    aux = NO
    exit(aux) # uncovered
if t == token.COMMENT:
    aux = DOUBLESPACE
    exit(aux) # uncovered
assert p is not None, f""INTERNAL ERROR: hand-made leaf without parent: {leaf!r}""
if t == token.COLON and p.type not in { # uncovered
    syms.subscript, # uncovered
    syms.subscriptlist, # uncovered
    syms.sliceop, # uncovered
}:
    aux = NO
    exit(aux) # uncovered
prev = leaf.prev_sibling
if not prev:
    prevp = preceding_leaf(p)
    if not prevp or prevp.type in OPENING_BRACKETS:
        aux = NO
        exit(aux) # uncovered
    if t == token.COLON: # uncovered
        if prevp.type == token.COLON: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type != token.COMMA and not complex_subscript: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        aux = SPACE # uncovered
        exit(aux) # uncovered
    if prevp.type == token.EQUAL: # uncovered
        if prevp.parent: # uncovered
            if prevp.parent.type in { # uncovered
                syms.arglist, # uncovered
                syms.argument, # uncovered
                syms.parameters, # uncovered
                syms.varargslist, # uncovered
            }: # uncovered
                aux = NO # uncovered
                exit(aux) # uncovered
            elif prevp.parent.type == syms.typedargslist: # uncovered
                aux = prevp.prefix # uncovered
                # A bit hacky: if the equal sign has whitespace, it means we
                # previously found it's a typed argument.  So, we're using
                # that, too.
                exit(aux) # uncovered
    elif ( # uncovered
        prevp.type == token.STAR # uncovered
        and parent_type(prevp) == syms.star_expr # uncovered
        and parent_type(prevp.parent) == syms.subscriptlist # uncovered
    ): # uncovered
        aux = NO # uncovered
        # No space between typevar tuples.
        exit(aux) # uncovered
    elif prevp.type in VARARGS_SPECIALS: # uncovered
        if is_vararg(prevp, within=VARARGS_PARENTS | UNPACKING_PARENTS): # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prevp.type == token.COLON: # uncovered
        if prevp.parent and prevp.parent.type in {syms.subscript, syms.sliceop}: # uncovered
            aux = SPACE if complex_subscript else NO # uncovered
            exit(aux) # uncovered
    elif ( # uncovered
        prevp.parent # uncovered
        and prevp.parent.type == syms.factor # uncovered
        and prevp.type in MATH_OPERATORS # uncovered
    ): # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif prevp.type == token.AT and p.parent and p.parent.type == syms.decorator: # uncovered
        aux = NO # uncovered
        # no space in decorators
        exit(aux) # uncovered
elif prev.type in OPENING_BRACKETS:
    aux = NO
    exit(aux) # uncovered
if p.type in {syms.parameters, syms.arglist}: # uncovered
    # untyped function signatures or calls
    if not prev or prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.varargslist: # uncovered
    # lambdas
    if prev and prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.typedargslist: # uncovered
    # typed function signatures
    if not prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if t == token.EQUAL: # uncovered
        if prev.type not in TYPED_NAMES: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type == token.EQUAL: # uncovered
        aux = prev.prefix # uncovered
        # A bit hacky: if the equal sign has whitespace, it means we
        # previously found it's a typed argument.  So, we're using that, too.
        exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in TYPED_NAMES: # uncovered
    # type names
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type != token.COMMA: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.trailer: # uncovered
    # attributes and calls
    if t == token.LPAR or t == token.RPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        if t == token.DOT or t == token.LSQB: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.argument: # uncovered
    # single argument
    if t == token.EQUAL: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type == token.LPAR: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type in {token.EQUAL} | VARARGS_SPECIALS: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.decorator: # uncovered
    aux = NO # uncovered
    # decorators
    exit(aux) # uncovered
elif p.type == syms.dotted_name: # uncovered
    if prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    prevp = preceding_leaf(p) # uncovered
    if not prevp or prevp.type == token.AT or prevp.type == token.DOT: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.classdef: # uncovered
    if t == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if prev and prev.type == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.subscript, syms.sliceop}: # uncovered
    # indexing
    if not prev: # uncovered
        assert p.parent is not None, ""subscripts are always parented"" # uncovered
        if p.parent.type == syms.subscriptlist: # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif not complex_subscript: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.atom: # uncovered
    if prev and t == token.DOT: # uncovered
        aux = NO # uncovered
        # dots, but not the first one.
        exit(aux) # uncovered
elif p.type == syms.dictsetmaker: # uncovered
    # dict unpacking
    if prev and prev.type == token.DOUBLESTAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.factor, syms.star_expr}: # uncovered
    # unary ops
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type in OPENING_BRACKETS: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        prevp_parent = prevp.parent # uncovered
        assert prevp_parent is not None # uncovered
        if prevp.type == token.COLON and prevp_parent.type in { # uncovered
            syms.subscript, # uncovered
            syms.sliceop, # uncovered
        }: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t in {token.NAME, token.NUMBER, token.STRING}: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.import_from: # uncovered
    if t == token.DOT: # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t == token.NAME: # uncovered
        if v == ""import"": # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.sliceop: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
elif p.type == syms.except_clause: # uncovered
    if t == token.STAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
aux = SPACE # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':')"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {token.LPAR}"",
            ""UNPACKING_PARENTS = {token.LBRACE}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH, token.DOUBLESLASH, token.PERCENT}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 'subscript',"",
            ""    'subscriptlist': 'subscriptlist',"",
            ""    'sliceop': 'sliceop',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument',"",
            ""    'parameters': 'parameters',"",
            ""    'varargslist': 'varargslist',"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'factor': 'factor',"",
            ""    'decorator': 'decorator',"",
            ""    'trailer': 'trailer',"",
            ""    'dotted_name': 'dotted_name',"",
            ""    'classdef': 'classdef',"",
            ""    'atom': 'atom',"",
            ""    'dictsetmaker': 'dictsetmaker',"",
            ""    'import_from': 'import_from',"",
            ""    'star_expr': 'star_expr',"",
            ""    'except_clause': 'except_clause'"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.classdef), prev_sibling=MockLeaf(token.LPAR, '('))"",
            ""complex_subscript = False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = set()"",
            ""TYPED_NAMES = set()"",
            ""syms = type('Mock', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'decorator': 9,"",
            ""    'trailer': 10,"",
            ""    'dotted_name': 11,"",
            ""    'classdef': 12,"",
            ""    'atom': 13,"",
            ""    'dictsetmaker': 14,"",
            ""    'star_expr': 15,"",
            ""    'import_from': 16,"",
            ""    'except_clause': 17"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':')"",
            ""leaf.parent = MockParent(syms.subscriptlist)"",
            ""complex_subscript = False"",
            ""def preceding_leaf(node): return MockLeaf(token.COLON, ':')"",
            ""def parent_type(node): return node.parent.type if node.parent else None"",
            ""def is_vararg(node, within): return False"",
            ""def exit(aux): print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            ""class MockParent:"",
            ""    def __init__(self, type_):"",
            ""        self.type = type_"",
            ""complex_subscript = False"",
            ""leaf = MockLeaf(token.COLON, ':', MockParent('some_parent_type'), None)"",
            ""ALWAYS_NO_SPACE = set()"",
            ""OPENING_BRACKETS = set()"",
            ""TYPED_NAMES = set()"",
            ""VARARGS_SPECIALS = set()"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 'subscript',"",
            ""    'subscriptlist': 'subscriptlist',"",
            ""    'sliceop': 'sliceop',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument',"",
            ""    'parameters': 'parameters',"",
            ""    'varargslist': 'varargslist',"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'factor': 'factor',"",
            ""    'decorator': 'decorator',"",
            ""    'trailer': 'trailer',"",
            ""    'dotted_name': 'dotted_name',"",
            ""    'classdef': 'classdef',"",
            ""    'atom': 'atom',"",
            ""    'dictsetmaker': 'dictsetmaker',"",
            ""    'star_expr': 'star_expr',"",
            ""    'import_from': 'import_from',"",
            ""    'except_clause': 'except_clause',"",
            ""})"",
            ""MATH_OPERATORS = set()"",
            ""def preceding_leaf(node): return MockLeaf(token.COLON, ':')"",
            ""def parent_type(node): return node.type"",
            ""def is_vararg(node, within): return False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':', MockParent(syms.subscriptlist))"",
            """",
            ""def parent_type(node):"",
            ""    return node.type"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = set()"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            """",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscript))"",
            ""complex_subscript = False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""class MockLeaf:"",
            ""    def __init__(self, type_, parent=None, value=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            ""        self.value = value"",
            ""        self.prev_sibling = prev_sibling"",
            ""class MockParent:"",
            ""    def __init__(self, type_):"",
            ""        self.type = type_"",
            ""class MockSyms:"",
            ""    def __init__(self):"",
            ""        self.subscript = 1"",
            ""        self.subscriptlist = 2"",
            ""        self.sliceop = 3""
        ],
        ""initialization"": [
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = set()"",
            ""VARARGS_SPECIALS = set()"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = set()"",
            ""TYPED_NAMES = set()"",
            ""leaf = MockLeaf(token.COLON, parent=MockParent(syms.subscript))"",
            ""complex_subscript = False"",
            ""def preceding_leaf(node): return MockLeaf(token.COLON)"",
            ""def parent_type(node): return syms.subscript"",
            ""def is_vararg(node, within): return False"",
            ""def exit(aux): print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = set()"",
            ""TYPED_NAMES = set()"",
            ""VARARGS_SPECIALS = set()"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = set()"",
            ""syms = type('Mock', (object,), {"",
            ""    'subscript': 'subscript',"",
            ""    'subscriptlist': 'subscriptlist',"",
            ""    'sliceop': 'sliceop',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument',"",
            ""    'parameters': 'parameters',"",
            ""    'varargslist': 'varargslist',"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'factor': 'factor',"",
            ""    'decorator': 'decorator',"",
            ""    'trailer': 'trailer',"",
            ""    'dotted_name': 'dotted_name',"",
            ""    'classdef': 'classdef',"",
            ""    'atom': 'atom',"",
            ""    'dictsetmaker': 'dictsetmaker',"",
            ""    'star_expr': 'star_expr',"",
            ""    'import_from': 'import_from',"",
            ""    'except_clause': 'except_clause',"",
            ""})"",
            ""class LeafMock:"",
            ""    def __init__(self, type, parent=None, prev_sibling=None):"",
            ""        self.type = type"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.value = 'value'"",
            ""leaf = LeafMock(token.COLON, parent=LeafMock(syms.sliceop))"",
            ""complex_subscript = False"",
            ""def preceding_leaf(node): return LeafMock(token.COLON)"",
            ""def exit(aux): pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""from unittest.mock import Mock""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {syms.arglist, syms.parameters}"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'dotted_name': 12,"",
            ""    'classdef': 13,"",
            ""    'trailer': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19})"",
            ""leaf = Mock(type=token.COLON, parent=Mock(type=2), value=':')"",
            ""complex_subscript = False"",
            ""def preceding_leaf(node): return Mock(type=token.COLON, parent=Mock(type=1), value=':')"",
            ""def parent_type(node): return node.parent.type"",
            ""def is_vararg(node, within): return False"",
            ""prev = None"",
            ""prevp = Mock(type=token.COLON)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {1, 2}"",
            ""UNPACKING_PARENTS = {1, 2}"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '//', '%', '**'}"",
            ""syms = type('Mock', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'except_clause': 18"",
            ""})"",
            ""class MockLeaf:"",
            ""    def __init__(self, type, value, parent=None, prev_sibling=None):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            ""leaf = MockLeaf(token.COLON, ':', MockLeaf(syms.classdef, 'classdef'), MockLeaf(token.LPAR, '('))"",
            ""def preceding_leaf(leaf):"",
            ""    return MockLeaf(token.LPAR, '(')"",
            ""def parent_type(node):"",
            ""    return syms.star_expr"",
            ""def is_vararg(node, within):"",
            ""    return False"",
            ""complex_subscript = False"",
            ""exit = sys.exit""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            ""class MockParent:"",
            ""    def __init__(self, type_):"",
            ""        self.type = type_"",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':')"",
            ""def parent_type(node):"",
            ""    return node.type if node else None"",
            ""def is_vararg(node, within):"",
            ""    return False"",
            ""ALWAYS_NO_SPACE = {token.COMMA}"",
            ""OPENING_BRACKETS = {'[', '(', '{'}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {token.COLON, token.COMMA}"",
            ""UNPACKING_PARENTS = {token.COLON, token.COMMA}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'dotted_name': 12,"",
            ""    'classdef': 13,"",
            ""    'trailer': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent('invalid_type'))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_):"",
            ""        self.type = type_"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':')"",
            """",
            ""def parent_type(node):"",
            ""    return syms.star_expr if node == prevp else syms.subscriptlist"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = set()"",
            ""OPENING_BRACKETS = {'[', '(', '{'}"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""VARARGS_PARENTS = {'parameters', 'arglist'}"",
            ""UNPACKING_PARENTS = {'dictsetmaker'}"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 'subscript',"",
            ""    'subscriptlist': 'subscriptlist',"",
            ""    'sliceop': 'sliceop',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument',"",
            ""    'parameters': 'parameters',"",
            ""    'varargslist': 'varargslist',"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'factor': 'factor',"",
            ""    'star_expr': 'star_expr',"",
            ""    'decorator': 'decorator',"",
            ""    'trailer': 'trailer',"",
            ""    'dotted_name': 'dotted_name',"",
            ""    'classdef': 'classdef',"",
            ""    'atom': 'atom',"",
            ""    'dictsetmaker': 'dictsetmaker',"",
            ""    'import_from': 'import_from',"",
            ""    'except_clause': 'except_clause'"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', MockParent(syms.subscriptlist), None)"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    sys.exit(aux)""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = {token.LPAR} # pragma: no cover"",
            ""UNPACKING_PARENTS = {token.LBRACE} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH, token.DOUBLESLASH, token.PERCENT} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 'subscript', # pragma: no cover"",
            ""    'subscriptlist': 'subscriptlist', # pragma: no cover"",
            ""    'sliceop': 'sliceop', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'argument': 'argument', # pragma: no cover"",
            ""    'parameters': 'parameters', # pragma: no cover"",
            ""    'varargslist': 'varargslist', # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'factor': 'factor', # pragma: no cover"",
            ""    'decorator': 'decorator', # pragma: no cover"",
            ""    'trailer': 'trailer', # pragma: no cover"",
            ""    'dotted_name': 'dotted_name', # pragma: no cover"",
            ""    'classdef': 'classdef', # pragma: no cover"",
            ""    'atom': 'atom', # pragma: no cover"",
            ""    'dictsetmaker': 'dictsetmaker', # pragma: no cover"",
            ""    'star_expr': 'star_expr', # pragma: no cover"",
            ""    'except_clause': 'except_clause' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.classdef), prev_sibling=MockLeaf(token.LPAR, '(')) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = set() # pragma: no cover"",
            ""TYPED_NAMES = set() # pragma: no cover"",
            ""syms = type('Mock', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'decorator': 9, # pragma: no cover"",
            ""    'trailer': 10, # pragma: no cover"",
            ""    'dotted_name': 11, # pragma: no cover"",
            ""    'classdef': 12, # pragma: no cover"",
            ""    'atom': 13, # pragma: no cover"",
            ""    'dictsetmaker': 14, # pragma: no cover"",
            ""    'star_expr': 15, # pragma: no cover"",
            ""    'except_clause': 17 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':') # pragma: no cover"",
            ""leaf.parent = MockParent(syms.subscriptlist) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(node): return MockLeaf(token.COLON, ':') # pragma: no cover"",
            ""def parent_type(node): return node.parent.type if node.parent else None # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', MockParent('some_parent_type'), None) # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""OPENING_BRACKETS = set() # pragma: no cover"",
            ""TYPED_NAMES = set() # pragma: no cover"",
            ""VARARGS_SPECIALS = set() # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 'subscript', # pragma: no cover"",
            ""    'subscriptlist': 'subscriptlist', # pragma: no cover"",
            ""    'sliceop': 'sliceop', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'argument': 'argument', # pragma: no cover"",
            ""    'parameters': 'parameters', # pragma: no cover"",
            ""    'varargslist': 'varargslist', # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'factor': 'factor', # pragma: no cover"",
            ""    'decorator': 'decorator', # pragma: no cover"",
            ""    'trailer': 'trailer', # pragma: no cover"",
            ""    'dotted_name': 'dotted_name', # pragma: no cover"",
            ""    'classdef': 'classdef', # pragma: no cover"",
            ""    'atom': 'atom', # pragma: no cover"",
            ""    'dictsetmaker': 'dictsetmaker', # pragma: no cover"",
            ""    'star_expr': 'star_expr', # pragma: no cover"",
            ""    'except_clause': 'except_clause', # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""MATH_OPERATORS = set() # pragma: no cover"",
            ""def preceding_leaf(node): return MockLeaf(token.COLON, ':') # pragma: no cover"",
            ""def parent_type(node): return node.type # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':', MockParent(syms.subscriptlist)) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.type # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscript)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None, value=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""class MockSyms: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.subscript = 1 # pragma: no cover"",
            ""        self.subscriptlist = 2 # pragma: no cover"",
            ""        self.sliceop = 3 # pragma: no cover""
        ],
        ""initialization"": [
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = set() # pragma: no cover"",
            ""VARARGS_SPECIALS = set() # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = set() # pragma: no cover"",
            ""TYPED_NAMES = set() # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, parent=MockParent(syms.subscript)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(node): return MockLeaf(token.COLON) # pragma: no cover"",
            ""def parent_type(node): return syms.subscript # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = set() # pragma: no cover"",
            ""TYPED_NAMES = set() # pragma: no cover"",
            ""VARARGS_SPECIALS = set() # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = set() # pragma: no cover"",
            ""syms = type('Mock', (object,), { # pragma: no cover"",
            ""    'subscript': 'subscript', # pragma: no cover"",
            ""    'subscriptlist': 'subscriptlist', # pragma: no cover"",
            ""    'sliceop': 'sliceop', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'argument': 'argument', # pragma: no cover"",
            ""    'parameters': 'parameters', # pragma: no cover"",
            ""    'varargslist': 'varargslist', # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'factor': 'factor', # pragma: no cover"",
            ""    'decorator': 'decorator', # pragma: no cover"",
            ""    'trailer': 'trailer', # pragma: no cover"",
            ""    'dotted_name': 'dotted_name', # pragma: no cover"",
            ""    'classdef': 'classdef', # pragma: no cover"",
            ""    'atom': 'atom', # pragma: no cover"",
            ""    'dictsetmaker': 'dictsetmaker', # pragma: no cover"",
            ""    'star_expr': 'star_expr', # pragma: no cover"",
            ""    'except_clause': 'except_clause', # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""class LeafMock: # pragma: no cover"",
            ""    def __init__(self, type, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.value = 'value' # pragma: no cover"",
            ""leaf = LeafMock(token.COLON, parent=LeafMock(syms.sliceop)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(node): return LeafMock(token.COLON) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'dotted_name': 12, # pragma: no cover"",
            ""    'classdef': 13, # pragma: no cover"",
            ""    'trailer': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19}) # pragma: no cover"",
            ""leaf = Mock(type=token.COLON, parent=Mock(type=2), value=':') # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(node): return Mock(type=token.COLON, parent=Mock(type=1), value=':') # pragma: no cover"",
            ""def parent_type(node): return node.parent.type # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""prev = None # pragma: no cover"",
            ""prevp = Mock(type=token.COLON) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = {1, 2} # pragma: no cover"",
            ""UNPACKING_PARENTS = {1, 2} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/', '//', '%', '**'} # pragma: no cover"",
            ""syms = type('Mock', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'except_clause': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', MockLeaf(syms.classdef, 'classdef'), MockLeaf(token.LPAR, '(')) # pragma: no cover"",
            ""def preceding_leaf(leaf): # pragma: no cover"",
            ""    return MockLeaf(token.LPAR, '(') # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return syms.star_expr # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""exit = sys.exit # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':') # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.type if node else None # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMA} # pragma: no cover"",
            ""OPENING_BRACKETS = {'[', '(', '{'} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = {token.COLON, token.COMMA} # pragma: no cover"",
            ""UNPACKING_PARENTS = {token.COLON, token.COMMA} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'dotted_name': 12, # pragma: no cover"",
            ""    'classdef': 13, # pragma: no cover"",
            ""    'trailer': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent('invalid_type')) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return syms.star_expr if node == prevp else syms.subscriptlist # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""OPENING_BRACKETS = {'[', '(', '{'} # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""VARARGS_PARENTS = {'parameters', 'arglist'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'dictsetmaker'} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 'subscript', # pragma: no cover"",
            ""    'subscriptlist': 'subscriptlist', # pragma: no cover"",
            ""    'sliceop': 'sliceop', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'argument': 'argument', # pragma: no cover"",
            ""    'parameters': 'parameters', # pragma: no cover"",
            ""    'varargslist': 'varargslist', # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'factor': 'factor', # pragma: no cover"",
            ""    'star_expr': 'star_expr', # pragma: no cover"",
            ""    'decorator': 'decorator', # pragma: no cover"",
            ""    'trailer': 'trailer', # pragma: no cover"",
            ""    'dotted_name': 'dotted_name', # pragma: no cover"",
            ""    'classdef': 'classdef', # pragma: no cover"",
            ""    'atom': 'atom', # pragma: no cover"",
            ""    'dictsetmaker': 'dictsetmaker', # pragma: no cover"",
            ""    'except_clause': 'except_clause' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', MockParent(syms.subscriptlist), None) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    }
]",3,8921,0.0044605,5268,0.007902,0.0123624999999999
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return whitespace prefix if needed for the given `leaf`.
    `complex_subscript` signals whether the given leaf is part of a subscription
    which has non-trivial arguments, like arithmetic expressions or function calls.
    """"""
NO: Final = """"
SPACE: Final = "" ""
DOUBLESPACE: Final = ""  ""
t = leaf.type
p = leaf.parent
v = leaf.value
if t in ALWAYS_NO_SPACE:
    aux = NO
    exit(aux) # uncovered
if t == token.COMMENT:
    aux = DOUBLESPACE
    exit(aux) # uncovered
assert p is not None, f""INTERNAL ERROR: hand-made leaf without parent: {leaf!r}""
if t == token.COLON and p.type not in { # uncovered
    syms.subscript, # uncovered
    syms.subscriptlist, # uncovered
    syms.sliceop, # uncovered
}:
    aux = NO
    exit(aux) # uncovered
prev = leaf.prev_sibling
if not prev:
    prevp = preceding_leaf(p)
    if not prevp or prevp.type in OPENING_BRACKETS:
        aux = NO
        exit(aux) # uncovered
    if t == token.COLON:
        if prevp.type == token.COLON:
            aux = NO
            exit(aux) # uncovered
        elif prevp.type != token.COMMA and not complex_subscript: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        aux = SPACE # uncovered
        exit(aux) # uncovered
    if prevp.type == token.EQUAL: # uncovered
        if prevp.parent: # uncovered
            if prevp.parent.type in { # uncovered
                syms.arglist, # uncovered
                syms.argument, # uncovered
                syms.parameters, # uncovered
                syms.varargslist, # uncovered
            }: # uncovered
                aux = NO # uncovered
                exit(aux) # uncovered
            elif prevp.parent.type == syms.typedargslist: # uncovered
                aux = prevp.prefix # uncovered
                # A bit hacky: if the equal sign has whitespace, it means we
                # previously found it's a typed argument.  So, we're using
                # that, too.
                exit(aux) # uncovered
    elif ( # uncovered
        prevp.type == token.STAR # uncovered
        and parent_type(prevp) == syms.star_expr # uncovered
        and parent_type(prevp.parent) == syms.subscriptlist # uncovered
    ): # uncovered
        aux = NO # uncovered
        # No space between typevar tuples.
        exit(aux) # uncovered
    elif prevp.type in VARARGS_SPECIALS: # uncovered
        if is_vararg(prevp, within=VARARGS_PARENTS | UNPACKING_PARENTS): # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prevp.type == token.COLON: # uncovered
        if prevp.parent and prevp.parent.type in {syms.subscript, syms.sliceop}: # uncovered
            aux = SPACE if complex_subscript else NO # uncovered
            exit(aux) # uncovered
    elif ( # uncovered
        prevp.parent # uncovered
        and prevp.parent.type == syms.factor # uncovered
        and prevp.type in MATH_OPERATORS # uncovered
    ): # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif prevp.type == token.AT and p.parent and p.parent.type == syms.decorator: # uncovered
        aux = NO # uncovered
        # no space in decorators
        exit(aux) # uncovered
elif prev.type in OPENING_BRACKETS:
    aux = NO
    exit(aux) # uncovered
if p.type in {syms.parameters, syms.arglist}: # uncovered
    # untyped function signatures or calls
    if not prev or prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.varargslist: # uncovered
    # lambdas
    if prev and prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.typedargslist: # uncovered
    # typed function signatures
    if not prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if t == token.EQUAL: # uncovered
        if prev.type not in TYPED_NAMES: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type == token.EQUAL: # uncovered
        aux = prev.prefix # uncovered
        # A bit hacky: if the equal sign has whitespace, it means we
        # previously found it's a typed argument.  So, we're using that, too.
        exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in TYPED_NAMES: # uncovered
    # type names
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type != token.COMMA: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.trailer: # uncovered
    # attributes and calls
    if t == token.LPAR or t == token.RPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        if t == token.DOT or t == token.LSQB: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.argument: # uncovered
    # single argument
    if t == token.EQUAL: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type == token.LPAR: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type in {token.EQUAL} | VARARGS_SPECIALS: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.decorator: # uncovered
    aux = NO # uncovered
    # decorators
    exit(aux) # uncovered
elif p.type == syms.dotted_name: # uncovered
    if prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    prevp = preceding_leaf(p) # uncovered
    if not prevp or prevp.type == token.AT or prevp.type == token.DOT: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.classdef: # uncovered
    if t == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if prev and prev.type == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.subscript, syms.sliceop}: # uncovered
    # indexing
    if not prev: # uncovered
        assert p.parent is not None, ""subscripts are always parented"" # uncovered
        if p.parent.type == syms.subscriptlist: # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif not complex_subscript: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.atom: # uncovered
    if prev and t == token.DOT: # uncovered
        aux = NO # uncovered
        # dots, but not the first one.
        exit(aux) # uncovered
elif p.type == syms.dictsetmaker: # uncovered
    # dict unpacking
    if prev and prev.type == token.DOUBLESTAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.factor, syms.star_expr}: # uncovered
    # unary ops
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type in OPENING_BRACKETS: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        prevp_parent = prevp.parent # uncovered
        assert prevp_parent is not None # uncovered
        if prevp.type == token.COLON and prevp_parent.type in { # uncovered
            syms.subscript, # uncovered
            syms.sliceop, # uncovered
        }: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t in {token.NAME, token.NUMBER, token.STRING}: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.import_from: # uncovered
    if t == token.DOT: # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t == token.NAME: # uncovered
        if v == ""import"": # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.sliceop: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
elif p.type == syms.except_clause: # uncovered
    if t == token.STAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
aux = SPACE # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':')"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = set()"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = set()"",
            ""TYPED_NAMES = set()"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 'subscript',"",
            ""    'subscriptlist': 'subscriptlist',"",
            ""    'sliceop': 'sliceop',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument',"",
            ""    'parameters': 'parameters',"",
            ""    'varargslist': 'varargslist',"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'factor': 'factor',"",
            ""    'star_expr': 'star_expr',"",
            ""    'decorator': 'decorator',"",
            ""    'trailer': 'trailer',"",
            ""    'dotted_name': 'dotted_name',"",
            ""    'classdef': 'classdef',"",
            ""    'atom': 'atom',"",
            ""    'dictsetmaker': 'dictsetmaker',"",
            ""    'import_from': 'import_from',"",
            ""    'except_clause': 'except_clause'"",
            ""})"",
            """",
            ""leaf = MockLeaf(token.COLON, ':', MockParent(syms.classdef), MockLeaf(token.LPAR, '('))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    sys.exit(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COMMA, ',')"",
            """",
            ""def parent_type(node):"",
            ""    return node.type if node else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {1, 2}"",
            ""UNPACKING_PARENTS = {3, 4}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'except_clause': 18"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(2))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':')"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', MockParent('dotted_name', None))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    sys.exit(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':')"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {MockLeaf(token.COLON).type}"",
            ""UNPACKING_PARENTS = {MockLeaf(token.COLON).type}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'except_clause': 18"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.sliceop))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':')"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'decorator': 10,"",
            ""    'trailer': 11,"",
            ""    'dotted_name': 12,"",
            ""    'classdef': 13,"",
            ""    'atom': 14,"",
            ""    'dictsetmaker': 15,"",
            ""    'star_expr': 16,"",
            ""    'import_from': 17,"",
            ""    'except_clause': 18"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscriptlist))"",
            ""complex_subscript = False"",
            ""def exit(aux): print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':')"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {'parameters', 'arglist'}"",
            ""UNPACKING_PARENTS = {'dictsetmaker'}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19})"",
            """",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.import_from))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':')"",
            ""def parent_type(node):"",
            ""    return node.type if node else None"",
            ""def is_vararg(node, within):"",
            ""    return False"",
            ""ALWAYS_NO_SPACE = {token.COMMA}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(1))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_):"",
            ""        self.type = type_"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':')"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {syms.arglist, syms.parameters}"",
            ""UNPACKING_PARENTS = {syms.dictsetmaker}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH, token.DOUBLESLASH, token.PERCENT}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'decorator': 10,"",
            ""    'trailer': 11,"",
            ""    'dotted_name': 12,"",
            ""    'classdef': 13,"",
            ""    'atom': 14,"",
            ""    'dictsetmaker': 15,"",
            ""    'import_from': 16,"",
            ""    'star_expr': 17,"",
            ""    'except_clause': 18"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(1), prev_sibling=None)"",
            ""complex_subscript = False"",
            ""def exit(aux): print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_):"",
            ""        self.type = type_"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':')"",
            """",
            ""def parent_type(node):"",
            ""    return node.type if node else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {token.LPAR}"",
            ""UNPACKING_PARENTS = {token.LSQB, token.LBRACE}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH, token.DOUBLESLASH, token.PERCENT}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 'subscript',"",
            ""    'subscriptlist': 'subscriptlist',"",
            ""    'sliceop': 'sliceop',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument',"",
            ""    'parameters': 'parameters',"",
            ""    'varargslist': 'varargslist',"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'factor': 'factor',"",
            ""    'star_expr': 'star_expr',"",
            ""    'decorator': 'decorator',"",
            ""    'trailer': 'trailer',"",
            ""    'dotted_name': 'dotted_name',"",
            ""    'classdef': 'classdef',"",
            ""    'atom': 'atom',"",
            ""    'dictsetmaker': 'dictsetmaker',"",
            ""    'import_from': 'import_from',"",
            ""    'except_clause': 'except_clause',"",
            ""})"",
            ""leaf = MockLeaf(token.EQUAL, '=', parent=MockParent(syms.typedargslist))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':')"",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            ""def is_vararg(node, within):"",
            ""    return False"",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {4, 6}"",
            ""UNPACKING_PARENTS = {16}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.EQUAL, '=', parent=MockParent(syms.argument))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = set() # pragma: no cover"",
            ""TYPED_NAMES = set() # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 'subscript', # pragma: no cover"",
            ""    'subscriptlist': 'subscriptlist', # pragma: no cover"",
            ""    'sliceop': 'sliceop', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'argument': 'argument', # pragma: no cover"",
            ""    'parameters': 'parameters', # pragma: no cover"",
            ""    'varargslist': 'varargslist', # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'factor': 'factor', # pragma: no cover"",
            ""    'star_expr': 'star_expr', # pragma: no cover"",
            ""    'decorator': 'decorator', # pragma: no cover"",
            ""    'trailer': 'trailer', # pragma: no cover"",
            ""    'dotted_name': 'dotted_name', # pragma: no cover"",
            ""    'classdef': 'classdef', # pragma: no cover"",
            ""    'atom': 'atom', # pragma: no cover"",
            ""    'dictsetmaker': 'dictsetmaker', # pragma: no cover"",
            ""    'except_clause': 'except_clause' # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', MockParent(syms.classdef), MockLeaf(token.LPAR, '(')) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COMMA, ',') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.type if node else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = {1, 2} # pragma: no cover"",
            ""UNPACKING_PARENTS = {3, 4} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'except_clause': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(2)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', MockParent('dotted_name', None)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'except_clause': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.sliceop)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'decorator': 10, # pragma: no cover"",
            ""    'trailer': 11, # pragma: no cover"",
            ""    'dotted_name': 12, # pragma: no cover"",
            ""    'classdef': 13, # pragma: no cover"",
            ""    'atom': 14, # pragma: no cover"",
            ""    'dictsetmaker': 15, # pragma: no cover"",
            ""    'star_expr': 16, # pragma: no cover"",
            ""    'except_clause': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscriptlist)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = {'parameters', 'arglist'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'dictsetmaker'} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':') # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.type if node else None # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMA} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(1)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH, token.DOUBLESLASH, token.PERCENT} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'decorator': 10, # pragma: no cover"",
            ""    'trailer': 11, # pragma: no cover"",
            ""    'dotted_name': 12, # pragma: no cover"",
            ""    'classdef': 13, # pragma: no cover"",
            ""    'atom': 14, # pragma: no cover"",
            ""    'dictsetmaker': 15, # pragma: no cover"",
            ""    'star_expr': 17, # pragma: no cover"",
            ""    'except_clause': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(1), prev_sibling=None) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.type if node else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = {token.LPAR} # pragma: no cover"",
            ""UNPACKING_PARENTS = {token.LSQB, token.LBRACE} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH, token.DOUBLESLASH, token.PERCENT} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 'subscript', # pragma: no cover"",
            ""    'subscriptlist': 'subscriptlist', # pragma: no cover"",
            ""    'sliceop': 'sliceop', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'argument': 'argument', # pragma: no cover"",
            ""    'parameters': 'parameters', # pragma: no cover"",
            ""    'varargslist': 'varargslist', # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'factor': 'factor', # pragma: no cover"",
            ""    'star_expr': 'star_expr', # pragma: no cover"",
            ""    'decorator': 'decorator', # pragma: no cover"",
            ""    'trailer': 'trailer', # pragma: no cover"",
            ""    'dotted_name': 'dotted_name', # pragma: no cover"",
            ""    'classdef': 'classdef', # pragma: no cover"",
            ""    'atom': 'atom', # pragma: no cover"",
            ""    'dictsetmaker': 'dictsetmaker', # pragma: no cover"",
            ""    'except_clause': 'except_clause', # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.EQUAL, '=', parent=MockParent(syms.typedargslist)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':') # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = {4, 6} # pragma: no cover"",
            ""UNPACKING_PARENTS = {16} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.EQUAL, '=', parent=MockParent(syms.argument)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    }
]",3,10187,0.0050935,5954,0.008931,0.0140244999999999
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return whitespace prefix if needed for the given `leaf`.
    `complex_subscript` signals whether the given leaf is part of a subscription
    which has non-trivial arguments, like arithmetic expressions or function calls.
    """"""
NO: Final = """"
SPACE: Final = "" ""
DOUBLESPACE: Final = ""  ""
t = leaf.type
p = leaf.parent
v = leaf.value
if t in ALWAYS_NO_SPACE:
    aux = NO
    exit(aux) # uncovered
if t == token.COMMENT:
    aux = DOUBLESPACE
    exit(aux) # uncovered
assert p is not None, f""INTERNAL ERROR: hand-made leaf without parent: {leaf!r}""
if t == token.COLON and p.type not in { # uncovered
    syms.subscript, # uncovered
    syms.subscriptlist, # uncovered
    syms.sliceop, # uncovered
}:
    aux = NO
    exit(aux) # uncovered
prev = leaf.prev_sibling
if not prev:
    prevp = preceding_leaf(p)
    if not prevp or prevp.type in OPENING_BRACKETS:
        aux = NO
        exit(aux) # uncovered
    if t == token.COLON:
        if prevp.type == token.COLON:
            aux = NO
            exit(aux) # uncovered
        elif prevp.type != token.COMMA and not complex_subscript: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        aux = SPACE # uncovered
        exit(aux) # uncovered
    if prevp.type == token.EQUAL: # uncovered
        if prevp.parent: # uncovered
            if prevp.parent.type in { # uncovered
                syms.arglist, # uncovered
                syms.argument, # uncovered
                syms.parameters, # uncovered
                syms.varargslist, # uncovered
            }: # uncovered
                aux = NO # uncovered
                exit(aux) # uncovered
            elif prevp.parent.type == syms.typedargslist: # uncovered
                aux = prevp.prefix # uncovered
                # A bit hacky: if the equal sign has whitespace, it means we
                # previously found it's a typed argument.  So, we're using
                # that, too.
                exit(aux) # uncovered
    elif ( # uncovered
        prevp.type == token.STAR # uncovered
        and parent_type(prevp) == syms.star_expr # uncovered
        and parent_type(prevp.parent) == syms.subscriptlist # uncovered
    ): # uncovered
        aux = NO # uncovered
        # No space between typevar tuples.
        exit(aux) # uncovered
    elif prevp.type in VARARGS_SPECIALS: # uncovered
        if is_vararg(prevp, within=VARARGS_PARENTS | UNPACKING_PARENTS): # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prevp.type == token.COLON:
        if prevp.parent and prevp.parent.type in {syms.subscript, syms.sliceop}: # uncovered
            aux = SPACE if complex_subscript else NO # uncovered
            exit(aux) # uncovered
    elif ( # uncovered
        prevp.parent # uncovered
        and prevp.parent.type == syms.factor # uncovered
        and prevp.type in MATH_OPERATORS # uncovered
    ): # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif prevp.type == token.AT and p.parent and p.parent.type == syms.decorator: # uncovered
        aux = NO # uncovered
        # no space in decorators
        exit(aux) # uncovered
elif prev.type in OPENING_BRACKETS:
    aux = NO
    exit(aux) # uncovered
if p.type in {syms.parameters, syms.arglist}: # uncovered
    # untyped function signatures or calls
    if not prev or prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.varargslist: # uncovered
    # lambdas
    if prev and prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.typedargslist:
    # typed function signatures
    if not prev:
        aux = NO
        exit(aux) # uncovered
    if t == token.EQUAL: # uncovered
        if prev.type not in TYPED_NAMES: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type == token.EQUAL: # uncovered
        aux = prev.prefix # uncovered
        # A bit hacky: if the equal sign has whitespace, it means we
        # previously found it's a typed argument.  So, we're using that, too.
        exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in TYPED_NAMES: # uncovered
    # type names
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type != token.COMMA: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.trailer: # uncovered
    # attributes and calls
    if t == token.LPAR or t == token.RPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        if t == token.DOT or t == token.LSQB: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.argument:
    # single argument
    if t == token.EQUAL:
        aux = NO
        exit(aux) # uncovered
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type == token.LPAR: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type in {token.EQUAL} | VARARGS_SPECIALS: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.decorator: # uncovered
    aux = NO # uncovered
    # decorators
    exit(aux) # uncovered
elif p.type == syms.dotted_name: # uncovered
    if prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    prevp = preceding_leaf(p) # uncovered
    if not prevp or prevp.type == token.AT or prevp.type == token.DOT: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.classdef: # uncovered
    if t == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if prev and prev.type == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.subscript, syms.sliceop}: # uncovered
    # indexing
    if not prev: # uncovered
        assert p.parent is not None, ""subscripts are always parented"" # uncovered
        if p.parent.type == syms.subscriptlist: # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif not complex_subscript: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.atom: # uncovered
    if prev and t == token.DOT: # uncovered
        aux = NO # uncovered
        # dots, but not the first one.
        exit(aux) # uncovered
elif p.type == syms.dictsetmaker: # uncovered
    # dict unpacking
    if prev and prev.type == token.DOUBLESTAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.factor, syms.star_expr}: # uncovered
    # unary ops
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type in OPENING_BRACKETS: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        prevp_parent = prevp.parent # uncovered
        assert prevp_parent is not None # uncovered
        if prevp.type == token.COLON and prevp_parent.type in { # uncovered
            syms.subscript, # uncovered
            syms.sliceop, # uncovered
        }: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t in {token.NAME, token.NUMBER, token.STRING}: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.import_from: # uncovered
    if t == token.DOT: # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t == token.NAME: # uncovered
        if v == ""import"": # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.sliceop: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
elif p.type == syms.except_clause: # uncovered
    if t == token.STAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
aux = SPACE # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':')"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.import_from), prev_sibling=MockLeaf(token.DOT, '.'))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    sys.exit(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_):"",
            ""        self.type = type_"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':')"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'except_clause': 18"",
            ""})"",
            """",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(3))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':', MockParent(syms.import_from))"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {'parameters', 'arglist'}"",
            ""UNPACKING_PARENTS = {'dictsetmaker'}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH, token.DOUBLESLASH, token.PERCENT}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'star_expr': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.STAR, '*', parent=MockParent(syms.except_clause))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.EQUAL, '=')"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON, token.COMMENT, token.COMMA, token.LSQB, token.LPAR, token.LBRACE, token.RPAR}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {1, 5, 7}"",
            ""UNPACKING_PARENTS = {15, 16}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(3),  prev_sibling=None)"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':')"",
            """",
            ""def parent_type(node):"",
            ""    return node.type if node else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {4, 6}"",
            ""UNPACKING_PARENTS = {16}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', MockParent(syms.trailer), MockLeaf(token.COMMA, ','))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':')"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'decorator': 10,"",
            ""    'trailer': 11,"",
            ""    'dotted_name': 12,"",
            ""    'classdef': 13,"",
            ""    'atom': 14,"",
            ""    'dictsetmaker': 15,"",
            ""    'import_from': 16,"",
            ""    'sliceop': 17,"",
            ""    'except_clause': 18"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(3), prev_sibling=None)"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_):"",
            ""        self.type = type_"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.LPAR, '(', None, None)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'except_clause': 18})"",
            ""leaf = MockLeaf(token.COLON, ':', MockParent(1), None)"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COMMA, ',')"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COMMA}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(1))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    # Returns a leaf with type token.COLON and value ':'"",
            ""    return MockLeaf(token.COLON, ':', parent=node.parent)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            """",
            ""leaf = MockLeaf(token.EQUAL, '=', parent=MockParent(syms.argument), prev_sibling=None)"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COMMA, ',')"",
            """",
            ""def parent_type(node):"",
            ""    return node.type if node else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.EQUAL, '=', parent=MockParent(syms.typedargslist), prev_sibling=MockLeaf(token.NAME, 'name'))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'except_clause': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(3)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = {'parameters', 'arglist'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'dictsetmaker'} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH, token.DOUBLESLASH, token.PERCENT} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'star_expr': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.STAR, '*', parent=MockParent(syms.except_clause)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.EQUAL, '=') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON, token.COMMENT, token.COMMA, token.LSQB, token.LPAR, token.LBRACE, token.RPAR} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = {1, 5, 7} # pragma: no cover"",
            ""UNPACKING_PARENTS = {15, 16} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(3),  prev_sibling=None) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.type if node else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = {4, 6} # pragma: no cover"",
            ""UNPACKING_PARENTS = {16} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', MockParent(syms.trailer), MockLeaf(token.COMMA, ',')) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'decorator': 10, # pragma: no cover"",
            ""    'trailer': 11, # pragma: no cover"",
            ""    'dotted_name': 12, # pragma: no cover"",
            ""    'classdef': 13, # pragma: no cover"",
            ""    'atom': 14, # pragma: no cover"",
            ""    'dictsetmaker': 15, # pragma: no cover"",
            ""    'sliceop': 17, # pragma: no cover"",
            ""    'except_clause': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(3), prev_sibling=None) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.LPAR, '(', None, None) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'except_clause': 18}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', MockParent(1), None) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COMMA, ',') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMA} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(1)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    # Returns a leaf with type token.COLON and value ':' # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':', parent=node.parent) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = MockLeaf(token.EQUAL, '=', parent=MockParent(syms.argument), prev_sibling=None) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COMMA, ',') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.type if node else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.EQUAL, '=', parent=MockParent(syms.typedargslist), prev_sibling=MockLeaf(token.NAME, 'name')) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    }
]",3,10846,0.005423,6037,0.0090555,0.0144784999999999
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return whitespace prefix if needed for the given `leaf`.
    `complex_subscript` signals whether the given leaf is part of a subscription
    which has non-trivial arguments, like arithmetic expressions or function calls.
    """"""
NO: Final = """"
SPACE: Final = "" ""
DOUBLESPACE: Final = ""  ""
t = leaf.type
p = leaf.parent
v = leaf.value
if t in ALWAYS_NO_SPACE:
    aux = NO
    exit(aux) # uncovered
if t == token.COMMENT:
    aux = DOUBLESPACE
    exit(aux) # uncovered
assert p is not None, f""INTERNAL ERROR: hand-made leaf without parent: {leaf!r}""
if t == token.COLON and p.type not in { # uncovered
    syms.subscript, # uncovered
    syms.subscriptlist, # uncovered
    syms.sliceop, # uncovered
}:
    aux = NO
    exit(aux) # uncovered
prev = leaf.prev_sibling
if not prev:
    prevp = preceding_leaf(p)
    if not prevp or prevp.type in OPENING_BRACKETS:
        aux = NO
        exit(aux) # uncovered
    if t == token.COLON:
        if prevp.type == token.COLON:
            aux = NO
            exit(aux) # uncovered
        elif prevp.type != token.COMMA and not complex_subscript: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        aux = SPACE
        exit(aux) # uncovered
    if prevp.type == token.EQUAL: # uncovered
        if prevp.parent: # uncovered
            if prevp.parent.type in { # uncovered
                syms.arglist, # uncovered
                syms.argument, # uncovered
                syms.parameters, # uncovered
                syms.varargslist, # uncovered
            }: # uncovered
                aux = NO # uncovered
                exit(aux) # uncovered
            elif prevp.parent.type == syms.typedargslist: # uncovered
                aux = prevp.prefix # uncovered
                # A bit hacky: if the equal sign has whitespace, it means we
                # previously found it's a typed argument.  So, we're using
                # that, too.
                exit(aux) # uncovered
    elif ( # uncovered
        prevp.type == token.STAR # uncovered
        and parent_type(prevp) == syms.star_expr # uncovered
        and parent_type(prevp.parent) == syms.subscriptlist # uncovered
    ): # uncovered
        aux = NO # uncovered
        # No space between typevar tuples.
        exit(aux) # uncovered
    elif prevp.type in VARARGS_SPECIALS: # uncovered
        if is_vararg(prevp, within=VARARGS_PARENTS | UNPACKING_PARENTS): # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prevp.type == token.COLON:
        if prevp.parent and prevp.parent.type in {syms.subscript, syms.sliceop}: # uncovered
            aux = SPACE if complex_subscript else NO # uncovered
            exit(aux) # uncovered
    elif ( # uncovered
        prevp.parent # uncovered
        and prevp.parent.type == syms.factor # uncovered
        and prevp.type in MATH_OPERATORS # uncovered
    ): # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif prevp.type == token.AT and p.parent and p.parent.type == syms.decorator: # uncovered
        aux = NO # uncovered
        # no space in decorators
        exit(aux) # uncovered
elif prev.type in OPENING_BRACKETS:
    aux = NO
    exit(aux) # uncovered
if p.type in {syms.parameters, syms.arglist}: # uncovered
    # untyped function signatures or calls
    if not prev or prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.varargslist: # uncovered
    # lambdas
    if prev and prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.typedargslist:
    # typed function signatures
    if not prev:
        aux = NO
        exit(aux) # uncovered
    if t == token.EQUAL:
        if prev.type not in TYPED_NAMES: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type == token.EQUAL: # uncovered
        aux = prev.prefix # uncovered
        # A bit hacky: if the equal sign has whitespace, it means we
        # previously found it's a typed argument.  So, we're using that, too.
        exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in TYPED_NAMES: # uncovered
    # type names
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type != token.COMMA: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.trailer: # uncovered
    # attributes and calls
    if t == token.LPAR or t == token.RPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        if t == token.DOT or t == token.LSQB: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.argument:
    # single argument
    if t == token.EQUAL:
        aux = NO
        exit(aux) # uncovered
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type == token.LPAR: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type in {token.EQUAL} | VARARGS_SPECIALS: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.decorator: # uncovered
    aux = NO # uncovered
    # decorators
    exit(aux) # uncovered
elif p.type == syms.dotted_name: # uncovered
    if prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    prevp = preceding_leaf(p) # uncovered
    if not prevp or prevp.type == token.AT or prevp.type == token.DOT: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.classdef: # uncovered
    if t == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if prev and prev.type == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.subscript, syms.sliceop}: # uncovered
    # indexing
    if not prev: # uncovered
        assert p.parent is not None, ""subscripts are always parented"" # uncovered
        if p.parent.type == syms.subscriptlist: # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif not complex_subscript: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.atom: # uncovered
    if prev and t == token.DOT: # uncovered
        aux = NO # uncovered
        # dots, but not the first one.
        exit(aux) # uncovered
elif p.type == syms.dictsetmaker: # uncovered
    # dict unpacking
    if prev and prev.type == token.DOUBLESTAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.factor, syms.star_expr}: # uncovered
    # unary ops
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type in OPENING_BRACKETS: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        prevp_parent = prevp.parent # uncovered
        assert prevp_parent is not None # uncovered
        if prevp.type == token.COLON and prevp_parent.type in { # uncovered
            syms.subscript, # uncovered
            syms.sliceop, # uncovered
        }: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t in {token.NAME, token.NUMBER, token.STRING}: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.import_from: # uncovered
    if t == token.DOT: # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t == token.NAME: # uncovered
        if v == ""import"": # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.sliceop: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
elif p.type == syms.except_clause: # uncovered
    if t == token.STAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
aux = SPACE
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_):"",
            ""        self.type = type_"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':')"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON, token.COMMA, token.LSQB, token.LPAR, token.LBRACE, token.RPAR}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {4, 5, 6, 7}"",
            ""UNPACKING_PARENTS = {15, 16}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH, token.DOUBLESLASH, token.PERCENT}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            """",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(18))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':')"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {4, 6, 7}"",
            ""UNPACKING_PARENTS = {16}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            """",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(3))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':')"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(3, parent=MockParent(2)))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':', parent=node.parent)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.classdef), prev_sibling=MockLeaf(token.LPAR, '('))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':', parent=node.parent)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.STAR, '*', parent=MockParent(syms.except_clause))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':')"",
            """",
            ""def parent_type(node):"",
            ""    return node.type if node else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.STAR, '*', parent=MockParent(syms.except_clause))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':')"",
            """",
            ""def parent_type(node):"",
            ""    return node.type if node else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COMMA}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COMMENT, '# comment')"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.import_from), prev_sibling=None)"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.LSQB, '[')"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscriptlist), prev_sibling=None)"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.LPAR, '(', parent=node.parent)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.trailer))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON, token.COMMA, token.LSQB, token.LPAR, token.LBRACE, token.RPAR} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = {4, 5, 6, 7} # pragma: no cover"",
            ""UNPACKING_PARENTS = {15, 16} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH, token.DOUBLESLASH, token.PERCENT} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(18)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = {4, 6, 7} # pragma: no cover"",
            ""UNPACKING_PARENTS = {16} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(3)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(3, parent=MockParent(2))) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':', parent=node.parent) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.classdef), prev_sibling=MockLeaf(token.LPAR, '(')) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':', parent=node.parent) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.STAR, '*', parent=MockParent(syms.except_clause)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.type if node else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.STAR, '*', parent=MockParent(syms.except_clause)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.type if node else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMA} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COMMENT, '# comment') # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.LSQB, '[') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscriptlist), prev_sibling=None) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.LPAR, '(', parent=node.parent) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.trailer)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    }
]",3,10903,0.0054515,6079,0.0091185,0.01457
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return whitespace prefix if needed for the given `leaf`.
    `complex_subscript` signals whether the given leaf is part of a subscription
    which has non-trivial arguments, like arithmetic expressions or function calls.
    """"""
NO: Final = """"
SPACE: Final = "" ""
DOUBLESPACE: Final = ""  ""
t = leaf.type
p = leaf.parent
v = leaf.value
if t in ALWAYS_NO_SPACE:
    aux = NO
    exit(aux) # uncovered
if t == token.COMMENT:
    aux = DOUBLESPACE
    exit(aux) # uncovered
assert p is not None, f""INTERNAL ERROR: hand-made leaf without parent: {leaf!r}""
if t == token.COLON and p.type not in { # uncovered
    syms.subscript, # uncovered
    syms.subscriptlist, # uncovered
    syms.sliceop, # uncovered
}:
    aux = NO
    exit(aux) # uncovered
prev = leaf.prev_sibling
if not prev:
    prevp = preceding_leaf(p)
    if not prevp or prevp.type in OPENING_BRACKETS:
        aux = NO
        exit(aux) # uncovered
    if t == token.COLON:
        if prevp.type == token.COLON:
            aux = NO
            exit(aux) # uncovered
        elif prevp.type != token.COMMA and not complex_subscript: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        aux = SPACE
        exit(aux) # uncovered
    if prevp.type == token.EQUAL: # uncovered
        if prevp.parent: # uncovered
            if prevp.parent.type in { # uncovered
                syms.arglist, # uncovered
                syms.argument, # uncovered
                syms.parameters, # uncovered
                syms.varargslist, # uncovered
            }: # uncovered
                aux = NO # uncovered
                exit(aux) # uncovered
            elif prevp.parent.type == syms.typedargslist: # uncovered
                aux = prevp.prefix # uncovered
                # A bit hacky: if the equal sign has whitespace, it means we
                # previously found it's a typed argument.  So, we're using
                # that, too.
                exit(aux) # uncovered
    elif ( # uncovered
        prevp.type == token.STAR # uncovered
        and parent_type(prevp) == syms.star_expr # uncovered
        and parent_type(prevp.parent) == syms.subscriptlist # uncovered
    ): # uncovered
        aux = NO # uncovered
        # No space between typevar tuples.
        exit(aux) # uncovered
    elif prevp.type in VARARGS_SPECIALS: # uncovered
        if is_vararg(prevp, within=VARARGS_PARENTS | UNPACKING_PARENTS): # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prevp.type == token.COLON:
        if prevp.parent and prevp.parent.type in {syms.subscript, syms.sliceop}: # uncovered
            aux = SPACE if complex_subscript else NO # uncovered
            exit(aux) # uncovered
    elif ( # uncovered
        prevp.parent # uncovered
        and prevp.parent.type == syms.factor # uncovered
        and prevp.type in MATH_OPERATORS # uncovered
    ): # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif prevp.type == token.AT and p.parent and p.parent.type == syms.decorator: # uncovered
        aux = NO # uncovered
        # no space in decorators
        exit(aux) # uncovered
elif prev.type in OPENING_BRACKETS:
    aux = NO
    exit(aux) # uncovered
if p.type in {syms.parameters, syms.arglist}: # uncovered
    # untyped function signatures or calls
    if not prev or prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.varargslist: # uncovered
    # lambdas
    if prev and prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.typedargslist:
    # typed function signatures
    if not prev:
        aux = NO
        exit(aux) # uncovered
    if t == token.EQUAL:
        if prev.type not in TYPED_NAMES: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type == token.EQUAL: # uncovered
        aux = prev.prefix # uncovered
        # A bit hacky: if the equal sign has whitespace, it means we
        # previously found it's a typed argument.  So, we're using that, too.
        exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in TYPED_NAMES: # uncovered
    # type names
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type != token.COMMA: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.trailer: # uncovered
    # attributes and calls
    if t == token.LPAR or t == token.RPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        if t == token.DOT or t == token.LSQB: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.argument:
    # single argument
    if t == token.EQUAL:
        aux = NO
        exit(aux) # uncovered
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type == token.LPAR: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type in {token.EQUAL} | VARARGS_SPECIALS: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.decorator: # uncovered
    aux = NO # uncovered
    # decorators
    exit(aux) # uncovered
elif p.type == syms.dotted_name: # uncovered
    if prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    prevp = preceding_leaf(p) # uncovered
    if not prevp or prevp.type == token.AT or prevp.type == token.DOT: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.classdef: # uncovered
    if t == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if prev and prev.type == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.subscript, syms.sliceop}: # uncovered
    # indexing
    if not prev: # uncovered
        assert p.parent is not None, ""subscripts are always parented"" # uncovered
        if p.parent.type == syms.subscriptlist: # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif not complex_subscript: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.atom: # uncovered
    if prev and t == token.DOT: # uncovered
        aux = NO # uncovered
        # dots, but not the first one.
        exit(aux) # uncovered
elif p.type == syms.dictsetmaker: # uncovered
    # dict unpacking
    if prev and prev.type == token.DOUBLESTAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.factor, syms.star_expr}: # uncovered
    # unary ops
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type in OPENING_BRACKETS: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        prevp_parent = prevp.parent # uncovered
        assert prevp_parent is not None # uncovered
        if prevp.type == token.COLON and prevp_parent.type in { # uncovered
            syms.subscript, # uncovered
            syms.sliceop, # uncovered
        }: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t in {token.NAME, token.NUMBER, token.STRING}: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.import_from: # uncovered
    if t == token.DOT: # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t == token.NAME: # uncovered
        if v == ""import"": # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.sliceop: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
elif p.type == syms.except_clause: # uncovered
    if t == token.STAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
aux = SPACE
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.sliceop))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.LSQB, '[')"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.typedargslist), prev_sibling=MockLeaf(token.EQUAL, '=', parent=MockParent(syms.argument)))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':', parent=node.parent)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON, token.COMMA, token.LSQB, token.LPAR, token.LBRACE, token.RPAR}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {4, 5, 6, 7}"",
            ""UNPACKING_PARENTS = {15, 16}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH, token.DOUBLESLASH, token.PERCENT}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.classdef), prev_sibling=MockLeaf(token.LPAR, '('))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.classdef))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':', parent=node.parent if node else None)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON, token.COMMA, token.LSQB, token.LPAR, token.LBRACE, token.RPAR}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {4, 5, 6, 7}"",
            ""UNPACKING_PARENTS = {15, 16}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH, token.DOUBLESLASH, token.PERCENT}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            """",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(20))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':', parent=node.parent)"",
            """",
            ""def parent_type(node):"",
            ""    return node.type if node else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.typedargslist), prev_sibling=MockLeaf(token.EQUAL, '=', parent=MockParent(8)))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.slicerop))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COMMA, ',', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.typedargslist), prev_sibling=None)"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':')"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON, token.COMMA}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.trailer))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':')"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.decorator))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.sliceop)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.LSQB, '[') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.typedargslist), prev_sibling=MockLeaf(token.EQUAL, '=', parent=MockParent(syms.argument))) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':', parent=node.parent) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON, token.COMMA, token.LSQB, token.LPAR, token.LBRACE, token.RPAR} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = {4, 5, 6, 7} # pragma: no cover"",
            ""UNPACKING_PARENTS = {15, 16} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH, token.DOUBLESLASH, token.PERCENT} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.classdef), prev_sibling=MockLeaf(token.LPAR, '(')) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.classdef)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':', parent=node.parent if node else None) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON, token.COMMA, token.LSQB, token.LPAR, token.LBRACE, token.RPAR} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = {4, 5, 6, 7} # pragma: no cover"",
            ""UNPACKING_PARENTS = {15, 16} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH, token.DOUBLESLASH, token.PERCENT} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(20)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':', parent=node.parent) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.type if node else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.typedargslist), prev_sibling=MockLeaf(token.EQUAL, '=', parent=MockParent(8))) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COMMA, ',', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.typedargslist), prev_sibling=None) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON, token.COMMA} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.trailer)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.decorator)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    }
]",3,10938,0.005469,6163,0.0092445,0.0147135
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return whitespace prefix if needed for the given `leaf`.
    `complex_subscript` signals whether the given leaf is part of a subscription
    which has non-trivial arguments, like arithmetic expressions or function calls.
    """"""
NO: Final = """"
SPACE: Final = "" ""
DOUBLESPACE: Final = ""  ""
t = leaf.type
p = leaf.parent
v = leaf.value
if t in ALWAYS_NO_SPACE:
    aux = NO
    exit(aux) # uncovered
if t == token.COMMENT:
    aux = DOUBLESPACE
    exit(aux) # uncovered
assert p is not None, f""INTERNAL ERROR: hand-made leaf without parent: {leaf!r}""
if t == token.COLON and p.type not in { # uncovered
    syms.subscript, # uncovered
    syms.subscriptlist, # uncovered
    syms.sliceop, # uncovered
}:
    aux = NO
    exit(aux) # uncovered
prev = leaf.prev_sibling
if not prev:
    prevp = preceding_leaf(p)
    if not prevp or prevp.type in OPENING_BRACKETS:
        aux = NO
        exit(aux) # uncovered
    if t == token.COLON:
        if prevp.type == token.COLON:
            aux = NO
            exit(aux) # uncovered
        elif prevp.type != token.COMMA and not complex_subscript: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        aux = SPACE
        exit(aux) # uncovered
    if prevp.type == token.EQUAL: # uncovered
        if prevp.parent: # uncovered
            if prevp.parent.type in { # uncovered
                syms.arglist, # uncovered
                syms.argument, # uncovered
                syms.parameters, # uncovered
                syms.varargslist, # uncovered
            }: # uncovered
                aux = NO # uncovered
                exit(aux) # uncovered
            elif prevp.parent.type == syms.typedargslist: # uncovered
                aux = prevp.prefix # uncovered
                # A bit hacky: if the equal sign has whitespace, it means we
                # previously found it's a typed argument.  So, we're using
                # that, too.
                exit(aux) # uncovered
    elif ( # uncovered
        prevp.type == token.STAR # uncovered
        and parent_type(prevp) == syms.star_expr # uncovered
        and parent_type(prevp.parent) == syms.subscriptlist # uncovered
    ): # uncovered
        aux = NO # uncovered
        # No space between typevar tuples.
        exit(aux) # uncovered
    elif prevp.type in VARARGS_SPECIALS: # uncovered
        if is_vararg(prevp, within=VARARGS_PARENTS | UNPACKING_PARENTS): # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prevp.type == token.COLON:
        if prevp.parent and prevp.parent.type in {syms.subscript, syms.sliceop}: # uncovered
            aux = SPACE if complex_subscript else NO # uncovered
            exit(aux) # uncovered
    elif ( # uncovered
        prevp.parent # uncovered
        and prevp.parent.type == syms.factor # uncovered
        and prevp.type in MATH_OPERATORS # uncovered
    ): # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif prevp.type == token.AT and p.parent and p.parent.type == syms.decorator: # uncovered
        aux = NO # uncovered
        # no space in decorators
        exit(aux) # uncovered
elif prev.type in OPENING_BRACKETS:
    aux = NO
    exit(aux) # uncovered
if p.type in {syms.parameters, syms.arglist}: # uncovered
    # untyped function signatures or calls
    if not prev or prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.varargslist: # uncovered
    # lambdas
    if prev and prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.typedargslist:
    # typed function signatures
    if not prev:
        aux = NO
        exit(aux) # uncovered
    if t == token.EQUAL:
        if prev.type not in TYPED_NAMES: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type == token.EQUAL: # uncovered
        aux = prev.prefix # uncovered
        # A bit hacky: if the equal sign has whitespace, it means we
        # previously found it's a typed argument.  So, we're using that, too.
        exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in TYPED_NAMES: # uncovered
    # type names
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type != token.COMMA: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.trailer: # uncovered
    # attributes and calls
    if t == token.LPAR or t == token.RPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        if t == token.DOT or t == token.LSQB: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.argument:
    # single argument
    if t == token.EQUAL:
        aux = NO
        exit(aux) # uncovered
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type == token.LPAR: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type in {token.EQUAL} | VARARGS_SPECIALS: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.decorator: # uncovered
    aux = NO # uncovered
    # decorators
    exit(aux) # uncovered
elif p.type == syms.dotted_name: # uncovered
    if prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    prevp = preceding_leaf(p) # uncovered
    if not prevp or prevp.type == token.AT or prevp.type == token.DOT: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.classdef: # uncovered
    if t == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if prev and prev.type == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.subscript, syms.sliceop}: # uncovered
    # indexing
    if not prev: # uncovered
        assert p.parent is not None, ""subscripts are always parented"" # uncovered
        if p.parent.type == syms.subscriptlist: # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif not complex_subscript: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.atom: # uncovered
    if prev and t == token.DOT: # uncovered
        aux = NO # uncovered
        # dots, but not the first one.
        exit(aux) # uncovered
elif p.type == syms.dictsetmaker: # uncovered
    # dict unpacking
    if prev and prev.type == token.DOUBLESTAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.factor, syms.star_expr}: # uncovered
    # unary ops
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type in OPENING_BRACKETS: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        prevp_parent = prevp.parent # uncovered
        assert prevp_parent is not None # uncovered
        if prevp.type == token.COLON and prevp_parent.type in { # uncovered
            syms.subscript, # uncovered
            syms.sliceop, # uncovered
        }: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t in {token.NAME, token.NUMBER, token.STRING}: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.import_from: # uncovered
    if t == token.DOT: # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t == token.NAME: # uncovered
        if v == ""import"": # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.sliceop: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
elif p.type == syms.except_clause: # uncovered
    if t == token.STAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
aux = SPACE
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.LPAR, '(', parent=node.parent)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON, token.LPAR, token.LBRACE}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {4, 5, 6, 7}"",
            ""UNPACKING_PARENTS = {15, 16}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(20))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscriptlist))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':', parent=node.parent)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON, token.COMMA}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscriptlist))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.PLUS, '+', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.factor), prev_sibling=MockLeaf(token.EQUAL, '=', parent=MockParent(syms.argument)))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.NAME, 'x')  # Simulated preceding leaf"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscript))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':', parent=MockParent(syms.subscriptlist))"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON, token.COMMA}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(3), prev_sibling=None)"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.EQUAL, '=', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.typedargslist))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.PLUS, '+', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.factor), prev_sibling=None)"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.sliceop))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':')"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.classdef))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.LPAR, '(', parent=node.parent) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON, token.LPAR, token.LBRACE} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = {4, 5, 6, 7} # pragma: no cover"",
            ""UNPACKING_PARENTS = {15, 16} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(20)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscriptlist)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':', parent=node.parent) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON, token.COMMA} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscriptlist)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.PLUS, '+', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.factor), prev_sibling=MockLeaf(token.EQUAL, '=', parent=MockParent(syms.argument))) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.NAME, 'x')  # Simulated preceding leaf # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscript)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':', parent=MockParent(syms.subscriptlist)) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON, token.COMMA} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(3), prev_sibling=None) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.EQUAL, '=', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.typedargslist)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.PLUS, '+', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.factor), prev_sibling=None) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.sliceop)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.classdef)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    }
]",3,11022,0.005511,6075,0.0091125,0.0146235
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return whitespace prefix if needed for the given `leaf`.
    `complex_subscript` signals whether the given leaf is part of a subscription
    which has non-trivial arguments, like arithmetic expressions or function calls.
    """"""
NO: Final = """"
SPACE: Final = "" ""
DOUBLESPACE: Final = ""  ""
t = leaf.type
p = leaf.parent
v = leaf.value
if t in ALWAYS_NO_SPACE:
    aux = NO
    exit(aux) # uncovered
if t == token.COMMENT:
    aux = DOUBLESPACE
    exit(aux) # uncovered
assert p is not None, f""INTERNAL ERROR: hand-made leaf without parent: {leaf!r}""
if t == token.COLON and p.type not in { # uncovered
    syms.subscript, # uncovered
    syms.subscriptlist, # uncovered
    syms.sliceop, # uncovered
}:
    aux = NO
    exit(aux) # uncovered
prev = leaf.prev_sibling
if not prev:
    prevp = preceding_leaf(p)
    if not prevp or prevp.type in OPENING_BRACKETS:
        aux = NO
        exit(aux) # uncovered
    if t == token.COLON:
        if prevp.type == token.COLON:
            aux = NO
            exit(aux) # uncovered
        elif prevp.type != token.COMMA and not complex_subscript: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        aux = SPACE
        exit(aux) # uncovered
    if prevp.type == token.EQUAL: # uncovered
        if prevp.parent: # uncovered
            if prevp.parent.type in { # uncovered
                syms.arglist, # uncovered
                syms.argument, # uncovered
                syms.parameters, # uncovered
                syms.varargslist, # uncovered
            }: # uncovered
                aux = NO # uncovered
                exit(aux) # uncovered
            elif prevp.parent.type == syms.typedargslist: # uncovered
                aux = prevp.prefix # uncovered
                # A bit hacky: if the equal sign has whitespace, it means we
                # previously found it's a typed argument.  So, we're using
                # that, too.
                exit(aux) # uncovered
    elif ( # uncovered
        prevp.type == token.STAR # uncovered
        and parent_type(prevp) == syms.star_expr # uncovered
        and parent_type(prevp.parent) == syms.subscriptlist # uncovered
    ): # uncovered
        aux = NO # uncovered
        # No space between typevar tuples.
        exit(aux) # uncovered
    elif prevp.type in VARARGS_SPECIALS: # uncovered
        if is_vararg(prevp, within=VARARGS_PARENTS | UNPACKING_PARENTS): # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prevp.type == token.COLON:
        if prevp.parent and prevp.parent.type in {syms.subscript, syms.sliceop}: # uncovered
            aux = SPACE if complex_subscript else NO # uncovered
            exit(aux) # uncovered
    elif ( # uncovered
        prevp.parent # uncovered
        and prevp.parent.type == syms.factor # uncovered
        and prevp.type in MATH_OPERATORS # uncovered
    ): # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif prevp.type == token.AT and p.parent and p.parent.type == syms.decorator: # uncovered
        aux = NO # uncovered
        # no space in decorators
        exit(aux) # uncovered
elif prev.type in OPENING_BRACKETS:
    aux = NO
    exit(aux) # uncovered
if p.type in {syms.parameters, syms.arglist}: # uncovered
    # untyped function signatures or calls
    if not prev or prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.varargslist: # uncovered
    # lambdas
    if prev and prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.typedargslist:
    # typed function signatures
    if not prev:
        aux = NO
        exit(aux) # uncovered
    if t == token.EQUAL:
        if prev.type not in TYPED_NAMES: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type == token.EQUAL: # uncovered
        aux = prev.prefix # uncovered
        # A bit hacky: if the equal sign has whitespace, it means we
        # previously found it's a typed argument.  So, we're using that, too.
        exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in TYPED_NAMES: # uncovered
    # type names
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type != token.COMMA: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.trailer: # uncovered
    # attributes and calls
    if t == token.LPAR or t == token.RPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        if t == token.DOT or t == token.LSQB: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.argument:
    # single argument
    if t == token.EQUAL:
        aux = NO
        exit(aux) # uncovered
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type == token.LPAR: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type in {token.EQUAL} | VARARGS_SPECIALS: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.decorator: # uncovered
    aux = NO # uncovered
    # decorators
    exit(aux) # uncovered
elif p.type == syms.dotted_name: # uncovered
    if prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    prevp = preceding_leaf(p) # uncovered
    if not prevp or prevp.type == token.AT or prevp.type == token.DOT: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.classdef: # uncovered
    if t == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if prev and prev.type == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.subscript, syms.sliceop}: # uncovered
    # indexing
    if not prev: # uncovered
        assert p.parent is not None, ""subscripts are always parented"" # uncovered
        if p.parent.type == syms.subscriptlist: # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif not complex_subscript: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.atom: # uncovered
    if prev and t == token.DOT: # uncovered
        aux = NO # uncovered
        # dots, but not the first one.
        exit(aux) # uncovered
elif p.type == syms.dictsetmaker: # uncovered
    # dict unpacking
    if prev and prev.type == token.DOUBLESTAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.factor, syms.star_expr}: # uncovered
    # unary ops
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type in OPENING_BRACKETS: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        prevp_parent = prevp.parent # uncovered
        assert prevp_parent is not None # uncovered
        if prevp.type == token.COLON and prevp_parent.type in { # uncovered
            syms.subscript, # uncovered
            syms.sliceop, # uncovered
        }: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t in {token.NAME, token.NUMBER, token.STRING}: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.import_from: # uncovered
    if t == token.DOT: # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t == token.NAME: # uncovered
        if v == ""import"": # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.sliceop: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
elif p.type == syms.except_clause: # uncovered
    if t == token.STAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
aux = SPACE
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    # Simulate a preceding leaf of a different type"",
            ""    return MockLeaf(token.LPAR, '(', parent=node.parent)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(2))  # syms.subscriptlist"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.PLUS, '+', parent=node.parent)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.decorator))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COMMA, ',', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscriptlist))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COMMA, ',', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON, token.COMMA}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.typedargslist))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.LPAR, '(', parent=node.parent)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.argument), prev_sibling=MockLeaf(token.EQUAL, '=', parent=MockParent(4)))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':', parent=MockParent(syms.subscript))"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON, token.COMMA}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(20), prev_sibling=None)"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.EQUAL, '=', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON, token.COMMA}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {1, 2, 3}"",
            ""UNPACKING_PARENTS = {4, 5}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscript), prev_sibling=None)"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COMMA, ',', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COMMA, token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscriptlist))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent_type=None):"",
            ""        self.type = type_"",
            ""        self.parent = MockParent(parent_type) if parent_type else None"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.NAME, 'x', parent=node, prev_sibling=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscriptlist))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.NAME, 'x', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.argument, parent=MockParent(syms.arglist)))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    # Simulate a preceding leaf of a different type # pragma: no cover"",
            ""    return MockLeaf(token.LPAR, '(', parent=node.parent) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(2))  # syms.subscriptlist # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.PLUS, '+', parent=node.parent) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.decorator)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COMMA, ',', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscriptlist)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COMMA, ',', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON, token.COMMA} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.typedargslist)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.LPAR, '(', parent=node.parent) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.argument), prev_sibling=MockLeaf(token.EQUAL, '=', parent=MockParent(4))) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':', parent=MockParent(syms.subscript)) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON, token.COMMA} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(20), prev_sibling=None) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.EQUAL, '=', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON, token.COMMA} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = {1, 2, 3} # pragma: no cover"",
            ""UNPACKING_PARENTS = {4, 5} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscript), prev_sibling=None) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COMMA, ',', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMA, token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscriptlist)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent_type=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = MockParent(parent_type) if parent_type else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.NAME, 'x', parent=node, prev_sibling=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscriptlist)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.NAME, 'x', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.argument, parent=MockParent(syms.arglist))) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    }
]",3,10934,0.005467,6111,0.0091665,0.0146334999999999
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return whitespace prefix if needed for the given `leaf`.
    `complex_subscript` signals whether the given leaf is part of a subscription
    which has non-trivial arguments, like arithmetic expressions or function calls.
    """"""
NO: Final = """"
SPACE: Final = "" ""
DOUBLESPACE: Final = ""  ""
t = leaf.type
p = leaf.parent
v = leaf.value
if t in ALWAYS_NO_SPACE:
    aux = NO
    exit(aux) # uncovered
if t == token.COMMENT:
    aux = DOUBLESPACE
    exit(aux) # uncovered
assert p is not None, f""INTERNAL ERROR: hand-made leaf without parent: {leaf!r}""
if t == token.COLON and p.type not in { # uncovered
    syms.subscript, # uncovered
    syms.subscriptlist, # uncovered
    syms.sliceop, # uncovered
}:
    aux = NO
    exit(aux) # uncovered
prev = leaf.prev_sibling
if not prev:
    prevp = preceding_leaf(p)
    if not prevp or prevp.type in OPENING_BRACKETS:
        aux = NO
        exit(aux) # uncovered
    if t == token.COLON:
        if prevp.type == token.COLON:
            aux = NO
            exit(aux) # uncovered
        elif prevp.type != token.COMMA and not complex_subscript: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        aux = SPACE
        exit(aux) # uncovered
    if prevp.type == token.EQUAL: # uncovered
        if prevp.parent: # uncovered
            if prevp.parent.type in { # uncovered
                syms.arglist, # uncovered
                syms.argument, # uncovered
                syms.parameters, # uncovered
                syms.varargslist, # uncovered
            }: # uncovered
                aux = NO # uncovered
                exit(aux) # uncovered
            elif prevp.parent.type == syms.typedargslist: # uncovered
                aux = prevp.prefix # uncovered
                # A bit hacky: if the equal sign has whitespace, it means we
                # previously found it's a typed argument.  So, we're using
                # that, too.
                exit(aux) # uncovered
    elif ( # uncovered
        prevp.type == token.STAR # uncovered
        and parent_type(prevp) == syms.star_expr # uncovered
        and parent_type(prevp.parent) == syms.subscriptlist # uncovered
    ): # uncovered
        aux = NO # uncovered
        # No space between typevar tuples.
        exit(aux) # uncovered
    elif prevp.type in VARARGS_SPECIALS: # uncovered
        if is_vararg(prevp, within=VARARGS_PARENTS | UNPACKING_PARENTS): # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prevp.type == token.COLON:
        if prevp.parent and prevp.parent.type in {syms.subscript, syms.sliceop}: # uncovered
            aux = SPACE if complex_subscript else NO # uncovered
            exit(aux) # uncovered
    elif ( # uncovered
        prevp.parent # uncovered
        and prevp.parent.type == syms.factor # uncovered
        and prevp.type in MATH_OPERATORS # uncovered
    ): # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif prevp.type == token.AT and p.parent and p.parent.type == syms.decorator: # uncovered
        aux = NO # uncovered
        # no space in decorators
        exit(aux) # uncovered
elif prev.type in OPENING_BRACKETS:
    aux = NO
    exit(aux) # uncovered
if p.type in {syms.parameters, syms.arglist}: # uncovered
    # untyped function signatures or calls
    if not prev or prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.varargslist: # uncovered
    # lambdas
    if prev and prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.typedargslist:
    # typed function signatures
    if not prev:
        aux = NO
        exit(aux) # uncovered
    if t == token.EQUAL:
        if prev.type not in TYPED_NAMES: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type == token.EQUAL: # uncovered
        aux = prev.prefix # uncovered
        # A bit hacky: if the equal sign has whitespace, it means we
        # previously found it's a typed argument.  So, we're using that, too.
        exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in TYPED_NAMES: # uncovered
    # type names
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type != token.COMMA: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.trailer: # uncovered
    # attributes and calls
    if t == token.LPAR or t == token.RPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        if t == token.DOT or t == token.LSQB: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.argument:
    # single argument
    if t == token.EQUAL:
        aux = NO
        exit(aux) # uncovered
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type == token.LPAR: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type in {token.EQUAL} | VARARGS_SPECIALS: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.decorator: # uncovered
    aux = NO # uncovered
    # decorators
    exit(aux) # uncovered
elif p.type == syms.dotted_name: # uncovered
    if prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    prevp = preceding_leaf(p) # uncovered
    if not prevp or prevp.type == token.AT or prevp.type == token.DOT: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.classdef: # uncovered
    if t == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if prev and prev.type == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.subscript, syms.sliceop}: # uncovered
    # indexing
    if not prev: # uncovered
        assert p.parent is not None, ""subscripts are always parented"" # uncovered
        if p.parent.type == syms.subscriptlist: # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif not complex_subscript: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.atom: # uncovered
    if prev and t == token.DOT: # uncovered
        aux = NO # uncovered
        # dots, but not the first one.
        exit(aux) # uncovered
elif p.type == syms.dictsetmaker: # uncovered
    # dict unpacking
    if prev and prev.type == token.DOUBLESTAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.factor, syms.star_expr}: # uncovered
    # unary ops
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type in OPENING_BRACKETS: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        prevp_parent = prevp.parent # uncovered
        assert prevp_parent is not None # uncovered
        if prevp.type == token.COLON and prevp_parent.type in { # uncovered
            syms.subscript, # uncovered
            syms.sliceop, # uncovered
        }: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t in {token.NAME, token.NUMBER, token.STRING}: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.import_from: # uncovered
    if t == token.DOT: # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t == token.NAME: # uncovered
        if v == ""import"": # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.sliceop: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
elif p.type == syms.except_clause: # uncovered
    if t == token.STAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
aux = SPACE
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent_type=None):"",
            ""        self.type = type_"",
            ""        self.parent = MockParent(parent_type) if parent_type else None"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.EQUAL, '=', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscript))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.EQUAL, '=', parent=node.parent)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscript, parent=MockParent(syms.subscriptlist)))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.RBRACE, '}', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(token.RBRACE, None))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.PLUS, '+', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.typedargslist), prev_sibling=None)"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COMMA, ',', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON, token.COMMA}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.argument))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.EQUAL, '=', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.argument))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COMMA, ',', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(2))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    # Simulate a preceding leaf of a different type"",
            ""    return MockLeaf(token.LPAR, '(', parent=node.parent)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscriptlist))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    # Mock a preceding leaf of a specific type"",
            ""    return MockLeaf(token.STAR, '*', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {1, 2, 3}"",
            ""UNPACKING_PARENTS = {4, 5}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscript), prev_sibling=MockLeaf(token.STAR, '*', parent=MockParent(syms.star_expr)))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.PLUS, '+', node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.import_from), prev_sibling=MockLeaf(token.DOT, '.'))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent_type=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = MockParent(parent_type) if parent_type else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.EQUAL, '=', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscript)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.EQUAL, '=', parent=node.parent) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscript, parent=MockParent(syms.subscriptlist))) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.RBRACE, '}', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(token.RBRACE, None)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.PLUS, '+', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.typedargslist), prev_sibling=None) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COMMA, ',', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON, token.COMMA} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.argument)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.EQUAL, '=', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.argument)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COMMA, ',', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(2)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    # Simulate a preceding leaf of a different type # pragma: no cover"",
            ""    return MockLeaf(token.LPAR, '(', parent=node.parent) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscriptlist)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    # Mock a preceding leaf of a specific type # pragma: no cover"",
            ""    return MockLeaf(token.STAR, '*', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = {1, 2, 3} # pragma: no cover"",
            ""UNPACKING_PARENTS = {4, 5} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscript), prev_sibling=MockLeaf(token.STAR, '*', parent=MockParent(syms.star_expr))) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.PLUS, '+', node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    }
]",3,10970,0.005485,6105,0.0091575,0.0146425
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return whitespace prefix if needed for the given `leaf`.
    `complex_subscript` signals whether the given leaf is part of a subscription
    which has non-trivial arguments, like arithmetic expressions or function calls.
    """"""
NO: Final = """"
SPACE: Final = "" ""
DOUBLESPACE: Final = ""  ""
t = leaf.type
p = leaf.parent
v = leaf.value
if t in ALWAYS_NO_SPACE:
    aux = NO
    exit(aux) # uncovered
if t == token.COMMENT:
    aux = DOUBLESPACE
    exit(aux) # uncovered
assert p is not None, f""INTERNAL ERROR: hand-made leaf without parent: {leaf!r}""
if t == token.COLON and p.type not in { # uncovered
    syms.subscript, # uncovered
    syms.subscriptlist, # uncovered
    syms.sliceop, # uncovered
}:
    aux = NO
    exit(aux) # uncovered
prev = leaf.prev_sibling
if not prev:
    prevp = preceding_leaf(p)
    if not prevp or prevp.type in OPENING_BRACKETS:
        aux = NO
        exit(aux) # uncovered
    if t == token.COLON:
        if prevp.type == token.COLON:
            aux = NO
            exit(aux) # uncovered
        elif prevp.type != token.COMMA and not complex_subscript: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        aux = SPACE
        exit(aux) # uncovered
    if prevp.type == token.EQUAL: # uncovered
        if prevp.parent: # uncovered
            if prevp.parent.type in { # uncovered
                syms.arglist, # uncovered
                syms.argument, # uncovered
                syms.parameters, # uncovered
                syms.varargslist, # uncovered
            }: # uncovered
                aux = NO # uncovered
                exit(aux) # uncovered
            elif prevp.parent.type == syms.typedargslist: # uncovered
                aux = prevp.prefix # uncovered
                # A bit hacky: if the equal sign has whitespace, it means we
                # previously found it's a typed argument.  So, we're using
                # that, too.
                exit(aux) # uncovered
    elif ( # uncovered
        prevp.type == token.STAR # uncovered
        and parent_type(prevp) == syms.star_expr # uncovered
        and parent_type(prevp.parent) == syms.subscriptlist # uncovered
    ): # uncovered
        aux = NO # uncovered
        # No space between typevar tuples.
        exit(aux) # uncovered
    elif prevp.type in VARARGS_SPECIALS: # uncovered
        if is_vararg(prevp, within=VARARGS_PARENTS | UNPACKING_PARENTS): # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prevp.type == token.COLON:
        if prevp.parent and prevp.parent.type in {syms.subscript, syms.sliceop}: # uncovered
            aux = SPACE if complex_subscript else NO # uncovered
            exit(aux) # uncovered
    elif ( # uncovered
        prevp.parent # uncovered
        and prevp.parent.type == syms.factor # uncovered
        and prevp.type in MATH_OPERATORS # uncovered
    ): # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif prevp.type == token.AT and p.parent and p.parent.type == syms.decorator: # uncovered
        aux = NO # uncovered
        # no space in decorators
        exit(aux) # uncovered
elif prev.type in OPENING_BRACKETS:
    aux = NO
    exit(aux) # uncovered
if p.type in {syms.parameters, syms.arglist}: # uncovered
    # untyped function signatures or calls
    if not prev or prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.varargslist: # uncovered
    # lambdas
    if prev and prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.typedargslist:
    # typed function signatures
    if not prev:
        aux = NO
        exit(aux) # uncovered
    if t == token.EQUAL:
        if prev.type not in TYPED_NAMES: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type == token.EQUAL: # uncovered
        aux = prev.prefix # uncovered
        # A bit hacky: if the equal sign has whitespace, it means we
        # previously found it's a typed argument.  So, we're using that, too.
        exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in TYPED_NAMES: # uncovered
    # type names
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type != token.COMMA: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.trailer: # uncovered
    # attributes and calls
    if t == token.LPAR or t == token.RPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        if t == token.DOT or t == token.LSQB: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.argument:
    # single argument
    if t == token.EQUAL:
        aux = NO
        exit(aux) # uncovered
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type == token.LPAR: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type in {token.EQUAL} | VARARGS_SPECIALS: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.decorator: # uncovered
    aux = NO # uncovered
    # decorators
    exit(aux) # uncovered
elif p.type == syms.dotted_name: # uncovered
    if prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    prevp = preceding_leaf(p) # uncovered
    if not prevp or prevp.type == token.AT or prevp.type == token.DOT: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.classdef: # uncovered
    if t == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if prev and prev.type == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.subscript, syms.sliceop}: # uncovered
    # indexing
    if not prev: # uncovered
        assert p.parent is not None, ""subscripts are always parented"" # uncovered
        if p.parent.type == syms.subscriptlist: # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif not complex_subscript: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.atom: # uncovered
    if prev and t == token.DOT: # uncovered
        aux = NO # uncovered
        # dots, but not the first one.
        exit(aux) # uncovered
elif p.type == syms.dictsetmaker: # uncovered
    # dict unpacking
    if prev and prev.type == token.DOUBLESTAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.factor, syms.star_expr}: # uncovered
    # unary ops
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type in OPENING_BRACKETS: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        prevp_parent = prevp.parent # uncovered
        assert prevp_parent is not None # uncovered
        if prevp.type == token.COLON and prevp_parent.type in { # uncovered
            syms.subscript, # uncovered
            syms.sliceop, # uncovered
        }: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t in {token.NAME, token.NUMBER, token.STRING}: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.import_from: # uncovered
    if t == token.DOT: # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t == token.NAME: # uncovered
        if v == ""import"": # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.sliceop: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
elif p.type == syms.except_clause: # uncovered
    if t == token.STAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
aux = SPACE
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.STAR, '*', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {5, 6}"",
            ""UNPACKING_PARENTS = {7, 8}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.typedargslist), prev_sibling=None)"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    # Mock a preceding leaf of a specific type"",
            ""    return MockLeaf(token.COLON, ':', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = {1, 2, 3}"",
            ""UNPACKING_PARENTS = {4, 5}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.argument))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscript))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    # Mock a preceding leaf of a specific type"",
            ""    return MockLeaf(token.COMMA, ',', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON, token.COMMA}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.parameter))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        this.type = type_"",
            ""        this.value = value"",
            ""        this.parent = parent"",
            ""        this.prev_sibling = prev_sibling"",
            ""        this.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        this.type = type_"",
            ""        this.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.EQUAL, '=', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscriptlist, parent=MockParent(syms.subscriptlist, None)))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON, token.COMMA}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscript))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.PLUS, '+', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'except_clause': 18,"",
            ""    'sliceop': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.import_from))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    # Mock a preceding leaf"",
            ""    return MockLeaf(token.LBRACE, '{', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscriptlist))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent_type=None):"",
            ""        self.type = type_"",
            ""        self.parent = MockParent(parent_type) if parent_type else None"",
            """",
            ""def preceding_leaf(node):"",
            ""    # Simulates preceding_leaf function"",
            ""    return MockLeaf(token.STAR, '*', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON, token.COMMA}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscript), prev_sibling=None)"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.parent = parent"",
            ""        self.prev_sibling = prev_sibling"",
            ""        self.prefix = ''"",
            """",
            ""class MockParent:"",
            ""    def __init__(self, type_, parent=None):"",
            ""        self.type = type_"",
            ""        self.parent = parent"",
            """",
            ""def preceding_leaf(node):"",
            ""    return MockLeaf(token.COLON, ':', parent=node)"",
            """",
            ""def parent_type(node):"",
            ""    return node.parent.type if node and node.parent else None"",
            """",
            ""def is_vararg(node, within):"",
            ""    return False"",
            """",
            ""ALWAYS_NO_SPACE = {token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (object,), {"",
            ""    'subscript': 1,"",
            ""    'subscriptlist': 2,"",
            ""    'sliceop': 3,"",
            ""    'arglist': 4,"",
            ""    'argument': 5,"",
            ""    'parameters': 6,"",
            ""    'varargslist': 7,"",
            ""    'typedargslist': 8,"",
            ""    'factor': 9,"",
            ""    'star_expr': 10,"",
            ""    'decorator': 11,"",
            ""    'trailer': 12,"",
            ""    'dotted_name': 13,"",
            ""    'classdef': 14,"",
            ""    'atom': 15,"",
            ""    'dictsetmaker': 16,"",
            ""    'import_from': 17,"",
            ""    'sliceop': 18,"",
            ""    'except_clause': 19"",
            ""})"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(token.INDENT))"",
            ""complex_subscript = False"",
            ""def exit(aux):"",
            ""    print(aux)""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.STAR, '*', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = {5, 6} # pragma: no cover"",
            ""UNPACKING_PARENTS = {7, 8} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.typedargslist), prev_sibling=None) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    # Mock a preceding leaf of a specific type # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = {1, 2, 3} # pragma: no cover"",
            ""UNPACKING_PARENTS = {4, 5} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.argument)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscript)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    # Mock a preceding leaf of a specific type # pragma: no cover"",
            ""    return MockLeaf(token.COMMA, ',', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON, token.COMMA} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        pass"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        pass"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.EQUAL, '=', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscriptlist, parent=MockParent(syms.subscriptlist, None))) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON, token.COMMA} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscript)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.PLUS, '+', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'except_clause': 18, # pragma: no cover"",
            ""    'sliceop': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    # Mock a preceding leaf # pragma: no cover"",
            ""    return MockLeaf(token.LBRACE, '{', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscriptlist)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent_type=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = MockParent(parent_type) if parent_type else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    # Simulates preceding_leaf function # pragma: no cover"",
            ""    return MockLeaf(token.STAR, '*', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON, token.COMMA} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(syms.subscript), prev_sibling=None) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, parent=None, prev_sibling=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""        self.prefix = '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent: # pragma: no cover"",
            ""    def __init__(self, type_, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(node): # pragma: no cover"",
            ""    return MockLeaf(token.COLON, ':', parent=node) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(node): # pragma: no cover"",
            ""    return node.parent.type if node and node.parent else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(node, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS, token.STAR, token.SLASH} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'subscript': 1, # pragma: no cover"",
            ""    'subscriptlist': 2, # pragma: no cover"",
            ""    'sliceop': 3, # pragma: no cover"",
            ""    'arglist': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'parameters': 6, # pragma: no cover"",
            ""    'varargslist': 7, # pragma: no cover"",
            ""    'typedargslist': 8, # pragma: no cover"",
            ""    'factor': 9, # pragma: no cover"",
            ""    'star_expr': 10, # pragma: no cover"",
            ""    'decorator': 11, # pragma: no cover"",
            ""    'trailer': 12, # pragma: no cover"",
            ""    'dotted_name': 13, # pragma: no cover"",
            ""    'classdef': 14, # pragma: no cover"",
            ""    'atom': 15, # pragma: no cover"",
            ""    'dictsetmaker': 16, # pragma: no cover"",
            ""    'sliceop': 18, # pragma: no cover"",
            ""    'except_clause': 19 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = MockLeaf(token.COLON, ':', parent=MockParent(token.INDENT)) # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    }
]",3,10964,0.005482,6113,0.0091695,0.014651500000000001
