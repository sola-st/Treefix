prompt,raw_predictions,predictions,prompt_type,input_size,input_price,output_size,output_price,total_price
"Provide self-contained and concrete Python values to initialize the undefined variables in the code snippet.

# begin code snippet
""""""Split line into many lines, starting with the first matching bracket pair.

    Note: this usually looks weird, only use this for function definitions.
    Prefer RHS otherwise.  This is why this function is not symmetrical with
    :func:`right_hand_split` which also handles optional parentheses.
    """"""
tail_leaves: List[Leaf] = []
body_leaves: List[Leaf] = []
head_leaves: List[Leaf] = []
current_leaves = head_leaves
matching_bracket: Optional[Leaf] = None
for leaf in line.leaves:
    if (
        current_leaves is body_leaves
        and leaf.type in CLOSING_BRACKETS
        and leaf.opening_bracket is matching_bracket
        and isinstance(matching_bracket, Leaf)
    ):
        ensure_visible(leaf)
        ensure_visible(matching_bracket)
        current_leaves = tail_leaves if body_leaves else head_leaves
    current_leaves.append(leaf)
    if current_leaves is head_leaves:
        if leaf.type in OPENING_BRACKETS:
            matching_bracket = leaf
            current_leaves = body_leaves
if not matching_bracket:
    raise CannotSplit(""No brackets found"")

head = bracket_split_build_line(
    head_leaves, line, matching_bracket, component=_BracketSplitComponent.head
)
body = bracket_split_build_line(
    body_leaves, line, matching_bracket, component=_BracketSplitComponent.body
)
tail = bracket_split_build_line(
    tail_leaves, line, matching_bracket, component=_BracketSplitComponent.tail
)
bracket_split_succeeded_or_raise(head, body, tail)
for result in (head, body, tail):
    if result:
        exit(result)

# end code snippet

# begin undefined variables
List
Leaf
Optional
line
CLOSING_BRACKETS
ensure_visible
OPENING_BRACKETS
CannotSplit
bracket_split_build_line
_BracketSplitComponent
bracket_split_succeeded_or_raise
# end undefined variables

# begin undefined attributes and methods
line.leaves
_BracketSplitComponent.head
_BracketSplitComponent.body
_BracketSplitComponent.tail
# end undefined attributes and methods

Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type_: str, opening_bracket: Optional['Leaf'] = None):"",
            ""        self.type = type_"",
            ""        self.opening_bracket = opening_bracket"",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            ""def ensure_visible(leaf: Leaf) -> None:"",
            ""    pass"",
            ""def bracket_split_build_line(leaves: List[Leaf], line: 'Line', matching_bracket: Leaf, component: '_BracketSplitComponent') -> Optional[Leaf]:"",
            ""    return None"",
            ""def bracket_split_succeeded_or_raise(head: Optional[Leaf], body: Optional[Leaf], tail: Optional[Leaf]) -> None:"",
            ""    pass"",
            ""class _BracketSplitComponent(Enum):"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            ""class Line:"",
            ""    def __init__(self, leaves: List[Leaf]):"",
            ""        self.leaves = leaves"",
            ""line = Line(leaves=[Leaf(type_='(', opening_bracket=None)])"",
            ""CLOSING_BRACKETS = [')', ']', '}']"",
            ""OPENING_BRACKETS = ['(', '[', '{']""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from collections import namedtuple"",
            ""import sys""
        ],
        ""initialization"": [
            ""Leaf = namedtuple('Leaf', ['type', 'opening_bracket'])"",
            ""line = type('Mock', (object,), {'leaves': []})"",
            ""CLOSING_BRACKETS = set()"",
            ""ensure_visible = lambda leaf: None"",
            ""OPENING_BRACKETS = set()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""bracket_split_build_line = lambda leaves, line, matching_bracket, component: None"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'})"",
            ""bracket_split_succeeded_or_raise = lambda head, body, tail: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""import typing"",
            ""import builtins""
        ],
        ""initialization"": [
            ""class Leaf: pass"",
            ""line = type('Mock', (object,), {'leaves': [Leaf(), Leaf()]})"",
            ""CLOSING_BRACKETS = {']', ')', '}'}"",
            ""def ensure_visible(leaf): pass"",
            ""OPENING_BRACKETS = {'[', '(', '{'}"",
            ""class CannotSplit(Exception): pass"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): return True"",
            ""BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'})"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""class CannotSplit(Exception): pass""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'result'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""CLOSING_BRACKETS = [')', ']', '}']"",
            ""OPENING_BRACKETS = ['(', '[', '{']"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf('arg1'), Leaf(','), Leaf('arg2'), Leaf(')')]})()"",
            """",
            ""_BracketSplitComponent = type('Mock', (object,), {"",
            ""    'head': 'head',"",
            ""    'body': 'body',"",
            ""    'tail': 'tail'"",
            ""})""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('open_bracket'), Leaf('close_bracket')]})"",
            """",
            ""CLOSING_BRACKETS = {'close_bracket'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""OPENING_BRACKETS = {'open_bracket'}"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""class _BracketSplitComponent(Enum):"",
            ""    head = 1"",
            ""    body = 2"",
            ""    tail = 3"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            ""line = type(\""Mock\"", (object,), {})()"",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            ""def bracket_split_build_line(*args, **kwargs):"",
            ""    return None"",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            ""def bracket_split_succeeded_or_raise(*args, **kwargs):"",
            ""    pass""
        ],
        ""initialization"": [
            ""line.leaves = [Leaf('('), Leaf('content'), Leaf(')')]""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET', 'BRACKET'), Leaf('some_type'), Leaf('CLOSING_BRACKET', 'BRACKET')]})()"",
            """",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from enum import Enum"",
            ""from dataclasses import dataclass""
        ],
        ""initialization"": [
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    opening_bracket: Optional['Leaf'] = None"",
            ""    def __init__(self, type: int, opening_bracket: Optional['Leaf'] = None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class MockLine:"",
            ""    def __init__(self, leaves):"",
            ""        self.leaves = leaves"",
            """",
            ""line = MockLine([Leaf(type=1), Leaf(type=2)])"",
            """",
            ""CLOSING_BRACKETS = {2}"",
            ""OPENING_BRACKETS = {1}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent(Enum):"",
            ""    head = 1"",
            ""    body = 2"",
            ""    tail = 3"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return None"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from enum import Enum"",
            ""class Leaf:"",
            ""    def __init__(self, type=None, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), {'leaves': [Leaf(type='opening', opening_bracket=None), Leaf(type='closing', opening_bracket=None)]})()"",
            ""CLOSING_BRACKETS = {'closing'}"",
            ""OPENING_BRACKETS = {'opening'}"",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'mock_result'"",
            ""class _BracketSplitComponent(Enum):"",
            ""    head = 1"",
            ""    body = 2"",
            ""    tail = 3"",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET'), Leaf('CLOSING_BRACKET')]})()"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            ""def ensure_visible(leaf): pass"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            ""class CannotSplit(Exception): pass"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return component"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'HEAD_COMPONENT', 'body': 'BODY_COMPONENT', 'tail': 'TAIL_COMPONENT'})"",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_: str, opening_bracket: Optional['Leaf'] = None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""def ensure_visible(leaf: Leaf) -> None: # pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""def bracket_split_build_line(leaves: List[Leaf], line: 'Line', matching_bracket: Leaf, component: '_BracketSplitComponent') -> Optional[Leaf]: # pragma: no cover"",
            ""    return None # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head: Optional[Leaf], body: Optional[Leaf], tail: Optional[Leaf]) -> None: # pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""class _BracketSplitComponent(Enum): # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, leaves: List[Leaf]): # pragma: no cover"",
            ""        self.leaves = leaves # pragma: no cover"",
            ""line = Line(leaves=[Leaf(type_='(', opening_bracket=None)]) # pragma: no cover"",
            ""CLOSING_BRACKETS = [')', ']', '}'] # pragma: no cover"",
            ""OPENING_BRACKETS = ['(', '[', '{'] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""Leaf = namedtuple('Leaf', ['type', 'opening_bracket']) # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': []}) # pragma: no cover"",
            ""CLOSING_BRACKETS = set() # pragma: no cover"",
            ""ensure_visible = lambda leaf: None # pragma: no cover"",
            ""OPENING_BRACKETS = set() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""bracket_split_build_line = lambda leaves, line, matching_bracket, component: None # pragma: no cover"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'}) # pragma: no cover"",
            ""bracket_split_succeeded_or_raise = lambda head, body, tail: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""import typing # pragma: no cover"",
            ""import builtins # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: pass # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf(), Leaf()]}) # pragma: no cover"",
            ""CLOSING_BRACKETS = {']', ')', '}'} # pragma: no cover"",
            ""def ensure_visible(leaf): pass # pragma: no cover"",
            ""OPENING_BRACKETS = {'[', '(', '{'} # pragma: no cover"",
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): return True # pragma: no cover"",
            ""BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'}) # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""class CannotSplit(Exception): pass # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'result' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = [')', ']', '}'] # pragma: no cover"",
            ""OPENING_BRACKETS = ['(', '[', '{'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf('arg1'), Leaf(','), Leaf('arg2'), Leaf(')')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""_BracketSplitComponent = type('Mock', (object,), { # pragma: no cover"",
            ""    'head': 'head', # pragma: no cover"",
            ""    'body': 'body', # pragma: no cover"",
            ""    'tail': 'tail' # pragma: no cover"",
            ""}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('open_bracket'), Leaf('close_bracket')]}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'close_bracket'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {'open_bracket'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent(Enum): # pragma: no cover"",
            ""    head = 1 # pragma: no cover"",
            ""    body = 2 # pragma: no cover"",
            ""    tail = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            ""line = type(\""Mock\"", (object,), {})() # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""def bracket_split_build_line(*args, **kwargs): # pragma: no cover"",
            ""    return None # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(*args, **kwargs): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ],
        ""initialization"": [
            ""line.leaves = [Leaf('('), Leaf('content'), Leaf(')')] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET', 'BRACKET'), Leaf('some_type'), Leaf('CLOSING_BRACKET', 'BRACKET')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""from dataclasses import dataclass # pragma: no cover""
        ],
        ""initialization"": [
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    opening_bracket: Optional['Leaf'] = None # pragma: no cover"",
            ""    def __init__(self, type: int, opening_bracket: Optional['Leaf'] = None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLine: # pragma: no cover"",
            ""    def __init__(self, leaves): # pragma: no cover"",
            ""        self.leaves = leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = MockLine([Leaf(type=1), Leaf(type=2)]) # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {2} # pragma: no cover"",
            ""OPENING_BRACKETS = {1} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent(Enum): # pragma: no cover"",
            ""    head = 1 # pragma: no cover"",
            ""    body = 2 # pragma: no cover"",
            ""    tail = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type=None, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), {'leaves': [Leaf(type='opening', opening_bracket=None), Leaf(type='closing', opening_bracket=None)]})() # pragma: no cover"",
            ""CLOSING_BRACKETS = {'closing'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'opening'} # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'mock_result' # pragma: no cover"",
            ""class _BracketSplitComponent(Enum): # pragma: no cover"",
            ""    head = 1 # pragma: no cover"",
            ""    body = 2 # pragma: no cover"",
            ""    tail = 3 # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET'), Leaf('CLOSING_BRACKET')]})() # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            ""def ensure_visible(leaf): pass # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return component # pragma: no cover"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'HEAD_COMPONENT', 'body': 'BODY_COMPONENT', 'tail': 'TAIL_COMPONENT'}) # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    }
]",1,723,0.0003615,2579,0.0038685,0.00423
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 43:
    raise CannotSplit(""No brackets found"")
__main__.CannotSplit: No brackets found
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from collections import namedtuple""
        ],
        ""initialization"": [
            ""Leaf = namedtuple('Leaf', ['type', 'opening_bracket'])"",
            ""line = type('Mock', (object,), {'leaves': [Leaf(type='(', opening_bracket=None), Leaf(type=')', opening_bracket=None)]})"",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""ensure_visible = lambda leaf: None"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""bracket_split_build_line = lambda leaves, line, matching_bracket, component: f'built_line_{component}'"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'})"",
            ""bracket_split_succeeded_or_raise = lambda head, body, tail: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from collections import namedtuple"",
            ""import sys""
        ],
        ""initialization"": [
            ""Leaf = namedtuple('Leaf', ['type', 'opening_bracket'])"",
            ""sample_opening_leaf = Leaf(type='(', opening_bracket=None)"",
            ""sample_closing_leaf = Leaf(type=')', opening_bracket=sample_opening_leaf)"",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            ""line = type('Mock', (object,), {'leaves': [sample_opening_leaf, sample_closing_leaf]})"",
            ""ensure_visible = lambda leaf: None"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""bracket_split_build_line = lambda leaves, line, matching_bracket, component: 'result'"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'})"",
            ""bracket_split_succeeded_or_raise = lambda head, body, tail: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from collections import namedtuple"",
            ""import sys""
        ],
        ""initialization"": [
            ""Leaf = namedtuple('Leaf', ['type', 'opening_bracket'])"",
            ""line = type('Mock', (object,), {'leaves': [Leaf(type='(', opening_bracket=None), Leaf(type=')', opening_bracket=None)]})"",
            ""CLOSING_BRACKETS = {')'}"",
            ""ensure_visible = lambda leaf: None"",
            ""OPENING_BRACKETS = {'('}"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""bracket_split_build_line = lambda leaves, line, matching_bracket, component: leaves"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'})"",
            ""bracket_split_succeeded_or_raise = lambda head, body, tail: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from collections import namedtuple""
        ],
        ""initialization"": [
            ""Leaf = namedtuple('Leaf', ['type', 'opening_bracket'])"",
            ""example_leaves = [Leaf(type='OPEN_BRACKET', opening_bracket=None), Leaf(type='CLOSING_BRACKET', opening_bracket=None)]"",
            ""line = type('Mock', (object,), {'leaves': example_leaves})"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            ""OPENING_BRACKETS = {'OPEN_BRACKET'}"",
            ""ensure_visible = lambda leaf: None"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""bracket_split_build_line = lambda leaves, line, matching_bracket, component: leaves"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'})"",
            ""bracket_split_succeeded_or_raise = lambda head, body, tail: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from collections import namedtuple"",
            ""import sys""
        ],
        ""initialization"": [
            ""Leaf = namedtuple('Leaf', ['type', 'opening_bracket'])"",
            ""line = type('Mock', (object,), {'leaves': [Leaf(type='(', opening_bracket=None), Leaf(type=')', opening_bracket=None)]})"",
            ""CLOSING_BRACKETS = {')'}"",
            ""ensure_visible = lambda leaf: None"",
            ""OPENING_BRACKETS = {'('}"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""bracket_split_build_line = lambda leaves, line, matching_bracket, component: f'{component} line with {len(leaves)} leaves'"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'})"",
            ""bracket_split_succeeded_or_raise = lambda head, body, tail: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from collections import namedtuple""
        ],
        ""initialization"": [
            ""Leaf = namedtuple('Leaf', ['type', 'opening_bracket'])"",
            ""line = type('Mock', (object,), {'leaves': [Leaf(type='OPEN_BRACKET', opening_bracket=None), Leaf(type='CLOSE_BRACKET', opening_bracket=None)]})"",
            ""CLOSING_BRACKETS = {'CLOSE_BRACKET'}"",
            ""ensure_visible = lambda leaf: None"",
            ""OPENING_BRACKETS = {'OPEN_BRACKET'}"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""bracket_split_build_line = lambda leaves, line, matching_bracket, component: 'line' if leaves else None"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'})"",
            ""bracket_split_succeeded_or_raise = lambda head, body, tail: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from collections import namedtuple""
        ],
        ""initialization"": [
            ""Leaf = namedtuple('Leaf', ['type', 'opening_bracket'])"",
            ""line = type('Mock', (object,), {'leaves': [Leaf(type='open_bracket', opening_bracket=None), Leaf(type='close_bracket', opening_bracket=None)]})"",
            ""CLOSING_BRACKETS = {'close_bracket'}"",
            ""ensure_visible = lambda leaf: None"",
            ""OPENING_BRACKETS = {'open_bracket'}"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""bracket_split_build_line = lambda leaves, line, matching_bracket, component: leaves"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'})"",
            ""bracket_split_succeeded_or_raise = lambda head, body, tail: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from collections import namedtuple"",
            ""import sys""
        ],
        ""initialization"": [
            ""Leaf = namedtuple('Leaf', ['type', 'opening_bracket'])"",
            ""leaf1 = Leaf(type='OPEN_BRACKET', opening_bracket=None)"",
            ""leaf2 = Leaf(type='CLOSE_BRACKET', opening_bracket=leaf1)"",
            ""line = type('Mock', (object,), {'leaves': [leaf1, leaf2]})()"",
            ""CLOSING_BRACKETS = {'CLOSE_BRACKET'}"",
            ""OPENING_BRACKETS = {'OPEN_BRACKET'}"",
            ""ensure_visible = lambda leaf: None"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""bracket_split_build_line = lambda leaves, line, matching_bracket, component: f'line_with_{component}'"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'})"",
            ""bracket_split_succeeded_or_raise = lambda head, body, tail: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from collections import namedtuple"",
            ""import enum""
        ],
        ""initialization"": [
            ""Leaf = namedtuple('Leaf', ['type', 'opening_bracket'])"",
            ""line = type('Mock', (object,), {'leaves': [Leaf(type='(', opening_bracket=None), Leaf(type=')', opening_bracket=None)]})"",
            ""CLOSING_BRACKETS = {')'}"",
            ""ensure_visible = lambda leaf: None"",
            ""OPENING_BRACKETS = {'('}"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""bracket_split_build_line = lambda leaves, line, matching_bracket, component: 'result'"",
            ""_BracketSplitComponent = enum.Enum('_BracketSplitComponent', 'head body tail')"",
            ""bracket_split_succeeded_or_raise = lambda head, body, tail: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from collections import namedtuple""
        ],
        ""initialization"": [
            ""Leaf = namedtuple('Leaf', ['type', 'opening_bracket'])"",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""matching_bracket_leaf = Leaf(type='(', opening_bracket=None)"",
            ""line = type('Mock', (object,), {'leaves': [matching_bracket_leaf, Leaf(type=')', opening_bracket=matching_bracket_leaf)]})"",
            ""ensure_visible = lambda leaf: None"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""bracket_split_build_line = lambda leaves, line, matching_bracket, component: leaves"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'})"",
            ""bracket_split_succeeded_or_raise = lambda head, body, tail: None""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover""
        ],
        ""initialization"": [
            ""Leaf = namedtuple('Leaf', ['type', 'opening_bracket']) # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf(type='(', opening_bracket=None), Leaf(type=')', opening_bracket=None)]}) # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""ensure_visible = lambda leaf: None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""bracket_split_build_line = lambda leaves, line, matching_bracket, component: f'built_line_{component}' # pragma: no cover"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'}) # pragma: no cover"",
            ""bracket_split_succeeded_or_raise = lambda head, body, tail: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""Leaf = namedtuple('Leaf', ['type', 'opening_bracket']) # pragma: no cover"",
            ""sample_opening_leaf = Leaf(type='(', opening_bracket=None) # pragma: no cover"",
            ""sample_closing_leaf = Leaf(type=')', opening_bracket=sample_opening_leaf) # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [sample_opening_leaf, sample_closing_leaf]}) # pragma: no cover"",
            ""ensure_visible = lambda leaf: None # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""bracket_split_build_line = lambda leaves, line, matching_bracket, component: 'result' # pragma: no cover"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'}) # pragma: no cover"",
            ""bracket_split_succeeded_or_raise = lambda head, body, tail: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""Leaf = namedtuple('Leaf', ['type', 'opening_bracket']) # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf(type='(', opening_bracket=None), Leaf(type=')', opening_bracket=None)]}) # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""ensure_visible = lambda leaf: None # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""bracket_split_build_line = lambda leaves, line, matching_bracket, component: leaves # pragma: no cover"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'}) # pragma: no cover"",
            ""bracket_split_succeeded_or_raise = lambda head, body, tail: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover""
        ],
        ""initialization"": [
            ""Leaf = namedtuple('Leaf', ['type', 'opening_bracket']) # pragma: no cover"",
            ""example_leaves = [Leaf(type='OPEN_BRACKET', opening_bracket=None), Leaf(type='CLOSING_BRACKET', opening_bracket=None)] # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': example_leaves}) # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPEN_BRACKET'} # pragma: no cover"",
            ""ensure_visible = lambda leaf: None # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""bracket_split_build_line = lambda leaves, line, matching_bracket, component: leaves # pragma: no cover"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'}) # pragma: no cover"",
            ""bracket_split_succeeded_or_raise = lambda head, body, tail: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""Leaf = namedtuple('Leaf', ['type', 'opening_bracket']) # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf(type='(', opening_bracket=None), Leaf(type=')', opening_bracket=None)]}) # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""ensure_visible = lambda leaf: None # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""bracket_split_build_line = lambda leaves, line, matching_bracket, component: f'{component} line with {len(leaves)} leaves' # pragma: no cover"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'}) # pragma: no cover"",
            ""bracket_split_succeeded_or_raise = lambda head, body, tail: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover""
        ],
        ""initialization"": [
            ""Leaf = namedtuple('Leaf', ['type', 'opening_bracket']) # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf(type='OPEN_BRACKET', opening_bracket=None), Leaf(type='CLOSE_BRACKET', opening_bracket=None)]}) # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSE_BRACKET'} # pragma: no cover"",
            ""ensure_visible = lambda leaf: None # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPEN_BRACKET'} # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""bracket_split_build_line = lambda leaves, line, matching_bracket, component: 'line' if leaves else None # pragma: no cover"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'}) # pragma: no cover"",
            ""bracket_split_succeeded_or_raise = lambda head, body, tail: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover""
        ],
        ""initialization"": [
            ""Leaf = namedtuple('Leaf', ['type', 'opening_bracket']) # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf(type='open_bracket', opening_bracket=None), Leaf(type='close_bracket', opening_bracket=None)]}) # pragma: no cover"",
            ""CLOSING_BRACKETS = {'close_bracket'} # pragma: no cover"",
            ""ensure_visible = lambda leaf: None # pragma: no cover"",
            ""OPENING_BRACKETS = {'open_bracket'} # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""bracket_split_build_line = lambda leaves, line, matching_bracket, component: leaves # pragma: no cover"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'}) # pragma: no cover"",
            ""bracket_split_succeeded_or_raise = lambda head, body, tail: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""Leaf = namedtuple('Leaf', ['type', 'opening_bracket']) # pragma: no cover"",
            ""leaf1 = Leaf(type='OPEN_BRACKET', opening_bracket=None) # pragma: no cover"",
            ""leaf2 = Leaf(type='CLOSE_BRACKET', opening_bracket=leaf1) # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [leaf1, leaf2]})() # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSE_BRACKET'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPEN_BRACKET'} # pragma: no cover"",
            ""ensure_visible = lambda leaf: None # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""bracket_split_build_line = lambda leaves, line, matching_bracket, component: f'line_with_{component}' # pragma: no cover"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'}) # pragma: no cover"",
            ""bracket_split_succeeded_or_raise = lambda head, body, tail: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover"",
            ""import enum # pragma: no cover""
        ],
        ""initialization"": [
            ""Leaf = namedtuple('Leaf', ['type', 'opening_bracket']) # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf(type='(', opening_bracket=None), Leaf(type=')', opening_bracket=None)]}) # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""ensure_visible = lambda leaf: None # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""bracket_split_build_line = lambda leaves, line, matching_bracket, component: 'result' # pragma: no cover"",
            ""_BracketSplitComponent = enum.Enum('_BracketSplitComponent', 'head body tail') # pragma: no cover"",
            ""bracket_split_succeeded_or_raise = lambda head, body, tail: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover""
        ],
        ""initialization"": [
            ""Leaf = namedtuple('Leaf', ['type', 'opening_bracket']) # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""matching_bracket_leaf = Leaf(type='(', opening_bracket=None) # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [matching_bracket_leaf, Leaf(type=')', opening_bracket=matching_bracket_leaf)]}) # pragma: no cover"",
            ""ensure_visible = lambda leaf: None # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""bracket_split_build_line = lambda leaves, line, matching_bracket, component: leaves # pragma: no cover"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'}) # pragma: no cover"",
            ""bracket_split_succeeded_or_raise = lambda head, body, tail: None # pragma: no cover""
        ]
    }
]",2,1215,0.0006075,2330,0.003495,0.0041025
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 39:
    if leaf.type in OPENING_BRACKETS:
AttributeError: 'Leaf' object has no attribute 'type'
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:\n    def __init__(self, type, opening_bracket=None):\n        self.type = type\n        self.opening_bracket = opening_bracket"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf('identifier1'), Leaf(')'), Leaf('}')]} )"",
            ""CLOSING_BRACKETS = {']', ')', '}'}"",
            ""def ensure_visible(leaf): pass"",
            ""OPENING_BRACKETS = {'[', '(', '{'}"",
            ""class CannotSplit(Exception): pass"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): return True"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'})"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""import builtins""
        ],
        ""initialization"": [
            ""class Leaf: \n\tdef __init__(self, type, opening_bracket=None):\n\t\tself.type = type\n\t\tself.opening_bracket = opening_bracket"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf(')')]})"",
            ""CLOSING_BRACKETS = {']', ')', '}'}"",
            ""def ensure_visible(leaf): pass"",
            ""OPENING_BRACKETS = {'[', '(', '{'}"",
            ""class CannotSplit(Exception): pass"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): return True"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'})"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""import typing"",
            ""import builtins""
        ],
        ""initialization"": [
            ""class Leaf: def __init__(self, leaf_type, opening_bracket=None): self.type = leaf_type; self.opening_bracket = opening_bracket"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf('identifier'), Leaf(')')]})"",
            ""CLOSING_BRACKETS = {']', ')', '}'}"",
            ""def ensure_visible(leaf): pass"",
            ""OPENING_BRACKETS = {'[', '(', '{'}"",
            ""class CannotSplit(Exception): pass"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): return 'result_' + component"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'})"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:\n    def __init__(self, leaf_type, opening_bracket=None):\n        self.type = leaf_type\n        self.opening_bracket = opening_bracket"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf('NAME'), Leaf(')')]})"",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""def ensure_visible(leaf): pass"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""class CannotSplit(Exception): pass"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): return f'{component} line'"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'})"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""import typing"",
            ""import builtins""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, leaf_type, opening_bracket=None):"",
            ""        self.type = leaf_type"",
            ""        self.opening_bracket = opening_bracket"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf(')')]})"",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""def ensure_visible(leaf): pass"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""class CannotSplit(Exception): pass"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): return leaves"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'})"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:\n    def __init__(self, type, opening_bracket=None):\n        self.type = type\n        self.opening_bracket = opening_bracket"",
            ""line = type('Mock', (object,), {'leaves': [Leaf(type='('), Leaf(type='token', opening_bracket=None), Leaf(type=')', opening_bracket=None)]})"",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""def ensure_visible(leaf): pass"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""class CannotSplit(Exception): pass"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): return 'result'"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'})"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:\n    def __init__(self, type, opening_bracket=None):\n        self.type = type\n        self.opening_bracket = opening_bracket"",
            ""CLOSING_BRACKETS = {']', ')', '}'}"",
            ""OPENING_BRACKETS = {'[', '(', '{'}"",
            ""ensure_visible = lambda leaf: None"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): return True"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'})"",
            ""bracket_split_succeeded_or_raise = lambda head, body, tail: None"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf('OTHER'), Leaf(')')]})""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""import builtins""
        ],
        ""initialization"": [
            ""class Leaf: pass"",
            ""class Leaf: def __init__(self, type, opening_bracket=None): self.type = type; self.opening_bracket = opening_bracket"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf(')')]})"",
            ""CLOSING_BRACKETS = {')'}"",
            ""def ensure_visible(leaf): pass"",
            ""OPENING_BRACKETS = {'('}"",
            ""class CannotSplit(Exception): pass"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): return 'result_' + component.name"",
            ""BracketSplitComponent = type('Mock', (object,), {'head': type('Head', (), {'name': 'head'}), 'body': type('Body', (), {'name': 'body'}), 'tail': type('Tail', (), {'name': 'tail'})})"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:\n    def __init__(self, type_, opening_bracket=None):\n        self.type = type_\n        self.opening_bracket = opening_bracket"",
            ""line = type('Mock', (object,), {'leaves': [Leaf(type_='('), Leaf(type_=')')]})"",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""def ensure_visible(leaf):\n    pass"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""class CannotSplit(Exception):\n    pass"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):\n    return f\""Component: {component}, Leaves: {leaves}, Matching Bracket: {matching_bracket}\"""",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'})"",
            ""def bracket_split_succeeded_or_raise(head, body, tail):\n    print(f\""Head: {head}, Body: {body}, Tail: {tail}\"")""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""import typing"",
            ""import builtins""
        ],
        ""initialization"": [
            ""class Leaf:\n    def __init__(self, type, opening_bracket=None):\n        self.type = type\n        self.opening_bracket = opening_bracket"",
            ""line = type('Mock', (object,), {'leaves': [Leaf(type='['), Leaf(type=']')]})"",
            ""CLOSING_BRACKETS = {']', ')', '}'}"",
            ""def ensure_visible(leaf): pass"",
            ""OPENING_BRACKETS = {'[', '(', '{'}"",
            ""class CannotSplit(Exception): pass"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): return type('Mock', (object,), {'result': True})"",
            ""BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'})"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): pass""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf('identifier1'), Leaf(')'), Leaf('}')]} ) # pragma: no cover"",
            ""CLOSING_BRACKETS = {']', ')', '}'} # pragma: no cover"",
            ""def ensure_visible(leaf): pass # pragma: no cover"",
            ""OPENING_BRACKETS = {'[', '(', '{'} # pragma: no cover"",
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): return True # pragma: no cover"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'}) # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""import builtins # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""\tdef __init__(self, type, opening_bracket=None):# pragma: no cover"",
            ""\t\tself.type = type# pragma: no cover"",
            ""\t\tself.opening_bracket = opening_bracket # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf(')')]}) # pragma: no cover"",
            ""CLOSING_BRACKETS = {']', ')', '}'} # pragma: no cover"",
            ""def ensure_visible(leaf): pass # pragma: no cover"",
            ""OPENING_BRACKETS = {'[', '(', '{'} # pragma: no cover"",
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): return True # pragma: no cover"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'}) # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""import typing # pragma: no cover"",
            ""import builtins # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, leaf_type, opening_bracket=None):# pragma: no cover"",
            ""        self.type = leaf_type# pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf('NAME'), Leaf(')')]}) # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""def ensure_visible(leaf): pass # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): return f'{component} line' # pragma: no cover"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'}) # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""import typing # pragma: no cover"",
            ""import builtins # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, leaf_type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = leaf_type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf(')')]}) # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""def ensure_visible(leaf): pass # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): return leaves # pragma: no cover"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'}) # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf(type='('), Leaf(type='token', opening_bracket=None), Leaf(type=')', opening_bracket=None)]}) # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""def ensure_visible(leaf): pass # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): return 'result' # pragma: no cover"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'}) # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            ""CLOSING_BRACKETS = {']', ')', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'[', '(', '{'} # pragma: no cover"",
            ""ensure_visible = lambda leaf: None # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): return True # pragma: no cover"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'}) # pragma: no cover"",
            ""bracket_split_succeeded_or_raise = lambda head, body, tail: None # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf('OTHER'), Leaf(')')]}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""import builtins # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type_, opening_bracket=None):# pragma: no cover"",
            ""        self.type = type_# pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf(type_='('), Leaf(type_=')')]}) # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""def ensure_visible(leaf):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""class CannotSplit(Exception):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):# pragma: no cover"",
            ""    return f\""Component: {component}, Leaves: {leaves}, Matching Bracket: {matching_bracket}\"" # pragma: no cover"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'}) # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail):# pragma: no cover"",
            ""    print(f\""Head: {head}, Body: {body}, Tail: {tail}\"") # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""import typing # pragma: no cover"",
            ""import builtins # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf(type='['), Leaf(type=']')]}) # pragma: no cover"",
            ""CLOSING_BRACKETS = {']', ')', '}'} # pragma: no cover"",
            ""def ensure_visible(leaf): pass # pragma: no cover"",
            ""OPENING_BRACKETS = {'[', '(', '{'} # pragma: no cover"",
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): return type('Mock', (object,), {'result': True}) # pragma: no cover"",
            ""BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'}) # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): pass # pragma: no cover""
        ]
    }
]",2,1705,0.0008525,2374,0.003561,0.0044135
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line :
result
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""class CannotSplit(Exception): pass""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return None"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""CLOSING_BRACKETS = [')', ']', '}']"",
            ""OPENING_BRACKETS = ['(', '[', '{']"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf('arg1'), Leaf(','), Leaf('arg2'), Leaf(')')]})()"",
            """",
            ""_BracketSplitComponent = type('Mock', (object,), {"",
            ""    'head': 'head',"",
            ""    'body': 'body',"",
            ""    'tail': 'tail'"",
            ""})""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return ''"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""CLOSING_BRACKETS = [')', ']', '}']"",
            ""OPENING_BRACKETS = ['(', '[', '{']"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf('arg1'), Leaf(','), Leaf('arg2'), Leaf(')')]})()"",
            """",
            ""_BracketSplitComponent = type('Mock', (object,), {"",
            ""    'head': 'head',"",
            ""    'body': 'body',"",
            ""    'tail': 'tail'"",
            ""})""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, leaf_type, opening_bracket=None):"",
            ""        self.type = leaf_type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return None  # Emulate successful line build"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""CLOSING_BRACKETS = [')', ']', '}']"",
            ""OPENING_BRACKETS = ['(', '[', '{']"",
            """",
            ""line = type('Mock', (object,), {'leaves': ["",
            ""    Leaf('(', leaf_type='('),"",
            ""    Leaf('name'),"",
            ""    Leaf(',', type=','),"",
            ""    Leaf('name2'),"",
            ""    Leaf(')', leaf_type=')')"",
            ""]})()"",
            """",
            ""_BracketSplitComponent = type('Mock', (object,), {"",
            ""    'head': 'head',"",
            ""    'body': 'body',"",
            ""    'tail': 'tail'"",
            ""})""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return None"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""CLOSING_BRACKETS = [')', ']', '}']"",
            ""OPENING_BRACKETS = ['(', '[', '{']"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf('arg1'), Leaf(','), Leaf('arg2'), Leaf(')')]})()"",
            """",
            ""_BracketSplitComponent = type('Mock', (object,), {"",
            ""    'head': 'head',"",
            ""    'body': 'body',"",
            ""    'tail': 'tail'"",
            ""})""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception): pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return ''"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""CLOSING_BRACKETS = [')', ']', '}']"",
            ""OPENING_BRACKETS = ['(', '[', '{']"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf('name'), Leaf(','), Leaf('arg1'), Leaf(')')]})()"",
            """",
            ""_BracketSplitComponent = type('Mock', (object,), {"",
            ""    'head': 'head',"",
            ""    'body': 'body',"",
            ""    'tail': 'tail'"",
            ""})""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return None"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""CLOSING_BRACKETS = [')', ']', '}']"",
            ""OPENING_BRACKETS = ['(', '[', '{']"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf('arg1'), Leaf(','), Leaf('arg2'), Leaf(')')]})()"",
            """",
            ""_BracketSplitComponent = type('Mock', (object,), {"",
            ""    'head': 'head',"",
            ""    'body': 'body',"",
            ""    'tail': 'tail'"",
            ""})""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""class CannotSplit(Exception): pass""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return ''"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""CLOSING_BRACKETS = [')', ']', '}']"",
            ""OPENING_BRACKETS = ['(', '[', '{']"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('(', '['), Leaf('arg1'), Leaf(','), Leaf('arg2'), Leaf(')', '[')]})()"",
            """",
            ""_BracketSplitComponent = type('Mock', (object,), {"",
            ""    'head': 'head',"",
            ""    'body': 'body',"",
            ""    'tail': 'tail'"",
            ""})""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'result'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""CLOSING_BRACKETS = [')', ']', '}']"",
            ""OPENING_BRACKETS = ['(', '[', '{']"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf('arg1'), Leaf(','), Leaf('arg2'), Leaf(')')]})()"",
            """",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'})"",
            """",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            """",
            ""def exit(result):"",
            ""    if result != 'result':"",
            ""        sys.exit(result)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""class CannotSplit(Exception): pass""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return None"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""CLOSING_BRACKETS = [')', ']', '}']"",
            ""OPENING_BRACKETS = ['(', '[', '{']"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf('arg1'), Leaf(','), Leaf('arg2'), Leaf(')')]})()"",
            """",
            ""_BracketSplitComponent = type('Mock', (object,), {"",
            ""    'head': 'head',"",
            ""    'body': 'body',"",
            ""    'tail': 'tail'"",
            ""})""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return None"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""CLOSING_BRACKETS = [')', ']', '}']"",
            ""OPENING_BRACKETS = ['(', '[', '{']"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf('arg1'), Leaf(','), Leaf('arg2'), Leaf(')')]})()"",
            """",
            ""_BracketSplitComponent = type('Mock', (object,), {"",
            ""    'head': 'head',"",
            ""    'body': 'body',"",
            ""    'tail': 'tail'"",
            ""})"",
            """",
            ""def exit(result):"",
            ""    sys.exit(0)""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""class CannotSplit(Exception): pass # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = [')', ']', '}'] # pragma: no cover"",
            ""OPENING_BRACKETS = ['(', '[', '{'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf('arg1'), Leaf(','), Leaf('arg2'), Leaf(')')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""_BracketSplitComponent = type('Mock', (object,), { # pragma: no cover"",
            ""    'head': 'head', # pragma: no cover"",
            ""    'body': 'body', # pragma: no cover"",
            ""    'tail': 'tail' # pragma: no cover"",
            ""}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = [')', ']', '}'] # pragma: no cover"",
            ""OPENING_BRACKETS = ['(', '[', '{'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf('arg1'), Leaf(','), Leaf('arg2'), Leaf(')')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""_BracketSplitComponent = type('Mock', (object,), { # pragma: no cover"",
            ""    'head': 'head', # pragma: no cover"",
            ""    'body': 'body', # pragma: no cover"",
            ""    'tail': 'tail' # pragma: no cover"",
            ""}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = [')', ']', '}'] # pragma: no cover"",
            ""OPENING_BRACKETS = ['(', '[', '{'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf('arg1'), Leaf(','), Leaf('arg2'), Leaf(')')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""_BracketSplitComponent = type('Mock', (object,), { # pragma: no cover"",
            ""    'head': 'head', # pragma: no cover"",
            ""    'body': 'body', # pragma: no cover"",
            ""    'tail': 'tail' # pragma: no cover"",
            ""}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = [')', ']', '}'] # pragma: no cover"",
            ""OPENING_BRACKETS = ['(', '[', '{'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf('name'), Leaf(','), Leaf('arg1'), Leaf(')')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""_BracketSplitComponent = type('Mock', (object,), { # pragma: no cover"",
            ""    'head': 'head', # pragma: no cover"",
            ""    'body': 'body', # pragma: no cover"",
            ""    'tail': 'tail' # pragma: no cover"",
            ""}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = [')', ']', '}'] # pragma: no cover"",
            ""OPENING_BRACKETS = ['(', '[', '{'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf('arg1'), Leaf(','), Leaf('arg2'), Leaf(')')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""_BracketSplitComponent = type('Mock', (object,), { # pragma: no cover"",
            ""    'head': 'head', # pragma: no cover"",
            ""    'body': 'body', # pragma: no cover"",
            ""    'tail': 'tail' # pragma: no cover"",
            ""}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""class CannotSplit(Exception): pass # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = [')', ']', '}'] # pragma: no cover"",
            ""OPENING_BRACKETS = ['(', '[', '{'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('(', '['), Leaf('arg1'), Leaf(','), Leaf('arg2'), Leaf(')', '[')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""_BracketSplitComponent = type('Mock', (object,), { # pragma: no cover"",
            ""    'head': 'head', # pragma: no cover"",
            ""    'body': 'body', # pragma: no cover"",
            ""    'tail': 'tail' # pragma: no cover"",
            ""}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'result' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = [')', ']', '}'] # pragma: no cover"",
            ""OPENING_BRACKETS = ['(', '[', '{'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf('arg1'), Leaf(','), Leaf('arg2'), Leaf(')')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""class CannotSplit(Exception): pass # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = [')', ']', '}'] # pragma: no cover"",
            ""OPENING_BRACKETS = ['(', '[', '{'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf('arg1'), Leaf(','), Leaf('arg2'), Leaf(')')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""_BracketSplitComponent = type('Mock', (object,), { # pragma: no cover"",
            ""    'head': 'head', # pragma: no cover"",
            ""    'body': 'body', # pragma: no cover"",
            ""    'tail': 'tail' # pragma: no cover"",
            ""}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = [')', ']', '}'] # pragma: no cover"",
            ""OPENING_BRACKETS = ['(', '[', '{'] # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf('arg1'), Leaf(','), Leaf('arg2'), Leaf(')')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""_BracketSplitComponent = type('Mock', (object,), { # pragma: no cover"",
            ""    'head': 'head', # pragma: no cover"",
            ""    'body': 'body', # pragma: no cover"",
            ""    'tail': 'tail' # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover""
        ]
    }
]",2,2254,0.001127,2826,0.004239,0.0053659999999999
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line :
[<__main__.Leaf object at 0x7fbbb3da9ac0>]
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': ["",
            ""    Leaf('open_bracket'),"",
            ""    Leaf('name', opening_bracket=Leaf('open_bracket')),"",
            ""    Leaf('close_bracket', opening_bracket=Leaf('open_bracket'))"",
            ""]})()"",
            """",
            ""CLOSING_BRACKETS = {'close_bracket'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""OPENING_BRACKETS = {'open_bracket'}"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'success'"",
            """",
            ""class _BracketSplitComponent(Enum):"",
            ""    head = 1"",
            ""    body = 2"",
            ""    tail = 3"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': ["",
            ""    Leaf('open_bracket'),"",
            ""    Leaf('name'),"",
            ""    Leaf('closed_bracket', opening_bracket=Leaf('open_bracket'))"",
            ""]})()"",
            """",
            ""CLOSING_BRACKETS = {'closed_bracket'}"",
            ""OPENING_BRACKETS = {'open_bracket'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return None"",
            """",
            ""class _BracketSplitComponent(Enum):"",
            ""    head = 1"",
            ""    body = 2"",
            ""    tail = 3"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""def exit(result):"",
            ""    if result:"",
            ""        sys.exit(0)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': ["",
            ""    Leaf('open_bracket', None), Leaf('arg1', None), Leaf('comma', None), Leaf('arg2', None), Leaf('close_bracket', None)"",
            ""]})()"",
            """",
            ""CLOSING_BRACKETS = {'close_bracket'}"",
            """",
            ""def ensure_visible(leaf): pass"",
            """",
            ""OPENING_BRACKETS = {'open_bracket'}"",
            """",
            ""class CannotSplit(Exception): pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): return 'success'"",
            """",
            ""class _BracketSplitComponent(Enum):"",
            ""    head = 1"",
            ""    body = 2"",
            ""    tail = 3"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail): pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('open_bracket', None), Leaf('content', 'open_bracket'), Leaf('close_bracket', 'open_bracket')]})()"",
            """",
            ""CLOSING_BRACKETS = {'close_bracket'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""OPENING_BRACKETS = {'open_bracket'}"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    # This function should return a dummy object to avoid code execution termination"",
            ""    return type('DummyResult', (object,), {'is_successful': True})()"",
            """",
            ""class _BracketSplitComponent(Enum):"",
            ""    head = 1"",
            ""    body = 2"",
            ""    tail = 3"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('open_bracket'), Leaf('content'), Leaf('close_bracket')]})()"",
            """",
            ""CLOSING_BRACKETS = {'close_bracket'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""OPENING_BRACKETS = {'open_bracket'}"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'success'"",
            """",
            ""class _BracketSplitComponent(Enum):"",
            ""    head = 1"",
            ""    body = 2"",
            ""    tail = 3"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': ["",
            ""    Leaf('open_bracket', opening_bracket=None),"",
            ""    Leaf('arg1', opening_bracket=Leaf('open_bracket')),"",
            ""    Leaf('comma', opening_bracket=Leaf('open_bracket')),"",
            ""    Leaf('arg2', opening_bracket=Leaf('open_bracket')),"",
            ""    Leaf('close_bracket', opening_bracket=Leaf('open_bracket'))"",
            "" ]})()"",
            """",
            ""CLOSING_BRACKETS = {'close_bracket'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""OPENING_BRACKETS = {'open_bracket'}"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'dummy_result'"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None, value=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            ""        self.value = value"",
            """",
            ""leaves = ["",
            ""    Leaf(type='open_bracket', opening_bracket=None, value='('),"",
            ""    Leaf(type='content', opening_bracket=None, value='arg1'),"",
            ""    Leaf(type='separator', opening_bracket=None, value=','),"",
            ""    Leaf(type='content', opening_bracket=None, value='arg2'),"",
            ""    Leaf(type='close_bracket', opening_bracket=None, value=')')"",
            ""]"",
            ""line = type('Mock', (object,), {'leaves': leaves})"",
            """",
            ""CLOSING_BRACKETS = {'close_bracket'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""OPENING_BRACKETS = {'open_bracket'}"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    # Simulating building line"",
            ""    return ' '.join([leaf.value for leaf in leaves])"",
            """",
            ""class _BracketSplitComponent(Enum):"",
            ""    head = 1"",
            ""    body = 2"",
            ""    tail = 3"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': ["",
            ""    Leaf(type='open_bracket'),"",
            ""    Leaf(type='name'),"",
            ""    Leaf(type='close_bracket', opening_bracket='open_bracket')"",
            ""]})()"",
            """",
            ""CLOSING_BRACKETS = {'close_bracket'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""OPENING_BRACKETS = {'open_bracket'}"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'completed'"",
            """",
            ""class _BracketSplitComponent(Enum):"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from enum import Enum"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('open_bracket'), Leaf('arg1'), Leaf('close_bracket', opening_bracket=Leaf('open_bracket'))]})()"",
            """",
            ""CLOSING_BRACKETS = {'close_bracket'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""OPENING_BRACKETS = {'open_bracket'}"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return None"",
            """",
            ""class _BracketSplitComponent(Enum):"",
            ""    head = 1"",
            ""    body = 2"",
            ""    tail = 3"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""exit = sys.exit""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('open_bracket', None), Leaf('content', None), Leaf('close_bracket', 'open_bracket')]})()"",
            """",
            ""CLOSING_BRACKETS = {'close_bracket'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""OPENING_BRACKETS = {'open_bracket'}"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return None"",
            """",
            ""class _BracketSplitComponent(Enum):"",
            ""    head = 1"",
            ""    body = 2"",
            ""    tail = 3"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [ # pragma: no cover"",
            ""    Leaf('open_bracket'), # pragma: no cover"",
            ""    Leaf('name', opening_bracket=Leaf('open_bracket')), # pragma: no cover"",
            ""    Leaf('close_bracket', opening_bracket=Leaf('open_bracket')) # pragma: no cover"",
            ""]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'close_bracket'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {'open_bracket'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'success' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent(Enum): # pragma: no cover"",
            ""    head = 1 # pragma: no cover"",
            ""    body = 2 # pragma: no cover"",
            ""    tail = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [ # pragma: no cover"",
            ""    Leaf('open_bracket'), # pragma: no cover"",
            ""    Leaf('name'), # pragma: no cover"",
            ""    Leaf('closed_bracket', opening_bracket=Leaf('open_bracket')) # pragma: no cover"",
            ""]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'closed_bracket'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'open_bracket'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return None # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent(Enum): # pragma: no cover"",
            ""    head = 1 # pragma: no cover"",
            ""    body = 2 # pragma: no cover"",
            ""    tail = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [ # pragma: no cover"",
            ""    Leaf('open_bracket', None), Leaf('arg1', None), Leaf('comma', None), Leaf('arg2', None), Leaf('close_bracket', None) # pragma: no cover"",
            ""]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'close_bracket'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {'open_bracket'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): return 'success' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent(Enum): # pragma: no cover"",
            ""    head = 1 # pragma: no cover"",
            ""    body = 2 # pragma: no cover"",
            ""    tail = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('open_bracket', None), Leaf('content', 'open_bracket'), Leaf('close_bracket', 'open_bracket')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'close_bracket'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {'open_bracket'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    # This function should return a dummy object to avoid code execution termination # pragma: no cover"",
            ""    return type('DummyResult', (object,), {'is_successful': True})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent(Enum): # pragma: no cover"",
            ""    head = 1 # pragma: no cover"",
            ""    body = 2 # pragma: no cover"",
            ""    tail = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('open_bracket'), Leaf('content'), Leaf('close_bracket')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'close_bracket'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {'open_bracket'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'success' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent(Enum): # pragma: no cover"",
            ""    head = 1 # pragma: no cover"",
            ""    body = 2 # pragma: no cover"",
            ""    tail = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [ # pragma: no cover"",
            ""    Leaf('open_bracket', opening_bracket=None), # pragma: no cover"",
            ""    Leaf('arg1', opening_bracket=Leaf('open_bracket')), # pragma: no cover"",
            ""    Leaf('comma', opening_bracket=Leaf('open_bracket')), # pragma: no cover"",
            ""    Leaf('arg2', opening_bracket=Leaf('open_bracket')), # pragma: no cover"",
            ""    Leaf('close_bracket', opening_bracket=Leaf('open_bracket')) # pragma: no cover"",
            "" ]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'close_bracket'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {'open_bracket'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'dummy_result' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None, value=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaves = [ # pragma: no cover"",
            ""    Leaf(type='open_bracket', opening_bracket=None, value='('), # pragma: no cover"",
            ""    Leaf(type='content', opening_bracket=None, value='arg1'), # pragma: no cover"",
            ""    Leaf(type='separator', opening_bracket=None, value=','), # pragma: no cover"",
            ""    Leaf(type='content', opening_bracket=None, value='arg2'), # pragma: no cover"",
            ""    Leaf(type='close_bracket', opening_bracket=None, value=')') # pragma: no cover"",
            ""] # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': leaves}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'close_bracket'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {'open_bracket'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    # Simulating building line # pragma: no cover"",
            ""    return ' '.join([leaf.value for leaf in leaves]) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent(Enum): # pragma: no cover"",
            ""    head = 1 # pragma: no cover"",
            ""    body = 2 # pragma: no cover"",
            ""    tail = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [ # pragma: no cover"",
            ""    Leaf(type='open_bracket'), # pragma: no cover"",
            ""    Leaf(type='name'), # pragma: no cover"",
            ""    Leaf(type='close_bracket', opening_bracket='open_bracket') # pragma: no cover"",
            ""]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'close_bracket'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {'open_bracket'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'completed' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent(Enum): # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('open_bracket'), Leaf('arg1'), Leaf('close_bracket', opening_bracket=Leaf('open_bracket'))]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'close_bracket'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {'open_bracket'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return None # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent(Enum): # pragma: no cover"",
            ""    head = 1 # pragma: no cover"",
            ""    body = 2 # pragma: no cover"",
            ""    tail = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""exit = sys.exit # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('open_bracket', None), Leaf('content', None), Leaf('close_bracket', 'open_bracket')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'close_bracket'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {'open_bracket'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return None # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent(Enum): # pragma: no cover"",
            ""    head = 1 # pragma: no cover"",
            ""    body = 2 # pragma: no cover"",
            ""    tail = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    }
]",2,2809,0.0014045,3081,0.0046215,0.006026
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line :
[<__main__.Leaf object at 0x7f710656dac0>]
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class MockLine:"",
            ""    leaves = [Leaf('OPENING_BRACKET', 'BRACKET'), Leaf('type', 'BRACKET'), Leaf('CLOSING_BRACKET', 'BRACKET')]"",
            """",
            ""line = MockLine()"",
            """",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'Line with components: ' + component"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    if head and body and tail:"",
            ""        pass"",
            """",
            ""sys.exit = lambda x: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET', 'BRACKET'), Leaf('IDENTIFIER'), Leaf('CLOSING_BRACKET', 'OPENING_BRACKET')]})()"",
            """",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    class MockResult: def __bool__(self): return False; sys.stdout.write(f'{component} built\\n')"",
            ""    return MockResult()"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET', 'BRACKET'), Leaf('arg1'), Leaf(','), Leaf('arg2'), Leaf('CLOSING_BRACKET', 'BRACKET')]})()"",
            """",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return ' '.join([leaf.type for leaf in leaves])"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET', 'BRACKET'), Leaf('ARG_TYPE'), Leaf('CLOSING_BRACKET', 'BRACKET')]})()"",
            """",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'split_result'"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""sys.exit = lambda x: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET', 'BRACKET'), Leaf('some_type'), Leaf('CLOSING_BRACKET', 'BRACKET')]})()"",
            """",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return True if leaves else False"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    if not (head and body and tail):"",
            ""        raise Exception('bracket_split failed')""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET', 'BRACKET'), Leaf('ARG1'), Leaf('COMMA'), Leaf('ARG2'), Leaf('CLOSING_BRACKET', 'BRACKET')]})()"",
            """",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'Success'"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET', 'BRACKET'), Leaf('ARG'), Leaf('CLOSING_BRACKET', 'BRACKET')]})()"",
            """",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'mocked_result'"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET', 'BRACKET'), Leaf('arg1'), Leaf('CLOSING_BRACKET', 'BRACKET')]})()"",
            """",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return ' '.join(str(leaf.type) for leaf in leaves)"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class MockLine:"",
            ""    def __init__(self, leaves):"",
            ""        self.leaves = leaves"",
            """",
            ""line = MockLine([Leaf('OPENING_BRACKET', 'BRACKET'), Leaf('ARG', None), Leaf('CLOSING_BRACKET', 'BRACKET')])"",
            """",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return None"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': ["",
            ""    Leaf('OPENING_BRACKET', 'BRACKET'),"",
            ""    Leaf('ARGUMENT'),"",
            ""    Leaf('CLOSING_BRACKET', 'BRACKET')"",
            ""]})()"",
            """",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    class LineResult:"",
            ""        def __init__(self, content):"",
            ""            self.content = content"",
            ""        def __bool__(self):"",
            ""            return bool(self.content)"",
            ""    return LineResult(leaves)"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""def exit(result):"",
            ""    print(result.content)""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLine: # pragma: no cover"",
            ""    leaves = [Leaf('OPENING_BRACKET', 'BRACKET'), Leaf('type', 'BRACKET'), Leaf('CLOSING_BRACKET', 'BRACKET')] # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = MockLine() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'Line with components: ' + component # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    if head and body and tail: # pragma: no cover"",
            ""        pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""sys.exit = lambda x: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET', 'BRACKET'), Leaf('IDENTIFIER'), Leaf('CLOSING_BRACKET', 'OPENING_BRACKET')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET', 'BRACKET'), Leaf('arg1'), Leaf(','), Leaf('arg2'), Leaf('CLOSING_BRACKET', 'BRACKET')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return ' '.join([leaf.type for leaf in leaves]) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET', 'BRACKET'), Leaf('ARG_TYPE'), Leaf('CLOSING_BRACKET', 'BRACKET')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'split_result' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""sys.exit = lambda x: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET', 'BRACKET'), Leaf('some_type'), Leaf('CLOSING_BRACKET', 'BRACKET')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return True if leaves else False # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    if not (head and body and tail): # pragma: no cover"",
            ""        raise Exception('bracket_split failed') # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET', 'BRACKET'), Leaf('ARG1'), Leaf('COMMA'), Leaf('ARG2'), Leaf('CLOSING_BRACKET', 'BRACKET')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'Success' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET', 'BRACKET'), Leaf('ARG'), Leaf('CLOSING_BRACKET', 'BRACKET')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'mocked_result' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET', 'BRACKET'), Leaf('arg1'), Leaf('CLOSING_BRACKET', 'BRACKET')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return ' '.join(str(leaf.type) for leaf in leaves) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLine: # pragma: no cover"",
            ""    def __init__(self, leaves): # pragma: no cover"",
            ""        self.leaves = leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = MockLine([Leaf('OPENING_BRACKET', 'BRACKET'), Leaf('ARG', None), Leaf('CLOSING_BRACKET', 'BRACKET')]) # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return None # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [ # pragma: no cover"",
            ""    Leaf('OPENING_BRACKET', 'BRACKET'), # pragma: no cover"",
            ""    Leaf('ARGUMENT'), # pragma: no cover"",
            ""    Leaf('CLOSING_BRACKET', 'BRACKET') # pragma: no cover"",
            ""]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    class LineResult: # pragma: no cover"",
            ""        def __init__(self, content): # pragma: no cover"",
            ""            self.content = content # pragma: no cover"",
            ""        def __bool__(self): # pragma: no cover"",
            ""            return bool(self.content) # pragma: no cover"",
            ""    return LineResult(leaves) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""    print(result.content) # pragma: no cover""
        ]
    }
]",2,3376,0.001688,2997,0.0044955,0.0061835
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line :
mock_result
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET', 'BRACKET'), Leaf('ARG'), Leaf('CLOSING_BRACKET', 'BRACKET')]})()"",
            """",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return None"",
            """",
            ""class _BracketSplitComponent(Enum):"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('opening_bracket'), Leaf('element'), Leaf('closing_bracket', 'opening_bracket')]})()"",
            """",
            ""CLOSING_BRACKETS = {'closing_bracket'}"",
            ""OPENING_BRACKETS = {'opening_bracket'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 0"",
            """",
            ""class _BracketSplitComponent(Enum):"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET', '('), Leaf('some_type'), Leaf('CLOSING_BRACKET', '(')]})()"",
            """",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'dummy_result'"",
            """",
            ""class _BracketSplitComponent(Enum):"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""sys.exit = lambda result: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('open_bracket', 'bracket'), Leaf('arg1'), Leaf(','), Leaf('arg2'), Leaf('close_bracket', 'bracket')]})()"",
            """",
            ""CLOSING_BRACKETS = {'close_bracket'}"",
            ""OPENING_BRACKETS = {'open_bracket'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return None"",
            """",
            ""class _BracketSplitComponent(Enum):"",
            ""    head = 1"",
            ""    body = 2"",
            ""    tail = 3"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('MockLine', (object,), {'leaves': [Leaf('OPENING_BRACKET'), Leaf('SOME_TYPE'), Leaf('CLOSING_BRACKET')]})()"",
            """",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return None"",
            """",
            ""class _BracketSplitComponent(Enum):"",
            ""    head = 1"",
            ""    body = 2"",
            ""    tail = 3"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET', 'BRACKET'), Leaf('some_type'), Leaf('CLOSING_BRACKET', 'BRACKET')]})()"",
            """",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return ''"",
            """",
            ""class _BracketSplitComponent(Enum):"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET', 'BRACKET'), Leaf('arg1'), Leaf('CLOSING_BRACKET', 'BRACKET')]})()"",
            """",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return None"",
            """",
            ""class _BracketSplitComponent(Enum):"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf(type='OPENING_BRACKET', opening_bracket='MATCHING_BRACKET'), Leaf(type='elem'), Leaf(type='CLOSING_BRACKET', opening_bracket='MATCHING_BRACKET')]})()"",
            """",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'mock_result'"",
            """",
            ""class _BracketSplitComponent(Enum):"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            ""sys.exit = lambda code: exec('raise SystemExit({})'.format(code)) if code else None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET', 'BRACKET'), Leaf('some_type'), Leaf('CLOSING_BRACKET', 'BRACKET')]})()"",
            """",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return None"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""def exit(result):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('OPENING_BRACKET', None),"",
            ""        Leaf('some_type', None),"",
            ""        Leaf('CLOSING_BRACKET', 'OPENING_BRACKET')"",
            ""    ]"",
            ""})()"",
            """",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return ''  # Return a non-error value"",
            """",
            ""class _BracketSplitComponent(Enum):"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET', 'BRACKET'), Leaf('ARG'), Leaf('CLOSING_BRACKET', 'BRACKET')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return None # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent(Enum): # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('opening_bracket'), Leaf('element'), Leaf('closing_bracket', 'opening_bracket')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'closing_bracket'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'opening_bracket'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent(Enum): # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET', '('), Leaf('some_type'), Leaf('CLOSING_BRACKET', '(')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'dummy_result' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent(Enum): # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('open_bracket', 'bracket'), Leaf('arg1'), Leaf(','), Leaf('arg2'), Leaf('close_bracket', 'bracket')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'close_bracket'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'open_bracket'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return None # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent(Enum): # pragma: no cover"",
            ""    head = 1 # pragma: no cover"",
            ""    body = 2 # pragma: no cover"",
            ""    tail = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), {'leaves': [Leaf('OPENING_BRACKET'), Leaf('SOME_TYPE'), Leaf('CLOSING_BRACKET')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return None # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent(Enum): # pragma: no cover"",
            ""    head = 1 # pragma: no cover"",
            ""    body = 2 # pragma: no cover"",
            ""    tail = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET', 'BRACKET'), Leaf('some_type'), Leaf('CLOSING_BRACKET', 'BRACKET')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent(Enum): # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET', 'BRACKET'), Leaf('arg1'), Leaf('CLOSING_BRACKET', 'BRACKET')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return None # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent(Enum): # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf(type='OPENING_BRACKET', opening_bracket='MATCHING_BRACKET'), Leaf(type='elem'), Leaf(type='CLOSING_BRACKET', opening_bracket='MATCHING_BRACKET')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'mock_result' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent(Enum): # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET', 'BRACKET'), Leaf('some_type'), Leaf('CLOSING_BRACKET', 'BRACKET')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return None # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('OPENING_BRACKET', None), # pragma: no cover"",
            ""        Leaf('some_type', None), # pragma: no cover"",
            ""        Leaf('CLOSING_BRACKET', 'OPENING_BRACKET') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return ''  # Return a non-error value # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent(Enum): # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    }
]",2,3905,0.0019525,2883,0.0043245,0.006277
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line :
HEAD_COMPONENT
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return None"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            """",
            ""_BracketSplitComponent = type('Mock', (object,), {"",
            ""    'head': type('MockComponent', (object,), {'__repr__': lambda self: 'HEAD_COMPONENT'})(),"",
            ""    'body': type('MockComponent', (object,), {'__repr__': lambda self: 'BODY_COMPONENT'})(),"",
            ""    'tail': type('MockComponent', (object,), {'__repr__': lambda self: 'TAIL_COMPONENT'})()"",
            ""})"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET'), Leaf('IN_BETWEEN'), Leaf('CLOSING_BRACKET')]})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('OPENING_BRACKET', None),"",
            ""        Leaf('SOME_TYPE', None),"",
            ""        Leaf('CLOSING_BRACKET', Leaf('OPENING_BRACKET', None))"",
            ""    ]"",
            ""})()"",
            """",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return None"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET', None), Leaf('code'), Leaf('CLOSING_BRACKET', Leaf('OPENING_BRACKET', None))]})()"",
            """",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return True"",
            """",
            ""class _BracketSplitComponent(Enum):"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET'), Leaf('CLOSING_BRACKET')]})()"",
            """",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return component"",
            """",
            ""class _BracketSplitComponent(Enum):"",
            ""    head = 'HEAD_COMPONENT'"",
            ""    body = 'BODY_COMPONENT'"",
            ""    tail = 'TAIL_COMPONENT'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class MockLine:"",
            ""    leaves = [Leaf('OPENING_BRACKET', 'BRACKET'), Leaf('some_type'), Leaf('CLOSING_BRACKET', 'BRACKET')]"",
            ""line = MockLine()"",
            """",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'success'"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'HEAD_COMPONENT'"",
            ""    body = 'BODY_COMPONENT'"",
            ""    tail = 'TAIL_COMPONENT'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, leaf_type, opening_bracket=None):"",
            ""        self.type = leaf_type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET'), Leaf('ARG'), Leaf('CLOSING_BRACKET', 'OPENING_BRACKET')]})()"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return True"",
            """",
            ""class _BracketSplitComponent(Enum):"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class MockLine:"",
            ""    leaves = [Leaf('OPENING_BRACKET'), Leaf('arg', 'OPENING_BRACKET'), Leaf('CLOSING_BRACKET', 'OPENING_BRACKET')]"",
            """",
            ""line = MockLine()"",
            """",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'split_line_result_' + component.name.lower()"",
            """",
            ""class _BracketSplitComponent(Enum):"",
            ""    head = 1"",
            ""    body = 2"",
            ""    tail = 3"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET'), Leaf('ARG'), Leaf('CLOSING_BRACKET', 'OPENING_BRACKET')]})()"",
            """",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return True"",
            """",
            ""class _BracketSplitComponent(Enum):"",
            ""    head = 'HEAD_COMPONENT'"",
            ""    body = 'BODY_COMPONENT'"",
            ""    tail = 'TAIL_COMPONENT'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""exit = lambda result: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET'), Leaf('argument'), Leaf('CLOSING_BRACKET', Leaf('OPENING_BRACKET'))]})()"",
            """",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head_component'"",
            ""    body = 'body_component'"",
            ""    tail = 'tail_component'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = SimpleNamespace(leaves=[Leaf('OPENING_BRACKET'), Leaf('IDENTIFIER'), Leaf('CLOSING_BRACKET', opening_bracket=Leaf('OPENING_BRACKET'))])"",
            """",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return SimpleNamespace(result=True)"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'HEAD_COMPONENT'"",
            ""    body = 'BODY_COMPONENT'"",
            ""    tail = 'TAIL_COMPONENT'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""_BracketSplitComponent = type('Mock', (object,), { # pragma: no cover"",
            ""    'head': type('MockComponent', (object,), {'__repr__': lambda self: 'HEAD_COMPONENT'})(), # pragma: no cover"",
            ""    'body': type('MockComponent', (object,), {'__repr__': lambda self: 'BODY_COMPONENT'})(), # pragma: no cover"",
            ""    'tail': type('MockComponent', (object,), {'__repr__': lambda self: 'TAIL_COMPONENT'})() # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET'), Leaf('IN_BETWEEN'), Leaf('CLOSING_BRACKET')]})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('OPENING_BRACKET', None), # pragma: no cover"",
            ""        Leaf('SOME_TYPE', None), # pragma: no cover"",
            ""        Leaf('CLOSING_BRACKET', Leaf('OPENING_BRACKET', None)) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return None # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET', None), Leaf('code'), Leaf('CLOSING_BRACKET', Leaf('OPENING_BRACKET', None))]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent(Enum): # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET'), Leaf('CLOSING_BRACKET')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return component # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent(Enum): # pragma: no cover"",
            ""    head = 'HEAD_COMPONENT' # pragma: no cover"",
            ""    body = 'BODY_COMPONENT' # pragma: no cover"",
            ""    tail = 'TAIL_COMPONENT' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLine: # pragma: no cover"",
            ""    leaves = [Leaf('OPENING_BRACKET', 'BRACKET'), Leaf('some_type'), Leaf('CLOSING_BRACKET', 'BRACKET')] # pragma: no cover"",
            ""line = MockLine() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'success' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'HEAD_COMPONENT' # pragma: no cover"",
            ""    body = 'BODY_COMPONENT' # pragma: no cover"",
            ""    tail = 'TAIL_COMPONENT' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, leaf_type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = leaf_type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET'), Leaf('ARG'), Leaf('CLOSING_BRACKET', 'OPENING_BRACKET')]})() # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent(Enum): # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLine: # pragma: no cover"",
            ""    leaves = [Leaf('OPENING_BRACKET'), Leaf('arg', 'OPENING_BRACKET'), Leaf('CLOSING_BRACKET', 'OPENING_BRACKET')] # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = MockLine() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'split_line_result_' + component.name.lower() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent(Enum): # pragma: no cover"",
            ""    head = 1 # pragma: no cover"",
            ""    body = 2 # pragma: no cover"",
            ""    tail = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET'), Leaf('ARG'), Leaf('CLOSING_BRACKET', 'OPENING_BRACKET')]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent(Enum): # pragma: no cover"",
            ""    head = 'HEAD_COMPONENT' # pragma: no cover"",
            ""    body = 'BODY_COMPONENT' # pragma: no cover"",
            ""    tail = 'TAIL_COMPONENT' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""exit = lambda result: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf('OPENING_BRACKET'), Leaf('argument'), Leaf('CLOSING_BRACKET', Leaf('OPENING_BRACKET'))]})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head_component' # pragma: no cover"",
            ""    body = 'body_component' # pragma: no cover"",
            ""    tail = 'tail_component' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = SimpleNamespace(leaves=[Leaf('OPENING_BRACKET'), Leaf('IDENTIFIER'), Leaf('CLOSING_BRACKET', opening_bracket=Leaf('OPENING_BRACKET'))]) # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return SimpleNamespace(result=True) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'HEAD_COMPONENT' # pragma: no cover"",
            ""    body = 'BODY_COMPONENT' # pragma: no cover"",
            ""    tail = 'TAIL_COMPONENT' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    }
]",2,4424,0.002212,2914,0.004371,0.006583
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Split line into many lines, starting with the first matching bracket pair.
    Note: this usually looks weird, only use this for function definitions.
    Prefer RHS otherwise.  This is why this function is not symmetrical with
    :func:`right_hand_split` which also handles optional parentheses.
    """"""
tail_leaves: List[Leaf] = []
body_leaves: List[Leaf] = []
head_leaves: List[Leaf] = []
current_leaves = head_leaves
matching_bracket: Optional[Leaf] = None
for leaf in line.leaves:
    if ( # uncovered
        current_leaves is body_leaves # uncovered
        and leaf.type in CLOSING_BRACKETS # uncovered
        and leaf.opening_bracket is matching_bracket # uncovered
        and isinstance(matching_bracket, Leaf) # uncovered
    ):
        ensure_visible(leaf)
        ensure_visible(matching_bracket)
        current_leaves = tail_leaves if body_leaves else head_leaves
    current_leaves.append(leaf)
    if current_leaves is head_leaves:
        if leaf.type in OPENING_BRACKETS:
            matching_bracket = leaf
            current_leaves = body_leaves
if not matching_bracket:
    raise CannotSplit(""No brackets found"") # uncovered
head = bracket_split_build_line( # uncovered
    head_leaves, line, matching_bracket, component=_BracketSplitComponent.head # uncovered
)
body = bracket_split_build_line( # uncovered
    body_leaves, line, matching_bracket, component=_BracketSplitComponent.body # uncovered
)
tail = bracket_split_build_line( # uncovered
    tail_leaves, line, matching_bracket, component=_BracketSplitComponent.tail # uncovered
)
bracket_split_succeeded_or_raise(head, body, tail)
for result in (head, body, tail):
    if result:
        aux = result
        exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from my_module import Leaf, OPENING_BRACKETS, CLOSING_BRACKETS, ensure_visible, bracket_split_build_line, _BracketSplitComponent, CannotSplit, bracket_split_succeeded_or_raise""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""OPENING_BRACKETS = {\""(\"", \""[\"", \""{\""}"",
            ""CLOSING_BRACKETS = {\"")\"", \""]\"", \""}\""}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return line"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = \""head\"""",
            ""    body = \""body\"""",
            ""    tail = \""tail\"""",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""line = type(\""Mock\"", (object,), {"",
            ""    \""leaves\"": ["",
            ""        Leaf(\""(\"", None),"",
            ""        Leaf(\""body_leaves\""),"",
            ""        Leaf(\"")\"", None)"",
            ""    ]"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""class Leaf: pass"",
            ""class CannotSplit(Exception): pass"",
            ""CLOSING_BRACKETS = set([')', ']', '}'])"",
            ""OPENING_BRACKETS = set(['(', '[', '{'])"",
            ""def ensure_visible(leaf): pass"",
            ""def bracket_split_build_line(leaves, line, match, component): return 'mock_line'"",
            ""class _BracketSplitComponent: head = 'head'; body = 'body'; tail = 'tail'"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): pass""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), {'leaves': [Leaf(), Leaf(), Leaf()]})()"",
            ""line.leaves[0].type = '('"",
            ""line.leaves[1].type = ')'"",
            ""line.leaves[2].type = ')'"",
            ""line.leaves[0].opening_bracket = None"",
            ""line.leaves[1].opening_bracket = line.leaves[0]"",
            ""line.leaves[0] = type('Leaf', (object,), {'type': \""(\"", 'opening_bracket': None})()"",
            ""line.leaves[1] = type('Leaf', (object,), {'type': \"")\"", 'opening_bracket': line.leaves[0]})()"",
            ""line.leaves[2] = type('Leaf', (object,), {'type': \"")\"", 'opening_bracket': line.leaves[0]})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from blib2to3.pytree import Leaf"",
            ""from black.linegen import bracket_split_build_line, bracket_split_succeeded_or_raise"",
            ""from black.nodes import CLOSING_BRACKETS, OPENING_BRACKETS"",
            ""from black import CannotSplit, ensure_visible"",
            ""from black.parsing import _BracketSplitComponent""
        ],
        ""initialization"": [
            ""class MockLeaf(Leaf):"",
            ""    def __init__(self, type, value, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""line = type('Mock', (object,), {'leaves': ["",
            ""    MockLeaf(type='OPENING_BRACKET', value='('),"",
            ""    MockLeaf(type='CODE', value='x'),"",
            ""    MockLeaf(type='CLOSING_BRACKET', value=')', opening_bracket=MockLeaf(type='OPENING_BRACKET', value='('))"",
            ""]})"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""_BracketSplitComponent = type('Mock', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'})"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            """",
            ""CannotSplit = Exception""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from dataclasses import dataclass"",
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""class CannotSplit(Exception): pass"",
            ""def ensure_visible(leaf): pass"",
            ""def bracket_split_build_line(leaves, line, match_bracket, component): return True"",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): pass""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf('content1'), Leaf('content2'), Leaf('content3'), Leaf(')')]})"",
            ""leaf = Leaf('mock')""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from typing import Type"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, leaf_type, opening_bracket=None):"",
            ""        self.type = leaf_type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    if not head or not body or not tail:"",
            ""        raise CannotSplit('Bracket split failed')"",
            """",
            ""class _BracketSplitComponent(Enum):"",
            ""    head = 1"",
            ""    body = 2"",
            ""    tail = 3"",
            """",
            ""OPENING_BRACKETS = {1}"",
            ""CLOSING_BRACKETS = {2}"",
            ""matching_bracket = Leaf(1)"",
            ""line = type('Mock', (object,), {'leaves': [Leaf(1), Leaf(3, matching_bracket)]})""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'result'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""_BracketSplitComponent = type('_BracketSplitComponent', (object,), {"",
            ""    'head': 'head',"",
            ""    'body': 'body',"",
            ""    'tail': 'tail'"",
            ""})"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf(type='('),"",
            ""        Leaf(type=')', opening_bracket=Leaf(type='(')),"",
            ""        Leaf(type='{', opening_bracket=None),"",
            ""        Leaf(type='}', opening_bracket=Leaf(type='{'))"",
            ""    ]"",
            ""})""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type_, opening_bracket=None: setattr(self, 'type', type_) or setattr(self, 'opening_bracket', opening_bracket)})"",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""ensure_visible = lambda x: None"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""BracketSplitComponent = type('_BracketSplitComponent', (object,), {'head': 1, 'body': 2, 'tail': 3})"",
            ""bracket_split_build_line = lambda leaves, line, matching_bracket, component: SimpleNamespace(leaves=leaves, line=line, matchingBracket=matching_bracket, component=component)"",
            ""bracket_split_succeeded_or_raise = lambda head, body, tail: None"",
            ""line = SimpleNamespace(leaves=[Leaf('OPENING_BRACKET', '('), Leaf('number'), Leaf('CLOSING_BRACKET', ')')])"",
            ""exit = lambda x: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from mymodule import Leaf, CLOSING_BRACKETS, OPENING_BRACKETS, CannotSplit, bracket_split_build_line, _BracketSplitComponent, bracket_split_succeeded_or_raise, ensure_visible""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), {'leaves': [Leaf(type='OPEN', opening_bracket=None), Leaf(type='CLOSE', opening_bracket=None)]})()"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type, opening_bracket: setattr(self, 'type', type) or setattr(self, 'opening_bracket', opening_bracket)})"",
            ""CLOSING_BRACKETS = ['CLOSE']"",
            ""OPENING_BRACKETS = ['OPEN']"",
            ""ensure_visible = lambda leaf: None"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""bracket_split_build_line = lambda leaves, line, matching_bracket, component: leaves"",
            ""_BracketSplitComponent = type('_BracketSplitComponent', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'})"",
            ""bracket_split_succeeded_or_raise = lambda head, body, tail: None"",
            ""exit = lambda aux: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from some_module import Leaf, CLOSING_BRACKETS, OPENING_BRACKETS, ensure_visible, CannotSplit, bracket_split_build_line, _BracketSplitComponent, bracket_split_succeeded_or_raise""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            ""line = type('Mock', (object,), {'leaves': [MockLeaf('opening_bracket_type'), MockLeaf('middle_type'), MockLeaf('closing_bracket_type', opening_bracket=MockLeaf('opening_bracket_type'))]})()"",
            ""CLOSING_BRACKETS = ['closing_bracket_type']"",
            ""OPENING_BRACKETS = ['opening_bracket_type']"",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return True"",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from black import Line, Leaf, CannotSplit"",
            ""from black.const import OPENING_BRACKETS, CLOSING_BRACKETS"",
            ""from black.mode import ensure_visible"",
            ""from black.operations import bracket_split_build_line, bracket_split_succeeded_or_raise"",
            ""from black.brackets import _BracketSplitComponent""
        ],
        ""initialization"": [
            ""line = Line.from_string('def example_function(arg1, arg2): pass', mode=None)"",
            ""Leaf = type('Leaf', (object,), {'type': None, 'opening_bracket': None})"",
            ""matching_bracket = None"",
            ""Leaf1 = Leaf()"",
            ""Leaf1.type = 'OPENING_BRACKET'"",
            ""Leaf1.opening_bracket = None"",
            ""Leaf2 = Leaf()"",
            ""Leaf2.type = 'CLOSING_BRACKET'"",
            ""Leaf2.opening_bracket = Leaf1"",
            ""line.leaves = [Leaf1, Leaf2]"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'}"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {\""(\"", \""[\"", \""{\""} # pragma: no cover"",
            ""CLOSING_BRACKETS = {\"")\"", \""]\"", \""}\""} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return line # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = \""head\"" # pragma: no cover"",
            ""    body = \""body\"" # pragma: no cover"",
            ""    tail = \""tail\"" # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type(\""Mock\"", (object,), { # pragma: no cover"",
            ""    \""leaves\"": [ # pragma: no cover"",
            ""        Leaf(\""(\"", None), # pragma: no cover"",
            ""        Leaf(\""body_leaves\""), # pragma: no cover"",
            ""        Leaf(\"")\"", None) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""class Leaf: pass # pragma: no cover"",
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""CLOSING_BRACKETS = set([')', ']', '}']) # pragma: no cover"",
            ""OPENING_BRACKETS = set(['(', '[', '{']) # pragma: no cover"",
            ""def ensure_visible(leaf): pass # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, match, component): return 'mock_line' # pragma: no cover"",
            ""class _BracketSplitComponent: head = 'head'; body = 'body'; tail = 'tail' # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): pass # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), {'leaves': [Leaf(), Leaf(), Leaf()]})() # pragma: no cover"",
            ""line.leaves[0].type = '(' # pragma: no cover"",
            ""line.leaves[1].type = ')' # pragma: no cover"",
            ""line.leaves[2].type = ')' # pragma: no cover"",
            ""line.leaves[0].opening_bracket = None # pragma: no cover"",
            ""line.leaves[1].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""line.leaves[0] = type('Leaf', (object,), {'type': \""(\"", 'opening_bracket': None})() # pragma: no cover"",
            ""line.leaves[1] = type('Leaf', (object,), {'type': \"")\"", 'opening_bracket': line.leaves[0]})() # pragma: no cover"",
            ""line.leaves[2] = type('Leaf', (object,), {'type': \"")\"", 'opening_bracket': line.leaves[0]})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from blib2to3.pytree import Leaf # pragma: no cover"",
            ""from black.linegen import bracket_split_build_line, bracket_split_succeeded_or_raise # pragma: no cover"",
            ""from black.nodes import CLOSING_BRACKETS, OPENING_BRACKETS # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from dataclasses import dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""def ensure_visible(leaf): pass # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, match_bracket, component): return True # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): pass # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), {'leaves': [Leaf('('), Leaf('content1'), Leaf('content2'), Leaf('content3'), Leaf(')')]}) # pragma: no cover"",
            ""leaf = Leaf('mock') # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from typing import Type # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, leaf_type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = leaf_type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    if not head or not body or not tail: # pragma: no cover"",
            ""        raise CannotSplit('Bracket split failed') # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent(Enum): # pragma: no cover"",
            ""    head = 1 # pragma: no cover"",
            ""    body = 2 # pragma: no cover"",
            ""    tail = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {1} # pragma: no cover"",
            ""CLOSING_BRACKETS = {2} # pragma: no cover"",
            ""matching_bracket = Leaf(1) # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf(1), Leaf(3, matching_bracket)]}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'result' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""_BracketSplitComponent = type('_BracketSplitComponent', (object,), { # pragma: no cover"",
            ""    'head': 'head', # pragma: no cover"",
            ""    'body': 'body', # pragma: no cover"",
            ""    'tail': 'tail' # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf(type='('), # pragma: no cover"",
            ""        Leaf(type=')', opening_bracket=Leaf(type='(')), # pragma: no cover"",
            ""        Leaf(type='{', opening_bracket=None), # pragma: no cover"",
            ""        Leaf(type='}', opening_bracket=Leaf(type='{')) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type_, opening_bracket=None: setattr(self, 'type', type_) or setattr(self, 'opening_bracket', opening_bracket)}) # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""ensure_visible = lambda x: None # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""BracketSplitComponent = type('_BracketSplitComponent', (object,), {'head': 1, 'body': 2, 'tail': 3}) # pragma: no cover"",
            ""bracket_split_build_line = lambda leaves, line, matching_bracket, component: SimpleNamespace(leaves=leaves, line=line, matchingBracket=matching_bracket, component=component) # pragma: no cover"",
            ""bracket_split_succeeded_or_raise = lambda head, body, tail: None # pragma: no cover"",
            ""line = SimpleNamespace(leaves=[Leaf('OPENING_BRACKET', '('), Leaf('number'), Leaf('CLOSING_BRACKET', ')')]) # pragma: no cover"",
            ""exit = lambda x: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type, opening_bracket: setattr(self, 'type', type) or setattr(self, 'opening_bracket', opening_bracket)}) # pragma: no cover"",
            ""CLOSING_BRACKETS = ['CLOSE'] # pragma: no cover"",
            ""OPENING_BRACKETS = ['OPEN'] # pragma: no cover"",
            ""ensure_visible = lambda leaf: None # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""bracket_split_build_line = lambda leaves, line, matching_bracket, component: leaves # pragma: no cover"",
            ""_BracketSplitComponent = type('_BracketSplitComponent', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'}) # pragma: no cover"",
            ""bracket_split_succeeded_or_raise = lambda head, body, tail: None # pragma: no cover"",
            ""exit = lambda aux: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [MockLeaf('opening_bracket_type'), MockLeaf('middle_type'), MockLeaf('closing_bracket_type', opening_bracket=MockLeaf('opening_bracket_type'))]})() # pragma: no cover"",
            ""CLOSING_BRACKETS = ['closing_bracket_type'] # pragma: no cover"",
            ""OPENING_BRACKETS = ['opening_bracket_type'] # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""Leaf = type('Leaf', (object,), {'type': None, 'opening_bracket': None}) # pragma: no cover"",
            ""matching_bracket = None # pragma: no cover"",
            ""Leaf1 = Leaf() # pragma: no cover"",
            ""Leaf1.type = 'OPENING_BRACKET' # pragma: no cover"",
            ""Leaf1.opening_bracket = None # pragma: no cover"",
            ""Leaf2 = Leaf() # pragma: no cover"",
            ""Leaf2.type = 'CLOSING_BRACKET' # pragma: no cover"",
            ""Leaf2.opening_bracket = Leaf1 # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPENING_BRACKET'} # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSING_BRACKET'} # pragma: no cover""
        ]
    }
]",3,698,0.000349,3108,0.004662,0.005011
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Split line into many lines, starting with the first matching bracket pair.
    Note: this usually looks weird, only use this for function definitions.
    Prefer RHS otherwise.  This is why this function is not symmetrical with
    :func:`right_hand_split` which also handles optional parentheses.
    """"""
tail_leaves: List[Leaf] = []
body_leaves: List[Leaf] = []
head_leaves: List[Leaf] = []
current_leaves = head_leaves
matching_bracket: Optional[Leaf] = None
for leaf in line.leaves:
    if ( # uncovered
        current_leaves is body_leaves # uncovered
        and leaf.type in CLOSING_BRACKETS # uncovered
        and leaf.opening_bracket is matching_bracket # uncovered
        and isinstance(matching_bracket, Leaf) # uncovered
    ):
        ensure_visible(leaf)
        ensure_visible(matching_bracket)
        current_leaves = tail_leaves if body_leaves else head_leaves
    current_leaves.append(leaf)
    if current_leaves is head_leaves:
        if leaf.type in OPENING_BRACKETS:
            matching_bracket = leaf
            current_leaves = body_leaves
if not matching_bracket:
    raise CannotSplit(""No brackets found"") # uncovered
head = bracket_split_build_line( # uncovered
    head_leaves, line, matching_bracket, component=_BracketSplitComponent.head # uncovered
)
body = bracket_split_build_line( # uncovered
    body_leaves, line, matching_bracket, component=_BracketSplitComponent.body # uncovered
)
tail = bracket_split_build_line( # uncovered
    tail_leaves, line, matching_bracket, component=_BracketSplitComponent.tail # uncovered
)
bracket_split_succeeded_or_raise(head, body, tail)
for result in (head, body, tail):
    if result:
        aux = result
        exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'build_line_result'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""_BracketSplitComponent = type('_BracketSplitComponent', (object,), {"",
            ""    'head': 'head',"",
            ""    'body': 'body',"",
            ""    'tail': 'tail'"",
            ""})"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf(type='('),"",
            ""        Leaf(type=')', opening_bracket=Leaf(type='('))"",
            ""    ]"",
            ""})""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, leaf_type, opening_bracket=None):"",
            ""        self.type = leaf_type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""OPENING_BRACKETS = {'('}"",
            ""CLOSING_BRACKETS = {')'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""_BracketSplitComponent = type('_BracketSplitComponent', (object,), {"",
            ""    'head': 'head',"",
            ""    'body': 'body',"",
            ""    'tail': 'tail'"",
            ""})"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('(', None),"",
            ""        Leaf('number'),"",
            ""        Leaf(')', Leaf('('))"",
            ""    ]"",
            ""})()"",
            ""exit = lambda aux: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type_, opening_bracket=None: setattr(self, 'type', type_) or setattr(self, 'opening_bracket', opening_bracket)})"",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""ensure_visible = lambda x: None"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""_BracketSplitComponent = type('_BracketSplitComponent', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'})"",
            ""bracket_split_build_line = lambda leaves, line, matching_bracket, component: leaves"",
            ""bracket_split_succeeded_or_raise = lambda head, body, tail: None"",
            ""line = SimpleNamespace(leaves=[Leaf('(', None), Leaf('content'), Leaf(')'), Leaf('extra')])"",
            ""line.leaves[2].opening_bracket = line.leaves[0]"",
            ""exit = lambda x: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'result'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""_BracketSplitComponent = type('MockComponent', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'})"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('(', None),"",
            ""        Leaf('element'),"",
            ""        Leaf(')', Leaf('('))"",
            ""    ]"",
            ""})""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return SimpleNamespace(leaves=leaves, line=line, matching_bracket=matching_bracket, component=component)"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""_BracketSplitComponent = type('_BracketSplitComponent', (object,), {"",
            ""    'head': 'HEAD',"",
            ""    'body': 'BODY',"",
            ""    'tail': 'TAIL'"",
            ""})"",
            """",
            ""line = SimpleNamespace(leaves=["",
            ""    Leaf(type='(', opening_bracket=None),"",
            ""    Leaf(type='identifier', opening_bracket=None),"",
            ""    Leaf(type=')', opening_bracket=Leaf(type='(', opening_bracket=None))"",
            ""])"",
            """",
            ""exit = lambda x: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type_, opening_bracket=None):"",
            ""        self.type = type_"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""OPENING_BRACKETS = {'OPEN'}"",
            ""CLOSING_BRACKETS = {'CLOSE'}"",
            """",
            ""matching_bracket = Leaf(type_='OPEN')"",
            ""line = type('Mock', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('OPEN'),"",
            ""        Leaf('content', opening_bracket=matching_bracket),"",
            ""        Leaf('CLOSE', opening_bracket=matching_bracket)"",
            ""    ]"",
            ""})()"",
            """",
            ""exit = lambda x: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type_, opening_bracket=None):"",
            ""        self.type = type_"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""OPENING_BRACKETS = {'OPEN'}"",
            ""CLOSING_BRACKETS = {'CLOSE'}"",
            """",
            ""matching_bracket = Leaf('OPEN')"",
            ""line = SimpleNamespace(leaves=[Leaf('HEAD'), matching_bracket, Leaf('BODY'), Leaf('CLOSE', opening_bracket=matching_bracket)])""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""class Leaf: pass"",
            ""class CannotSplit(Exception): pass"",
            ""CLOSING_BRACKETS = set([')', ']', '}'])"",
            ""OPENING_BRACKETS = set(['(', '[', '{'])"",
            ""def ensure_visible(leaf): pass"",
            ""def bracket_split_build_line(leaves, line, match, component): return 'mock_line'"",
            ""class _BracketSplitComponent: head = 'head'; body = 'body'; tail = 'tail'"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): pass""
        ],
        ""initialization"": [
            ""class MockLeaf(Leaf):"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""Leaf1 = MockLeaf('(', None)"",
            ""Leaf2 = MockLeaf(')', Leaf1)"",
            """",
            ""line = type('Mock', (object,), {'leaves': [Leaf1, Leaf2]})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'result'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""matching_bracket = Leaf('(')"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf(type='(', opening_bracket=None),"",
            ""        Leaf(type='content', opening_bracket=None),"",
            ""        Leaf(type=')', opening_bracket=matching_bracket)"",
            ""    ]"",
            ""})""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""CLOSING_BRACKETS = {']', ')', '}'}"",
            ""OPENING_BRACKETS = {'[', '(', '{'}"",
            """",
            ""class CannotSplit(Exception): pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""_BracketSplitComponent = SimpleNamespace(head='head', body='body', tail='tail')"",
            """",
            ""line = SimpleNamespace(leaves=["",
            ""    Leaf(type='(', opening_bracket=None),"",
            ""    Leaf(type='test', opening_bracket=None),"",
            ""    Leaf(type=')', opening_bracket='(')"",
            ""])""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'build_line_result' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""_BracketSplitComponent = type('_BracketSplitComponent', (object,), { # pragma: no cover"",
            ""    'head': 'head', # pragma: no cover"",
            ""    'body': 'body', # pragma: no cover"",
            ""    'tail': 'tail' # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf(type='('), # pragma: no cover"",
            ""        Leaf(type=')', opening_bracket=Leaf(type='(')) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, leaf_type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = leaf_type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""_BracketSplitComponent = type('_BracketSplitComponent', (object,), { # pragma: no cover"",
            ""    'head': 'head', # pragma: no cover"",
            ""    'body': 'body', # pragma: no cover"",
            ""    'tail': 'tail' # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('(', None), # pragma: no cover"",
            ""        Leaf('number'), # pragma: no cover"",
            ""        Leaf(')', Leaf('(')) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""exit = lambda aux: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type_, opening_bracket=None: setattr(self, 'type', type_) or setattr(self, 'opening_bracket', opening_bracket)}) # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""ensure_visible = lambda x: None # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""_BracketSplitComponent = type('_BracketSplitComponent', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'}) # pragma: no cover"",
            ""bracket_split_build_line = lambda leaves, line, matching_bracket, component: leaves # pragma: no cover"",
            ""bracket_split_succeeded_or_raise = lambda head, body, tail: None # pragma: no cover"",
            ""line = SimpleNamespace(leaves=[Leaf('(', None), Leaf('content'), Leaf(')'), Leaf('extra')]) # pragma: no cover"",
            ""line.leaves[2].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""exit = lambda x: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'result' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""_BracketSplitComponent = type('MockComponent', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('(', None), # pragma: no cover"",
            ""        Leaf('element'), # pragma: no cover"",
            ""        Leaf(')', Leaf('(')) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return SimpleNamespace(leaves=leaves, line=line, matching_bracket=matching_bracket, component=component) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""_BracketSplitComponent = type('_BracketSplitComponent', (object,), { # pragma: no cover"",
            ""    'head': 'HEAD', # pragma: no cover"",
            ""    'body': 'BODY', # pragma: no cover"",
            ""    'tail': 'TAIL' # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = SimpleNamespace(leaves=[ # pragma: no cover"",
            ""    Leaf(type='(', opening_bracket=None), # pragma: no cover"",
            ""    Leaf(type='identifier', opening_bracket=None), # pragma: no cover"",
            ""    Leaf(type=')', opening_bracket=Leaf(type='(', opening_bracket=None)) # pragma: no cover"",
            ""]) # pragma: no cover"",
            "" # pragma: no cover"",
            ""exit = lambda x: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPEN'} # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSE'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf(type_='OPEN') # pragma: no cover"",
            ""line = type('Mock', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('OPEN'), # pragma: no cover"",
            ""        Leaf('content', opening_bracket=matching_bracket), # pragma: no cover"",
            ""        Leaf('CLOSE', opening_bracket=matching_bracket) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""exit = lambda x: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPEN'} # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSE'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('OPEN') # pragma: no cover"",
            ""line = SimpleNamespace(leaves=[Leaf('HEAD'), matching_bracket, Leaf('BODY'), Leaf('CLOSE', opening_bracket=matching_bracket)]) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""class Leaf: pass # pragma: no cover"",
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""CLOSING_BRACKETS = set([')', ']', '}']) # pragma: no cover"",
            ""OPENING_BRACKETS = set(['(', '[', '{']) # pragma: no cover"",
            ""def ensure_visible(leaf): pass # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, match, component): return 'mock_line' # pragma: no cover"",
            ""class _BracketSplitComponent: head = 'head'; body = 'body'; tail = 'tail' # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): pass # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf(Leaf): # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""Leaf1 = MockLeaf('(', None) # pragma: no cover"",
            ""Leaf2 = MockLeaf(')', Leaf1) # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), {'leaves': [Leaf1, Leaf2]})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'result' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('(') # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf(type='(', opening_bracket=None), # pragma: no cover"",
            ""        Leaf(type='content', opening_bracket=None), # pragma: no cover"",
            ""        Leaf(type=')', opening_bracket=matching_bracket) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {']', ')', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'[', '(', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""_BracketSplitComponent = SimpleNamespace(head='head', body='body', tail='tail') # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = SimpleNamespace(leaves=[ # pragma: no cover"",
            ""    Leaf(type='(', opening_bracket=None), # pragma: no cover"",
            ""    Leaf(type='test', opening_bracket=None), # pragma: no cover"",
            ""    Leaf(type=')', opening_bracket='(') # pragma: no cover"",
            ""]) # pragma: no cover""
        ]
    }
]",3,4481,0.0022405,2951,0.0044265,0.0066669999999999
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Split line into many lines, starting with the first matching bracket pair.
    Note: this usually looks weird, only use this for function definitions.
    Prefer RHS otherwise.  This is why this function is not symmetrical with
    :func:`right_hand_split` which also handles optional parentheses.
    """"""
tail_leaves: List[Leaf] = []
body_leaves: List[Leaf] = []
head_leaves: List[Leaf] = []
current_leaves = head_leaves
matching_bracket: Optional[Leaf] = None
for leaf in line.leaves:
    if ( # uncovered
        current_leaves is body_leaves # uncovered
        and leaf.type in CLOSING_BRACKETS # uncovered
        and leaf.opening_bracket is matching_bracket # uncovered
        and isinstance(matching_bracket, Leaf) # uncovered
    ):
        ensure_visible(leaf)
        ensure_visible(matching_bracket)
        current_leaves = tail_leaves if body_leaves else head_leaves
    current_leaves.append(leaf)
    if current_leaves is head_leaves:
        if leaf.type in OPENING_BRACKETS:
            matching_bracket = leaf
            current_leaves = body_leaves
if not matching_bracket:
    raise CannotSplit(""No brackets found"") # uncovered
head = bracket_split_build_line( # uncovered
    head_leaves, line, matching_bracket, component=_BracketSplitComponent.head # uncovered
)
body = bracket_split_build_line( # uncovered
    body_leaves, line, matching_bracket, component=_BracketSplitComponent.body # uncovered
)
tail = bracket_split_build_line( # uncovered
    tail_leaves, line, matching_bracket, component=_BracketSplitComponent.tail # uncovered
)
bracket_split_succeeded_or_raise(head, body, tail)
for result in (head, body, tail):
    if result:
        aux = result
        exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'result'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""_BracketSplitComponent = type('MockComponent', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'})"",
            """",
            ""matching_bracket = Leaf('(')"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf(type='(', opening_bracket=None),"",
            ""        Leaf(type='element', opening_bracket=None),"",
            ""        Leaf(type=')', opening_bracket=matching_bracket)"",
            ""    ]"",
            ""})"",
            """",
            ""exit = lambda x: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    if not head or not body or not tail:"",
            ""        raise CannotSplit('Bracket split failed')"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""OPENING_BRACKETS = {'('}"",
            ""CLOSING_BRACKETS = {')'}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf(type='('),"",
            ""        Leaf(type='number', opening_bracket=None),"",
            ""        Leaf(type=')', opening_bracket=Leaf(type='('))"",
            ""    ]"",
            ""})()"",
            ""exit = lambda x: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'result'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""matching_bracket = Leaf('(')"",
            """",
            ""line = type('Mock', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf(type='{'),"",
            ""        Leaf(type='body_element', opening_bracket=Leaf(type='{')),"",
            ""        Leaf(type='}', opening_bracket=Leaf(type='{'))"",
            ""    ]"",
            ""})()"",
            """",
            ""exit = lambda aux: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type_, opening_bracket=None):"",
            ""        self.type = type_"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""_BracketSplitComponent = SimpleNamespace(head='head', body='body', tail='tail')"",
            """",
            ""matching_bracket = Leaf('(')"",
            ""line = SimpleNamespace(leaves=["",
            ""    Leaf('content1'),"",
            ""    matching_bracket,"",
            ""    Leaf('content2'),"",
            ""    Leaf(')', matching_bracket)"",
            ""])"",
            """",
            ""exit = lambda aux: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""_BracketSplitComponent = type('MockComponent', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'})"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('(', None),"",
            ""        Leaf('number', None),"",
            ""        Leaf(')', Leaf('('))"",
            ""    ]"",
            ""})()"",
            ""exit = lambda aux: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, leaf_type, opening_bracket=None):"",
            ""        self.type = leaf_type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""OPENING_BRACKETS = {'OPEN'}"",
            ""CLOSING_BRACKETS = {'CLOSE'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""_BracketSplitComponent = type('_BracketSplitComponent', (object,), {"",
            ""    'head': 'head',"",
            ""    'body': 'body',"",
            ""    'tail': 'tail'"",
            ""})"",
            """",
            ""matching_bracket = Leaf('OPEN')"",
            ""line = type('Mock', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('OPEN'),"",
            ""        Leaf('content', matching_bracket),"",
            ""        Leaf('CLOSE', matching_bracket)"",
            ""    ]"",
            ""})()"",
            """",
            ""exit = lambda x: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'result'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""matching_bracket = Leaf('(', opening_bracket=None)"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('(', None),"",
            ""        Leaf('content', matching_bracket),"",
            ""        Leaf(')', matching_bracket)"",
            ""    ]"",
            ""})()"",
            ""exit = lambda x: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'result'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""matching_bracket = Leaf('(')"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf(type='(', opening_bracket=None),"",
            ""        Leaf(type='content', opening_bracket=None),"",
            ""        Leaf(type=')', opening_bracket=matching_bracket),"",
            ""        Leaf(type='additional', opening_bracket=None)"",
            ""    ]"",
            ""})()"",
            """",
            ""exit = lambda x: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    assert head and body and tail"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('(', None),"",
            ""        Leaf('content'),"",
            ""        Leaf(')',Leaf('('))"",
            ""    ]"",
            ""})()"",
            """",
            ""exit = lambda aux: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'result'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""matching_bracket = Leaf('(')"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf(type='(', opening_bracket=None),"",
            ""        Leaf(type='identifier', opening_bracket=None),"",
            ""        Leaf(type=')', opening_bracket=matching_bracket)"",
            ""    ]"",
            ""})()"",
            ""exit = lambda aux: None""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'result' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""_BracketSplitComponent = type('MockComponent', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('(') # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf(type='(', opening_bracket=None), # pragma: no cover"",
            ""        Leaf(type='element', opening_bracket=None), # pragma: no cover"",
            ""        Leaf(type=')', opening_bracket=matching_bracket) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""exit = lambda x: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    if not head or not body or not tail: # pragma: no cover"",
            ""        raise CannotSplit('Bracket split failed') # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf(type='('), # pragma: no cover"",
            ""        Leaf(type='number', opening_bracket=None), # pragma: no cover"",
            ""        Leaf(type=')', opening_bracket=Leaf(type='(')) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""exit = lambda x: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'result' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('(') # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('Mock', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf(type='{'), # pragma: no cover"",
            ""        Leaf(type='body_element', opening_bracket=Leaf(type='{')), # pragma: no cover"",
            ""        Leaf(type='}', opening_bracket=Leaf(type='{')) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""exit = lambda aux: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""_BracketSplitComponent = SimpleNamespace(head='head', body='body', tail='tail') # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('(') # pragma: no cover"",
            ""line = SimpleNamespace(leaves=[ # pragma: no cover"",
            ""    Leaf('content1'), # pragma: no cover"",
            ""    matching_bracket, # pragma: no cover"",
            ""    Leaf('content2'), # pragma: no cover"",
            ""    Leaf(')', matching_bracket) # pragma: no cover"",
            ""]) # pragma: no cover"",
            "" # pragma: no cover"",
            ""exit = lambda aux: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""_BracketSplitComponent = type('MockComponent', (object,), {'head': 'head', 'body': 'body', 'tail': 'tail'}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('(', None), # pragma: no cover"",
            ""        Leaf('number', None), # pragma: no cover"",
            ""        Leaf(')', Leaf('(')) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""exit = lambda aux: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, leaf_type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = leaf_type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPEN'} # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSE'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""_BracketSplitComponent = type('_BracketSplitComponent', (object,), { # pragma: no cover"",
            ""    'head': 'head', # pragma: no cover"",
            ""    'body': 'body', # pragma: no cover"",
            ""    'tail': 'tail' # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('OPEN') # pragma: no cover"",
            ""line = type('Mock', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('OPEN'), # pragma: no cover"",
            ""        Leaf('content', matching_bracket), # pragma: no cover"",
            ""        Leaf('CLOSE', matching_bracket) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""exit = lambda x: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'result' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('(', opening_bracket=None) # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('(', None), # pragma: no cover"",
            ""        Leaf('content', matching_bracket), # pragma: no cover"",
            ""        Leaf(')', matching_bracket) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""exit = lambda x: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'result' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('(') # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf(type='(', opening_bracket=None), # pragma: no cover"",
            ""        Leaf(type='content', opening_bracket=None), # pragma: no cover"",
            ""        Leaf(type=')', opening_bracket=matching_bracket), # pragma: no cover"",
            ""        Leaf(type='additional', opening_bracket=None) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""exit = lambda x: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    assert head and body and tail # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('(', None), # pragma: no cover"",
            ""        Leaf('content'), # pragma: no cover"",
            ""        Leaf(')',Leaf('(')) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""exit = lambda aux: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'result' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('(') # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf(type='(', opening_bracket=None), # pragma: no cover"",
            ""        Leaf(type='identifier', opening_bracket=None), # pragma: no cover"",
            ""        Leaf(type=')', opening_bracket=matching_bracket) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""exit = lambda aux: None # pragma: no cover""
        ]
    }
]",3,8107,0.0040535,3156,0.004734,0.0087875
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Split line into many lines, starting with the first matching bracket pair.
    Note: this usually looks weird, only use this for function definitions.
    Prefer RHS otherwise.  This is why this function is not symmetrical with
    :func:`right_hand_split` which also handles optional parentheses.
    """"""
tail_leaves: List[Leaf] = []
body_leaves: List[Leaf] = []
head_leaves: List[Leaf] = []
current_leaves = head_leaves
matching_bracket: Optional[Leaf] = None
for leaf in line.leaves:
    if ( # uncovered
        current_leaves is body_leaves # uncovered
        and leaf.type in CLOSING_BRACKETS # uncovered
        and leaf.opening_bracket is matching_bracket # uncovered
        and isinstance(matching_bracket, Leaf) # uncovered
    ):
        ensure_visible(leaf)
        ensure_visible(matching_bracket)
        current_leaves = tail_leaves if body_leaves else head_leaves
    current_leaves.append(leaf)
    if current_leaves is head_leaves:
        if leaf.type in OPENING_BRACKETS:
            matching_bracket = leaf
            current_leaves = body_leaves
if not matching_bracket:
    raise CannotSplit(""No brackets found"") # uncovered
head = bracket_split_build_line( # uncovered
    head_leaves, line, matching_bracket, component=_BracketSplitComponent.head # uncovered
)
body = bracket_split_build_line( # uncovered
    body_leaves, line, matching_bracket, component=_BracketSplitComponent.body # uncovered
)
tail = bracket_split_build_line( # uncovered
    tail_leaves, line, matching_bracket, component=_BracketSplitComponent.tail # uncovered
)
bracket_split_succeeded_or_raise(head, body, tail)
for result in (head, body, tail):
    if result:
        aux = result
        exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return True"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""OPENING_BRACKETS = {'OPEN'}"",
            ""CLOSING_BRACKETS = {'CLOSE'}"",
            """",
            ""matching_bracket = Leaf('OPEN')"",
            ""line = type('Mock', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('OPEN'),"",
            ""        Leaf('content1', matching_bracket),"",
            ""        Leaf('CLOSE', matching_bracket)"",
            ""    ]"",
            ""})()"",
            """",
            ""exit = lambda x: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, leaf_type, opening_bracket=None):"",
            ""        self.type = leaf_type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'result'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""OPENING_BRACKETS = {'('}"",
            ""CLOSING_BRACKETS = {')'}"",
            """",
            ""matching_bracket = Leaf('(')"",
            ""line = type('Mock', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('content1'),"",
            ""        Leaf('(', matching_bracket),"",
            ""        Leaf('content2'),"",
            ""        Leaf(')', matching_bracket)"",
            ""    ]"",
            ""})()"",
            """",
            ""exit = lambda x: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type_, opening_bracket=None):"",
            ""        self.type = type_"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""OPENING_BRACKETS = {'OPEN'}"",
            ""CLOSING_BRACKETS = {'CLOSE'}"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""matching_bracket = Leaf('OPEN')"",
            ""leaf1 = Leaf('OPEN')"",
            ""leaf2 = Leaf('CLOSE', opening_bracket=matching_bracket)"",
            ""line = type('Mock', (object,), {"",
            ""    'leaves': [leaf1, leaf2]"",
            ""})()"",
            ""exit = lambda x: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'result'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""matching_bracket = Leaf('(')"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('(', None),"",
            ""        Leaf('content1'),"",
            ""        Leaf(')', matching_bracket),"",
            ""        Leaf('extra_content')"",
            ""    ]"",
            ""})()"",
            ""exit = lambda aux: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return SimpleNamespace()"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""_BracketSplitComponent = type('_BracketSplitComponent', (object,), {"",
            ""    'head': 'head',"",
            ""    'body': 'body',"",
            ""    'tail': 'tail'"",
            ""})"",
            """",
            ""matching_bracket = Leaf('(')"",
            ""line = type('Mock', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('(', None),"",
            ""        Leaf('identifier', matching_bracket),"",
            ""        Leaf(')', matching_bracket)"",
            ""    ]"",
            ""})()"",
            """",
            ""exit = lambda aux: print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'result'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""matching_bracket = Leaf('(')"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf(type='(', opening_bracket=None),"",
            ""        Leaf(type=')', opening_bracket=matching_bracket)"",
            ""    ]"",
            ""})()"",
            ""exit = lambda aux: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""matching_bracket = Leaf('(', None)"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('(', None),"",
            ""        Leaf('content'),"",
            ""        Leaf(')', Leaf('('))"",
            ""    ]"",
            ""})()"",
            ""exit = lambda x: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'result'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""matching_bracket = Leaf('(')"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf(type='(', opening_bracket=None),"",
            ""        Leaf(type='element1', opening_bracket=matching_bracket),"",
            ""        Leaf(type=')', opening_bracket=matching_bracket)"",
            ""    ]"",
            ""})()"",
            ""exit = lambda x: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""OPENING_BRACKETS = {'('}"",
            ""CLOSING_BRACKETS = {')'}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content'),"",
            ""        Leaf(')'),"",
            ""        Leaf('extra')"",
            ""    ]"",
            ""})"",
            ""matching_bracket = line.leaves[0]"",
            ""line.leaves[2].opening_bracket = matching_bracket"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, leaf_type, opening_bracket=None):"",
            ""        self.type = leaf_type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""matching_bracket = Leaf('(')"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('(','('),"",
            ""        Leaf('arg', opening_bracket=matching_bracket),"",
            ""        Leaf(')', matching_bracket)"",
            ""    ]"",
            ""})()"",
            ""exit = lambda x: None""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPEN'} # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSE'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('OPEN') # pragma: no cover"",
            ""line = type('Mock', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('OPEN'), # pragma: no cover"",
            ""        Leaf('content1', matching_bracket), # pragma: no cover"",
            ""        Leaf('CLOSE', matching_bracket) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""exit = lambda x: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, leaf_type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = leaf_type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'result' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('(') # pragma: no cover"",
            ""line = type('Mock', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('content1'), # pragma: no cover"",
            ""        Leaf('(', matching_bracket), # pragma: no cover"",
            ""        Leaf('content2'), # pragma: no cover"",
            ""        Leaf(')', matching_bracket) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""exit = lambda x: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {'OPEN'} # pragma: no cover"",
            ""CLOSING_BRACKETS = {'CLOSE'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('OPEN') # pragma: no cover"",
            ""leaf1 = Leaf('OPEN') # pragma: no cover"",
            ""leaf2 = Leaf('CLOSE', opening_bracket=matching_bracket) # pragma: no cover"",
            ""line = type('Mock', (object,), { # pragma: no cover"",
            ""    'leaves': [leaf1, leaf2] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""exit = lambda x: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'result' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('(') # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('(', None), # pragma: no cover"",
            ""        Leaf('content1'), # pragma: no cover"",
            ""        Leaf(')', matching_bracket), # pragma: no cover"",
            ""        Leaf('extra_content') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""exit = lambda aux: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return SimpleNamespace() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""_BracketSplitComponent = type('_BracketSplitComponent', (object,), { # pragma: no cover"",
            ""    'head': 'head', # pragma: no cover"",
            ""    'body': 'body', # pragma: no cover"",
            ""    'tail': 'tail' # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('(') # pragma: no cover"",
            ""line = type('Mock', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('(', None), # pragma: no cover"",
            ""        Leaf('identifier', matching_bracket), # pragma: no cover"",
            ""        Leaf(')', matching_bracket) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""exit = lambda aux: print(aux) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'result' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('(') # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf(type='(', opening_bracket=None), # pragma: no cover"",
            ""        Leaf(type=')', opening_bracket=matching_bracket) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""exit = lambda aux: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('(', None) # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('(', None), # pragma: no cover"",
            ""        Leaf('content'), # pragma: no cover"",
            ""        Leaf(')', Leaf('(')) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""exit = lambda x: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'result' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('(') # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf(type='(', opening_bracket=None), # pragma: no cover"",
            ""        Leaf(type='element1', opening_bracket=matching_bracket), # pragma: no cover"",
            ""        Leaf(type=')', opening_bracket=matching_bracket) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""exit = lambda x: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content'), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('extra') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""matching_bracket = line.leaves[0] # pragma: no cover"",
            ""line.leaves[2].opening_bracket = matching_bracket # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, leaf_type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = leaf_type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('(') # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('(','('), # pragma: no cover"",
            ""        Leaf('arg', opening_bracket=matching_bracket), # pragma: no cover"",
            ""        Leaf(')', matching_bracket) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""exit = lambda x: None # pragma: no cover""
        ]
    }
]",3,11938,0.005969,3135,0.0047025,0.0106715
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Split line into many lines, starting with the first matching bracket pair.
    Note: this usually looks weird, only use this for function definitions.
    Prefer RHS otherwise.  This is why this function is not symmetrical with
    :func:`right_hand_split` which also handles optional parentheses.
    """"""
tail_leaves: List[Leaf] = []
body_leaves: List[Leaf] = []
head_leaves: List[Leaf] = []
current_leaves = head_leaves
matching_bracket: Optional[Leaf] = None
for leaf in line.leaves:
    if ( # uncovered
        current_leaves is body_leaves # uncovered
        and leaf.type in CLOSING_BRACKETS # uncovered
        and leaf.opening_bracket is matching_bracket # uncovered
        and isinstance(matching_bracket, Leaf) # uncovered
    ):
        ensure_visible(leaf)
        ensure_visible(matching_bracket)
        current_leaves = tail_leaves if body_leaves else head_leaves
    current_leaves.append(leaf)
    if current_leaves is head_leaves:
        if leaf.type in OPENING_BRACKETS:
            matching_bracket = leaf
            current_leaves = body_leaves
if not matching_bracket:
    raise CannotSplit(""No brackets found"") # uncovered
head = bracket_split_build_line( # uncovered
    head_leaves, line, matching_bracket, component=_BracketSplitComponent.head # uncovered
)
body = bracket_split_build_line( # uncovered
    body_leaves, line, matching_bracket, component=_BracketSplitComponent.body # uncovered
)
tail = bracket_split_build_line( # uncovered
    tail_leaves, line, matching_bracket, component=_BracketSplitComponent.tail # uncovered
)
bracket_split_succeeded_or_raise(head, body, tail)
for result in (head, body, tail):
    if result:
        aux = result
        exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('(', None),"",
            ""        Leaf('content', None),"",
            ""        Leaf(')', None),"",
            ""        Leaf('extra', None)"",
            ""    ]"",
            ""})()"",
            ""line.leaves[2].opening_bracket = line.leaves[0]"",
            ""matching_bracket = line.leaves[0]"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf(')'),"",
            ""        Leaf('dummy')"",
            ""    ]"",
            ""})()"",
            """",
            ""line.leaves[1].opening_bracket = line.leaves[0]"",
            ""matching_bracket = line.leaves[0]"",
            """",
            ""exit = lambda x: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, leaf_type, opening_bracket=None):"",
            ""        self.type = leaf_type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    return"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""OPENING_BRACKETS = {'('}"",
            ""CLOSING_BRACKETS = {')'}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('identifier', opening_bracket=None),"",
            ""        Leaf(')', opening_bracket=Leaf('(')),"",
            ""        Leaf('extra', opening_bracket=None)"",
            ""    ]"",
            ""})()"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""matching_bracket = Leaf('(')"",
            ""line = type('Mock', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('content'),"",
            ""        Leaf('(', None),"",
            ""        Leaf('content', matching_bracket),"",
            ""        Leaf(')', matching_bracket)"",
            ""    ]"",
            ""})()"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('content'),"",
            ""        Leaf('('),"",
            ""        Leaf('content'),"",
            ""        Leaf(')'),"",
            ""        Leaf('content')"",
            ""    ]"",
            ""})()"",
            """",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('(', None),"",
            ""        Leaf('content'),"",
            ""        Leaf(')', Leaf('(')),"",
            ""        Leaf(']'),"",
            ""        Leaf('}', Leaf('{'))"",
            ""    ]"",
            ""})()"",
            ""exit = lambda aux: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('identifier', opening_bracket=None),"",
            ""        Leaf(')', opening_bracket=Leaf('('))"",
            ""    ]"",
            ""})()"",
            ""exit = lambda x: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""OPENING_BRACKETS = {'('}"",
            ""CLOSING_BRACKETS = {')'}"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves if leaves else None"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    if not head or not body or not tail:"",
            ""        raise CannotSplit('Bracket split failed')"",
            """",
            ""_BracketSplitComponent = type('_BracketSplitComponent', (object,), {"",
            ""    'head': 'head',"",
            ""    'body': 'body',"",
            ""    'tail': 'tail'"",
            ""})"",
            """",
            ""matching_bracket = Leaf('(')"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content1', matching_bracket),"",
            ""        Leaf('content2'),"",
            ""        Leaf(')'),"",
            ""        Leaf('extra')"",
            ""    ]"",
            ""})()"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, leaf_type, opening_bracket=None):"",
            ""        self.type = leaf_type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""matching_bracket = Leaf('(')"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('(', None),"",
            ""        Leaf('arg', opening_bracket=matching_bracket),"",
            ""        Leaf(')', matching_bracket)"",
            ""    ]"",
            ""})()"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type_, opening_bracket=None):"",
            ""        self.type = type_"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'result'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""matching_bracket = Leaf('(')"",
            ""line = type('Mock', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content'),"",
            ""        Leaf(')', matching_bracket),"",
            ""        Leaf('extra_content')"",
            ""    ]"",
            ""})()"",
            """",
            ""exit = lambda x: print(x)""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('(', None), # pragma: no cover"",
            ""        Leaf('content', None), # pragma: no cover"",
            ""        Leaf(')', None), # pragma: no cover"",
            ""        Leaf('extra', None) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[2].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""matching_bracket = line.leaves[0] # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('dummy') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.leaves[1].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""matching_bracket = line.leaves[0] # pragma: no cover"",
            "" # pragma: no cover"",
            ""exit = lambda x: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, leaf_type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = leaf_type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    return # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('identifier', opening_bracket=None), # pragma: no cover"",
            ""        Leaf(')', opening_bracket=Leaf('(')), # pragma: no cover"",
            ""        Leaf('extra', opening_bracket=None) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('(') # pragma: no cover"",
            ""line = type('Mock', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('content'), # pragma: no cover"",
            ""        Leaf('(', None), # pragma: no cover"",
            ""        Leaf('content', matching_bracket), # pragma: no cover"",
            ""        Leaf(')', matching_bracket) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('content'), # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content'), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('content') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('(', None), # pragma: no cover"",
            ""        Leaf('content'), # pragma: no cover"",
            ""        Leaf(')', Leaf('(')), # pragma: no cover"",
            ""        Leaf(']'), # pragma: no cover"",
            ""        Leaf('}', Leaf('{')) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""exit = lambda aux: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('identifier', opening_bracket=None), # pragma: no cover"",
            ""        Leaf(')', opening_bracket=Leaf('(')) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""exit = lambda x: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves if leaves else None # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    if not head or not body or not tail: # pragma: no cover"",
            ""        raise CannotSplit('Bracket split failed') # pragma: no cover"",
            "" # pragma: no cover"",
            ""_BracketSplitComponent = type('_BracketSplitComponent', (object,), { # pragma: no cover"",
            ""    'head': 'head', # pragma: no cover"",
            ""    'body': 'body', # pragma: no cover"",
            ""    'tail': 'tail' # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('(') # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content1', matching_bracket), # pragma: no cover"",
            ""        Leaf('content2'), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('extra') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, leaf_type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = leaf_type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('(') # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('(', None), # pragma: no cover"",
            ""        Leaf('arg', opening_bracket=matching_bracket), # pragma: no cover"",
            ""        Leaf(')', matching_bracket) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'result' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('(') # pragma: no cover"",
            ""line = type('Mock', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content'), # pragma: no cover"",
            ""        Leaf(')', matching_bracket), # pragma: no cover"",
            ""        Leaf('extra_content') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    }
]",3,11965,0.0059825,3183,0.0047745,0.010757
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Split line into many lines, starting with the first matching bracket pair.
    Note: this usually looks weird, only use this for function definitions.
    Prefer RHS otherwise.  This is why this function is not symmetrical with
    :func:`right_hand_split` which also handles optional parentheses.
    """"""
tail_leaves: List[Leaf] = []
body_leaves: List[Leaf] = []
head_leaves: List[Leaf] = []
current_leaves = head_leaves
matching_bracket: Optional[Leaf] = None
for leaf in line.leaves:
    if ( # uncovered
        current_leaves is body_leaves # uncovered
        and leaf.type in CLOSING_BRACKETS # uncovered
        and leaf.opening_bracket is matching_bracket # uncovered
        and isinstance(matching_bracket, Leaf) # uncovered
    ):
        ensure_visible(leaf)
        ensure_visible(matching_bracket)
        current_leaves = tail_leaves if body_leaves else head_leaves
    current_leaves.append(leaf)
    if current_leaves is head_leaves:
        if leaf.type in OPENING_BRACKETS:
            matching_bracket = leaf
            current_leaves = body_leaves
if not matching_bracket:
    raise CannotSplit(""No brackets found"") # uncovered
head = bracket_split_build_line( # uncovered
    head_leaves, line, matching_bracket, component=_BracketSplitComponent.head # uncovered
)
body = bracket_split_build_line( # uncovered
    body_leaves, line, matching_bracket, component=_BracketSplitComponent.body # uncovered
)
tail = bracket_split_build_line( # uncovered
    tail_leaves, line, matching_bracket, component=_BracketSplitComponent.tail # uncovered
)
bracket_split_succeeded_or_raise(head, body, tail)
for result in (head, body, tail):
    if result:
        aux = result
        exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    if not head or not body or not tail:"",
            ""        raise CannotSplit('Bracket split failed')"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content'),"",
            ""        Leaf(')'),"",
            ""        Leaf('extra')"",
            ""    ]"",
            ""})()"",
            ""line.leaves[1].opening_bracket = line.leaves[0]"",
            ""line.leaves[2].opening_bracket = line.leaves[0]"",
            """",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content1', None),"",
            ""        Leaf('content2', None),"",
            ""        Leaf(')', Leaf('('))"",
            ""    ]"",
            ""})()"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""matching_bracket = Leaf('(')"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content'),"",
            ""        Leaf(')'),"",
            ""        Leaf('}'),"",
            ""        Leaf('extra')"",
            ""    ]"",
            ""})()"",
            """",
            ""line.leaves[2].opening_bracket = line.leaves[0]"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'result'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {']'}"",
            ""OPENING_BRACKETS = {'['}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('[', None),"",
            ""        Leaf('content', None),"",
            ""        Leaf(']', Leaf('['))"",
            ""    ]"",
            ""})()"",
            ""matching_bracket = line.leaves[0]"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""matching_bracket = Leaf('(', None)"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('content'),"",
            ""        Leaf('(', None),"",
            ""        Leaf(')', Leaf('('))"",
            ""    ]"",
            ""})()"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('identifier', opening_bracket=None),"",
            ""        Leaf(')', opening_bracket=Leaf('('))"",
            ""    ]"",
            ""})()"",
            ""matching_bracket = line.leaves[0]"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type_, opening_bracket=None):"",
            ""        self.type = type_"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""OPENING_BRACKETS = {'('}"",
            ""CLOSING_BRACKETS = {')'}"",
            """",
            ""matching_bracket = Leaf('(')"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf(')'),"",
            ""    ]"",
            ""})()"",
            ""line.leaves[1].opening_bracket = line.leaves[0]"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""matching_bracket = Leaf('(')"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content', matching_bracket),"",
            ""        Leaf(')'),"",
            ""        Leaf('extra')"",
            ""    ]"",
            ""})()"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type_, opening_bracket=None):"",
            ""        self.type = type_"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'result'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""matching_bracket = Leaf('(')"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('(', None),"",
            ""        Leaf('content'),"",
            ""        Leaf(')', matching_bracket)"",
            ""    ]"",
            ""})()"",
            ""exit = lambda x: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""matching_bracket = Leaf('(')"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('content'),"",
            ""        Leaf('('),"",
            ""        Leaf('content1'),"",
            ""        Leaf(')'),"",
            ""        Leaf('content2')"",
            ""    ]"",
            ""})()"",
            ""line.leaves[3].opening_bracket = line.leaves[1]"",
            """",
            ""exit = lambda aux: print(aux)""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    if not head or not body or not tail: # pragma: no cover"",
            ""        raise CannotSplit('Bracket split failed') # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content'), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('extra') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[1].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""line.leaves[2].opening_bracket = line.leaves[0] # pragma: no cover"",
            "" # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content1', None), # pragma: no cover"",
            ""        Leaf('content2', None), # pragma: no cover"",
            ""        Leaf(')', Leaf('(')) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('(') # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content'), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('}'), # pragma: no cover"",
            ""        Leaf('extra') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.leaves[2].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'result' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {']'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'['} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('[', None), # pragma: no cover"",
            ""        Leaf('content', None), # pragma: no cover"",
            ""        Leaf(']', Leaf('[')) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""matching_bracket = line.leaves[0] # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('(', None) # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('content'), # pragma: no cover"",
            ""        Leaf('(', None), # pragma: no cover"",
            ""        Leaf(')', Leaf('(')) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('identifier', opening_bracket=None), # pragma: no cover"",
            ""        Leaf(')', opening_bracket=Leaf('(')) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""matching_bracket = line.leaves[0] # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('(') # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[1].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('(') # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content', matching_bracket), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('extra') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'result' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('(') # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('(', None), # pragma: no cover"",
            ""        Leaf('content'), # pragma: no cover"",
            ""        Leaf(')', matching_bracket) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""exit = lambda x: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('(') # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('content'), # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content1'), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('content2') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[3].opening_bracket = line.leaves[1] # pragma: no cover"",
            "" # pragma: no cover"",
            ""exit = lambda aux: print(aux) # pragma: no cover""
        ]
    }
]",3,12197,0.0060985,3159,0.0047385,0.010837
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Split line into many lines, starting with the first matching bracket pair.
    Note: this usually looks weird, only use this for function definitions.
    Prefer RHS otherwise.  This is why this function is not symmetrical with
    :func:`right_hand_split` which also handles optional parentheses.
    """"""
tail_leaves: List[Leaf] = []
body_leaves: List[Leaf] = []
head_leaves: List[Leaf] = []
current_leaves = head_leaves
matching_bracket: Optional[Leaf] = None
for leaf in line.leaves:
    if ( # uncovered
        current_leaves is body_leaves # uncovered
        and leaf.type in CLOSING_BRACKETS # uncovered
        and leaf.opening_bracket is matching_bracket # uncovered
        and isinstance(matching_bracket, Leaf) # uncovered
    ):
        ensure_visible(leaf)
        ensure_visible(matching_bracket)
        current_leaves = tail_leaves if body_leaves else head_leaves
    current_leaves.append(leaf)
    if current_leaves is head_leaves:
        if leaf.type in OPENING_BRACKETS:
            matching_bracket = leaf
            current_leaves = body_leaves
if not matching_bracket:
    raise CannotSplit(""No brackets found"") # uncovered
head = bracket_split_build_line( # uncovered
    head_leaves, line, matching_bracket, component=_BracketSplitComponent.head # uncovered
)
body = bracket_split_build_line( # uncovered
    body_leaves, line, matching_bracket, component=_BracketSplitComponent.body # uncovered
)
tail = bracket_split_build_line( # uncovered
    tail_leaves, line, matching_bracket, component=_BracketSplitComponent.tail # uncovered
)
bracket_split_succeeded_or_raise(head, body, tail)
for result in (head, body, tail):
    if result:
        aux = result
        exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'result'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('element1', matching_bracket=None),"",
            ""        Leaf(')', matching_bracket=Leaf('(')),"",
            ""        Leaf('element2', matching_bracket=None),"",
            ""        Leaf('=', matching_bracket=None)"",
            ""    ]"",
            ""})()"",
            ""exit = lambda x: x""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""matching_bracket = Leaf('(')"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('(', None),"",
            ""        Leaf('content1'),"",
            ""        Leaf('content2'),"",
            ""        Leaf(')', '(', matching_bracket)"",
            ""    ]"",
            ""})()"",
            ""matching_bracket = line.leaves[0]"",
            ""line.leaves[3].opening_bracket = line.leaves[0]"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content1', None),"",
            ""        Leaf(')'),"",
            ""        Leaf('extra', None)"",
            ""    ]"",
            ""})()"",
            ""line.leaves[2].opening_bracket = line.leaves[0]"",
            ""line.leaves[1].opening_bracket = line.leaves[0]"",
            """",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('{'),"",
            ""        Leaf('content1', matching_bracket=None),"",
            ""        Leaf('}', '{')"",
            ""    ]"",
            ""})()"",
            ""matching_bracket = line.leaves[0]"",
            ""line.leaves[2].opening_bracket = matching_bracket"",
            """",
            ""exit = lambda aux: print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content1'),"",
            ""        Leaf(')'),"",
            ""        Leaf('content2')"",
            ""    ]"",
            ""})()"",
            ""matching_bracket = line.leaves[0]"",
            ""line.leaves[2].opening_bracket = matching_bracket"",
            ""exit = lambda x: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type_, opening_bracket=None):"",
            ""        self.type = type_"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'result'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content'),"",
            ""        Leaf(')', opening_bracket=Leaf('(')),"",
            ""        Leaf('('),"",
            ""        Leaf(')'),"",
            ""        Leaf(']'),"",
            ""        Leaf('}'),"",
            ""        Leaf('extra')"",
            ""    ]"",
            ""})()"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""matching_bracket = Leaf('(')"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content'),"",
            ""        Leaf(')'),"",
            ""    ]"",
            ""})()"",
            ""line.leaves[2].opening_bracket = line.leaves[0]"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'result'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('(', None),"",
            ""        Leaf('content1', None),"",
            ""        Leaf('content2', None),"",
            ""        Leaf(')', Leaf('('))"",
            ""    ]"",
            ""})()"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'result'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content'),"",
            ""        Leaf('content_end'),"",
            ""        Leaf(')'),"",
            ""        Leaf('extra')"",
            ""    ]"",
            ""})()"",
            ""line.leaves[3].opening_bracket = line.leaves[0]"",
            ""exit = lambda aux: print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    if not head or not body or not tail:"",
            ""        raise CannotSplit('Bracket split failed')"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content1', None),"",
            ""        Leaf(')', Leaf('(')),"",
            ""        Leaf('extra', None)"",
            ""    ]"",
            ""})()"",
            ""exit = lambda x: print(x)""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content1', None), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('extra', None) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[2].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""line.leaves[1].opening_bracket = line.leaves[0] # pragma: no cover"",
            "" # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content1'), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('content2') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""matching_bracket = line.leaves[0] # pragma: no cover"",
            ""line.leaves[2].opening_bracket = matching_bracket # pragma: no cover"",
            ""exit = lambda x: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'result' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content'), # pragma: no cover"",
            ""        Leaf(')', opening_bracket=Leaf('(')), # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf(']'), # pragma: no cover"",
            ""        Leaf('}'), # pragma: no cover"",
            ""        Leaf('extra') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('(') # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content'), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[2].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'result' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('(', None), # pragma: no cover"",
            ""        Leaf('content1', None), # pragma: no cover"",
            ""        Leaf('content2', None), # pragma: no cover"",
            ""        Leaf(')', Leaf('(')) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'result' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content'), # pragma: no cover"",
            ""        Leaf('content_end'), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('extra') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[3].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""exit = lambda aux: print(aux) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    if not head or not body or not tail: # pragma: no cover"",
            ""        raise CannotSplit('Bracket split failed') # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content1', None), # pragma: no cover"",
            ""        Leaf(')', Leaf('(')), # pragma: no cover"",
            ""        Leaf('extra', None) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    }
]",3,12200,0.0061,3234,0.004851,0.010951
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Split line into many lines, starting with the first matching bracket pair.
    Note: this usually looks weird, only use this for function definitions.
    Prefer RHS otherwise.  This is why this function is not symmetrical with
    :func:`right_hand_split` which also handles optional parentheses.
    """"""
tail_leaves: List[Leaf] = []
body_leaves: List[Leaf] = []
head_leaves: List[Leaf] = []
current_leaves = head_leaves
matching_bracket: Optional[Leaf] = None
for leaf in line.leaves:
    if ( # uncovered
        current_leaves is body_leaves # uncovered
        and leaf.type in CLOSING_BRACKETS # uncovered
        and leaf.opening_bracket is matching_bracket # uncovered
        and isinstance(matching_bracket, Leaf) # uncovered
    ):
        ensure_visible(leaf)
        ensure_visible(matching_bracket)
        current_leaves = tail_leaves if body_leaves else head_leaves
    current_leaves.append(leaf)
    if current_leaves is head_leaves:
        if leaf.type in OPENING_BRACKETS:
            matching_bracket = leaf
            current_leaves = body_leaves
if not matching_bracket:
    raise CannotSplit(""No brackets found"") # uncovered
head = bracket_split_build_line( # uncovered
    head_leaves, line, matching_bracket, component=_BracketSplitComponent.head # uncovered
)
body = bracket_split_build_line( # uncovered
    body_leaves, line, matching_bracket, component=_BracketSplitComponent.body # uncovered
)
tail = bracket_split_build_line( # uncovered
    tail_leaves, line, matching_bracket, component=_BracketSplitComponent.tail # uncovered
)
bracket_split_succeeded_or_raise(head, body, tail)
for result in (head, body, tail):
    if result:
        aux = result
        exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        this.opening_bracket = opening_bracket"",
            ""        this.type = type"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('content'),"",
            ""        Leaf('('),"",
            ""        Leaf(')'),"",
            ""        Leaf('content')"",
            ""    ]"",
            ""})()"",
            ""line.leaves[2].opening_bracket = line.leaves[1]"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content1', None),"",
            ""        Leaf(')', None),"",
            ""        Leaf('content2', None)"",
            ""    ]"",
            ""})()"",
            ""line.leaves[2].opening_bracket = line.leaves[0]"",
            ""line.leaves[3].opening_bracket = line.leaves[0]"",
            """",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content1'),"",
            ""        Leaf(')'),"",
            ""        Leaf('extra')"",
            ""    ]"",
            ""})()"",
            ""line.leaves[2].opening_bracket = line.leaves[0]"",
            ""matching_bracket = line.leaves[0]"",
            ""exit = lambda aux: print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content'),"",
            ""        Leaf(')'),"",
            ""        Leaf('extra')"",
            ""    ]"",
            ""})()"",
            ""line.leaves[2].opening_bracket = line.leaves[0]"",
            ""matching_bracket = line.leaves[0]"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content1'),"",
            ""        Leaf(')'),"",
            ""        Leaf('}'),"",
            ""        Leaf('content2')"",
            ""    ]"",
            ""})()"",
            ""line.leaves[2].opening_bracket = line.leaves[0]"",
            """",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content1'),"",
            ""        Leaf(')'),"",
            ""        Leaf('content2')"",
            ""    ]"",
            ""})()"",
            ""line.leaves[2].opening_bracket = line.leaves[0]"",
            ""matching_bracket = line.leaves[0]"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    if not head or not body or not tail:"",
            ""        raise CannotSplit('Bracket split failed')"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content'),"",
            ""        Leaf(')'),"",
            ""        Leaf('extra')"",
            ""    ]"",
            ""})()"",
            ""line.leaves[2].opening_bracket = line.leaves[0]"",
            ""matching_bracket = line.leaves[0]"",
            """",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""matching_bracket = Leaf('(')"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content'),"",
            ""        Leaf(')'),"",
            ""        Leaf(';')"",
            ""    ]"",
            ""})()"",
            ""line.leaves[2].opening_bracket = line.leaves[0]"",
            ""exit = lambda aux: print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content1'),"",
            ""        Leaf(')'),"",
            ""        Leaf('extra')"",
            ""    ]"",
            ""})()"",
            ""line.leaves[1].opening_bracket = line.leaves[0]"",
            ""line.leaves[2].opening_bracket = line.leaves[0]"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content1', None),"",
            ""        Leaf('content2', None),"",
            ""        Leaf(')', Leaf('('))"",
            ""    ]"",
            ""})()"",
            ""matching_bracket = line.leaves[0]"",
            ""exit = lambda x: print(x)""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        pass"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('content'), # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('content') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[2].opening_bracket = line.leaves[1] # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content1', None), # pragma: no cover"",
            ""        Leaf(')', None), # pragma: no cover"",
            ""        Leaf('content2', None) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[2].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""line.leaves[3].opening_bracket = line.leaves[0] # pragma: no cover"",
            "" # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content1'), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('extra') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[2].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""matching_bracket = line.leaves[0] # pragma: no cover"",
            ""exit = lambda aux: print(aux) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content'), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('extra') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[2].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""matching_bracket = line.leaves[0] # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content1'), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('}'), # pragma: no cover"",
            ""        Leaf('content2') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[2].opening_bracket = line.leaves[0] # pragma: no cover"",
            "" # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content1'), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('content2') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[2].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""matching_bracket = line.leaves[0] # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    if not head or not body or not tail: # pragma: no cover"",
            ""        raise CannotSplit('Bracket split failed') # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content'), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('extra') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[2].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""matching_bracket = line.leaves[0] # pragma: no cover"",
            "" # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('(') # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content'), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf(';') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[2].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""exit = lambda aux: print(aux) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content1'), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('extra') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[1].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""line.leaves[2].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content1', None), # pragma: no cover"",
            ""        Leaf('content2', None), # pragma: no cover"",
            ""        Leaf(')', Leaf('(')) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""matching_bracket = line.leaves[0] # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    }
]",3,8441,0.0042205,3250,0.004875,0.0090955
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Split line into many lines, starting with the first matching bracket pair.
    Note: this usually looks weird, only use this for function definitions.
    Prefer RHS otherwise.  This is why this function is not symmetrical with
    :func:`right_hand_split` which also handles optional parentheses.
    """"""
tail_leaves: List[Leaf] = []
body_leaves: List[Leaf] = []
head_leaves: List[Leaf] = []
current_leaves = head_leaves
matching_bracket: Optional[Leaf] = None
for leaf in line.leaves:
    if ( # uncovered
        current_leaves is body_leaves # uncovered
        and leaf.type in CLOSING_BRACKETS # uncovered
        and leaf.opening_bracket is matching_bracket # uncovered
        and isinstance(matching_bracket, Leaf) # uncovered
    ):
        ensure_visible(leaf)
        ensure_visible(matching_bracket)
        current_leaves = tail_leaves if body_leaves else head_leaves
    current_leaves.append(leaf)
    if current_leaves is head_leaves:
        if leaf.type in OPENING_BRACKETS:
            matching_bracket = leaf
            current_leaves = body_leaves
if not matching_bracket:
    raise CannotSplit(""No brackets found"") # uncovered
head = bracket_split_build_line( # uncovered
    head_leaves, line, matching_bracket, component=_BracketSplitComponent.head # uncovered
)
body = bracket_split_build_line( # uncovered
    body_leaves, line, matching_bracket, component=_BracketSplitComponent.body # uncovered
)
tail = bracket_split_build_line( # uncovered
    tail_leaves, line, matching_bracket, component=_BracketSplitComponent.tail # uncovered
)
bracket_split_succeeded_or_raise(head, body, tail)
for result in (head, body, tail):
    if result:
        aux = result
        exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content1'),"",
            ""        Leaf(')'),"",
            ""        Leaf('content2')"",
            ""    ]"",
            ""})()"",
            ""line.leaves[2].opening_bracket = line.leaves[0]"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('content1'),"",
            ""        Leaf('('),"",
            ""        Leaf('content2', None),"",
            ""        Leaf(')'),"",
            ""        Leaf('content3')"",
            ""    ]"",
            ""})()"",
            ""line.leaves[3].opening_bracket = line.leaves[1]"",
            ""exit = lambda aux: print(aux)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content1'),"",
            ""        Leaf('content2'),"",
            ""        Leaf(')', '(')"",
            ""    ]"",
            ""})()"",
            ""line.leaves[3].opening_bracket = line.leaves[0]"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'result'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content'),"",
            ""        Leaf(')'),"",
            ""        Leaf('content_end')"",
            ""    ]"",
            ""})()"",
            ""line.leaves[2].opening_bracket = line.leaves[0]"",
            ""exit = lambda x: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'result'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content1'),"",
            ""        Leaf(')'),"",
            ""        Leaf('extra', '(')"",
            ""    ]"",
            ""})()"",
            ""line.leaves[2].opening_bracket = line.leaves[0]"",
            ""matching_bracket = line.leaves[0]"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('content'),"",
            ""        Leaf('('),"",
            ""        Leaf(')'),"",
            ""        Leaf('content')"",
            ""    ]"",
            ""})()"",
            ""line.leaves[2].opening_bracket = line.leaves[1]"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('content1'),"",
            ""        Leaf('('),"",
            ""        Leaf('content2'),"",
            ""        Leaf(')'),"",
            ""        Leaf('content3')"",
            ""    ]"",
            ""})()"",
            ""line.leaves[3].opening_bracket = line.leaves[1]"",
            ""matching_bracket = line.leaves[1]"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content1'),"",
            ""        Leaf('content2'),"",
            ""        Leaf(')', opening_bracket=Leaf('('))"",
            ""    ]"",
            ""})()"",
            ""matching_bracket = line.leaves[0]"",
            ""line.leaves[3].opening_bracket = matching_bracket"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content1'),"",
            ""        Leaf(')'),"",
            ""        Leaf('content2')"",
            ""    ]"",
            ""})()"",
            ""line.leaves[1].opening_bracket = None"",
            ""line.leaves[2].opening_bracket = line.leaves[0]"",
            ""matching_bracket = line.leaves[0]"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')', ']', '}'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content1'),"",
            ""        Leaf(')'),"",
            ""        Leaf('content2')"",
            ""    ]"",
            ""})()"",
            ""line.leaves[2].opening_bracket = line.leaves[0]"",
            ""exit = lambda x: print(x)""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content1'), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('content2') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[2].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('content1'), # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content2', None), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('content3') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[3].opening_bracket = line.leaves[1] # pragma: no cover"",
            ""exit = lambda aux: print(aux) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content1'), # pragma: no cover"",
            ""        Leaf('content2'), # pragma: no cover"",
            ""        Leaf(')', '(') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[3].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'result' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content'), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('content_end') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[2].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""exit = lambda x: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'result' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content1'), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('extra', '(') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[2].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""matching_bracket = line.leaves[0] # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('content'), # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('content') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[2].opening_bracket = line.leaves[1] # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('content1'), # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content2'), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('content3') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[3].opening_bracket = line.leaves[1] # pragma: no cover"",
            ""matching_bracket = line.leaves[1] # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content1'), # pragma: no cover"",
            ""        Leaf('content2'), # pragma: no cover"",
            ""        Leaf(')', opening_bracket=Leaf('(')) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""matching_bracket = line.leaves[0] # pragma: no cover"",
            ""line.leaves[3].opening_bracket = matching_bracket # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content1'), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('content2') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[1].opening_bracket = None # pragma: no cover"",
            ""line.leaves[2].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""matching_bracket = line.leaves[0] # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')', ']', '}'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content1'), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('content2') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[2].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    }
]",3,8532,0.004266,3213,0.0048195,0.0090855
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Split line into many lines, starting with the first matching bracket pair.
    Note: this usually looks weird, only use this for function definitions.
    Prefer RHS otherwise.  This is why this function is not symmetrical with
    :func:`right_hand_split` which also handles optional parentheses.
    """"""
tail_leaves: List[Leaf] = []
body_leaves: List[Leaf] = []
head_leaves: List[Leaf] = []
current_leaves = head_leaves
matching_bracket: Optional[Leaf] = None
for leaf in line.leaves:
    if ( # uncovered
        current_leaves is body_leaves # uncovered
        and leaf.type in CLOSING_BRACKETS # uncovered
        and leaf.opening_bracket is matching_bracket # uncovered
        and isinstance(matching_bracket, Leaf) # uncovered
    ):
        ensure_visible(leaf)
        ensure_visible(matching_bracket)
        current_leaves = tail_leaves if body_leaves else head_leaves
    current_leaves.append(leaf)
    if current_leaves is head_leaves:
        if leaf.type in OPENING_BRACKETS:
            matching_bracket = leaf
            current_leaves = body_leaves
if not matching_bracket:
    raise CannotSplit(""No brackets found"") # uncovered
head = bracket_split_build_line( # uncovered
    head_leaves, line, matching_bracket, component=_BracketSplitComponent.head # uncovered
)
body = bracket_split_build_line( # uncovered
    body_leaves, line, matching_bracket, component=_BracketSplitComponent.body # uncovered
)
tail = bracket_split_build_line( # uncovered
    tail_leaves, line, matching_bracket, component=_BracketSplitComponent.tail # uncovered
)
bracket_split_succeeded_or_raise(head, body, tail)
for result in (head, body, tail):
    if result:
        aux = result
        exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves if leaves else None"",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content1', '('),"",
            ""        Leaf('content2', '('),"",
            ""        Leaf(')', '(')"",
            ""    ]"",
            ""})()"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content1'),"",
            ""        Leaf(')'),"",
            ""        Leaf('content2')"",
            ""    ]"",
            ""})()"",
            ""line.leaves[2].opening_bracket = line.leaves[0]"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('content1'),"",
            ""        Leaf('('),"",
            ""        Leaf('content2'),"",
            ""        Leaf(')'),"",
            ""        Leaf('content3')"",
            ""    ]"",
            ""})()"",
            ""line.leaves[3].opening_bracket = line.leaves[1]"",
            ""matching_bracket = line.leaves[1]"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return 'result'"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""matching_bracket = Leaf('(')"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content1'),"",
            ""        Leaf(')'),"",
            ""        Leaf('extra', '(')"",
            ""    ]"",
            ""})()"",
            ""line.leaves[2].opening_bracket = line.leaves[0]"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return [l.type for l in leaves]  # return a list of leaf types"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content'),"",
            ""        Leaf(')'),"",
            ""        Leaf('content')"",
            ""    ]"",
            ""})()"",
            ""line.leaves[2].opening_bracket = line.leaves[0]"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content1'),"",
            ""        Leaf(')'),"",
            ""        Leaf('content2')"",
            ""    ]"",
            ""})()"",
            ""line.leaves[2].opening_bracket = line.leaves[0]"",
            ""matching_bracket = line.leaves[0]"",
            ""current_leaves = body_leaves"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('content1'),"",
            ""        Leaf('('),"",
            ""        Leaf(')'),"",
            ""        Leaf('content2')"",
            ""    ]"",
            ""})()"",
            ""line.leaves[2].opening_bracket = line.leaves[1]"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf(','),"",
            ""        Leaf(')'),"",
            ""        Leaf('-')"",
            ""    ]"",
            ""})()"",
            ""line.leaves[2].opening_bracket = line.leaves[0]"",
            ""matching_bracket = line.leaves[0]"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('('),"",
            ""        Leaf('content1'),"",
            ""        Leaf(')'),"",
            ""        Leaf('content2')"",
            ""    ]"",
            ""})()"",
            ""line.leaves[1].opening_bracket = line.leaves[0]"",
            ""line.leaves[2].opening_bracket = line.leaves[0]"",
            ""matching_bracket = line.leaves[0]"",
            ""exit = lambda x: print(x)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, opening_bracket=None):"",
            ""        self.type = type"",
            ""        self.opening_bracket = opening_bracket"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""def ensure_visible(leaf):"",
            ""    pass"",
            """",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component):"",
            ""    return leaves"",
            """",
            ""def bracket_split_succeeded_or_raise(head, body, tail):"",
            ""    pass"",
            """",
            ""class _BracketSplitComponent:"",
            ""    head = 'head'"",
            ""    body = 'body'"",
            ""    tail = 'tail'"",
            """",
            ""CLOSING_BRACKETS = {')'}"",
            ""OPENING_BRACKETS = {'('}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        Leaf('content1'),"",
            ""        Leaf('('),"",
            ""        Leaf(')'),"",
            ""        Leaf('content2', opening_bracket=Leaf('('))"",
            ""    ]"",
            ""})()"",
            ""line.leaves[2].opening_bracket = line.leaves[1]"",
            ""exit = lambda x: print(x)""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves if leaves else None # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content1', '('), # pragma: no cover"",
            ""        Leaf('content2', '('), # pragma: no cover"",
            ""        Leaf(')', '(') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content1'), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('content2') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[2].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('content1'), # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content2'), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('content3') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[3].opening_bracket = line.leaves[1] # pragma: no cover"",
            ""matching_bracket = line.leaves[1] # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return 'result' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""matching_bracket = Leaf('(') # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content1'), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('extra', '(') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[2].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return [l.type for l in leaves]  # return a list of leaf types # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content'), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('content') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[2].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content1'), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('content2') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[2].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""matching_bracket = line.leaves[0] # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('content1'), # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('content2') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[2].opening_bracket = line.leaves[1] # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf(','), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('-') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[2].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""matching_bracket = line.leaves[0] # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf('content1'), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('content2') # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[1].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""line.leaves[2].opening_bracket = line.leaves[0] # pragma: no cover"",
            ""matching_bracket = line.leaves[0] # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, opening_bracket=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.opening_bracket = opening_bracket # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def ensure_visible(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_build_line(leaves, line, matching_bracket, component): # pragma: no cover"",
            ""    return leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""def bracket_split_succeeded_or_raise(head, body, tail): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class _BracketSplitComponent: # pragma: no cover"",
            ""    head = 'head' # pragma: no cover"",
            ""    body = 'body' # pragma: no cover"",
            ""    tail = 'tail' # pragma: no cover"",
            "" # pragma: no cover"",
            ""CLOSING_BRACKETS = {')'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'('} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        Leaf('content1'), # pragma: no cover"",
            ""        Leaf('('), # pragma: no cover"",
            ""        Leaf(')'), # pragma: no cover"",
            ""        Leaf('content2', opening_bracket=Leaf('(')) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.leaves[2].opening_bracket = line.leaves[1] # pragma: no cover"",
            ""exit = lambda x: print(x) # pragma: no cover""
        ]
    }
]",3,8511,0.0042555,3200,0.0048,0.0090555
