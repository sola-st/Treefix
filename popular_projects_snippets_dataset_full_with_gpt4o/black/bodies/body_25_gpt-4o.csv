prompt,raw_predictions,predictions,prompt_type,input_size,input_price,output_size,output_price,total_price
"Provide self-contained and concrete Python values to initialize the undefined variables in the code snippet.

# begin code snippet
if Preview.hex_codes_in_unicode_sequences in self.mode:
    normalize_unicode_escape_sequences(leaf)

if is_docstring(leaf) and ""\\\n"" not in leaf.value:
    # We're ignoring docstrings with backslash newline escapes because changing
    # indentation of those changes the AST representation of the code.
    if Preview.normalize_docstring_quotes_and_prefixes_properly in self.mode:
        # There was a bug where --skip-string-normalization wouldn't stop us
        # from normalizing docstring prefixes. To maintain stability, we can
        # only address this buggy behaviour while the preview style is enabled.
        if self.mode.string_normalization:
            docstring = normalize_string_prefix(leaf.value)
            # visit_default() does handle string normalization for us, but
            # since this method acts differently depending on quote style (ex.
            # see padding logic below), there's a possibility for unstable
            # formatting as visit_default() is called *after*. To avoid a
            # situation where this function formats a docstring differently on
            # the second pass, normalize it early.
            docstring = normalize_string_quotes(docstring)
        else:
            docstring = leaf.value
    else:
        # ... otherwise, we'll keep the buggy behaviour >.<
        docstring = normalize_string_prefix(leaf.value)
    prefix = get_string_prefix(docstring)
    docstring = docstring[len(prefix) :]  # Remove the prefix
    quote_char = docstring[0]
    # A natural way to remove the outer quotes is to do:
    #   docstring = docstring.strip(quote_char)
    # but that breaks on """"""""""x"""""" (which is '""""x').
    # So we actually need to remove the first character and the next two
    # characters but only if they are the same as the first.
    quote_len = 1 if docstring[1] != quote_char else 3
    docstring = docstring[quote_len:-quote_len]
    docstring_started_empty = not docstring
    indent = "" "" * 4 * self.current_line.depth

    if is_multiline_string(leaf):
        docstring = fix_docstring(docstring, indent)
    else:
        docstring = docstring.strip()

    has_trailing_backslash = False
    if docstring:
        # Add some padding if the docstring starts / ends with a quote mark.
        if docstring[0] == quote_char:
            docstring = "" "" + docstring
        if docstring[-1] == quote_char:
            docstring += "" ""
        if docstring[-1] == ""\\"":
            backslash_count = len(docstring) - len(docstring.rstrip(""\\""))
            if backslash_count % 2:
                # Odd number of tailing backslashes, add some padding to
                # avoid escaping the closing string quote.
                docstring += "" ""
                has_trailing_backslash = True
    elif not docstring_started_empty:
        docstring = "" ""

    # We could enforce triple quotes at this point.
    quote = quote_char * quote_len

    # It's invalid to put closing single-character quotes on a new line.
    if Preview.long_docstring_quotes_on_newline in self.mode and quote_len == 3:
        # We need to find the length of the last line of the docstring
        # to find if we can add the closing quotes to the line without
        # exceeding the maximum line length.
        # If docstring is one line, we don't put the closing quotes on a
        # separate line because it looks ugly (#3320).
        lines = docstring.splitlines()
        last_line_length = len(lines[-1]) if docstring else 0

        # If adding closing quotes would cause the last line to exceed
        # the maximum line length then put a line break before the
        # closing quotes
        if (
            len(lines) > 1
            and last_line_length + quote_len > self.mode.line_length
            and len(indent) + quote_len <= self.mode.line_length
            and not has_trailing_backslash
        ):
            leaf.value = prefix + quote + docstring + ""\n"" + indent + quote
        else:
            leaf.value = prefix + quote + docstring + quote
    else:
        leaf.value = prefix + quote + docstring + quote

exit(self.visit_default(leaf))

# end code snippet

# begin undefined variables
Preview
self
normalize_unicode_escape_sequences
leaf
is_docstring
normalize_string_prefix
normalize_string_quotes
get_string_prefix
is_multiline_string
fix_docstring
# end undefined variables

# begin undefined attributes and methods
Preview.hex_codes_in_unicode_sequences
self.mode
leaf.value
Preview.normalize_docstring_quotes_and_prefixes_properly
self.current_line
Preview.long_docstring_quotes_on_newline
self.visit_default
# end undefined attributes and methods

Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import copy""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize', 'long_docstring_quotes_on_newline': 'newline'})"",
            ""self = type('SelfMock', (object,), {'mode': type('Mode', (object,), {'line_length': 80, 'string_normalization': True})(), 'current_line': type('Line', (object,), {'depth': 2})(), 'visit_default': lambda self, leaf: True})()"",
            ""normalize_unicode_escape_sequences = lambda input: input"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})()"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\""))"",
            ""normalize_string_prefix = lambda s: s.lower() if s.isupper() else s"",
            ""normalize_string_quotes = lambda s: s.replace(\""'\"", '\""')"",
            ""get_string_prefix = lambda s: 'u' if s.startswith('u') else ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda s, indent: '\\n'.join(indent + line.strip() for line in s.split('\\n'))""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'})"",
            ""class Mode:\n    def __init__(self):\n        self.string_normalization = False\n        self.line_length = 88\n    "",
            ""self = type('Mock', (object,), {'mode': Mode(), 'current_line': type('Line', (object,), {'depth': 1}), 'visit_default': lambda leaf: None})()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""This is a docstring.\""\""\""'})()"",
            ""is_docstring = lambda leaf: bool(re.match(r'^\""\""\"".*\""\""\""$', leaf.value))"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value.replace('\""\""\""', '\""')"",
            ""get_string_prefix = lambda docstring: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: docstring.replace('\\n', '\\n' + indent)""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Dict""
        ],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'\n\n    def __init__(self, mode):\n        self.mode = mode\n\nclass Mode:\n    def __init__(self, string_normalization: bool, line_length: int):\n        self.string_normalization = string_normalization\n        self.line_length = line_length\n\nclass Leaf:\n    def __init__(self, value: str):\n        self.value = value\n\nclass CurrentLine:\n    def __init__(self, depth: int):\n        self.depth = depth\n\nclass Mock:\n    def __init__(self, mode, current_line):\n        self.mode = mode\n        self.current_line = current_line\n\n    def visit_default(self, leaf: Leaf):\n        pass"",
            ""preview_mode = Preview(Mode(string_normalization=True, line_length=80))"",
            ""self = Mock(mode=preview_mode.mode, current_line=CurrentLine(depth=1))"",
            ""def normalize_unicode_escape_sequences(leaf):\n    pass"",
            ""leaf = Leaf(value='\""\""\""Example docstring\""\""\""')"",
            ""def is_docstring(leaf) -> bool:\n    return leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"")"",
            ""def normalize_string_prefix(string: str) -> str:\n    return string"",
            ""def normalize_string_quotes(string: str) -> str:\n    return string"",
            ""def get_string_prefix(string: str) -> str:\n    return ''"",
            ""def is_multiline_string(leaf: Leaf) -> bool:\n    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring: str, indent: str) -> str:\n    return '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""Preview = type('MockPreview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})()"",
            ""self = type('MockSelf', (object,), {"",
            ""    'mode': type('MockMode', (object,), {"",
            ""        'string_normalization': True,"",
            ""        'line_length': 80"",
            ""    })(),"",
            ""    'current_line': type('MockCurrentLine', (object,), {"",
            ""        'depth': 1"",
            ""    })(),"",
            ""    'visit_default': lambda leaf: None"",
            ""})()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring\""\""\""'})()"",
            ""is_docstring = lambda leaf: isinstance(leaf, type('MockLeaf', (object,), {}))"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value.strip('\""\""\""')"",
            ""get_string_prefix = lambda value: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: docstring.strip()""
        ]
    },
    {
        ""imports"": [
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""Preview = type('Preview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})"",
            ""self = SimpleNamespace("",
            ""    mode=SimpleNamespace("",
            ""        hex_codes_in_unicode_sequences=True,"",
            ""        normalize_docstring_quotes_and_prefixes_properly=True,"",
            ""        long_docstring_quotes_on_newline=True,"",
            ""        string_normalization=True,"",
            ""        line_length=80"",
            ""    ),"",
            ""    current_line=SimpleNamespace("",
            ""        depth=1"",
            ""    ),"",
            ""    visit_default=lambda x: None"",
            "")"",
            ""normalize_unicode_escape_sequences = lambda x: None"",
            ""leaf = SimpleNamespace("",
            ""    value=''''\""\""\""Sample docstring\""\""\""'''"",
            "")"",
            ""is_docstring = lambda x: True"",
            ""normalize_string_prefix = lambda x: x"",
            ""normalize_string_quotes = lambda x: x"",
            ""get_string_prefix = lambda x: ''"",
            ""is_multiline_string = lambda x: '\\n' in x.value"",
            ""fix_docstring = lambda x, y: x""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'"",
            ""class Mode:\n    string_normalization = True\n    line_length = 80"",
            ""class Leaf:\n    def __init__(self, value):\n        self.value = value"",
            ""def normalize_unicode_escape_sequences(leaf):\n    pass"",
            ""leaf = Leaf('''\""\""\""This is a docstring\""\""\""''')"",
            ""def is_docstring(leaf):\n    return leaf.value.startswith(('\""\""\""', '\\'\\'\\'\""'''))"",
            ""def normalize_string_prefix(value):\n    return value"",
            ""def normalize_string_quotes(value):\n    return value"",
            ""def get_string_prefix(value):\n    match = re.match(r'(?:[bBfFrRuU]{0,2})(\""\""\""|\\\\'\\\\'\\\\')', value)\n    return match.group(0) if match else ''"",
            ""def is_multiline_string(leaf):\n    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring, indent):\n    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            ""class CurrentLine:\n    depth = 1"",
            ""class Self:\n    mode = Mode()\n    current_line = CurrentLine()\n    def visit_default(self, leaf):\n        pass"",
            ""self = Self()""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': [], 'normalize_docstring_quotes_and_prefixes_properly': [], 'long_docstring_quotes_on_newline': []})"",
            ""class MockMode:\n    def __init__(self):\n        self.string_normalization = True\n        self.line_length = 80\nself = type('Mock', (object,), {'mode': MockMode(), 'current_line': type('MockLine', (object,), {'depth': 1})(), 'visit_default': lambda leaf: None})()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})()"",
            ""is_docstring = lambda leaf: True"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value"",
            ""get_string_prefix = lambda value: '\""\""\""'"",
            ""is_multiline_string = lambda leaf: False"",
            ""fix_docstring = lambda docstring, indent: docstring""
        ]
    },
    {
        ""imports"": [
            ""from typing import Any"",
            ""import types""
        ],
        ""initialization"": [
            ""Preview = type('Preview', (object,), {'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'})"",
            ""self = type('SelfMock', (object,), {'mode': type('Mode', (object,), {'string_normalization': True, 'line_length': 80})(), 'current_line': type('Line', (object,), {'depth': 1})(), 'visit_default': lambda self, leaf: None})()"",
            ""normalize_unicode_escape_sequences = lambda leaf: leaf"",
            ""leaf = type('Leaf', (object,), {'value': \""'''Sample docstring'''\""})()"",
            ""is_docstring = lambda leaf: True"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value"",
            ""get_string_prefix = lambda value: \""'''\"""",
            ""is_multiline_string = lambda leaf: True"",
            ""fix_docstring = lambda docstring, indent: docstring""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": []
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'mock_hex_codes',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'mock_normalize_prefixes',"",
            ""    'long_docstring_quotes_on_newline': 'mock_long_quotes'"",
            ""})"",
            """",
            ""self = type('Mock', (object,), {"",
            ""    'mode': type('MockMode', (object,), {"",
            ""        'string_normalization': True,"",
            ""        'line_length': 80"",
            ""    })(),"",
            ""    'current_line': type('MockLine', (object,), {"",
            ""        'depth': 2"",
            ""    })(),"",
            ""    'visit_default': lambda self, leaf: None"",
            ""})()"",
            """",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            """",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': 'mock_docstring'"",
            ""})()"",
            """",
            ""is_docstring = lambda leaf: True"",
            """",
            ""normalize_string_prefix = lambda value: value"",
            """",
            ""normalize_string_quotes = lambda value: value"",
            """",
            ""get_string_prefix = lambda value: ''"",
            """",
            ""is_multiline_string = lambda leaf: True"",
            """",
            ""fix_docstring = lambda docstring, indent: docstring.strip()""
        ]
    }
]","[
    {
        ""imports"": [
            ""import copy # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize', 'long_docstring_quotes_on_newline': 'newline'}) # pragma: no cover"",
            ""self = type('SelfMock', (object,), {'mode': type('Mode', (object,), {'line_length': 80, 'string_normalization': True})(), 'current_line': type('Line', (object,), {'depth': 2})(), 'visit_default': lambda self, leaf: True})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda input: input # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\"")) # pragma: no cover"",
            ""normalize_string_prefix = lambda s: s.lower() if s.isupper() else s # pragma: no cover"",
            ""normalize_string_quotes = lambda s: s.replace(\""'\"", '\""') # pragma: no cover"",
            ""get_string_prefix = lambda s: 'u' if s.startswith('u') else '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda s, indent: '\\n'.join(indent + line.strip() for line in s.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'}) # pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.string_normalization = False# pragma: no cover"",
            ""        self.line_length = 88# pragma: no cover"",
            ""     # pragma: no cover"",
            ""self = type('Mock', (object,), {'mode': Mode(), 'current_line': type('Line', (object,), {'depth': 1}), 'visit_default': lambda leaf: None})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""This is a docstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: bool(re.match(r'^\""\""\"".*\""\""\""$', leaf.value)) # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value.replace('\""\""\""', '\""') # pragma: no cover"",
            ""get_string_prefix = lambda docstring: '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: docstring.replace('\\n', '\\n' + indent) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Dict # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def __init__(self, mode):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self, string_normalization: bool, line_length: int):# pragma: no cover"",
            ""        self.string_normalization = string_normalization# pragma: no cover"",
            ""        self.line_length = line_length# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, value: str):# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""# pragma: no cover"",
            ""class CurrentLine:# pragma: no cover"",
            ""    def __init__(self, depth: int):# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Mock:# pragma: no cover"",
            ""    def __init__(self, mode, current_line):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.current_line = current_line# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def visit_default(self, leaf: Leaf):# pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""preview_mode = Preview(Mode(string_normalization=True, line_length=80)) # pragma: no cover"",
            ""self = Mock(mode=preview_mode.mode, current_line=CurrentLine(depth=1)) # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""leaf = Leaf(value='\""\""\""Example docstring\""\""\""') # pragma: no cover"",
            ""def is_docstring(leaf) -> bool:# pragma: no cover"",
            ""    return leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"") # pragma: no cover"",
            ""def normalize_string_prefix(string: str) -> str:# pragma: no cover"",
            ""    return string # pragma: no cover"",
            ""def normalize_string_quotes(string: str) -> str:# pragma: no cover"",
            ""    return string # pragma: no cover"",
            ""def get_string_prefix(string: str) -> str:# pragma: no cover"",
            ""    return '' # pragma: no cover"",
            ""def is_multiline_string(leaf: Leaf) -> bool:# pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            ""def fix_docstring(docstring: str, indent: str) -> str:# pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('MockPreview', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self = type('MockSelf', (object,), { # pragma: no cover"",
            ""    'mode': type('MockMode', (object,), { # pragma: no cover"",
            ""        'string_normalization': True, # pragma: no cover"",
            ""        'line_length': 80 # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'current_line': type('MockCurrentLine', (object,), { # pragma: no cover"",
            ""        'depth': 1 # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'visit_default': lambda leaf: None # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: isinstance(leaf, type('MockLeaf', (object,), {})) # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value.strip('\""\""\""') # pragma: no cover"",
            ""get_string_prefix = lambda value: '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: docstring.strip() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Preview', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""self = SimpleNamespace( # pragma: no cover"",
            ""    mode=SimpleNamespace( # pragma: no cover"",
            ""        hex_codes_in_unicode_sequences=True, # pragma: no cover"",
            ""        normalize_docstring_quotes_and_prefixes_properly=True, # pragma: no cover"",
            ""        long_docstring_quotes_on_newline=True, # pragma: no cover"",
            ""        string_normalization=True, # pragma: no cover"",
            ""        line_length=80 # pragma: no cover"",
            ""    ), # pragma: no cover"",
            ""    current_line=SimpleNamespace( # pragma: no cover"",
            ""        depth=1 # pragma: no cover"",
            ""    ), # pragma: no cover"",
            ""    visit_default=lambda x: None # pragma: no cover"",
            "") # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda x: None # pragma: no cover"",
            ""leaf = SimpleNamespace( # pragma: no cover"",
            ""    value=''''\""\""\""Sample docstring\""\""\""''' # pragma: no cover"",
            "") # pragma: no cover"",
            ""is_docstring = lambda x: True # pragma: no cover"",
            ""normalize_string_prefix = lambda x: x # pragma: no cover"",
            ""normalize_string_quotes = lambda x: x # pragma: no cover"",
            ""get_string_prefix = lambda x: '' # pragma: no cover"",
            ""is_multiline_string = lambda x: '\\n' in x.value # pragma: no cover"",
            ""fix_docstring = lambda x, y: x # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': [], 'normalize_docstring_quotes_and_prefixes_properly': [], 'long_docstring_quotes_on_newline': []}) # pragma: no cover"",
            ""class MockMode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80# pragma: no cover"",
            ""self = type('Mock', (object,), {'mode': MockMode(), 'current_line': type('MockLine', (object,), {'depth': 1})(), 'visit_default': lambda leaf: None})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: True # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value # pragma: no cover"",
            ""get_string_prefix = lambda value: '\""\""\""' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: False # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: docstring # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Any # pragma: no cover"",
            ""import types # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Preview', (object,), {'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'}) # pragma: no cover"",
            ""self = type('SelfMock', (object,), {'mode': type('Mode', (object,), {'string_normalization': True, 'line_length': 80})(), 'current_line': type('Line', (object,), {'depth': 1})(), 'visit_default': lambda self, leaf: None})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: leaf # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'value': \""'''Sample docstring'''\""})() # pragma: no cover"",
            ""is_docstring = lambda leaf: True # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value # pragma: no cover"",
            ""get_string_prefix = lambda value: \""'''\"" # pragma: no cover"",
            ""is_multiline_string = lambda leaf: True # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: docstring # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'mock_hex_codes', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'mock_normalize_prefixes', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'mock_long_quotes' # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), { # pragma: no cover"",
            ""    'mode': type('MockMode', (object,), { # pragma: no cover"",
            ""        'string_normalization': True, # pragma: no cover"",
            ""        'line_length': 80 # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'current_line': type('MockLine', (object,), { # pragma: no cover"",
            ""        'depth': 2 # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'visit_default': lambda self, leaf: None # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': 'mock_docstring' # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""is_docstring = lambda leaf: True # pragma: no cover"",
            "" # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            "" # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value # pragma: no cover"",
            "" # pragma: no cover"",
            ""get_string_prefix = lambda value: '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""is_multiline_string = lambda leaf: True # pragma: no cover"",
            "" # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: docstring.strip() # pragma: no cover""
        ]
    }
]",1,1280,0.00064,7173,0.0107595,0.0113995
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 15:
    if Preview.hex_codes_in_unicode_sequences in self.mode:
TypeError: argument of type 'Mode' is not iterable
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import copy""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'HEX_CODES', 'normalize_docstring_quotes_and_prefixes_properly': 'NORMALIZE_QUOTES', 'long_docstring_quotes_on_newline': 'LONG_QUOTES_ON_NEWLINE'})"",
            ""self = type('SelfMock', (object,), {'mode': type('Mode', (object,), {'line_length': 80, 'string_normalization': True, '__contains__': lambda self, item: item in ('HEX_CODES', 'NORMALIZE_QUOTES', 'LONG_QUOTES_ON_NEWLINE')})(), 'current_line': type('Line', (object,), {'depth': 2})(), 'visit_default': lambda self, leaf: True})()"",
            ""normalize_unicode_escape_sequences = lambda input: input"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})()"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\""))"",
            ""normalize_string_prefix = lambda s: s.lower() if s.isupper() else s"",
            ""normalize_string_quotes = lambda s: s.replace(\""'\"", '\""')"",
            ""get_string_prefix = lambda s: 'u' if s.startswith('u') else ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda s, indent: '\\n'.join(indent + line.strip() for line in s.split('\\n'))""
        ]
    },
    {
        ""imports"": [
            ""import copy""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize', 'long_docstring_quotes_on_newline': 'newline'})"",
            ""self = type('SelfMock', (object,), {'mode': type('Mode', (object,), {'line_length': 80, 'string_normalization': True, '__contains__': lambda self, key: key in ['hex', 'normalize', 'newline']})(), 'current_line': type('Line', (object,), {'depth': 2})(), 'visit_default': lambda self, leaf: True})()"",
            ""normalize_unicode_escape_sequences = lambda input: input"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})()"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\""))"",
            ""normalize_string_prefix = lambda s: s.lower() if s.isupper() else s"",
            ""normalize_string_quotes = lambda s: s.replace(\""'\"", '\""')"",
            ""get_string_prefix = lambda s: 'u' if s.startswith('u') else ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda s, indent: '\\n'.join(indent + line.strip() for line in s.split('\\n'))""
        ]
    },
    {
        ""imports"": [
            ""import copy""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize', 'long_docstring_quotes_on_newline': 'newline'})"",
            ""self = type('SelfMock', (object,), {'mode': type('Mode', (object,), {'line_length': 80, 'string_normalization': True, '__contains__': lambda self, item: item in ['hex', 'normalize', 'newline']})(), 'current_line': type('Line', (object,), {'depth': 2})(), 'visit_default': lambda self, leaf: True})()"",
            ""normalize_unicode_escape_sequences = lambda input: input"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})()"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\""))"",
            ""normalize_string_prefix = lambda s: s.lower() if s.isupper() else s"",
            ""normalize_string_quotes = lambda s: s.replace(\""'\"", '\""')"",
            ""get_string_prefix = lambda s: 'u' if s.startswith('u') else ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda s, indent: '\\n'.join(indent + line.strip() for line in s.split('\\n'))""
        ]
    },
    {
        ""imports"": [
            ""import copy""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize', 'long_docstring_quotes_on_newline': 'newline'})"",
            ""self = type('SelfMock', (object,), {'mode': type('Mode', (object,), {'line_length': 80, 'string_normalization': True, 'hex_codes_in_unicode_sequences': True, 'normalize_docstring_quotes_and_prefixes_properly': True, 'long_docstring_quotes_on_newline': True})(), 'current_line': type('Line', (object,), {'depth': 2})(), 'visit_default': lambda self, leaf: True})()"",
            ""normalize_unicode_escape_sequences = lambda input: input"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})()"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\""))"",
            ""normalize_string_prefix = lambda s: s.lower() if s.isupper() else s"",
            ""normalize_string_quotes = lambda s: s.replace(\""'\"", '\""')"",
            ""get_string_prefix = lambda s: 'u' if s.startswith('u') else ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda s, indent: '\\n'.join(indent + line.strip() for line in s.split('\\n'))""
        ]
    },
    {
        ""imports"": [
            ""import copy""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize', 'long_docstring_quotes_on_newline': 'newline'})"",
            ""self_mode = type('Mode', (object,), {'line_length': 80, 'string_normalization': True, '__contains__': lambda self, item: item in ['hex', 'normalize', 'newline']})()"",
            ""self = type('SelfMock', (object,), {'mode': self_mode, 'current_line': type('Line', (object,), {'depth': 2})(), 'visit_default': lambda self, leaf: True})()"",
            ""normalize_unicode_escape_sequences = lambda input: input"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})()"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\""))"",
            ""normalize_string_prefix = lambda s: s.lower() if s.isupper() else s"",
            ""normalize_string_quotes = lambda s: s.replace(\""'\"", '\""')"",
            ""get_string_prefix = lambda s: 'u' if s.startswith('u') else ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda s, indent: '\\n'.join(indent + line.strip() for line in s.split('\\n'))""
        ]
    },
    {
        ""imports"": [
            ""import copy""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize', 'long_docstring_quotes_on_newline': 'newline'})"",
            ""self = type('SelfMock', (object,), {'mode': type('Mode', (object,), {'line_length': 80, 'string_normalization': True, '__contains__': lambda self, item: item in ['hex', 'normalize', 'newline']})(), 'current_line': type('Line', (object,), {'depth': 2})(), 'visit_default': lambda self, leaf: True})()"",
            ""normalize_unicode_escape_sequences = lambda input: input"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})()"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\""))"",
            ""normalize_string_prefix = lambda s: s.lower() if s.isupper() else s"",
            ""normalize_string_quotes = lambda s: s.replace(\""'\"", '\""')"",
            ""get_string_prefix = lambda s: 'u' if s.startswith('u') else ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda s, indent: '\\n'.join(indent + line.strip() for line in s.split('\\n'))""
        ]
    },
    {
        ""imports"": [
            ""import copy""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize', 'long_docstring_quotes_on_newline': 'newline'})"",
            ""self = type('SelfMock', (object,), {'mode': type('Mode', (object,), {'line_length': 80, 'string_normalization': True, 'hex_codes_in_unicode_sequences': True, 'normalize_docstring_quotes_and_prefixes_properly': True, 'long_docstring_quotes_on_newline': True}), 'current_line': type('Line', (object,), {'depth': 2})(), 'visit_default': lambda self, leaf: True})()"",
            ""normalize_unicode_escape_sequences = lambda input: input"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})()"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\""))"",
            ""normalize_string_prefix = lambda s: s.lower() if s.isupper() else s"",
            ""normalize_string_quotes = lambda s: s.replace(\""'\"", '\""')"",
            ""get_string_prefix = lambda s: 'u' if s.startswith('u') else ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda s, indent: '\\n'.join(indent + line.strip() for line in s.split('\\n'))""
        ]
    },
    {
        ""imports"": [
            ""import copy""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'})"",
            ""self = type('SelfMock', (object,), {'mode': {'hex_codes_in_unicode_sequences': True, 'normalize_docstring_quotes_and_prefixes_properly': True, 'long_docstring_quotes_on_newline': True, 'line_length': 80, 'string_normalization': True}, 'current_line': type('Line', (object,), {'depth': 2})(), 'visit_default': lambda self, leaf: True})()"",
            ""normalize_unicode_escape_sequences = lambda input: input"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})()"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\""))"",
            ""normalize_string_prefix = lambda s: s.lower() if s.isupper() else s"",
            ""normalize_string_quotes = lambda s: s.replace(\""'\"", '\""')"",
            ""get_string_prefix = lambda s: 'u' if s.startswith('u') else ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda s, indent: '\\n'.join(indent + line.strip() for line in s.split('\\n'))""
        ]
    },
    {
        ""imports"": [
            ""import copy""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize',"",
            ""    'long_docstring_quotes_on_newline': 'newline'"",
            ""})"",
            ""self = type('SelfMock', (object,), {"",
            ""    'mode': type('Mode', (object,), {"",
            ""        'line_length': 80,"",
            ""        'string_normalization': True,"",
            ""        'hex_codes_in_unicode_sequences': 'hex',"",
            ""        'normalize_docstring_quotes_and_prefixes_properly': 'normalize',"",
            ""        'long_docstring_quotes_on_newline': 'newline'"",
            ""    }),"",
            ""    'current_line': type('Line', (object,), {"",
            ""        'depth': 2"",
            ""    }),"",
            ""    'visit_default': lambda self, leaf: True"",
            ""})()"",
            ""normalize_unicode_escape_sequences = lambda input: input"",
            ""leaf = type('Leaf', (object,), {"",
            ""    'value': '\""\""\""Example docstring.\""\""\""'"",
            ""})()"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\""))"",
            ""normalize_string_prefix = lambda s: s.lower() if s.isupper() else s"",
            ""normalize_string_quotes = lambda s: s.replace(\""'\"", '\""')"",
            ""get_string_prefix = lambda s: 'u' if s.startswith('u') else ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda s, indent: '\\n'.join(indent + line.strip() for line in s.split('\\n'))""
        ]
    },
    {
        ""imports"": [
            ""import copy""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize', 'long_docstring_quotes_on_newline': 'newline'})"",
            ""self = type('SelfMock', (object,), {'mode': {'hex_codes_in_unicode_sequences': 'hex', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize', 'long_docstring_quotes_on_newline': 'newline', 'string_normalization': True, 'line_length': 80}, 'current_line': type('Line', (object,), {'depth': 2})(), 'visit_default': lambda self, leaf: True})()"",
            ""normalize_unicode_escape_sequences = lambda input: input"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})()"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\""))"",
            ""normalize_string_prefix = lambda s: s.lower() if s.isupper() else s"",
            ""normalize_string_quotes = lambda s: s.replace(\""'\"", '\""')"",
            ""get_string_prefix = lambda s: 'u' if s.startswith('u') else ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda s, indent: '\\n'.join(indent + line.strip() for line in s.split('\\n'))""
        ]
    }
]","[
    {
        ""imports"": [
            ""import copy # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'HEX_CODES', 'normalize_docstring_quotes_and_prefixes_properly': 'NORMALIZE_QUOTES', 'long_docstring_quotes_on_newline': 'LONG_QUOTES_ON_NEWLINE'}) # pragma: no cover"",
            ""self = type('SelfMock', (object,), {'mode': type('Mode', (object,), {'line_length': 80, 'string_normalization': True, '__contains__': lambda self, item: item in ('HEX_CODES', 'NORMALIZE_QUOTES', 'LONG_QUOTES_ON_NEWLINE')})(), 'current_line': type('Line', (object,), {'depth': 2})(), 'visit_default': lambda self, leaf: True})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda input: input # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\"")) # pragma: no cover"",
            ""normalize_string_prefix = lambda s: s.lower() if s.isupper() else s # pragma: no cover"",
            ""normalize_string_quotes = lambda s: s.replace(\""'\"", '\""') # pragma: no cover"",
            ""get_string_prefix = lambda s: 'u' if s.startswith('u') else '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda s, indent: '\\n'.join(indent + line.strip() for line in s.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import copy # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize', 'long_docstring_quotes_on_newline': 'newline'}) # pragma: no cover"",
            ""self = type('SelfMock', (object,), {'mode': type('Mode', (object,), {'line_length': 80, 'string_normalization': True, '__contains__': lambda self, key: key in ['hex', 'normalize', 'newline']})(), 'current_line': type('Line', (object,), {'depth': 2})(), 'visit_default': lambda self, leaf: True})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda input: input # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\"")) # pragma: no cover"",
            ""normalize_string_prefix = lambda s: s.lower() if s.isupper() else s # pragma: no cover"",
            ""normalize_string_quotes = lambda s: s.replace(\""'\"", '\""') # pragma: no cover"",
            ""get_string_prefix = lambda s: 'u' if s.startswith('u') else '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda s, indent: '\\n'.join(indent + line.strip() for line in s.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import copy # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize', 'long_docstring_quotes_on_newline': 'newline'}) # pragma: no cover"",
            ""self = type('SelfMock', (object,), {'mode': type('Mode', (object,), {'line_length': 80, 'string_normalization': True, '__contains__': lambda self, item: item in ['hex', 'normalize', 'newline']})(), 'current_line': type('Line', (object,), {'depth': 2})(), 'visit_default': lambda self, leaf: True})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda input: input # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\"")) # pragma: no cover"",
            ""normalize_string_prefix = lambda s: s.lower() if s.isupper() else s # pragma: no cover"",
            ""normalize_string_quotes = lambda s: s.replace(\""'\"", '\""') # pragma: no cover"",
            ""get_string_prefix = lambda s: 'u' if s.startswith('u') else '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda s, indent: '\\n'.join(indent + line.strip() for line in s.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import copy # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize', 'long_docstring_quotes_on_newline': 'newline'}) # pragma: no cover"",
            ""self = type('SelfMock', (object,), {'mode': type('Mode', (object,), {'line_length': 80, 'string_normalization': True, 'hex_codes_in_unicode_sequences': True, 'normalize_docstring_quotes_and_prefixes_properly': True, 'long_docstring_quotes_on_newline': True})(), 'current_line': type('Line', (object,), {'depth': 2})(), 'visit_default': lambda self, leaf: True})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda input: input # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\"")) # pragma: no cover"",
            ""normalize_string_prefix = lambda s: s.lower() if s.isupper() else s # pragma: no cover"",
            ""normalize_string_quotes = lambda s: s.replace(\""'\"", '\""') # pragma: no cover"",
            ""get_string_prefix = lambda s: 'u' if s.startswith('u') else '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda s, indent: '\\n'.join(indent + line.strip() for line in s.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import copy # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize', 'long_docstring_quotes_on_newline': 'newline'}) # pragma: no cover"",
            ""self_mode = type('Mode', (object,), {'line_length': 80, 'string_normalization': True, '__contains__': lambda self, item: item in ['hex', 'normalize', 'newline']})() # pragma: no cover"",
            ""self = type('SelfMock', (object,), {'mode': self_mode, 'current_line': type('Line', (object,), {'depth': 2})(), 'visit_default': lambda self, leaf: True})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda input: input # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\"")) # pragma: no cover"",
            ""normalize_string_prefix = lambda s: s.lower() if s.isupper() else s # pragma: no cover"",
            ""normalize_string_quotes = lambda s: s.replace(\""'\"", '\""') # pragma: no cover"",
            ""get_string_prefix = lambda s: 'u' if s.startswith('u') else '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda s, indent: '\\n'.join(indent + line.strip() for line in s.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import copy # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize', 'long_docstring_quotes_on_newline': 'newline'}) # pragma: no cover"",
            ""self = type('SelfMock', (object,), {'mode': type('Mode', (object,), {'line_length': 80, 'string_normalization': True, '__contains__': lambda self, item: item in ['hex', 'normalize', 'newline']})(), 'current_line': type('Line', (object,), {'depth': 2})(), 'visit_default': lambda self, leaf: True})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda input: input # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\"")) # pragma: no cover"",
            ""normalize_string_prefix = lambda s: s.lower() if s.isupper() else s # pragma: no cover"",
            ""normalize_string_quotes = lambda s: s.replace(\""'\"", '\""') # pragma: no cover"",
            ""get_string_prefix = lambda s: 'u' if s.startswith('u') else '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda s, indent: '\\n'.join(indent + line.strip() for line in s.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import copy # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize', 'long_docstring_quotes_on_newline': 'newline'}) # pragma: no cover"",
            ""self = type('SelfMock', (object,), {'mode': type('Mode', (object,), {'line_length': 80, 'string_normalization': True, 'hex_codes_in_unicode_sequences': True, 'normalize_docstring_quotes_and_prefixes_properly': True, 'long_docstring_quotes_on_newline': True}), 'current_line': type('Line', (object,), {'depth': 2})(), 'visit_default': lambda self, leaf: True})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda input: input # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\"")) # pragma: no cover"",
            ""normalize_string_prefix = lambda s: s.lower() if s.isupper() else s # pragma: no cover"",
            ""normalize_string_quotes = lambda s: s.replace(\""'\"", '\""') # pragma: no cover"",
            ""get_string_prefix = lambda s: 'u' if s.startswith('u') else '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda s, indent: '\\n'.join(indent + line.strip() for line in s.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import copy # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'}) # pragma: no cover"",
            ""self = type('SelfMock', (object,), {'mode': {'hex_codes_in_unicode_sequences': True, 'normalize_docstring_quotes_and_prefixes_properly': True, 'long_docstring_quotes_on_newline': True, 'line_length': 80, 'string_normalization': True}, 'current_line': type('Line', (object,), {'depth': 2})(), 'visit_default': lambda self, leaf: True})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda input: input # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\"")) # pragma: no cover"",
            ""normalize_string_prefix = lambda s: s.lower() if s.isupper() else s # pragma: no cover"",
            ""normalize_string_quotes = lambda s: s.replace(\""'\"", '\""') # pragma: no cover"",
            ""get_string_prefix = lambda s: 'u' if s.startswith('u') else '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda s, indent: '\\n'.join(indent + line.strip() for line in s.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import copy # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'newline' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""self = type('SelfMock', (object,), { # pragma: no cover"",
            ""    'mode': type('Mode', (object,), { # pragma: no cover"",
            ""        'line_length': 80, # pragma: no cover"",
            ""        'string_normalization': True, # pragma: no cover"",
            ""        'hex_codes_in_unicode_sequences': 'hex', # pragma: no cover"",
            ""        'normalize_docstring_quotes_and_prefixes_properly': 'normalize', # pragma: no cover"",
            ""        'long_docstring_quotes_on_newline': 'newline' # pragma: no cover"",
            ""    }), # pragma: no cover"",
            ""    'current_line': type('Line', (object,), { # pragma: no cover"",
            ""        'depth': 2 # pragma: no cover"",
            ""    }), # pragma: no cover"",
            ""    'visit_default': lambda self, leaf: True # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda input: input # pragma: no cover"",
            ""leaf = type('Leaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""Example docstring.\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\"")) # pragma: no cover"",
            ""normalize_string_prefix = lambda s: s.lower() if s.isupper() else s # pragma: no cover"",
            ""normalize_string_quotes = lambda s: s.replace(\""'\"", '\""') # pragma: no cover"",
            ""get_string_prefix = lambda s: 'u' if s.startswith('u') else '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda s, indent: '\\n'.join(indent + line.strip() for line in s.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import copy # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize', 'long_docstring_quotes_on_newline': 'newline'}) # pragma: no cover"",
            ""self = type('SelfMock', (object,), {'mode': {'hex_codes_in_unicode_sequences': 'hex', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize', 'long_docstring_quotes_on_newline': 'newline', 'string_normalization': True, 'line_length': 80}, 'current_line': type('Line', (object,), {'depth': 2})(), 'visit_default': lambda self, leaf: True})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda input: input # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\"")) # pragma: no cover"",
            ""normalize_string_prefix = lambda s: s.lower() if s.isupper() else s # pragma: no cover"",
            ""normalize_string_quotes = lambda s: s.replace(\""'\"", '\""') # pragma: no cover"",
            ""get_string_prefix = lambda s: 'u' if s.startswith('u') else '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda s, indent: '\\n'.join(indent + line.strip() for line in s.split('\\n')) # pragma: no cover""
        ]
    }
]",2,1896,0.000948,3558,0.005337,0.006285
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 20:
    if Preview.hex_codes_in_unicode_sequences in self.mode:
TypeError: argument of type 'Mode' is not iterable
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'})"",
            ""class Mode:\n    def __init__(self):\n        self.features = {\n            'hex_codes_in_unicode_sequences',\n            'normalize_docstring_quotes_and_prefixes_properly',\n            'long_docstring_quotes_on_newline',\n        }\n        self.string_normalization = False\n        self.line_length = 88\n    def __contains__(self, item):\n        return item in self.features"",
            ""self = type('Mock', (object,), {'mode': Mode(), 'current_line': type('Line', (object,), {'depth': 1})(), 'visit_default': lambda leaf: None})()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""This is a docstring.\""\""\""'})()"",
            ""is_docstring = lambda leaf: bool(re.match(r'^\""\""\"".*\""\""\""$', leaf.value))"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value.replace('\""\""\""', '\""')"",
            ""get_string_prefix = lambda docstring: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: docstring.replace('\\n', '\\n' + indent)""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'})"",
            ""class Mode:\n    def __init__(self):\n        self.string_normalization = True\n        self.line_length = 80\n        self._features = {Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline}\n    def __contains__(self, feature):\n        return feature in self._features\n"",
            ""self = type('Mock', (object,), {'mode': Mode(), 'current_line': type('Line', (object,), {'depth': 1}), 'visit_default': lambda leaf: None})()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""This is a multiline\\ndocstring.\""\""\""'})()"",
            ""is_docstring = lambda leaf: bool(re.match(r'^\""\""\"".*\""\""\""$', leaf.value, re.DOTALL))"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value.replace(\""'''\"", '\""\""\""').replace('\""\""\""', '\""'),"",
            ""get_string_prefix = lambda docstring: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'})"",
            ""class Mode:\n    def __init__(self):\n        self.string_normalization = True\n        self.line_length = 88\n        self.options = [Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline]\n    def __contains__(self, item):\n        return item in self.options\n    "",
            ""self = type('Mock', (object,), {'mode': Mode(), 'current_line': type('Line', (object,), {'depth': 1})(), 'visit_default': lambda self, leaf: None})()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""This is a docstring.\""\""\""'})()"",
            ""is_docstring = lambda leaf: bool(re.match(r'^\""\""\"".*\""\""\""$', leaf.value))"",
            ""normalize_string_prefix = lambda value: value.lower()"",
            ""normalize_string_quotes = lambda value: value.replace('\""', '\""')"",
            ""get_string_prefix = lambda docstring: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: docstring.replace('\\n', '\\n' + indent)""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'})"",
            ""class Mode:\n    def __init__(self):\n        self.string_normalization = False\n        self.line_length = 88\n        self.settings = [\n            Preview.hex_codes_in_unicode_sequences,\n            Preview.normalize_docstring_quotes_and_prefixes_properly,\n            Preview.long_docstring_quotes_on_newline\n        ]\n\n    def __contains__(self, item):\n        return item in self.settings"",
            ""self = type('Mock', (object,), {'mode': Mode(), 'current_line': type('Line', (object,), {'depth': 1}), 'visit_default': lambda leaf: None})()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""This is a docstring.\""\""\""'})()"",
            ""is_docstring = lambda leaf: bool(re.match(r'^\""\""\"".*\""\""\""$', leaf.value))"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value.replace('\""\""\""', '\""')"",
            ""get_string_prefix = lambda docstring: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: docstring.replace('\\n', '\\n' + indent)""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'})"",
            ""class Mode:\n    def __init__(self):\n        self.options = ['hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline']\n        self.string_normalization = True\n        self.line_length = 88\n"",
            ""self = type('SelfMock', (object,), {'mode': Mode(), 'current_line': type('LineMock', (object,), {'depth': 1})(), 'visit_default': lambda leaf: None})()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = type('LeafMock', (object,), {'value': '\""\""\""This is a docstring.\""\""\""'})()"",
            ""is_docstring = lambda leaf: bool(re.match(r'^\""\""\"".*\""\""\""$', leaf.value))"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value.replace('\""\""\""', '\""')"",
            ""get_string_prefix = lambda docstring: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: docstring.replace('\\n', '\\n' + indent)""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'})"",
            ""class Mode:\n    def __init__(self):\n        self.string_normalization = True\n        self.line_length = 88\n        self.features = {Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline}\n    def __contains__(self, feature):\n        return feature in self.features"",
            ""self = type('Mock', (object,), {'mode': Mode(), 'current_line': type('Line', (object,), {'depth': 1}), 'visit_default': lambda dummy_leaf: None})()"",
            ""normalize_unicode_escape_sequences = lambda dummy_leaf: None"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""This is a docstring.\""\""\""'})()"",
            ""is_docstring = lambda dummy_leaf: bool(re.match(r'^\""\""\"".*\""\""\""$', dummy_leaf.value))"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value.replace('\""', '\""')"",
            ""get_string_prefix = lambda docstring: ''"",
            ""is_multiline_string = lambda dummy_leaf: '\\n' in dummy_leaf.value"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'})"",
            ""class Mode:\n    def __init__(self):\n        self.string_normalization = False\n        self.line_length = 88\n        self.active_modes = {Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline}\n    def __contains__(self, mode):\n        return mode in self.active_modes\n    "",
            ""self = type('Mock', (object,), {'mode': Mode(), 'current_line': type('Line', (object,), {'depth': 1}), 'visit_default': lambda leaf: None})()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""This is a docstring.\""\""\""'})()"",
            ""is_docstring = lambda leaf: bool(re.match(r'^\""\""\"".*\""\""\""$', leaf.value))"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value.replace('\""\""\""', '\""')"",
            ""get_string_prefix = lambda docstring: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: docstring.replace('\\n', '\\n' + indent)""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'})"",
            ""class Mode:\n    def __init__(self):\n        self.string_normalization = True\n        self.line_length = 88\n        self.options = [Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline]\n    def __contains__(self, item):\n        return item in self.options"",
            ""self = type('Mock', (object,), {'mode': Mode(), 'current_line': type('Line', (object,), {'depth': 1}), 'visit_default': lambda leaf: None})()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""This is a docstring.\""\""\""'})()"",
            ""is_docstring = lambda leaf: bool(re.match(r'^\""\""\"".*\""\""\""$', leaf.value))"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value.replace('\""\""\""', '\""')"",
            ""get_string_prefix = lambda docstring: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: docstring.replace('\\n', '\\n' + indent)""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'})"",
            ""class Mode:\n    def __init__(self):\n        self.string_normalization = True\n        self.line_length = 88\n        self.options = {Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline}\n\n    def __contains__(self, item):\n        return item in self.options"",
            ""self = type('Mock', (object,), {'mode': Mode(), 'current_line': type('Line', (object,), {'depth': 1})(), 'visit_default': lambda leaf: None})()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""This is a docstring.\""\""\""'})()"",
            ""is_docstring = lambda leaf: bool(re.match(r'^\""\""\"".*\""\""\""$', leaf.value))"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value.replace('\""\""\""', '\""')"",
            ""get_string_prefix = lambda docstring: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: docstring.replace('\\n', '\\n' + indent)""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'})"",
            ""class Mode:\n    def __init__(self):\n        self.string_normalization = False\n        self.line_length = 88\n        self._modes = ['hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline']\n    def __contains__(self, item):\n        return item in self._modes\n"",
            ""self = type('Mock', (object,), {'mode': Mode(), 'current_line': type('Line', (object,), {'depth': 1})(), 'visit_default': lambda leaf: None})()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""This is a docstring.\""\""\""'})()"",
            ""is_docstring = lambda leaf: bool(re.match(r'^\""\""\"".*\""\""\""$', leaf.value))"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value.replace('\""\""\""', '\""')"",
            ""get_string_prefix = lambda docstring: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: docstring.replace('\\n', '\\n' + indent)""
        ]
    }
]","[
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'}) # pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.features = {# pragma: no cover"",
            ""            'hex_codes_in_unicode_sequences',# pragma: no cover"",
            ""            'normalize_docstring_quotes_and_prefixes_properly',# pragma: no cover"",
            ""            'long_docstring_quotes_on_newline',# pragma: no cover"",
            ""        }# pragma: no cover"",
            ""        self.string_normalization = False# pragma: no cover"",
            ""        self.line_length = 88# pragma: no cover"",
            ""    def __contains__(self, item):# pragma: no cover"",
            ""        return item in self.features # pragma: no cover"",
            ""self = type('Mock', (object,), {'mode': Mode(), 'current_line': type('Line', (object,), {'depth': 1})(), 'visit_default': lambda leaf: None})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""This is a docstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: bool(re.match(r'^\""\""\"".*\""\""\""$', leaf.value)) # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value.replace('\""\""\""', '\""') # pragma: no cover"",
            ""get_string_prefix = lambda docstring: '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: docstring.replace('\\n', '\\n' + indent) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'}) # pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80# pragma: no cover"",
            ""        self._features = {Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline}# pragma: no cover"",
            ""    def __contains__(self, feature):# pragma: no cover"",
            ""        return feature in self._features# pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {'mode': Mode(), 'current_line': type('Line', (object,), {'depth': 1}), 'visit_default': lambda leaf: None})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""This is a multiline\\ndocstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: bool(re.match(r'^\""\""\"".*\""\""\""$', leaf.value, re.DOTALL)) # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value.replace(\""'''\"", '\""\""\""').replace('\""\""\""', '\""'), # pragma: no cover"",
            ""get_string_prefix = lambda docstring: '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'}) # pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 88# pragma: no cover"",
            ""        self.options = [Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline]# pragma: no cover"",
            ""    def __contains__(self, item):# pragma: no cover"",
            ""        return item in self.options# pragma: no cover"",
            ""     # pragma: no cover"",
            ""self = type('Mock', (object,), {'mode': Mode(), 'current_line': type('Line', (object,), {'depth': 1})(), 'visit_default': lambda self, leaf: None})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""This is a docstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: bool(re.match(r'^\""\""\"".*\""\""\""$', leaf.value)) # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value.lower() # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value.replace('\""', '\""') # pragma: no cover"",
            ""get_string_prefix = lambda docstring: '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: docstring.replace('\\n', '\\n' + indent) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'}) # pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.string_normalization = False# pragma: no cover"",
            ""        self.line_length = 88# pragma: no cover"",
            ""        self.settings = [# pragma: no cover"",
            ""            Preview.hex_codes_in_unicode_sequences,# pragma: no cover"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly,# pragma: no cover"",
            ""            Preview.long_docstring_quotes_on_newline# pragma: no cover"",
            ""        ]# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def __contains__(self, item):# pragma: no cover"",
            ""        return item in self.settings # pragma: no cover"",
            ""self = type('Mock', (object,), {'mode': Mode(), 'current_line': type('Line', (object,), {'depth': 1}), 'visit_default': lambda leaf: None})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""This is a docstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: bool(re.match(r'^\""\""\"".*\""\""\""$', leaf.value)) # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value.replace('\""\""\""', '\""') # pragma: no cover"",
            ""get_string_prefix = lambda docstring: '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: docstring.replace('\\n', '\\n' + indent) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'}) # pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.options = ['hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline']# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 88# pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('SelfMock', (object,), {'mode': Mode(), 'current_line': type('LineMock', (object,), {'depth': 1})(), 'visit_default': lambda leaf: None})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = type('LeafMock', (object,), {'value': '\""\""\""This is a docstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: bool(re.match(r'^\""\""\"".*\""\""\""$', leaf.value)) # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value.replace('\""\""\""', '\""') # pragma: no cover"",
            ""get_string_prefix = lambda docstring: '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: docstring.replace('\\n', '\\n' + indent) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'}) # pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 88# pragma: no cover"",
            ""        self.features = {Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline}# pragma: no cover"",
            ""    def __contains__(self, feature):# pragma: no cover"",
            ""        return feature in self.features # pragma: no cover"",
            ""self = type('Mock', (object,), {'mode': Mode(), 'current_line': type('Line', (object,), {'depth': 1}), 'visit_default': lambda dummy_leaf: None})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda dummy_leaf: None # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""This is a docstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda dummy_leaf: bool(re.match(r'^\""\""\"".*\""\""\""$', dummy_leaf.value)) # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value.replace('\""', '\""') # pragma: no cover"",
            ""get_string_prefix = lambda docstring: '' # pragma: no cover"",
            ""is_multiline_string = lambda dummy_leaf: '\\n' in dummy_leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'}) # pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.string_normalization = False# pragma: no cover"",
            ""        self.line_length = 88# pragma: no cover"",
            ""        self.active_modes = {Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline}# pragma: no cover"",
            ""    def __contains__(self, mode):# pragma: no cover"",
            ""        return mode in self.active_modes# pragma: no cover"",
            ""     # pragma: no cover"",
            ""self = type('Mock', (object,), {'mode': Mode(), 'current_line': type('Line', (object,), {'depth': 1}), 'visit_default': lambda leaf: None})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""This is a docstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: bool(re.match(r'^\""\""\"".*\""\""\""$', leaf.value)) # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value.replace('\""\""\""', '\""') # pragma: no cover"",
            ""get_string_prefix = lambda docstring: '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: docstring.replace('\\n', '\\n' + indent) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'}) # pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 88# pragma: no cover"",
            ""        self.options = [Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline]# pragma: no cover"",
            ""    def __contains__(self, item):# pragma: no cover"",
            ""        return item in self.options # pragma: no cover"",
            ""self = type('Mock', (object,), {'mode': Mode(), 'current_line': type('Line', (object,), {'depth': 1}), 'visit_default': lambda leaf: None})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""This is a docstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: bool(re.match(r'^\""\""\"".*\""\""\""$', leaf.value)) # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value.replace('\""\""\""', '\""') # pragma: no cover"",
            ""get_string_prefix = lambda docstring: '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: docstring.replace('\\n', '\\n' + indent) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'}) # pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 88# pragma: no cover"",
            ""        self.options = {Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline}# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def __contains__(self, item):# pragma: no cover"",
            ""        return item in self.options # pragma: no cover"",
            ""self = type('Mock', (object,), {'mode': Mode(), 'current_line': type('Line', (object,), {'depth': 1})(), 'visit_default': lambda leaf: None})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""This is a docstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: bool(re.match(r'^\""\""\"".*\""\""\""$', leaf.value)) # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value.replace('\""\""\""', '\""') # pragma: no cover"",
            ""get_string_prefix = lambda docstring: '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: docstring.replace('\\n', '\\n' + indent) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'}) # pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.string_normalization = False# pragma: no cover"",
            ""        self.line_length = 88# pragma: no cover"",
            ""        self._modes = ['hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline']# pragma: no cover"",
            ""    def __contains__(self, item):# pragma: no cover"",
            ""        return item in self._modes# pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {'mode': Mode(), 'current_line': type('Line', (object,), {'depth': 1})(), 'visit_default': lambda leaf: None})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""This is a docstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: bool(re.match(r'^\""\""\"".*\""\""\""$', leaf.value)) # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value.replace('\""\""\""', '\""') # pragma: no cover"",
            ""get_string_prefix = lambda docstring: '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: docstring.replace('\\n', '\\n' + indent) # pragma: no cover""
        ]
    }
]",2,2517,0.0012585,3792,0.005688,0.0069465
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 50:
    if Preview.hex_codes_in_unicode_sequences in self.mode:
TypeError: argument of type 'Mode' is not iterable
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'\n\nclass Mode:\n    def __init__(self, string_normalization: bool, line_length: int, modes: list):\n        self.string_normalization = string_normalization\n        self.line_length = line_length\n        self.modes = modes\n\nclass Leaf:\n    def __init__(self, value: str):\n        self.value = value\n\nclass CurrentLine:\n    def __init__(self, depth: int):\n        self.depth = depth\n\nclass Mock:\n    def __init__(self, mode, current_line):\n        self.mode = mode\n        self.current_line = current_line\n\n    def visit_default(self, leaf: Leaf):\n        return None"",
            ""preview_modes = [Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline]"",
            ""preview_mode = Mode(string_normalization=True, line_length=80, modes=preview_modes)"",
            ""self = Mock(mode=preview_mode, current_line=CurrentLine(depth=1))"",
            ""def normalize_unicode_escape_sequences(leaf):\n    pass"",
            ""leaf = Leaf(value='\""\""\""Example docstring\""\""\""')"",
            ""def is_docstring(leaf) -> bool:\n    return leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"")"",
            ""def normalize_string_prefix(string: str) -> str:\n    return string"",
            ""def normalize_string_quotes(string: str) -> str:\n    return string"",
            ""def get_string_prefix(string: str) -> str:\n    return ''"",
            ""def is_multiline_string(leaf: Leaf) -> bool:\n    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring: str, indent: str) -> str:\n    return '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'"",
            ""class Mode:\n    def __init__(self):\n        self.string_normalization = True\n        self.line_length = 80\n        self.enabled_features = {\n            Preview.hex_codes_in_unicode_sequences,\n            Preview.normalize_docstring_quotes_and_prefixes_properly,\n            Preview.long_docstring_quotes_on_newline\n        }\n\n    def __contains__(self, item):\n        return item in self.enabled_features"",
            ""mode_instance = Mode()"",
            ""class CurrentLine:\n    def __init__(self, depth):\n        self.depth = depth"",
            ""class Mock:\n    def __init__(self, mode, current_line):\n        self.mode = mode\n        self.current_line = current_line\n    def visit_default(self, leaf):\n        pass"",
            ""self = Mock(mode_instance, CurrentLine(1))"",
            ""def normalize_unicode_escape_sequences(leaf):\n    pass"",
            ""class Leaf:\n    def __init__(self, value):\n        self.value = value"",
            ""leaf = Leaf('\""\""\""Example docstring\""\""\""')"",
            ""def is_docstring(leaf):\n    return isinstance(leaf.value, str) and (leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""''\""))"",
            ""def normalize_string_prefix(value):\n    return value"",
            ""def normalize_string_quotes(value):\n    return value"",
            ""def get_string_prefix(docstring):\n    return ''"",
            ""def is_multiline_string(leaf):\n    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring, indent):\n    return '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""class PreviewMock:\n    hex_codes_in_unicode_sequences = 'HEX_CODES'\n    normalize_docstring_quotes_and_prefixes_properly = 'NORMALIZE_DOCSTRINGS'\n    long_docstring_quotes_on_newline = 'LONG_QUOTES_ON_NEWLINE'\n\nclass ModeMock:\n    def __init__(self, enabled_flags):\n        self.enabled_flags = enabled_flags\n        self.string_normalization = True\n        self.line_length = 80\n\n    def __contains__(self, item):\n        return item in self.enabled_flags\n\nclass LeafMock:\n    def __init__(self, value):\n        self.value = value\n\nclass CurrentLineMock:\n    def __init__(self, depth):\n        self.depth = depth\n\nclass SelfMock:\n    def __init__(self, mode, current_line):\n        self.mode = mode\n        self.current_line = current_line\n\n    def visit_default(self, leaf):\n        pass\n\npreview_mode = ModeMock({PreviewMock.hex_codes_in_unicode_sequences, PreviewMock.normalize_docstring_quotes_and_prefixes_properly, PreviewMock.long_docstring_quotes_on_newline})"",
            ""self = SelfMock(mode=preview_mode, current_line=CurrentLineMock(depth=1))"",
            ""def normalize_unicode_escape_sequences(leaf): pass"",
            ""leaf = LeafMock(value='\""\""\""Example docstring.\""\""\""')"",
            ""def is_docstring(leaf):\n    return leaf.value.startswith(('\""\""\""', \""''''\""))"",
            ""def normalize_string_prefix(value):\n    return value"",
            ""def normalize_string_quotes(value):\n    return value"",
            ""def get_string_prefix(docstring):\n    return ''"",
            ""def is_multiline_string(leaf):\n    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring, indent):\n    return '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'\n\nclass Mode:\n    def __init__(self, flags):\n        self.flags = flags\n        self.string_normalization = True\n        self.line_length = 80\n\n    def __contains__(self, item):\n        return item in self.flags\n\nclass Leaf:\n    def __init__(self, value: str):\n        self.value = value\n\nclass CurrentLine:\n    def __init__(self, depth: int):\n        self.depth = depth\n\nclass Mock:\n    def __init__(self, mode, current_line):\n        self.mode = mode\n        self.current_line = current_line\n\n    def visit_default(self, leaf: Leaf):\n        pass"",
            ""flags = {Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline}"",
            ""mode_instance = Mode(flags=flags)"",
            ""self = Mock(mode=mode_instance, current_line=CurrentLine(depth=1))"",
            ""def normalize_unicode_escape_sequences(leaf):\n    pass"",
            ""leaf = Leaf(value='\""\""\""Example docstring\""\""\""')"",
            ""def is_docstring(leaf) -> bool:\n    return leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"")"",
            ""def normalize_string_prefix(string: str) -> str:\n    return string"",
            ""def normalize_string_quotes(string: str) -> str:\n    return string"",
            ""def get_string_prefix(string: str) -> str:\n    return ''"",
            ""def is_multiline_string(leaf: Leaf) -> bool:\n    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring: str, indent: str) -> str:\n    return '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Dict""
        ],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'\n\nclass Mode:\n    def __init__(self, string_normalization: bool, line_length: int, modes: List[str]):\n        self.string_normalization = string_normalization\n        self.line_length = line_length\n        self.modes = modes\n\nclass Leaf:\n    def __init__(self, value: str):\n        self.value = value\n\nclass CurrentLine:\n    def __init__(self, depth: int):\n        self.depth = depth\n\nclass Mock:\n    def __init__(self, mode, current_line):\n        self.mode = mode\n        self.current_line = current_line\n\n    def visit_default(self, leaf: Leaf):\n        pass"",
            ""preview_mode = Preview()"",
            ""self = Mock(mode=Mode(string_normalization=True, line_length=80, modes=[preview_mode.hex_codes_in_unicode_sequences, preview_mode.normalize_docstring_quotes_and_prefixes_properly, preview_mode.long_docstring_quotes_on_newline]), current_line=CurrentLine(depth=1))"",
            ""def normalize_unicode_escape_sequences(leaf):\n    pass"",
            ""leaf = Leaf(value='\""\""\""Example docstring\""\""\""')"",
            ""def is_docstring(leaf) -> bool:\n    return leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"")"",
            ""def normalize_string_prefix(string: str) -> str:\n    return string"",
            ""def normalize_string_quotes(string: str) -> str:\n    return string"",
            ""def get_string_prefix(string: str) -> str:\n    return ''"",
            ""def is_multiline_string(leaf: Leaf) -> bool:\n    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring: str, indent: str) -> str:\n    return '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [
            ""from typing import List""
        ],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'\n\n    def __init__(self, modes: List[str]):\n        self.modes = modes\n\nclass Mode:\n    def __init__(self, string_normalization: bool, line_length: int, modes: List[str]):\n        self.string_normalization = string_normalization\n        self.line_length = line_length\n        self.modes = modes\n\nclass Leaf:\n    def __init__(self, value: str):\n        self.value = value\n\nclass CurrentLine:\n    def __init__(self, depth: int):\n        self.depth = depth\n\nclass Mock:\n    def __init__(self, mode, current_line):\n        self.mode = mode\n        self.current_line = current_line\n\n    def visit_default(self, leaf: Leaf):\n        pass"",
            ""preview_mode = Preview(['hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline'])"",
            ""self = Mock(mode=Mode(string_normalization=True, line_length=80, modes=preview_mode.modes), current_line=CurrentLine(depth=1))"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = Leaf(value='\""\""\""Example docstring\""\""\""')"",
            ""is_docstring = lambda leaf: leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"")"",
            ""normalize_string_prefix = lambda string: string"",
            ""normalize_string_quotes = lambda string: string"",
            ""get_string_prefix = lambda string: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Dict""
        ],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'\n\nclass Mode:\n    def __init__(self, string_normalization: bool, line_length: int, features: List[str]):\n        self.string_normalization = string_normalization\n        self.line_length = line_length\n        self.features = features\n\n    def __contains__(self, item):\n        return item in self.features\n\nclass Leaf:\n    def __init__(self, value: str):\n        self.value = value\n\nclass CurrentLine:\n    def __init__(self, depth: int):\n        self.depth = depth\n\nclass Mock:\n    def __init__(self, mode, current_line):\n        self.mode = mode\n        self.current_line = current_line\n\n    def visit_default(self, leaf: Leaf):\n        pass"",
            ""preview_mode = Mode(string_normalization=True, line_length=80, features=[Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline])"",
            ""self = Mock(mode=preview_mode, current_line=CurrentLine(depth=1))"",
            ""def normalize_unicode_escape_sequences(leaf):\n    pass"",
            ""leaf = Leaf(value='\""\""\""Example docstring\""\""\""')"",
            ""def is_docstring(leaf) -> bool:\n    return leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"")"",
            ""def normalize_string_prefix(string: str) -> str:\n    return string"",
            ""def normalize_string_quotes(string: str) -> str:\n    return string"",
            ""def get_string_prefix(string: str) -> str:\n    return ''"",
            ""def is_multiline_string(leaf: Leaf) -> bool:\n    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring: str, indent: str) -> str:\n    return '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'\n\nclass Mode:\n    def __init__(self, options):\n        self._options = options\n        self.string_normalization = True\n        self.line_length = 80\n\n    def __contains__(self, item):\n        return item in self._options\n\nclass Leaf:\n    def __init__(self, value):\n        self.value = value\n\nclass CurrentLine:\n    def __init__(self, depth):\n        self.depth = depth\n\nclass Mock:\n    def __init__(self, mode, current_line):\n        self.mode = mode\n        self.current_line = current_line\n\n    def visit_default(self, leaf):\n        pass"",
            ""self = Mock(Mode({'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline'}), CurrentLine(1))"",
            ""def normalize_unicode_escape_sequences(leaf):\n    pass"",
            ""leaf = Leaf('\""\""\""Example docstring\""\""\""')"",
            ""def is_docstring(leaf):\n    return leaf.value.startswith(('\""\""\""', \""'''\""))"",
            ""def normalize_string_prefix(value):\n    return value"",
            ""def normalize_string_quotes(value):\n    return value"",
            ""def get_string_prefix(docstring):\n    return ''"",
            ""def is_multiline_string(leaf):\n    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring, indent):\n    return '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Dict""
        ],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'\n\nclass Mode:\n    def __init__(self, string_normalization: bool, line_length: int, modes: List[str]):\n        self.string_normalization = string_normalization\n        self.line_length = line_length\n        self.modes = modes\n\n    def __contains__(self, item):\n        return item in self.modes\n\nclass Leaf:\n    def __init__(self, value: str):\n        self.value = value\n\nclass CurrentLine:\n    def __init__(self, depth: int):\n        self.depth = depth\n\nclass Mock:\n    def __init__(self, mode, current_line):\n        self.mode = mode\n        self.current_line = current_line\n\n    def visit_default(self, leaf: Leaf):\n        pass"",
            ""preview_mode = Preview(Mode(string_normalization=True, line_length=88, modes=[Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline]))"",
            ""self = Mock(mode=preview_mode.mode, current_line=CurrentLine(depth=1))"",
            ""def normalize_unicode_escape_sequences(leaf):\n    pass"",
            ""leaf = Leaf(value='\""\""\""Example docstring\""\""\""')"",
            ""def is_docstring(leaf) -> bool:\n    return leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"")"",
            ""def normalize_string_prefix(string: str) -> str:\n    return string"",
            ""def normalize_string_quotes(string: str) -> str:\n    return string"",
            ""def get_string_prefix(string: str) -> str:\n    return ''"",
            ""def is_multiline_string(leaf: Leaf) -> bool:\n    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring: str, indent: str) -> str:\n    return '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Dict""
        ],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'\n\nclass Mode:\n    def __init__(self, string_normalization: bool, line_length: int, features: List[str]):\n        self.string_normalization = string_normalization\n        self.line_length = line_length\n        self.features = features\n\nclass Leaf:\n    def __init__(self, value: str):\n        self.value = value\n\nclass CurrentLine:\n    def __init__(self, depth: int):\n        self.depth = depth\n\nclass Mock:\n    def __init__(self, mode, current_line):\n        self.mode = mode\n        self.current_line = current_line\n\n    def visit_default(self, leaf: Leaf):\n        pass"",
            ""preview_mode = Preview(Mode(string_normalization=True, line_length=80, features=[Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline]))"",
            ""self = Mock(mode=preview_mode.mode, current_line=CurrentLine(depth=1))"",
            ""def normalize_unicode_escape_sequences(leaf):\n    pass"",
            ""leaf = Leaf(value='\""\""\""Example docstring\""\""\""')"",
            ""def is_docstring(leaf) -> bool:\n    return leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"")"",
            ""def normalize_string_prefix(string: str) -> str:\n    return string"",
            ""def normalize_string_quotes(string: str) -> str:\n    return string"",
            ""def get_string_prefix(string: str) -> str:\n    return ''"",
            ""def is_multiline_string(leaf: Leaf) -> bool:\n    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring: str, indent: str) -> str:\n    return '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    }
]","[
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self, string_normalization: bool, line_length: int, modes: list):# pragma: no cover"",
            ""        self.string_normalization = string_normalization# pragma: no cover"",
            ""        self.line_length = line_length# pragma: no cover"",
            ""        self.modes = modes# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, value: str):# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""# pragma: no cover"",
            ""class CurrentLine:# pragma: no cover"",
            ""    def __init__(self, depth: int):# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Mock:# pragma: no cover"",
            ""    def __init__(self, mode, current_line):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.current_line = current_line# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def visit_default(self, leaf: Leaf):# pragma: no cover"",
            ""        return None # pragma: no cover"",
            ""preview_modes = [Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline] # pragma: no cover"",
            ""preview_mode = Mode(string_normalization=True, line_length=80, modes=preview_modes) # pragma: no cover"",
            ""self = Mock(mode=preview_mode, current_line=CurrentLine(depth=1)) # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""leaf = Leaf(value='\""\""\""Example docstring\""\""\""') # pragma: no cover"",
            ""def is_docstring(leaf) -> bool:# pragma: no cover"",
            ""    return leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"") # pragma: no cover"",
            ""def normalize_string_prefix(string: str) -> str:# pragma: no cover"",
            ""    return string # pragma: no cover"",
            ""def normalize_string_quotes(string: str) -> str:# pragma: no cover"",
            ""    return string # pragma: no cover"",
            ""def get_string_prefix(string: str) -> str:# pragma: no cover"",
            ""    return '' # pragma: no cover"",
            ""def is_multiline_string(leaf: Leaf) -> bool:# pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            ""def fix_docstring(docstring: str, indent: str) -> str:# pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80# pragma: no cover"",
            ""        self.enabled_features = {# pragma: no cover"",
            ""            Preview.hex_codes_in_unicode_sequences,# pragma: no cover"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly,# pragma: no cover"",
            ""            Preview.long_docstring_quotes_on_newline# pragma: no cover"",
            ""        }# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def __contains__(self, item):# pragma: no cover"",
            ""        return item in self.enabled_features # pragma: no cover"",
            ""mode_instance = Mode() # pragma: no cover"",
            ""class CurrentLine:# pragma: no cover"",
            ""    def __init__(self, depth):# pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""class Mock:# pragma: no cover"",
            ""    def __init__(self, mode, current_line):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.current_line = current_line# pragma: no cover"",
            ""    def visit_default(self, leaf):# pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""self = Mock(mode_instance, CurrentLine(1)) # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, value):# pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""leaf = Leaf('\""\""\""Example docstring\""\""\""') # pragma: no cover"",
            ""def is_docstring(leaf):# pragma: no cover"",
            ""    return isinstance(leaf.value, str) and (leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""''\"")) # pragma: no cover"",
            ""def normalize_string_prefix(value):# pragma: no cover"",
            ""    return value # pragma: no cover"",
            ""def normalize_string_quotes(value):# pragma: no cover"",
            ""    return value # pragma: no cover"",
            ""def get_string_prefix(docstring):# pragma: no cover"",
            ""    return '' # pragma: no cover"",
            ""def is_multiline_string(leaf):# pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            ""def fix_docstring(docstring, indent):# pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""class PreviewMock:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'HEX_CODES'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'NORMALIZE_DOCSTRINGS'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'LONG_QUOTES_ON_NEWLINE'# pragma: no cover"",
            ""# pragma: no cover"",
            ""class ModeMock:# pragma: no cover"",
            ""    def __init__(self, enabled_flags):# pragma: no cover"",
            ""        self.enabled_flags = enabled_flags# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def __contains__(self, item):# pragma: no cover"",
            ""        return item in self.enabled_flags# pragma: no cover"",
            ""# pragma: no cover"",
            ""class LeafMock:# pragma: no cover"",
            ""    def __init__(self, value):# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""# pragma: no cover"",
            ""class CurrentLineMock:# pragma: no cover"",
            ""    def __init__(self, depth):# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""# pragma: no cover"",
            ""class SelfMock:# pragma: no cover"",
            ""    def __init__(self, mode, current_line):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.current_line = current_line# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def visit_default(self, leaf):# pragma: no cover"",
            ""        pass# pragma: no cover"",
            ""# pragma: no cover"",
            ""preview_mode = ModeMock({PreviewMock.hex_codes_in_unicode_sequences, PreviewMock.normalize_docstring_quotes_and_prefixes_properly, PreviewMock.long_docstring_quotes_on_newline}) # pragma: no cover"",
            ""self = SelfMock(mode=preview_mode, current_line=CurrentLineMock(depth=1)) # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): pass # pragma: no cover"",
            ""leaf = LeafMock(value='\""\""\""Example docstring.\""\""\""') # pragma: no cover"",
            ""def is_docstring(leaf):# pragma: no cover"",
            ""    return leaf.value.startswith(('\""\""\""', \""''''\"")) # pragma: no cover"",
            ""def normalize_string_prefix(value):# pragma: no cover"",
            ""    return value # pragma: no cover"",
            ""def normalize_string_quotes(value):# pragma: no cover"",
            ""    return value # pragma: no cover"",
            ""def get_string_prefix(docstring):# pragma: no cover"",
            ""    return '' # pragma: no cover"",
            ""def is_multiline_string(leaf):# pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            ""def fix_docstring(docstring, indent):# pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self, flags):# pragma: no cover"",
            ""        self.flags = flags# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def __contains__(self, item):# pragma: no cover"",
            ""        return item in self.flags# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, value: str):# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""# pragma: no cover"",
            ""class CurrentLine:# pragma: no cover"",
            ""    def __init__(self, depth: int):# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Mock:# pragma: no cover"",
            ""    def __init__(self, mode, current_line):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.current_line = current_line# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def visit_default(self, leaf: Leaf):# pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""flags = {Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline} # pragma: no cover"",
            ""mode_instance = Mode(flags=flags) # pragma: no cover"",
            ""self = Mock(mode=mode_instance, current_line=CurrentLine(depth=1)) # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""leaf = Leaf(value='\""\""\""Example docstring\""\""\""') # pragma: no cover"",
            ""def is_docstring(leaf) -> bool:# pragma: no cover"",
            ""    return leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"") # pragma: no cover"",
            ""def normalize_string_prefix(string: str) -> str:# pragma: no cover"",
            ""    return string # pragma: no cover"",
            ""def normalize_string_quotes(string: str) -> str:# pragma: no cover"",
            ""    return string # pragma: no cover"",
            ""def get_string_prefix(string: str) -> str:# pragma: no cover"",
            ""    return '' # pragma: no cover"",
            ""def is_multiline_string(leaf: Leaf) -> bool:# pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            ""def fix_docstring(docstring: str, indent: str) -> str:# pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Dict # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self, string_normalization: bool, line_length: int, modes: List[str]):# pragma: no cover"",
            ""        self.string_normalization = string_normalization# pragma: no cover"",
            ""        self.line_length = line_length# pragma: no cover"",
            ""        self.modes = modes# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, value: str):# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""# pragma: no cover"",
            ""class CurrentLine:# pragma: no cover"",
            ""    def __init__(self, depth: int):# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Mock:# pragma: no cover"",
            ""    def __init__(self, mode, current_line):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.current_line = current_line# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def visit_default(self, leaf: Leaf):# pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""preview_mode = Preview() # pragma: no cover"",
            ""self = Mock(mode=Mode(string_normalization=True, line_length=80, modes=[preview_mode.hex_codes_in_unicode_sequences, preview_mode.normalize_docstring_quotes_and_prefixes_properly, preview_mode.long_docstring_quotes_on_newline]), current_line=CurrentLine(depth=1)) # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""leaf = Leaf(value='\""\""\""Example docstring\""\""\""') # pragma: no cover"",
            ""def is_docstring(leaf) -> bool:# pragma: no cover"",
            ""    return leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"") # pragma: no cover"",
            ""def normalize_string_prefix(string: str) -> str:# pragma: no cover"",
            ""    return string # pragma: no cover"",
            ""def normalize_string_quotes(string: str) -> str:# pragma: no cover"",
            ""    return string # pragma: no cover"",
            ""def get_string_prefix(string: str) -> str:# pragma: no cover"",
            ""    return '' # pragma: no cover"",
            ""def is_multiline_string(leaf: Leaf) -> bool:# pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            ""def fix_docstring(docstring: str, indent: str) -> str:# pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def __init__(self, modes: List[str]):# pragma: no cover"",
            ""        self.modes = modes# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self, string_normalization: bool, line_length: int, modes: List[str]):# pragma: no cover"",
            ""        self.string_normalization = string_normalization# pragma: no cover"",
            ""        self.line_length = line_length# pragma: no cover"",
            ""        self.modes = modes# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, value: str):# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""# pragma: no cover"",
            ""class CurrentLine:# pragma: no cover"",
            ""    def __init__(self, depth: int):# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Mock:# pragma: no cover"",
            ""    def __init__(self, mode, current_line):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.current_line = current_line# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def visit_default(self, leaf: Leaf):# pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""preview_mode = Preview(['hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline']) # pragma: no cover"",
            ""self = Mock(mode=Mode(string_normalization=True, line_length=80, modes=preview_mode.modes), current_line=CurrentLine(depth=1)) # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = Leaf(value='\""\""\""Example docstring\""\""\""') # pragma: no cover"",
            ""is_docstring = lambda leaf: leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"") # pragma: no cover"",
            ""normalize_string_prefix = lambda string: string # pragma: no cover"",
            ""normalize_string_quotes = lambda string: string # pragma: no cover"",
            ""get_string_prefix = lambda string: '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Dict # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self, string_normalization: bool, line_length: int, features: List[str]):# pragma: no cover"",
            ""        self.string_normalization = string_normalization# pragma: no cover"",
            ""        self.line_length = line_length# pragma: no cover"",
            ""        self.features = features# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def __contains__(self, item):# pragma: no cover"",
            ""        return item in self.features# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, value: str):# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""# pragma: no cover"",
            ""class CurrentLine:# pragma: no cover"",
            ""    def __init__(self, depth: int):# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Mock:# pragma: no cover"",
            ""    def __init__(self, mode, current_line):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.current_line = current_line# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def visit_default(self, leaf: Leaf):# pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""preview_mode = Mode(string_normalization=True, line_length=80, features=[Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline]) # pragma: no cover"",
            ""self = Mock(mode=preview_mode, current_line=CurrentLine(depth=1)) # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""leaf = Leaf(value='\""\""\""Example docstring\""\""\""') # pragma: no cover"",
            ""def is_docstring(leaf) -> bool:# pragma: no cover"",
            ""    return leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"") # pragma: no cover"",
            ""def normalize_string_prefix(string: str) -> str:# pragma: no cover"",
            ""    return string # pragma: no cover"",
            ""def normalize_string_quotes(string: str) -> str:# pragma: no cover"",
            ""    return string # pragma: no cover"",
            ""def get_string_prefix(string: str) -> str:# pragma: no cover"",
            ""    return '' # pragma: no cover"",
            ""def is_multiline_string(leaf: Leaf) -> bool:# pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            ""def fix_docstring(docstring: str, indent: str) -> str:# pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self, options):# pragma: no cover"",
            ""        self._options = options# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def __contains__(self, item):# pragma: no cover"",
            ""        return item in self._options# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, value):# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""# pragma: no cover"",
            ""class CurrentLine:# pragma: no cover"",
            ""    def __init__(self, depth):# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Mock:# pragma: no cover"",
            ""    def __init__(self, mode, current_line):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.current_line = current_line# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def visit_default(self, leaf):# pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""self = Mock(Mode({'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline'}), CurrentLine(1)) # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""leaf = Leaf('\""\""\""Example docstring\""\""\""') # pragma: no cover"",
            ""def is_docstring(leaf):# pragma: no cover"",
            ""    return leaf.value.startswith(('\""\""\""', \""'''\"")) # pragma: no cover"",
            ""def normalize_string_prefix(value):# pragma: no cover"",
            ""    return value # pragma: no cover"",
            ""def normalize_string_quotes(value):# pragma: no cover"",
            ""    return value # pragma: no cover"",
            ""def get_string_prefix(docstring):# pragma: no cover"",
            ""    return '' # pragma: no cover"",
            ""def is_multiline_string(leaf):# pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            ""def fix_docstring(docstring, indent):# pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Dict # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self, string_normalization: bool, line_length: int, modes: List[str]):# pragma: no cover"",
            ""        self.string_normalization = string_normalization# pragma: no cover"",
            ""        self.line_length = line_length# pragma: no cover"",
            ""        self.modes = modes# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def __contains__(self, item):# pragma: no cover"",
            ""        return item in self.modes# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, value: str):# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""# pragma: no cover"",
            ""class CurrentLine:# pragma: no cover"",
            ""    def __init__(self, depth: int):# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Mock:# pragma: no cover"",
            ""    def __init__(self, mode, current_line):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.current_line = current_line# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def visit_default(self, leaf: Leaf):# pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""leaf = Leaf(value='\""\""\""Example docstring\""\""\""') # pragma: no cover"",
            ""def is_docstring(leaf) -> bool:# pragma: no cover"",
            ""    return leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"") # pragma: no cover"",
            ""def normalize_string_prefix(string: str) -> str:# pragma: no cover"",
            ""    return string # pragma: no cover"",
            ""def normalize_string_quotes(string: str) -> str:# pragma: no cover"",
            ""    return string # pragma: no cover"",
            ""def get_string_prefix(string: str) -> str:# pragma: no cover"",
            ""    return '' # pragma: no cover"",
            ""def is_multiline_string(leaf: Leaf) -> bool:# pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            ""def fix_docstring(docstring: str, indent: str) -> str:# pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Dict # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self, string_normalization: bool, line_length: int, features: List[str]):# pragma: no cover"",
            ""        self.string_normalization = string_normalization# pragma: no cover"",
            ""        self.line_length = line_length# pragma: no cover"",
            ""        self.features = features# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, value: str):# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""# pragma: no cover"",
            ""class CurrentLine:# pragma: no cover"",
            ""    def __init__(self, depth: int):# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Mock:# pragma: no cover"",
            ""    def __init__(self, mode, current_line):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.current_line = current_line# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def visit_default(self, leaf: Leaf):# pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""leaf = Leaf(value='\""\""\""Example docstring\""\""\""') # pragma: no cover"",
            ""def is_docstring(leaf) -> bool:# pragma: no cover"",
            ""    return leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"") # pragma: no cover"",
            ""def normalize_string_prefix(string: str) -> str:# pragma: no cover"",
            ""    return string # pragma: no cover"",
            ""def normalize_string_quotes(string: str) -> str:# pragma: no cover"",
            ""    return string # pragma: no cover"",
            ""def get_string_prefix(string: str) -> str:# pragma: no cover"",
            ""    return '' # pragma: no cover"",
            ""def is_multiline_string(leaf: Leaf) -> bool:# pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            ""def fix_docstring(docstring: str, indent: str) -> str:# pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover""
        ]
    }
]",2,3293,0.0016465,4831,0.0072465,0.008893
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 28:
    if Preview.hex_codes_in_unicode_sequences in self.mode:
TypeError: argument of type 'MockMode' is not iterable
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""Preview = type('MockPreview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})()"",
            ""class MockMode:"",
            ""    def __init__(self, string_normalization, line_length):"",
            ""        self.string_normalization = string_normalization"",
            ""        self.line_length = line_length"",
            ""        self._options = [Preview.hex_codes_in_unicode_sequences,"",
            ""                        Preview.normalize_docstring_quotes_and_prefixes_properly,"",
            ""                        Preview.long_docstring_quotes_on_newline]"",
            ""    def __contains__(self, item):"",
            ""        return item in self._options"",
            ""class MockSelf:"",
            ""    def __init__(self, mode, current_line):"",
            ""        self.mode = mode"",
            ""        self.current_line = current_line"",
            ""    def visit_default(self, leaf):"",
            ""        return None"",
            ""class MockCurrentLine:"",
            ""    def __init__(self, depth):"",
            ""        self.depth = depth"",
            ""class MockLeaf:"",
            ""    def __init__(self, value):"",
            ""        self.value = value"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = MockLeaf('\""\""\""Example docstring\""\""\""')"",
            ""is_docstring = lambda leaf: isinstance(leaf, MockLeaf) and (leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""''\""))"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value.replace('\""\""\""', '\""')"",
            ""get_string_prefix = lambda value: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: docstring.strip()"",
            ""self = MockSelf(MockMode(True, 80), MockCurrentLine(1))""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""Preview = type('MockPreview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})"",
            ""class Mode:"",
            ""    def __init__(self, string_normalization, line_length, options):"",
            ""        self.string_normalization = string_normalization"",
            ""        self.line_length = line_length"",
            ""        self.options = options"",
            ""class CurrentLine:"",
            ""    def __init__(self, depth):"",
            ""        self.depth = depth"",
            ""class MockSelf:"",
            ""    def __init__(self, mode, current_line):"",
            ""        self.mode = mode"",
            ""        self.current_line = current_line"",
            ""    def visit_default(self, leaf):"",
            ""        pass"",
            ""mode = Mode(string_normalization=True, line_length=80, options={"",
            ""    'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline'"",
            ""})"",
            ""self = MockSelf(mode, CurrentLine(depth=1))"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring\""\""\""'})()"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and (leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"")"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value.strip('\""\""\""')"",
            ""get_string_prefix = lambda value: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: docstring.strip()""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""Preview = type('MockPreview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})()"",
            ""class MockMode:"",
            ""    def __init__(self, string_normalization, line_length):"",
            ""        self.string_normalization = string_normalization"",
            ""        self.line_length = line_length"",
            ""        self.active_modes = {"",
            ""            Preview.hex_codes_in_unicode_sequences,"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly,"",
            ""            Preview.long_docstring_quotes_on_newline"",
            ""        }"",
            ""    def __contains__(self, item):"",
            ""        return item in self.active_modes"",
            ""class MockCurrentLine:"",
            ""    def __init__(self, depth):"",
            ""        self.depth = depth"",
            ""self = type('MockSelf', (object,), {"",
            ""    'mode': MockMode(True, 80),"",
            ""    'current_line': MockCurrentLine(1),"",
            ""    'visit_default': lambda leaf: None"",
            ""})()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring\""\""\""'})()"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and (leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"")'"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value.strip('\""\""\""')"",
            ""get_string_prefix = lambda value: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line.strip() for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""Preview = type('MockPreview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})"",
            ""class Mode:"",
            ""    def __init__(self, string_normalization, line_length, modes):"",
            ""        self.string_normalization = string_normalization"",
            ""        self.line_length = line_length"",
            ""        self.modes = modes"",
            ""    def __contains__(self, item):"",
            ""        return item in self.modes"",
            ""class CurrentLine:"",
            ""    def __init__(self, depth):"",
            ""        self.depth = depth"",
            ""class MockSelf:"",
            ""    def __init__(self):"",
            ""        self.mode = Mode(string_normalization=True, line_length=80, modes=["",
            ""            Preview.hex_codes_in_unicode_sequences,"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly,"",
            ""            Preview.long_docstring_quotes_on_newline"",
            ""        ])"",
            ""        self.current_line = CurrentLine(depth=1)"",
            ""    def visit_default(self, leaf):"",
            ""        pass"",
            ""self = MockSelf()"",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring\""\""\""'})()"",
            ""def is_docstring(leaf):"",
            ""    return isinstance(leaf, type) and hasattr(leaf, 'value') and (leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"") or leaf.value)"",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            ""def normalize_string_quotes(value):"",
            ""    return value.strip('\""\""\""')"",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring.strip()""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""Preview = type('MockPreview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})"",
            ""class Mode:"",
            ""    def __init__(self, string_normalization, line_length):"",
            ""        self.string_normalization = string_normalization"",
            ""        self.line_length = line_length"",
            ""        self.options = ["",
            ""            Preview.hex_codes_in_unicode_sequences,"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly,"",
            ""            Preview.long_docstring_quotes_on_newline"",
            ""        ]"",
            ""self = type('MockSelf', (object,), {"",
            ""    'mode': Mode(True, 80),"",
            ""    'current_line': type('MockCurrentLine', (object,), {"",
            ""        'depth': 1"",
            ""    })(),"",
            ""    'visit_default': lambda self, leaf: None"",
            ""})()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring\""\""\""'})()"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and (leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"") )"",
            ""normalize_string_prefix = lambda value: value "",
            ""normalize_string_quotes = lambda value: '\""\""\""' + value.strip('\""\""\""') + '\""\""\""'"",
            ""get_string_prefix = lambda value: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: docstring.strip()""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})"",
            ""class Mode:"",
            ""    def __init__(self):"",
            ""        self.string_normalization = False"",
            ""        self.line_length = 88"",
            ""        self.options = {"",
            ""            'hex_codes_in_unicode_sequences': True,"",
            ""            'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""            'long_docstring_quotes_on_newline': True"",
            ""        }"",
            ""    def __contains__(self, item):"",
            ""        return item in self.options and self.options[item]"",
            ""self = type('SelfMock', (object,), {'mode': Mode(), 'current_line': type('Line', (object,), {'depth': 1})(), 'visit_default': lambda leaf: None})()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})()"",
            ""is_docstring = lambda leaf: bool(re.match(r'^\""\""\"".*\""\""\""$', leaf.value))"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value.replace(\""'''\"", '\""\""\""').replace(\""'\"", '\""').replace('\\\""', '\""')"",
            ""get_string_prefix = lambda docstring: 'u' if docstring.startswith('u') else ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: docstring.replace('\\n', '\\n' + indent)""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""Preview = type('MockPreview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})()"",
            ""class Mode:"",
            ""    def __init__(self):"",
            ""        self.string_normalization = True"",
            ""        self.line_length = 80"",
            ""        self.active_previews = {"",
            ""            Preview.hex_codes_in_unicode_sequences,"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly,"",
            ""            Preview.long_docstring_quotes_on_newline"",
            ""        }"",
            ""    def __contains__(self, item):"",
            ""        return item in self.active_previews"",
            ""class CurrentLine:"",
            ""    def __init__(self, depth):"",
            ""        self.depth = depth"",
            ""self = type('MockSelf', (object,), {"",
            ""    'mode': Mode(),"",
            ""    'current_line': CurrentLine(depth=1),"",
            ""    'visit_default': lambda leaf: None"",
            ""})()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring\""\""\""'})()"",
            ""is_docstring = lambda leaf: leaf.value.startswith(('\""\""\""', \""'''\"", '\""', \""'\""))"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value"",
            ""get_string_prefix = lambda value: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""Preview = type('MockPreview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})()"",
            ""class Mode:"",
            ""    def __init__(self):"",
            ""        self.options = {"",
            ""            'hex_codes_in_unicode_sequences': True,"",
            ""            'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""            'long_docstring_quotes_on_newline': True"",
            ""        }"",
            ""        self.string_normalization = True"",
            ""        self.line_length = 80"",
            ""    def __contains__(self, item):"",
            ""        return item in self.options"",
            ""class CurrentLine:"",
            ""    def __init__(self, depth):"",
            ""        self.depth = depth"",
            ""class MockSelf:"",
            ""    def __init__(self):"",
            ""        self.mode = Mode()"",
            ""        self.current_line = CurrentLine(depth=1)"",
            ""    def visit_default(self, leaf):"",
            ""        pass"",
            ""self = MockSelf()"",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring\""\""\""'})()"",
            ""def is_docstring(leaf):"",
            ""    return leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"")"",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            ""def normalize_string_quotes(value):"",
            ""    return value.strip('\""\""\""')"",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'\n\nclass Mode:\n    def __init__(self):\n        self.string_normalization = True\n        self.line_length = 80\n        self.options = [\n            'hex_codes_in_unicode_sequences',\n            'normalize_docstring_quotes_and_prefixes_properly',\n            'long_docstring_quotes_on_newline'\n        ]\n\nclass Leaf:\n    def __init__(self, value):\n        self.value = value\n\nclass CurrentLine:\n    def __init__(self, depth):\n        self.depth = depth\n\nclass Mock:\n    def __init__(self, mode, current_line):\n        self.mode = mode\n        self.current_line = current_line\n\n    def visit_default(self, leaf):\n        pass"",
            ""mode = Mode()"",
            ""mode.__contains__ = lambda item: item in mode.options"",
            ""self = Mock(mode, CurrentLine(depth=1))"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = Leaf('\""\""\""Example docstring\""\""\""')"",
            ""is_docstring = lambda leaf: isinstance(leaf, Leaf) and (leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"")"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value.strip('\""\""\""')"",
            ""get_string_prefix = lambda value: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'\n\nclass Mode:\n    def __init__(self, flags):\n        self.string_normalization = True\n        self.line_length = 80\n        self.flags = flags\n\n    def __contains__(self, item):\n        return item in self.flags\n\nclass Leaf:\n    def __init__(self, value):\n        self.value = value\n\nclass CurrentLine:\n    def __init__(self, depth):\n        self.depth = depth\n\nclass SelfMock:\n    def __init__(self, mode, current_line):\n        self.mode = mode\n        self.current_line = current_line\n\n    def visit_default(self, leaf):\n        pass"",
            ""flags = {Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline}"",
            ""mode = Mode(flags)"",
            ""self = SelfMock(mode, CurrentLine(1))"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = Leaf('\""\""\""Example docstring\""\""\""')"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\""))"",
            ""normalize_string_prefix = lambda s: s.lower() if s.isupper() else s"",
            ""normalize_string_quotes = lambda s: s.replace('\""\""\""', '\""').replace(\""'''\"", \""'\"")"",
            ""get_string_prefix = lambda s: 'u' if s.startswith('u') else ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda s, indent: '\\n'.join(indent + line.strip() for line in s.split('\\n'))""
        ]
    }
]","[
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('MockPreview', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""class MockMode: # pragma: no cover"",
            ""    def __init__(self, string_normalization, line_length): # pragma: no cover"",
            ""        self.string_normalization = string_normalization # pragma: no cover"",
            ""        self.line_length = line_length # pragma: no cover"",
            ""        self._options = [Preview.hex_codes_in_unicode_sequences, # pragma: no cover"",
            ""                        Preview.normalize_docstring_quotes_and_prefixes_properly, # pragma: no cover"",
            ""                        Preview.long_docstring_quotes_on_newline] # pragma: no cover"",
            ""    def __contains__(self, item): # pragma: no cover"",
            ""        return item in self._options # pragma: no cover"",
            ""class MockSelf: # pragma: no cover"",
            ""    def __init__(self, mode, current_line): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.current_line = current_line # pragma: no cover"",
            ""    def visit_default(self, leaf): # pragma: no cover"",
            ""        return None # pragma: no cover"",
            ""class MockCurrentLine: # pragma: no cover"",
            ""    def __init__(self, depth): # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, value): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = MockLeaf('\""\""\""Example docstring\""\""\""') # pragma: no cover"",
            ""is_docstring = lambda leaf: isinstance(leaf, MockLeaf) and (leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""''\"")) # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value.replace('\""\""\""', '\""') # pragma: no cover"",
            ""get_string_prefix = lambda value: '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: docstring.strip() # pragma: no cover"",
            ""self = MockSelf(MockMode(True, 80), MockCurrentLine(1)) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('MockPreview', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""class Mode: # pragma: no cover"",
            ""    def __init__(self, string_normalization, line_length, options): # pragma: no cover"",
            ""        self.string_normalization = string_normalization # pragma: no cover"",
            ""        self.line_length = line_length # pragma: no cover"",
            ""        self.options = options # pragma: no cover"",
            ""class CurrentLine: # pragma: no cover"",
            ""    def __init__(self, depth): # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""class MockSelf: # pragma: no cover"",
            ""    def __init__(self, mode, current_line): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.current_line = current_line # pragma: no cover"",
            ""    def visit_default(self, leaf): # pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""mode = Mode(string_normalization=True, line_length=80, options={ # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""self = MockSelf(mode, CurrentLine(depth=1)) # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring\""\""\""'})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value.strip('\""\""\""') # pragma: no cover"",
            ""get_string_prefix = lambda value: '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line.strip() for line in docstring.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('MockPreview', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""class Mode: # pragma: no cover"",
            ""    def __init__(self, string_normalization, line_length, modes): # pragma: no cover"",
            ""        self.string_normalization = string_normalization # pragma: no cover"",
            ""        self.line_length = line_length # pragma: no cover"",
            ""        self.modes = modes # pragma: no cover"",
            ""    def __contains__(self, item): # pragma: no cover"",
            ""        return item in self.modes # pragma: no cover"",
            ""class CurrentLine: # pragma: no cover"",
            ""    def __init__(self, depth): # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""class MockSelf: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.mode = Mode(string_normalization=True, line_length=80, modes=[ # pragma: no cover"",
            ""            Preview.hex_codes_in_unicode_sequences, # pragma: no cover"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly, # pragma: no cover"",
            ""            Preview.long_docstring_quotes_on_newline # pragma: no cover"",
            ""        ]) # pragma: no cover"",
            ""        self.current_line = CurrentLine(depth=1) # pragma: no cover"",
            ""    def visit_default(self, leaf): # pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""self = MockSelf() # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring\""\""\""'})() # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return isinstance(leaf, type) and hasattr(leaf, 'value') and (leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"") or leaf.value) # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value.strip('\""\""\""') # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring.strip() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('MockPreview', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""class Mode: # pragma: no cover"",
            ""    def __init__(self, string_normalization, line_length): # pragma: no cover"",
            ""        self.string_normalization = string_normalization # pragma: no cover"",
            ""        self.line_length = line_length # pragma: no cover"",
            ""        self.options = [ # pragma: no cover"",
            ""            Preview.hex_codes_in_unicode_sequences, # pragma: no cover"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly, # pragma: no cover"",
            ""            Preview.long_docstring_quotes_on_newline # pragma: no cover"",
            ""        ] # pragma: no cover"",
            ""self = type('MockSelf', (object,), { # pragma: no cover"",
            ""    'mode': Mode(True, 80), # pragma: no cover"",
            ""    'current_line': type('MockCurrentLine', (object,), { # pragma: no cover"",
            ""        'depth': 1 # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'visit_default': lambda self, leaf: None # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and (leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"") ) # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value  # pragma: no cover"",
            ""normalize_string_quotes = lambda value: '\""\""\""' + value.strip('\""\""\""') + '\""\""\""' # pragma: no cover"",
            ""get_string_prefix = lambda value: '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: docstring.strip() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""class Mode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.string_normalization = False # pragma: no cover"",
            ""        self.line_length = 88 # pragma: no cover"",
            ""        self.options = { # pragma: no cover"",
            ""            'hex_codes_in_unicode_sequences': True, # pragma: no cover"",
            ""            'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""            'long_docstring_quotes_on_newline': True # pragma: no cover"",
            ""        } # pragma: no cover"",
            ""    def __contains__(self, item): # pragma: no cover"",
            ""        return item in self.options and self.options[item] # pragma: no cover"",
            ""self = type('SelfMock', (object,), {'mode': Mode(), 'current_line': type('Line', (object,), {'depth': 1})(), 'visit_default': lambda leaf: None})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: bool(re.match(r'^\""\""\"".*\""\""\""$', leaf.value)) # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value.replace(\""'''\"", '\""\""\""').replace(\""'\"", '\""').replace('\\\""', '\""') # pragma: no cover"",
            ""get_string_prefix = lambda docstring: 'u' if docstring.startswith('u') else '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: docstring.replace('\\n', '\\n' + indent) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('MockPreview', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""class Mode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.string_normalization = True # pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            ""        self.active_previews = { # pragma: no cover"",
            ""            Preview.hex_codes_in_unicode_sequences, # pragma: no cover"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly, # pragma: no cover"",
            ""            Preview.long_docstring_quotes_on_newline # pragma: no cover"",
            ""        } # pragma: no cover"",
            ""    def __contains__(self, item): # pragma: no cover"",
            ""        return item in self.active_previews # pragma: no cover"",
            ""class CurrentLine: # pragma: no cover"",
            ""    def __init__(self, depth): # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""self = type('MockSelf', (object,), { # pragma: no cover"",
            ""    'mode': Mode(), # pragma: no cover"",
            ""    'current_line': CurrentLine(depth=1), # pragma: no cover"",
            ""    'visit_default': lambda leaf: None # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: leaf.value.startswith(('\""\""\""', \""'''\"", '\""', \""'\"")) # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value # pragma: no cover"",
            ""get_string_prefix = lambda value: '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""Preview = type('MockPreview', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""class Mode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.options = { # pragma: no cover"",
            ""            'hex_codes_in_unicode_sequences': True, # pragma: no cover"",
            ""            'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""            'long_docstring_quotes_on_newline': True # pragma: no cover"",
            ""        } # pragma: no cover"",
            ""        self.string_normalization = True # pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            ""    def __contains__(self, item): # pragma: no cover"",
            ""        return item in self.options # pragma: no cover"",
            ""class CurrentLine: # pragma: no cover"",
            ""    def __init__(self, depth): # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""class MockSelf: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.mode = Mode() # pragma: no cover"",
            ""        self.current_line = CurrentLine(depth=1) # pragma: no cover"",
            ""    def visit_default(self, leaf): # pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""self = MockSelf() # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring\""\""\""'})() # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"") # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value.strip('\""\""\""') # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80# pragma: no cover"",
            ""        self.options = [# pragma: no cover"",
            ""            'hex_codes_in_unicode_sequences',# pragma: no cover"",
            ""            'normalize_docstring_quotes_and_prefixes_properly',# pragma: no cover"",
            ""            'long_docstring_quotes_on_newline'# pragma: no cover"",
            ""        ]# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, value):# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""# pragma: no cover"",
            ""class CurrentLine:# pragma: no cover"",
            ""    def __init__(self, depth):# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Mock:# pragma: no cover"",
            ""    def __init__(self, mode, current_line):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.current_line = current_line# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def visit_default(self, leaf):# pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""mode = Mode() # pragma: no cover"",
            ""mode.__contains__ = lambda item: item in mode.options # pragma: no cover"",
            ""self = Mock(mode, CurrentLine(depth=1)) # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = Leaf('\""\""\""Example docstring\""\""\""') # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self, flags):# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80# pragma: no cover"",
            ""        self.flags = flags# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def __contains__(self, item):# pragma: no cover"",
            ""        return item in self.flags# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, value):# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""# pragma: no cover"",
            ""class CurrentLine:# pragma: no cover"",
            ""    def __init__(self, depth):# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""# pragma: no cover"",
            ""class SelfMock:# pragma: no cover"",
            ""    def __init__(self, mode, current_line):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.current_line = current_line# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def visit_default(self, leaf):# pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""flags = {Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline} # pragma: no cover"",
            ""mode = Mode(flags) # pragma: no cover"",
            ""self = SelfMock(mode, CurrentLine(1)) # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = Leaf('\""\""\""Example docstring\""\""\""') # pragma: no cover"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\"")) # pragma: no cover"",
            ""normalize_string_prefix = lambda s: s.lower() if s.isupper() else s # pragma: no cover"",
            ""normalize_string_quotes = lambda s: s.replace('\""\""\""', '\""').replace(\""'''\"", \""'\"") # pragma: no cover"",
            ""get_string_prefix = lambda s: 'u' if s.startswith('u') else '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda s, indent: '\\n'.join(indent + line.strip() for line in s.split('\\n')) # pragma: no cover""
        ]
    }
]",2,3950,0.001975,4709,0.0070635,0.0090385
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 33:
    if Preview.hex_codes_in_unicode_sequences in self.mode:
TypeError: argument of type 'types.SimpleNamespace' is not iterable
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'\n\nclass Mode:\n    def __init__(self):\n        self.string_normalization = True\n        self.line_length = 80\n        self.features = {\n            'hex_codes_in_unicode_sequences',\n            'normalize_docstring_quotes_and_prefixes_properly',\n            'long_docstring_quotes_on_newline',\n        }\n\n    def __contains__(self, item):\n        return item in self.features\n\nleaf = SimpleNamespace(value='\""\""\""Example docstring\""\""\""')\n\nself = SimpleNamespace(\n    mode=Mode(),\n    current_line=SimpleNamespace(depth=1),\n    visit_default=lambda x: None\n)\n\nnormalize_unicode_escape_sequences = lambda leaf: None\n\nis_docstring = lambda leaf: leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"")\n\nnormalize_string_prefix = lambda value: value\n\nnormalize_string_quotes = lambda value: value\n\nget_string_prefix = lambda docstring: ''\n\nis_multiline_string = lambda leaf: '\\n' in leaf.value\n\nfix_docstring = lambda docstring, indent: '\\n'.join(indent + line.strip() for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'\n\n    def __init__(self, mode):\n        self.mode = mode\n\nclass Mode:\n    def __init__(self, string_normalization=False, line_length=88):\n        self.string_normalization = string_normalization\n        self.line_length = line_length\n        self.options = set(\n            ['hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline']\n        )\n\n    def __contains__(self, item):\n        return item in self.options\n\nclass Leaf:\n    def __init__(self, value: str):\n        self.value = value\n\nclass CurrentLine:\n    def __init__(self, depth: int):\n        self.depth = depth\n\nclass Mock:\n    def __init__(self, mode, current_line):\n        self.mode = mode\n        self.current_line = current_line\n\n    def visit_default(self, leaf: Leaf):\n        pass"",
            ""preview_mode = Preview(Mode(string_normalization=True, line_length=80))"",
            ""self = Mock(mode=preview_mode.mode, current_line=CurrentLine(depth=1))"",
            ""def normalize_unicode_escape_sequences(leaf):\n    pass"",
            ""leaf = Leaf(value='\""\""\""Example docstring\""\""\""')"",
            ""def is_docstring(leaf) -> bool:\n    return leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"")"",
            ""def normalize_string_prefix(string: str) -> str:\n    return string"",
            ""def normalize_string_quotes(string: str) -> str:\n    return string"",
            ""def get_string_prefix(string: str) -> str:\n    return ''"",
            ""def is_multiline_string(leaf: Leaf) -> bool:\n    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring: str, indent: str) -> str:\n    return '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""Preview = type('Preview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})"",
            ""self = SimpleNamespace("",
            ""    mode=SimpleNamespace("",
            ""        __contains__=lambda self, key: key in self.__dict__,"",
            ""        hex_codes_in_unicode_sequences=True,"",
            ""        normalize_docstring_quotes_and_prefixes_properly=True,"",
            ""        long_docstring_quotes_on_newline=True,"",
            ""        string_normalization=True,"",
            ""        line_length=80"",
            ""    ),"",
            ""    current_line=SimpleNamespace("",
            ""        depth=1"",
            ""    ),"",
            ""    visit_default=lambda x: None"",
            "")"",
            ""normalize_unicode_escape_sequences = lambda x: None"",
            ""leaf = SimpleNamespace("",
            ""    value='''''\""\""\""Sample docstring\""\""\""'''"",
            "")"",
            ""is_docstring = lambda x: True"",
            ""normalize_string_prefix = lambda x: x"",
            ""normalize_string_quotes = lambda x: x"",
            ""get_string_prefix = lambda x: ''"",
            ""is_multiline_string = lambda x: '\\n' in x.value"",
            ""fix_docstring = lambda x, y: x""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""Preview = type('MockPreview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})"",
            ""class MockMode:"",
            ""    def __init__(self):"",
            ""        self.string_normalization = True"",
            ""        self.line_length = 80"",
            ""        self.active_features = ["",
            ""            Preview.hex_codes_in_unicode_sequences,"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly,"",
            ""            Preview.long_docstring_quotes_on_newline"",
            ""        ]"",
            ""    def __contains__(self, item):"",
            ""        return item in self.active_features"",
            """",
            ""self = type('MockSelf', (object,), {"",
            ""    'mode': MockMode(),"",
            ""    'current_line': type('MockCurrentLine', (object,), {"",
            ""        'depth': 1"",
            ""    })(),"",
            ""    'visit_default': lambda leaf: None"",
            ""})()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring\""\""\""'})()"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\""))"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value.replace(\""'\"", '\""')"",
            ""get_string_prefix = lambda value: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line.strip() for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""Preview = type('Preview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})"",
            ""self = SimpleNamespace("",
            ""    mode=SimpleNamespace("",
            ""        enabled_features=['hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline'],"",
            ""        string_normalization=True,"",
            ""        line_length=80"",
            ""    ),"",
            ""    current_line=SimpleNamespace("",
            ""        depth=1"",
            ""    ),"",
            ""    visit_default=lambda leaf: None"",
            "")"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = SimpleNamespace("",
            ""    value='\""\""\""Example docstring\""\""\""'"",
            "")"",
            ""is_docstring = lambda leaf: leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"")"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value.replace('\""', '\""\""\""')"",
            ""get_string_prefix = lambda value: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [
            ""from types import SimpleNamespace"",
            ""from collections import defaultdict""
        ],
        ""initialization"": [
            ""Preview = type('Preview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})"",
            ""self = SimpleNamespace("",
            ""    mode=defaultdict("",
            ""        lambda: False, {"",
            ""            'hex_codes_in_unicode_sequences': True,"",
            ""            'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""            'long_docstring_quotes_on_newline': True,"",
            ""            'string_normalization': True,"",
            ""            'line_length': 80"",
            ""        }"",
            ""    ),"",
            ""    current_line=SimpleNamespace("",
            ""        depth=1"",
            ""    ),"",
            ""    visit_default=lambda x: None"",
            "")"",
            ""normalize_unicode_escape_sequences = lambda x: None"",
            ""leaf = SimpleNamespace("",
            ""    value=''''\""\""\""Sample docstring\""\""\""'''"",
            "")"",
            ""is_docstring = lambda x: True"",
            ""normalize_string_prefix = lambda x: x"",
            ""normalize_string_quotes = lambda x: x"",
            ""get_string_prefix = lambda x: ''"",
            ""is_multiline_string = lambda x: '\\n' in x.value"",
            ""fix_docstring = lambda x, y: x""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""class MockMode:\n    def __init__(self, features):\n        self.features = features\n        self.string_normalization = True\n        self.line_length = 80\n\n    def __contains__(self, feature):\n        return feature in self.features\n"",
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'\n"",
            ""self = type('MockSelf', (object,), {\n    'mode': MockMode({\n        Preview.hex_codes_in_unicode_sequences,\n        Preview.normalize_docstring_quotes_and_prefixes_properly,\n        Preview.long_docstring_quotes_on_newline\n    }),\n    'current_line': type('MockCurrentLine', (object,), {'depth': 1})(),\n    'visit_default': lambda leaf: None\n})()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring\""\""\""'})()"",
            ""is_docstring = lambda leaf: leaf.value.startswith(('\""\""\""', \""'''\""))"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value.replace('\""', '\""')"",
            ""get_string_prefix = lambda value: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""Preview = type('Preview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})"",
            ""self_mode = {"",
            ""    'hex_codes_in_unicode_sequences': True,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': True,"",
            ""    'line_length': 80"",
            ""}"",
            ""self = SimpleNamespace("",
            ""    mode=self_mode,"",
            ""    current_line=SimpleNamespace("",
            ""        depth=1"",
            ""    ),"",
            ""    visit_default=lambda x: None"",
            "")"",
            ""normalize_unicode_escape_sequences = lambda x: None"",
            ""leaf = SimpleNamespace("",
            ""    value='''\""\""\""Sample docstring\""\""\""'''"",
            "")"",
            ""is_docstring = lambda x: True"",
            ""normalize_string_prefix = lambda x: x"",
            ""normalize_string_quotes = lambda x: x"",
            ""get_string_prefix = lambda x: ''"",
            ""is_multiline_string = lambda x: '\\n' in x.value"",
            ""fix_docstring = lambda x, y: x""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""class Mode:\n    def __init__(self, options):\n        self.options = options\n        self.string_normalization = True\n        self.line_length = 80"",
            ""Preview = type('Mock', (object,), {\n    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',\n    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',\n    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'\n})"",
            ""options = set([\n    Preview.hex_codes_in_unicode_sequences,\n    Preview.normalize_docstring_quotes_and_prefixes_properly,\n    Preview.long_docstring_quotes_on_newline\n])"",
            ""self = type('Mock', (object,), {\n    'mode': Mode(options),\n    'current_line': type('Line', (object,), {'depth': 1})(),\n    'visit_default': lambda leaf: True\n})()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})()"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\""))"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value.replace(\""'\"", '\""')"",
            ""get_string_prefix = lambda s: 'u' if s.startswith('u') else ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda s, indent: '\\n'.join(indent + line.strip() for line in s.split('\\n'))""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""Preview = type('Preview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})"",
            ""class Mode:"",
            ""    def __init__(self, options):"",
            ""        self.options = options"",
            ""        self.string_normalization = True"",
            ""        self.line_length = 80"",
            ""    def __contains__(self, item):"",
            ""        return item in self.options"",
            ""self = type('Self', (object,), {"",
            ""    'mode': Mode(options=["",
            ""        'hex_codes_in_unicode_sequences',"",
            ""        'normalize_docstring_quotes_and_prefixes_properly',"",
            ""        'long_docstring_quotes_on_newline'"",
            ""    ]),"",
            ""    'current_line': type('CurrentLine', (object,), {"",
            ""        'depth': 1"",
            ""    })(),"",
            ""    'visit_default': lambda leaf: None"",
            ""})()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring\""\""\""'})()"",
            ""is_docstring = lambda leaf: leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"")"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value"",
            ""get_string_prefix = lambda value: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    }
]","[
    {
        ""imports"": [
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80# pragma: no cover"",
            ""        self.features = {# pragma: no cover"",
            ""            'hex_codes_in_unicode_sequences',# pragma: no cover"",
            ""            'normalize_docstring_quotes_and_prefixes_properly',# pragma: no cover"",
            ""            'long_docstring_quotes_on_newline',# pragma: no cover"",
            ""        }# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def __contains__(self, item):# pragma: no cover"",
            ""        return item in self.features# pragma: no cover"",
            ""# pragma: no cover"",
            ""leaf = SimpleNamespace(value='\""\""\""Example docstring\""\""\""')# pragma: no cover"",
            ""# pragma: no cover"",
            ""self = SimpleNamespace(# pragma: no cover"",
            ""    mode=Mode(),# pragma: no cover"",
            ""    current_line=SimpleNamespace(depth=1),# pragma: no cover"",
            ""    visit_default=lambda x: None# pragma: no cover"",
            "")# pragma: no cover"",
            ""# pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None# pragma: no cover"",
            ""# pragma: no cover"",
            ""is_docstring = lambda leaf: leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"")# pragma: no cover"",
            ""# pragma: no cover"",
            ""normalize_string_prefix = lambda value: value# pragma: no cover"",
            ""# pragma: no cover"",
            ""normalize_string_quotes = lambda value: value# pragma: no cover"",
            ""# pragma: no cover"",
            ""get_string_prefix = lambda docstring: ''# pragma: no cover"",
            ""# pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value# pragma: no cover"",
            ""# pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line.strip() for line in docstring.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def __init__(self, mode):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self, string_normalization=False, line_length=88):# pragma: no cover"",
            ""        self.string_normalization = string_normalization# pragma: no cover"",
            ""        self.line_length = line_length# pragma: no cover"",
            ""        self.options = set(# pragma: no cover"",
            ""            ['hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline']# pragma: no cover"",
            ""        )# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def __contains__(self, item):# pragma: no cover"",
            ""        return item in self.options# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, value: str):# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""# pragma: no cover"",
            ""class CurrentLine:# pragma: no cover"",
            ""    def __init__(self, depth: int):# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Mock:# pragma: no cover"",
            ""    def __init__(self, mode, current_line):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.current_line = current_line# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def visit_default(self, leaf: Leaf):# pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""preview_mode = Preview(Mode(string_normalization=True, line_length=80)) # pragma: no cover"",
            ""self = Mock(mode=preview_mode.mode, current_line=CurrentLine(depth=1)) # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""leaf = Leaf(value='\""\""\""Example docstring\""\""\""') # pragma: no cover"",
            ""def is_docstring(leaf) -> bool:# pragma: no cover"",
            ""    return leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"") # pragma: no cover"",
            ""def normalize_string_prefix(string: str) -> str:# pragma: no cover"",
            ""    return string # pragma: no cover"",
            ""def normalize_string_quotes(string: str) -> str:# pragma: no cover"",
            ""    return string # pragma: no cover"",
            ""def get_string_prefix(string: str) -> str:# pragma: no cover"",
            ""    return '' # pragma: no cover"",
            ""def is_multiline_string(leaf: Leaf) -> bool:# pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            ""def fix_docstring(docstring: str, indent: str) -> str:# pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Preview', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""self = SimpleNamespace( # pragma: no cover"",
            ""    mode=SimpleNamespace( # pragma: no cover"",
            ""        __contains__=lambda self, key: key in self.__dict__, # pragma: no cover"",
            ""        hex_codes_in_unicode_sequences=True, # pragma: no cover"",
            ""        normalize_docstring_quotes_and_prefixes_properly=True, # pragma: no cover"",
            ""        long_docstring_quotes_on_newline=True, # pragma: no cover"",
            ""        string_normalization=True, # pragma: no cover"",
            ""        line_length=80 # pragma: no cover"",
            ""    ), # pragma: no cover"",
            ""    current_line=SimpleNamespace( # pragma: no cover"",
            ""        depth=1 # pragma: no cover"",
            ""    ), # pragma: no cover"",
            ""    visit_default=lambda x: None # pragma: no cover"",
            "") # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda x: None # pragma: no cover"",
            ""leaf = SimpleNamespace( # pragma: no cover"",
            ""    value='''''\""\""\""Sample docstring\""\""\""''' # pragma: no cover"",
            "") # pragma: no cover"",
            ""is_docstring = lambda x: True # pragma: no cover"",
            ""normalize_string_prefix = lambda x: x # pragma: no cover"",
            ""normalize_string_quotes = lambda x: x # pragma: no cover"",
            ""get_string_prefix = lambda x: '' # pragma: no cover"",
            ""is_multiline_string = lambda x: '\\n' in x.value # pragma: no cover"",
            ""fix_docstring = lambda x, y: x # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""Preview = type('MockPreview', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""class MockMode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.string_normalization = True # pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            ""        self.active_features = [ # pragma: no cover"",
            ""            Preview.hex_codes_in_unicode_sequences, # pragma: no cover"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly, # pragma: no cover"",
            ""            Preview.long_docstring_quotes_on_newline # pragma: no cover"",
            ""        ] # pragma: no cover"",
            ""    def __contains__(self, item): # pragma: no cover"",
            ""        return item in self.active_features # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('MockSelf', (object,), { # pragma: no cover"",
            ""    'mode': MockMode(), # pragma: no cover"",
            ""    'current_line': type('MockCurrentLine', (object,), { # pragma: no cover"",
            ""        'depth': 1 # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'visit_default': lambda leaf: None # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\"")) # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value.replace(\""'\"", '\""') # pragma: no cover"",
            ""get_string_prefix = lambda value: '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line.strip() for line in docstring.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Preview', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""self = SimpleNamespace( # pragma: no cover"",
            ""    mode=SimpleNamespace( # pragma: no cover"",
            ""        enabled_features=['hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline'], # pragma: no cover"",
            ""        string_normalization=True, # pragma: no cover"",
            ""        line_length=80 # pragma: no cover"",
            ""    ), # pragma: no cover"",
            ""    current_line=SimpleNamespace( # pragma: no cover"",
            ""        depth=1 # pragma: no cover"",
            ""    ), # pragma: no cover"",
            ""    visit_default=lambda leaf: None # pragma: no cover"",
            "") # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = SimpleNamespace( # pragma: no cover"",
            ""    value='\""\""\""Example docstring\""\""\""' # pragma: no cover"",
            "") # pragma: no cover"",
            ""is_docstring = lambda leaf: leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"") # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value.replace('\""', '\""\""\""') # pragma: no cover"",
            ""get_string_prefix = lambda value: '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from types import SimpleNamespace # pragma: no cover"",
            ""from collections import defaultdict # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Preview', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""self = SimpleNamespace( # pragma: no cover"",
            ""    mode=defaultdict( # pragma: no cover"",
            ""        lambda: False, { # pragma: no cover"",
            ""            'hex_codes_in_unicode_sequences': True, # pragma: no cover"",
            ""            'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""            'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""            'string_normalization': True, # pragma: no cover"",
            ""            'line_length': 80 # pragma: no cover"",
            ""        } # pragma: no cover"",
            ""    ), # pragma: no cover"",
            ""    current_line=SimpleNamespace( # pragma: no cover"",
            ""        depth=1 # pragma: no cover"",
            ""    ), # pragma: no cover"",
            ""    visit_default=lambda x: None # pragma: no cover"",
            "") # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda x: None # pragma: no cover"",
            ""leaf = SimpleNamespace( # pragma: no cover"",
            ""    value=''''\""\""\""Sample docstring\""\""\""''' # pragma: no cover"",
            "") # pragma: no cover"",
            ""is_docstring = lambda x: True # pragma: no cover"",
            ""normalize_string_prefix = lambda x: x # pragma: no cover"",
            ""normalize_string_quotes = lambda x: x # pragma: no cover"",
            ""get_string_prefix = lambda x: '' # pragma: no cover"",
            ""is_multiline_string = lambda x: '\\n' in x.value # pragma: no cover"",
            ""fix_docstring = lambda x, y: x # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""class MockMode:# pragma: no cover"",
            ""    def __init__(self, features):# pragma: no cover"",
            ""        self.features = features# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def __contains__(self, feature):# pragma: no cover"",
            ""        return feature in self.features# pragma: no cover"",
            "" # pragma: no cover"",
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'# pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('MockSelf', (object,), {# pragma: no cover"",
            ""    'mode': MockMode({# pragma: no cover"",
            ""        Preview.hex_codes_in_unicode_sequences,# pragma: no cover"",
            ""        Preview.normalize_docstring_quotes_and_prefixes_properly,# pragma: no cover"",
            ""        Preview.long_docstring_quotes_on_newline# pragma: no cover"",
            ""    }),# pragma: no cover"",
            ""    'current_line': type('MockCurrentLine', (object,), {'depth': 1})(),# pragma: no cover"",
            ""    'visit_default': lambda leaf: None# pragma: no cover"",
            ""})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: leaf.value.startswith(('\""\""\""', \""'''\"")) # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value.replace('\""', '\""') # pragma: no cover"",
            ""get_string_prefix = lambda value: '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Preview', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""self_mode = { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': True, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': True, # pragma: no cover"",
            ""    'line_length': 80 # pragma: no cover"",
            ""} # pragma: no cover"",
            ""self = SimpleNamespace( # pragma: no cover"",
            ""    mode=self_mode, # pragma: no cover"",
            ""    current_line=SimpleNamespace( # pragma: no cover"",
            ""        depth=1 # pragma: no cover"",
            ""    ), # pragma: no cover"",
            ""    visit_default=lambda x: None # pragma: no cover"",
            "") # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda x: None # pragma: no cover"",
            ""leaf = SimpleNamespace( # pragma: no cover"",
            ""    value='''\""\""\""Sample docstring\""\""\""''' # pragma: no cover"",
            "") # pragma: no cover"",
            ""is_docstring = lambda x: True # pragma: no cover"",
            ""normalize_string_prefix = lambda x: x # pragma: no cover"",
            ""normalize_string_quotes = lambda x: x # pragma: no cover"",
            ""get_string_prefix = lambda x: '' # pragma: no cover"",
            ""is_multiline_string = lambda x: '\\n' in x.value # pragma: no cover"",
            ""fix_docstring = lambda x, y: x # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self, options):# pragma: no cover"",
            ""        self.options = options# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            ""Preview = type('Mock', (object,), {# pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',# pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',# pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'# pragma: no cover"",
            ""}) # pragma: no cover"",
            ""options = set([# pragma: no cover"",
            ""    Preview.hex_codes_in_unicode_sequences,# pragma: no cover"",
            ""    Preview.normalize_docstring_quotes_and_prefixes_properly,# pragma: no cover"",
            ""    Preview.long_docstring_quotes_on_newline# pragma: no cover"",
            ""]) # pragma: no cover"",
            ""self = type('Mock', (object,), {# pragma: no cover"",
            ""    'mode': Mode(options),# pragma: no cover"",
            ""    'current_line': type('Line', (object,), {'depth': 1})(),# pragma: no cover"",
            ""    'visit_default': lambda leaf: True# pragma: no cover"",
            ""})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\"")) # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value.replace(\""'\"", '\""') # pragma: no cover"",
            ""get_string_prefix = lambda s: 'u' if s.startswith('u') else '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda s, indent: '\\n'.join(indent + line.strip() for line in s.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""Preview = type('Preview', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""class Mode: # pragma: no cover"",
            ""    def __init__(self, options): # pragma: no cover"",
            ""        self.options = options # pragma: no cover"",
            ""        self.string_normalization = True # pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            ""    def __contains__(self, item): # pragma: no cover"",
            ""        return item in self.options # pragma: no cover"",
            ""self = type('Self', (object,), { # pragma: no cover"",
            ""    'mode': Mode(options=[ # pragma: no cover"",
            ""        'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""        'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""        'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""    ]), # pragma: no cover"",
            ""    'current_line': type('CurrentLine', (object,), { # pragma: no cover"",
            ""        'depth': 1 # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'visit_default': lambda leaf: None # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"") # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value # pragma: no cover"",
            ""get_string_prefix = lambda value: '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover""
        ]
    }
]",2,4592,0.002296,4036,0.006054,0.00835
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 4:
    if Preview.hex_codes_in_unicode_sequences in self.mode:
NameError: name 'Preview' is not defined
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'"",
            ""class Mode:\n    def __init__(self):\n        self.string_normalization = True\n        self.line_length = 80\n        self.settings = [Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline]\n    def __contains__(self, item):\n        return item in self.settings"",
            ""class CurrentLine:\n    def __init__(self):\n        self.depth = 1"",
            ""class Leaf:\n    def __init__(self, value):\n        self.value = value"",
            ""def normalize_unicode_escape_sequences(leaf):\n    pass"",
            ""leaf = Leaf('\""\""\""This is a sample docstring.\""\""\""')"",
            ""def is_docstring(leaf):\n    return leaf.value.startswith(('\""\""\""', \""'''\"")"",
            ""def normalize_string_prefix(value):\n    return value"",
            ""def normalize_string_quotes(value):\n    return value"",
            ""def get_string_prefix(value):\n    return ''"",
            ""def is_multiline_string(leaf):\n    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring, indent):\n    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            ""class Self:\n    def __init__(self):\n        self.mode = Mode()\n        self.current_line = CurrentLine()\n    def visit_default(self, leaf):\n        pass"",
            ""self = Self()""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""Preview = type('Preview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})"",
            ""Mode = type('Mode', (object,), {"",
            ""    '__contains__': lambda self, key: hasattr(self, key) and getattr(self, key) is not None,"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline',"",
            ""    'string_normalization': True,"",
            ""    'line_length': 80"",
            ""})"",
            ""CurrentLine = type('CurrentLine', (object,), { 'depth': 1 })"",
            ""Leaf = type('Leaf', (object,), { 'value': '\""\""\""This is a sample docstring\""\""\""' })"",
            ""Self = type('Self', (object,), {"",
            ""    'mode': Mode(),"",
            ""    'current_line': CurrentLine(),"",
            ""    'visit_default': lambda self, leaf: None"",
            ""})"",
            ""self = Self()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""is_docstring = lambda leaf: leaf.value.startswith(('\""\""\""', \""'''\"")"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value"",
            ""get_string_prefix = lambda value: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            ""leaf = Leaf()""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""Preview = type('Preview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})"",
            ""class Mode:"",
            ""    def __init__(self):"",
            ""        self.string_normalization = True"",
            ""        self.line_length = 80"",
            ""        self.flags = {"",
            ""            Preview.hex_codes_in_unicode_sequences,"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly,"",
            ""            Preview.long_docstring_quotes_on_newline"",
            ""        }"",
            ""class Leaf:"",
            ""    def __init__(self, value):"",
            ""        self.value = value"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = Leaf('\""\""\""Example docstring\""\""\""')"",
            ""is_docstring = lambda leaf: leaf.value.startswith(('\""\""\""', \""'''\"")"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value"",
            ""get_string_prefix = lambda value: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            ""class CurrentLine:"",
            ""    def __init__(self, depth):"",
            ""        self.depth = depth"",
            ""class Self:"",
            ""    def __init__(self):"",
            ""        self.mode = Mode()"",
            ""        self.current_line = CurrentLine(1)"",
            ""    def visit_default(self, leaf):"",
            ""        pass"",
            ""self = Self()""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'"",
            ""class Mode:\n    def __init__(self):\n        self.active_features = {\n            Preview.hex_codes_in_unicode_sequences,\n            Preview.normalize_docstring_quotes_and_prefixes_properly,\n            Preview.long_docstring_quotes_on_newline\n        }\n        self.string_normalization = True\n        self.line_length = 80\n\n    def __contains__(self, item):\n        return item in self.active_features"",
            ""class Leaf:\n    def __init__(self, value):\n        self.value = value"",
            ""def normalize_unicode_escape_sequences(leaf):\n    pass"",
            ""leaf = Leaf('''\""\""\""This is a docstring\""\""\""''')"",
            ""def is_docstring(leaf):\n    return leaf.value.startswith(('\""\""\""', \""'''\"")"",
            ""def normalize_string_prefix(value):\n    return value"",
            ""def normalize_string_quotes(value):\n    return value"",
            ""def get_string_prefix(value):\n    match = re.match(r'(?:[bBfFrRuU]{0,2})(\""\""\""|\\'\\'\\')', value)\n    return match.group(0) if match else ''"",
            ""def is_multiline_string(leaf):\n    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring, indent):\n    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            ""class CurrentLine:\n    depth = 1"",
            ""class Self:\n    def __init__(self):\n        self.mode = Mode()\n        self.current_line = CurrentLine()\n    def visit_default(self, leaf):\n        pass"",
            ""self = Self()""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""Preview = type('Preview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})"",
            ""class Mode:"",
            ""    def __init__(self):"",
            ""        self.string_normalization = True"",
            ""        self.line_length = 80"",
            ""        self.options = {"",
            ""            Preview.hex_codes_in_unicode_sequences,"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly,"",
            ""            Preview.long_docstring_quotes_on_newline,"",
            ""        }"",
            ""class Leaf:"",
            ""    def __init__(self, value):"",
            ""        self.value = value"",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            ""leaf = Leaf('''\""\""\""This is a docstring\""\""\""''')"",
            ""def is_docstring(leaf):"",
            ""    return leaf.value.startswith(('\""\""\""', \""'''\"")"",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            ""def get_string_prefix(value):"",
            ""    match = re.match(r'([furbFURB]?)(\""\""\""|''')"",
            ""    return match.group(1) if match else ''"",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            ""class CurrentLine:"",
            ""    def __init__(self):"",
            ""        self.depth = 1"",
            ""class Self:"",
            ""    def __init__(self):"",
            ""        self.mode = Mode()"",
            ""        self.current_line = CurrentLine()"",
            ""    def visit_default(self, leaf):"",
            ""        pass"",
            ""self = Self()""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'"",
            ""class Mode:\n    def __init__(self):\n        self.string_normalization = True\n        self.line_length = 80\n        self.settings = {Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline}"",
            ""class Leaf:\n    def __init__(self, value):\n        self.value = value"",
            ""def normalize_unicode_escape_sequences(leaf):\n    pass"",
            ""leaf = Leaf('\""\""\""This is a docstring\""\""\""')"",
            ""def is_docstring(leaf):\n    return leaf.value.startswith(('\""\""\""', \""'''\"")"",
            ""def normalize_string_prefix(value):\n    return value"",
            ""def normalize_string_quotes(value):\n    return value"",
            ""def get_string_prefix(value):\n    match = re.match(r'^[furbFURB]*', value)\n    return match.group(0) if match else ''"",
            ""def is_multiline_string(leaf):\n    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring, indent):\n    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            ""class CurrentLine:\n    def __init__(self):\n        self.depth = 1"",
            ""class Self:\n    def __init__(self):\n        self.mode = Mode()\n        self.current_line = CurrentLine()\n    def visit_default(self, leaf):\n        pass"",
            ""self = Self()""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'"",
            ""class Mode:\n    def __init__(self):\n        self.options = {"",
            ""            'hex_codes_in_unicode_sequences': True,"",
            ""            'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""            'long_docstring_quotes_on_newline': True,"",
            ""            'string_normalization': True,"",
            ""            'line_length': 80"",
            ""        }"",
            ""    def __contains__(self, item):\n        return self.options.get(item, False)"",
            ""class Leaf:\n    def __init__(self, value):\n        self.value = value"",
            ""class CurrentLine:\n    depth = 1"",
            ""class Self:\n    def __init__(self):\n        self.mode = Mode()\n        self.current_line = CurrentLine()\n    def visit_default(self, leaf):\n        pass"",
            ""self = Self()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = Leaf('''\""\""\""This is a docstring\""\""\""''')"",
            ""def is_docstring(leaf):\n    return leaf.value.startswith(('\""\""\""', '''\\'\\'\\'\""'''))"",
            ""def normalize_string_prefix(value):\n    return value"",
            ""def normalize_string_quotes(value):\n    return value"",
            ""def get_string_prefix(value):\n    match = re.match(r'(?:[bBfFrRuU]{0,2})(\""\""\""|\\'\\'\\')', value)\n    return match.group(0) if match else ''"",
            ""def is_multiline_string(leaf):\n    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring, indent):\n    return '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""class PreviewOptions:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'\n\nclass Mode:\n    def __init__(self):\n        self.options = [\n            PreviewOptions.hex_codes_in_unicode_sequences,\n            PreviewOptions.normalize_docstring_quotes_and_prefixes_properly,\n            PreviewOptions.long_docstring_quotes_on_newline\n        ]\n        self.string_normalization = True\n        self.line_length = 80\n\nclass Leaf:\n    def __init__(self, value):\n        self.value = value"",
            ""def normalize_unicode_escape_sequences(leaf):\n    pass"",
            ""leaf = Leaf('\""\""\""This is a docstring\""\""\""')"",
            ""def is_docstring(leaf):\n    return leaf.value.startswith(('\""\""\""', \""'''\"")"",
            ""def normalize_string_prefix(value):\n    return value"",
            ""def normalize_string_quotes(value):\n    return value"",
            ""def get_string_prefix(value):\n    match = re.match(r'(?:[bBfFrRuU]{0,2})(\""\""\""|\\'\\'\\')', value)\n    return match.group(0) if match else ''"",
            ""def is_multiline_string(leaf):\n    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring, indent):\n    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            ""class CurrentLine:\n    def __init__(self, depth):\n        self.depth = depth"",
            ""class Self:\n    def __init__(self):\n        self.mode = Mode()\n        self.current_line = CurrentLine(1)\n    \n    def visit_default(self, leaf):\n        pass"",
            ""self = Self()""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 1\n    normalize_docstring_quotes_and_prefixes_properly = 2\n    long_docstring_quotes_on_newline = 3"",
            ""class Mode:\n    def __init__(self):\n        self.string_normalization = True\n        self.line_length = 80\n        self.settings = [Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline]\n    def __contains__(self, item):\n        return item in self.settings"",
            ""class Leaf:\n    def __init__(self, value):\n        self.value = value"",
            ""def normalize_unicode_escape_sequences(leaf):\n    pass"",
            ""leaf = Leaf('\""\""\""This is a docstring\""\""\""')"",
            ""def is_docstring(leaf):\n    return isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\""))"",
            ""def normalize_string_prefix(value):\n    return value"",
            ""def normalize_string_quotes(value):\n    return value"",
            ""def get_string_prefix(value):\n    match = re.match(r'^[urUR]*', value)\n    return match.group(0) if match else ''"",
            ""def is_multiline_string(leaf):\n    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring, indent):\n    return '\\n'.join(indent + line if line else '' for line in docstring.split('\\n'))"",
            ""class CurrentLine:\n    depth = 1"",
            ""class Self:\n    def __init__(self):\n        self.mode = Mode()\n        self.current_line = CurrentLine()\n    def visit_default(self, leaf):\n        pass"",
            ""self = Self()""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""Preview = type('Preview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})()"",
            ""class Mode:"",
            ""    def __init__(self):"",
            ""        self.string_normalization = True"",
            ""        self.line_length = 80"",
            ""        self.options = {"",
            ""            'hex_codes_in_unicode_sequences',"",
            ""            'normalize_docstring_quotes_and_prefixes_properly',"",
            ""            'long_docstring_quotes_on_newline'"",
            ""        }"",
            ""class Leaf:"",
            ""    def __init__(self, value):"",
            ""        self.value = value"",
            ""class CurrentLine:"",
            ""    def __init__(self, depth):"",
            ""        self.depth = depth"",
            ""class Self:"",
            ""    def __init__(self):"",
            ""        self.mode = Mode()"",
            ""        self.current_line = CurrentLine(depth=1)"",
            ""    def visit_default(self, leaf):"",
            ""        pass"",
            ""self = Self()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = Leaf('''\""\""\""This is a docstring\""\""\""''')"",
            ""is_docstring = lambda leaf: leaf.value.startswith(('\""\""\""', '\\'\\'\\''))"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value"",
            ""get_string_prefix = lambda value: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    }
]","[
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80# pragma: no cover"",
            ""        self.settings = [Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline]# pragma: no cover"",
            ""    def __contains__(self, item):# pragma: no cover"",
            ""        return item in self.settings # pragma: no cover"",
            ""class CurrentLine:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.depth = 1 # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, value):# pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""leaf = Leaf('\""\""\""This is a sample docstring.\""\""\""') # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Preview', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Mode = type('Mode', (object,), { # pragma: no cover"",
            ""    '__contains__': lambda self, key: hasattr(self, key) and getattr(self, key) is not None, # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline', # pragma: no cover"",
            ""    'string_normalization': True, # pragma: no cover"",
            ""    'line_length': 80 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""CurrentLine = type('CurrentLine', (object,), { 'depth': 1 }) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), { 'value': '\""\""\""This is a sample docstring\""\""\""' }) # pragma: no cover"",
            ""Self = type('Self', (object,), { # pragma: no cover"",
            ""    'mode': Mode(), # pragma: no cover"",
            ""    'current_line': CurrentLine(), # pragma: no cover"",
            ""    'visit_default': lambda self, leaf: None # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""self = Self() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Preview', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""class Mode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.string_normalization = True # pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            ""        self.flags = { # pragma: no cover"",
            ""            Preview.hex_codes_in_unicode_sequences, # pragma: no cover"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly, # pragma: no cover"",
            ""            Preview.long_docstring_quotes_on_newline # pragma: no cover"",
            ""        } # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, value): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = Leaf('\""\""\""Example docstring\""\""\""') # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.active_features = {# pragma: no cover"",
            ""            Preview.hex_codes_in_unicode_sequences,# pragma: no cover"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly,# pragma: no cover"",
            ""            Preview.long_docstring_quotes_on_newline# pragma: no cover"",
            ""        }# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def __contains__(self, item):# pragma: no cover"",
            ""        return item in self.active_features # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, value):# pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""leaf = Leaf('''\""\""\""This is a docstring\""\""\""''') # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Preview', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""class Mode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.string_normalization = True # pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            ""        self.options = { # pragma: no cover"",
            ""            Preview.hex_codes_in_unicode_sequences, # pragma: no cover"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly, # pragma: no cover"",
            ""            Preview.long_docstring_quotes_on_newline, # pragma: no cover"",
            ""        } # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, value): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""leaf = Leaf('''\""\""\""This is a docstring\""\""\""''') # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80# pragma: no cover"",
            ""        self.settings = {Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline} # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, value):# pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""leaf = Leaf('\""\""\""This is a docstring\""\""\""') # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.options = { # pragma: no cover"",
            ""            'hex_codes_in_unicode_sequences': True, # pragma: no cover"",
            ""            'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""            'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""            'string_normalization': True, # pragma: no cover"",
            ""            'line_length': 80 # pragma: no cover"",
            ""        } # pragma: no cover"",
            ""    def __contains__(self, item):# pragma: no cover"",
            ""        return self.options.get(item, False) # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, value):# pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""class CurrentLine:# pragma: no cover"",
            ""    depth = 1 # pragma: no cover"",
            ""class Self:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.mode = Mode()# pragma: no cover"",
            ""        self.current_line = CurrentLine()# pragma: no cover"",
            ""    def visit_default(self, leaf):# pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""self = Self() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = Leaf('''\""\""\""This is a docstring\""\""\""''') # pragma: no cover"",
            ""def is_docstring(leaf):# pragma: no cover"",
            ""    return leaf.value.startswith(('\""\""\""', '''\\'\\'\\'\""''')) # pragma: no cover"",
            ""def normalize_string_prefix(value):# pragma: no cover"",
            ""    return value # pragma: no cover"",
            ""def normalize_string_quotes(value):# pragma: no cover"",
            ""    return value # pragma: no cover"",
            ""def get_string_prefix(value):# pragma: no cover"",
            ""    match = re.match(r'(?:[bBfFrRuU]{0,2})(\""\""\""|\\'\\'\\')', value)# pragma: no cover"",
            ""    return match.group(0) if match else '' # pragma: no cover"",
            ""def is_multiline_string(leaf):# pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            ""def fix_docstring(docstring, indent):# pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""class PreviewOptions:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.options = [# pragma: no cover"",
            ""            PreviewOptions.hex_codes_in_unicode_sequences,# pragma: no cover"",
            ""            PreviewOptions.normalize_docstring_quotes_and_prefixes_properly,# pragma: no cover"",
            ""            PreviewOptions.long_docstring_quotes_on_newline# pragma: no cover"",
            ""        ]# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, value):# pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""leaf = Leaf('\""\""\""This is a docstring\""\""\""') # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80# pragma: no cover"",
            ""        self.settings = [Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline]# pragma: no cover"",
            ""    def __contains__(self, item):# pragma: no cover"",
            ""        return item in self.settings # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, value):# pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""leaf = Leaf('\""\""\""This is a docstring\""\""\""') # pragma: no cover"",
            ""def is_docstring(leaf):# pragma: no cover"",
            ""    return isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\"")) # pragma: no cover"",
            ""def normalize_string_prefix(value):# pragma: no cover"",
            ""    return value # pragma: no cover"",
            ""def normalize_string_quotes(value):# pragma: no cover"",
            ""    return value # pragma: no cover"",
            ""def get_string_prefix(value):# pragma: no cover"",
            ""    match = re.match(r'^[urUR]*', value)# pragma: no cover"",
            ""    return match.group(0) if match else '' # pragma: no cover"",
            ""def is_multiline_string(leaf):# pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            ""def fix_docstring(docstring, indent):# pragma: no cover"",
            ""    return '\\n'.join(indent + line if line else '' for line in docstring.split('\\n')) # pragma: no cover"",
            ""class CurrentLine:# pragma: no cover"",
            ""    depth = 1 # pragma: no cover"",
            ""class Self:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.mode = Mode()# pragma: no cover"",
            ""        self.current_line = CurrentLine()# pragma: no cover"",
            ""    def visit_default(self, leaf):# pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""self = Self() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Preview', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""class Mode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.string_normalization = True # pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            ""        self.options = { # pragma: no cover"",
            ""            'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""            'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""            'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""        } # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, value): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""class CurrentLine: # pragma: no cover"",
            ""    def __init__(self, depth): # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""class Self: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.mode = Mode() # pragma: no cover"",
            ""        self.current_line = CurrentLine(depth=1) # pragma: no cover"",
            ""    def visit_default(self, leaf): # pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""self = Self() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = Leaf('''\""\""\""This is a docstring\""\""\""''') # pragma: no cover"",
            ""is_docstring = lambda leaf: leaf.value.startswith(('\""\""\""', '\\'\\'\\'')) # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value # pragma: no cover"",
            ""get_string_prefix = lambda value: '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover""
        ]
    }
]",2,5279,0.0026395,4589,0.0068835,0.009523
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 17:
    if Preview.hex_codes_in_unicode_sequences in self.mode:
TypeError: argument of type 'MockMode' is not iterable
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import types""
        ],
        ""initialization"": [
            ""Preview = type('Preview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})()"",
            ""class Mode:"",
            ""    def __init__(self, enabled_features):"",
            ""        self.enabled_features = enabled_features"",
            ""        self.string_normalization = True"",
            ""        self.line_length = 80"",
            ""    def __contains__(self, item):"",
            ""        return item in self.enabled_features"",
            ""self = types.SimpleNamespace("",
            ""    mode=Mode({"",
            ""        'hex_codes_in_unicode_sequences',"",
            ""        'normalize_docstring_quotes_and_prefixes_properly',"",
            ""        'long_docstring_quotes_on_newline'"",
            ""    }),"",
            ""    current_line=types.SimpleNamespace(depth=1),"",
            ""    visit_default=lambda leaf: None"",
            "")"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = types.SimpleNamespace(value='\""\""\""Example docstring\""\""\""')"",
            ""is_docstring = lambda leaf: leaf.value.startswith(('\""\""\""', \""'''\""))"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value"",
            ""get_string_prefix = lambda value: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {\n    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',\n    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',\n    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'\n})"",
            ""class MockMode:\n    def __init__(self):\n        self.string_normalization = True\n        self.line_length = 80\n        self.features = [\n            'hex_codes_in_unicode_sequences',\n            'normalize_docstring_quotes_and_prefixes_properly',\n            'long_docstring_quotes_on_newline'\n        ]\n\n    def __contains__(self, item):\n        return item in self.features"",
            ""class MockCurrentLine:\n    def __init__(self):\n        self.depth = 1"",
            ""self = type('MockSelf', (object,), {\n    'mode': MockMode(),\n    'current_line': MockCurrentLine(),\n    'visit_default': lambda leaf: None\n})()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})()"",
            ""is_docstring = lambda leaf: True"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value"",
            ""get_string_prefix = lambda value: '\""\""\""'"",
            ""is_multiline_string = lambda leaf: False"",
            ""fix_docstring = lambda docstring, indent: docstring""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""Preview = type('MockPreview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})"",
            ""class Mode:"",
            ""    def __init__(self):"",
            ""        self.string_normalization = True"",
            ""        self.line_length = 80"",
            ""        self.active_modes = {"",
            ""            Preview.hex_codes_in_unicode_sequences,"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly,"",
            ""            Preview.long_docstring_quotes_on_newline"",
            ""        }"",
            ""    def __contains__(self, item):"",
            ""        return item in self.active_modes"",
            ""self = type('MockSelf', (object,), {"",
            ""    'mode': Mode(),"",
            ""    'current_line': type('CurrentLine', (object,), { 'depth': 1 })(),"",
            ""    'visit_default': lambda x: None"",
            ""})()"",
            ""normalize_unicode_escape_sequences = lambda x: None"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring\""\""\""'})()"",
            ""is_docstring = lambda x: isinstance(x.value, str) and x.value.startswith(('\""\""\""', \""'''\""))"",
            ""normalize_string_prefix = lambda x: x"",
            ""normalize_string_quotes = lambda x: x"",
            ""get_string_prefix = lambda x: ''"",
            ""is_multiline_string = lambda x: '\\n' in x.value"",
            ""fix_docstring = lambda x, y: x.strip()""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'"",
            ""class Mode:\n    def __init__(self):\n        self.string_normalization = True\n        self.line_length = 80\n        self.active_modes = [\n            Preview.hex_codes_in_unicode_sequences,\n            Preview.normalize_docstring_quotes_and_prefixes_properly,\n            Preview.long_docstring_quotes_on_newline\n        ]\n    def __contains__(self, item):\n        return item in self.active_modes"",
            ""class Leaf:\n    def __init__(self, value):\n        self.value = value"",
            ""def normalize_unicode_escape_sequences(leaf):\n    pass"",
            ""leaf = Leaf('''\""\""\""This is a docstring\""\""\""''')"",
            ""def is_docstring(leaf):\n    return leaf.value.startswith(('\""\""\""', '\\'\\'\\'\""'''))"",
            ""def normalize_string_prefix(value):\n    return value"",
            ""def normalize_string_quotes(value):\n    return value"",
            ""def get_string_prefix(value):\n    match = re.match(r'(?:[bBfFrRuU]{0,2})(\""\""\""|\\\\'\\\\'\\\\')', value)\n    return match.group(0) if match else ''"",
            ""def is_multiline_string(leaf):\n    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring, indent):\n    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            ""class CurrentLine:\n    depth = 1"",
            ""class Self:\n    def __init__(self):\n        self.mode = Mode()\n        self.current_line = CurrentLine()\n    def visit_default(self, leaf):\n        pass"",
            ""self = Self()""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})"",
            ""class Mode:"",
            ""    def __init__(self):"",
            ""        self.string_normalization = True"",
            ""        self.line_length = 80"",
            ""        self.active_modes = ["",
            ""            Preview.hex_codes_in_unicode_sequences,"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly,"",
            ""            Preview.long_docstring_quotes_on_newline"",
            ""        ]"",
            ""    def __contains__(self, item):"",
            ""        return item in self.active_modes"",
            ""self = type('Mock', (object,), {"",
            ""    'mode': Mode(),"",
            ""    'current_line': type('MockLine', (object,), {'depth': 1})(),"",
            ""    'visit_default': lambda leaf: None"",
            ""})()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})()"",
            ""is_docstring = lambda leaf: leaf.value.startswith(('\""\""\""', \""'''\""))"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value"",
            ""get_string_prefix = lambda value: '\""\""\""'"",
            ""is_multiline_string = lambda leaf: False"",
            ""fix_docstring = lambda docstring, indent: docstring""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'"",
            ""class Mode:\n    def __init__(self):\n        self.string_normalization = True\n        self.line_length = 80\n        self.active_modes = [\n            Preview.hex_codes_in_unicode_sequences,\n            Preview.normalize_docstring_quotes_and_prefixes_properly,\n            Preview.long_docstring_quotes_on_newline\n        ]\n\n    def __contains__(self, item):\n        return item in self.active_modes"",
            ""class CurrentLine:\n    def __init__(self, depth):\n        self.depth = depth"",
            ""class Self:\n    def __init__(self, mode, current_line):\n        self.mode = mode\n        self.current_line = current_line\n\n    def visit_default(self, leaf):\n        pass"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})()"",
            ""is_docstring = lambda leaf: leaf.value.startswith(('\""\""\""', \""'''\"", '\""', \""'\""))"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value"",
            ""get_string_prefix = lambda value: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            ""self = Self(mode=Mode(), current_line=CurrentLine(depth=1))""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'})"",
            ""class Mode:\n    def __init__(self):\n        self.string_normalization = True\n        self.line_length = 80\n        self._modes = [Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline]\n\n    def __contains__(self, mode):\n        return mode in self._modes"",
            ""class Leaf:\n    def __init__(self, value):\n        self.value = value"",
            ""class CurrentLine:\n    def __init__(self, depth):\n        self.depth = depth"",
            ""class Self:\n    def __init__(self):\n        self.mode = Mode()\n        self.current_line = CurrentLine(1)\n\n    def visit_default(self, leaf):\n        pass"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = Leaf('\""\""\""Example docstring.\""\""\""')"",
            ""is_docstring = lambda leaf: True"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value"",
            ""get_string_prefix = lambda value: '\""\""\""' if value.startswith('\""\""\""') else ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            ""self = Self()""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""Preview = type('MockPreview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})"",
            ""class Mode:"",
            ""    def __init__(self, features):"",
            ""        self.features = features"",
            ""        self.string_normalization = True"",
            ""        self.line_length = 80"",
            ""    def __contains__(self, item):"",
            ""        return item in self.features"",
            ""class CurrentLine:"",
            ""    def __init__(self, depth):"",
            ""        self.depth = depth"",
            ""class Self:"",
            ""    def __init__(self):"",
            ""        self.mode = Mode(["",
            ""            Preview.hex_codes_in_unicode_sequences,"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly,"",
            ""            Preview.long_docstring_quotes_on_newline"",
            ""        ])"",
            ""        self.current_line = CurrentLine(1)"",
            ""    def visit_default(self, leaf):"",
            ""        pass"",
            ""self = Self()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})()"",
            ""is_docstring = lambda leaf: True"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value"",
            ""get_string_prefix = lambda value: '\""\""\""'"",
            ""is_multiline_string = lambda leaf: False"",
            ""fix_docstring = lambda docstring, indent: docstring""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""Preview = type('Preview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})"",
            ""class Mode:"",
            ""    def __init__(self):"",
            ""        self.options = ["",
            ""            'hex_codes_in_unicode_sequences',"",
            ""            'normalize_docstring_quotes_and_prefixes_properly',"",
            ""            'long_docstring_quotes_on_newline'"",
            ""        ]"",
            ""        self.string_normalization = True"",
            ""        self.line_length = 80"",
            ""    def __contains__(self, item):"",
            ""        return item in self.options"",
            ""class Leaf:"",
            ""    def __init__(self, value):"",
            ""        self.value = value"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and (leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\""))"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value.replace('\""\""\""', '\""').replace(\""'''\"", \""'\"")"",
            ""get_string_prefix = lambda value: '\""\""\""' if value.startswith('\""\""\""') else \""'''\"""",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            ""class CurrentLine:"",
            ""    def __init__(self):"",
            ""        self.depth = 1"",
            ""class Self:"",
            ""    def __init__(self):"",
            ""        self.mode = Mode()"",
            ""        self.current_line = CurrentLine()"",
            ""    def visit_default(self, leaf):"",
            ""        pass"",
            ""self = Self()"",
            ""leaf = Leaf('''\""\""\""Example docstring.\""\""\""''')""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'"",
            ""class Mode:\n    def __init__(self):\n        self.string_normalization = True\n        self.line_length = 80\n        self.options = [Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline]\n    def __contains__(self, item):\n        return item in self.options"",
            ""class Leaf:\n    def __init__(self, value):\n        self.value = value"",
            ""def normalize_unicode_escape_sequences(leaf):\n    pass"",
            ""leaf = Leaf('''\""\""\""This is a docstring\""\""\""''')"",
            ""def is_docstring(leaf):\n    return leaf.value.startswith(('\""\""\""', '\\'\\'\\'\""'''))"",
            ""def normalize_string_prefix(value):\n    return value"",
            ""def normalize_string_quotes(value):\n    return value"",
            ""def get_string_prefix(value):\n    match = re.match(r'(?:[bBfFrRuU]{0,2})(\""\""\""|\\\\'\\\\'\\\\')', value)\n    return match.group(0) if match else ''"",
            ""def is_multiline_string(leaf):\n    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring, indent):\n    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            ""class CurrentLine:\n    def __init__(self):\n        self.depth = 1"",
            ""class Self:\n    def __init__(self):\n        self.mode = Mode()\n        self.current_line = CurrentLine()\n    def visit_default(self, leaf):\n        pass"",
            ""self = Self()""
        ]
    }
]","[
    {
        ""imports"": [
            ""import types # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Preview', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""class Mode: # pragma: no cover"",
            ""    def __init__(self, enabled_features): # pragma: no cover"",
            ""        self.enabled_features = enabled_features # pragma: no cover"",
            ""        self.string_normalization = True # pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            ""    def __contains__(self, item): # pragma: no cover"",
            ""        return item in self.enabled_features # pragma: no cover"",
            ""self = types.SimpleNamespace( # pragma: no cover"",
            ""    mode=Mode({ # pragma: no cover"",
            ""        'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""        'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""        'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""    }), # pragma: no cover"",
            ""    current_line=types.SimpleNamespace(depth=1), # pragma: no cover"",
            ""    visit_default=lambda leaf: None # pragma: no cover"",
            "") # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = types.SimpleNamespace(value='\""\""\""Example docstring\""\""\""') # pragma: no cover"",
            ""is_docstring = lambda leaf: leaf.value.startswith(('\""\""\""', \""'''\"")) # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value # pragma: no cover"",
            ""get_string_prefix = lambda value: '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {# pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',# pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',# pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'# pragma: no cover"",
            ""}) # pragma: no cover"",
            ""class MockMode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80# pragma: no cover"",
            ""        self.features = [# pragma: no cover"",
            ""            'hex_codes_in_unicode_sequences',# pragma: no cover"",
            ""            'normalize_docstring_quotes_and_prefixes_properly',# pragma: no cover"",
            ""            'long_docstring_quotes_on_newline'# pragma: no cover"",
            ""        ]# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def __contains__(self, item):# pragma: no cover"",
            ""        return item in self.features # pragma: no cover"",
            ""class MockCurrentLine:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.depth = 1 # pragma: no cover"",
            ""self = type('MockSelf', (object,), {# pragma: no cover"",
            ""    'mode': MockMode(),# pragma: no cover"",
            ""    'current_line': MockCurrentLine(),# pragma: no cover"",
            ""    'visit_default': lambda leaf: None# pragma: no cover"",
            ""})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: True # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value # pragma: no cover"",
            ""get_string_prefix = lambda value: '\""\""\""' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: False # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: docstring # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""Preview = type('MockPreview', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""class Mode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.string_normalization = True # pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            ""        self.active_modes = { # pragma: no cover"",
            ""            Preview.hex_codes_in_unicode_sequences, # pragma: no cover"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly, # pragma: no cover"",
            ""            Preview.long_docstring_quotes_on_newline # pragma: no cover"",
            ""        } # pragma: no cover"",
            ""    def __contains__(self, item): # pragma: no cover"",
            ""        return item in self.active_modes # pragma: no cover"",
            ""self = type('MockSelf', (object,), { # pragma: no cover"",
            ""    'mode': Mode(), # pragma: no cover"",
            ""    'current_line': type('CurrentLine', (object,), { 'depth': 1 })(), # pragma: no cover"",
            ""    'visit_default': lambda x: None # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda x: None # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda x: isinstance(x.value, str) and x.value.startswith(('\""\""\""', \""'''\"")) # pragma: no cover"",
            ""normalize_string_prefix = lambda x: x # pragma: no cover"",
            ""normalize_string_quotes = lambda x: x # pragma: no cover"",
            ""get_string_prefix = lambda x: '' # pragma: no cover"",
            ""is_multiline_string = lambda x: '\\n' in x.value # pragma: no cover"",
            ""fix_docstring = lambda x, y: x.strip() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""class Mode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.string_normalization = True # pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            ""        self.active_modes = [ # pragma: no cover"",
            ""            Preview.hex_codes_in_unicode_sequences, # pragma: no cover"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly, # pragma: no cover"",
            ""            Preview.long_docstring_quotes_on_newline # pragma: no cover"",
            ""        ] # pragma: no cover"",
            ""    def __contains__(self, item): # pragma: no cover"",
            ""        return item in self.active_modes # pragma: no cover"",
            ""self = type('Mock', (object,), { # pragma: no cover"",
            ""    'mode': Mode(), # pragma: no cover"",
            ""    'current_line': type('MockLine', (object,), {'depth': 1})(), # pragma: no cover"",
            ""    'visit_default': lambda leaf: None # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: leaf.value.startswith(('\""\""\""', \""'''\"")) # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value # pragma: no cover"",
            ""get_string_prefix = lambda value: '\""\""\""' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: False # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: docstring # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80# pragma: no cover"",
            ""        self.active_modes = [# pragma: no cover"",
            ""            Preview.hex_codes_in_unicode_sequences,# pragma: no cover"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly,# pragma: no cover"",
            ""            Preview.long_docstring_quotes_on_newline# pragma: no cover"",
            ""        ]# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def __contains__(self, item):# pragma: no cover"",
            ""        return item in self.active_modes # pragma: no cover"",
            ""class CurrentLine:# pragma: no cover"",
            ""    def __init__(self, depth):# pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""class Self:# pragma: no cover"",
            ""    def __init__(self, mode, current_line):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.current_line = current_line# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def visit_default(self, leaf):# pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: leaf.value.startswith(('\""\""\""', \""'''\"", '\""', \""'\"")) # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value # pragma: no cover"",
            ""get_string_prefix = lambda value: '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            ""self = Self(mode=Mode(), current_line=CurrentLine(depth=1)) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'}) # pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80# pragma: no cover"",
            ""        self._modes = [Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline]# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def __contains__(self, mode):# pragma: no cover"",
            ""        return mode in self._modes # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, value):# pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""class CurrentLine:# pragma: no cover"",
            ""    def __init__(self, depth):# pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""class Self:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.mode = Mode()# pragma: no cover"",
            ""        self.current_line = CurrentLine(1)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def visit_default(self, leaf):# pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = Leaf('\""\""\""Example docstring.\""\""\""') # pragma: no cover"",
            ""is_docstring = lambda leaf: True # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value # pragma: no cover"",
            ""get_string_prefix = lambda value: '\""\""\""' if value.startswith('\""\""\""') else '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            ""self = Self() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""Preview = type('MockPreview', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""class Mode: # pragma: no cover"",
            ""    def __init__(self, features): # pragma: no cover"",
            ""        self.features = features # pragma: no cover"",
            ""        self.string_normalization = True # pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            ""    def __contains__(self, item): # pragma: no cover"",
            ""        return item in self.features # pragma: no cover"",
            ""class CurrentLine: # pragma: no cover"",
            ""    def __init__(self, depth): # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""class Self: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.mode = Mode([ # pragma: no cover"",
            ""            Preview.hex_codes_in_unicode_sequences, # pragma: no cover"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly, # pragma: no cover"",
            ""            Preview.long_docstring_quotes_on_newline # pragma: no cover"",
            ""        ]) # pragma: no cover"",
            ""        self.current_line = CurrentLine(1) # pragma: no cover"",
            ""    def visit_default(self, leaf): # pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""self = Self() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: True # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value # pragma: no cover"",
            ""get_string_prefix = lambda value: '\""\""\""' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: False # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: docstring # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""Preview = type('Preview', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""class Mode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.options = [ # pragma: no cover"",
            ""            'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""            'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""            'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""        ] # pragma: no cover"",
            ""        self.string_normalization = True # pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            ""    def __contains__(self, item): # pragma: no cover"",
            ""        return item in self.options # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, value): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and (leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"")) # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value.replace('\""\""\""', '\""').replace(\""'''\"", \""'\"") # pragma: no cover"",
            ""get_string_prefix = lambda value: '\""\""\""' if value.startswith('\""\""\""') else \""'''\"" # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            ""class CurrentLine: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.depth = 1 # pragma: no cover"",
            ""class Self: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.mode = Mode() # pragma: no cover"",
            ""        self.current_line = CurrentLine() # pragma: no cover"",
            ""    def visit_default(self, leaf): # pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""self = Self() # pragma: no cover"",
            ""leaf = Leaf('''\""\""\""Example docstring.\""\""\""''') # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    }
]",2,5833,0.0029165,4288,0.006432,0.0093485
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 16:
    if Preview.hex_codes_in_unicode_sequences in self.mode:
TypeError: argument of type 'Mode' is not iterable
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import List""
        ],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'"",
            ""class Mode:\n    def __init__(self):\n        self.options = [\n            Preview.hex_codes_in_unicode_sequences,\n            Preview.normalize_docstring_quotes_and_prefixes_properly,\n            Preview.long_docstring_quotes_on_newline\n        ]\n        self.string_normalization = True\n        self.line_length = 80"",
            ""class Leaf:\n    def __init__(self, value):\n        self.value = value"",
            ""def normalize_unicode_escape_sequences(leaf):\n    pass"",
            ""leaf = Leaf('''\""\""\""Example docstring\""\""\""''')"",
            ""def is_docstring(leaf):\n    return leaf.value.startswith(('\""\""\""', '\\'\\'\\''))"",
            ""def normalize_string_prefix(value):\n    return value"",
            ""def normalize_string_quotes(value):\n    return value"",
            ""def get_string_prefix(value):\n    return '\""\""\""' if value.startswith('\""\""\""') else ''"",
            ""def is_multiline_string(leaf):\n    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring, indent):\n    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            ""class CurrentLine:\n    depth = 1"",
            ""class Self:\n    def __init__(self):\n        self.mode = Mode()\n        self.current_line = CurrentLine()\n    def visit_default(self, leaf):\n        pass"",
            ""self = Self()""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'"",
            ""class Mode:\n    def __init__(self):\n        self.string_normalization = True\n        self.line_length = 80\n        self.active_modes = [\n            Preview.hex_codes_in_unicode_sequences,\n            Preview.normalize_docstring_quotes_and_prefixes_properly,\n            Preview.long_docstring_quotes_on_newline,\n        ]"",
            ""class CurrentLine:\n    def __init__(self):\n        self.depth = 1"",
            ""class Leaf:\n    def __init__(self, value):\n        self.value = value"",
            ""def normalize_unicode_escape_sequences(leaf):\n    pass"",
            ""leaf = Leaf('\""\""\""Sample docstring\""\""\""')"",
            ""def is_docstring(leaf):\n    return True"",
            ""def normalize_string_prefix(value):\n    return value"",
            ""def normalize_string_quotes(value):\n    return value"",
            ""def get_string_prefix(value):\n    return '\""\""\""'"",
            ""def is_multiline_string(leaf):\n    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring, indent):\n    return docstring"",
            ""class Self:\n    def __init__(self):\n        self.mode = Mode()\n        self.current_line = CurrentLine()\n    def visit_default(self, leaf):\n        pass"",
            ""self = Self()""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""Preview = type('Preview', (object,), {'hex_codes_in_unicode_sequences': [], 'normalize_docstring_quotes_and_prefixes_properly': [], 'long_docstring_quotes_on_newline': []})"",
            ""class MockMode:\n    def __init__(self):\n        self.string_normalization = True\n        self.line_length = 80\n        self.options = [Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline]\nself = type('Mock', (object,), {'mode': MockMode(), 'current_line': type('MockLine', (object,), {'depth': 1})(), 'visit_default': lambda leaf: None})()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})()"",
            ""is_docstring = lambda leaf: True"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value"",
            ""get_string_prefix = lambda value: '\""\""\""'"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: docstring""
        ]
    },
    {
        ""imports"": [
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})()"",
            ""class Mode:"",
            ""    def __init__(self):"",
            ""        self.string_normalization = True"",
            ""        self.line_length = 80"",
            ""        self._options = ["",
            ""            Preview.hex_codes_in_unicode_sequences,"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly,"",
            ""            Preview.long_docstring_quotes_on_newline"",
            ""        ]"",
            ""    def __contains__(self, item):"",
            ""        return item in self._options"",
            ""self = SimpleNamespace("",
            ""    mode=Mode(),"",
            ""    current_line=SimpleNamespace(depth=1),"",
            ""    visit_default=lambda x: None"",
            "")"",
            ""normalize_unicode_escape_sequences = lambda x: None"",
            ""leaf = SimpleNamespace("",
            ""    value=''''\""\""\""Sample docstring\""\""\""'''"",
            "")"",
            ""is_docstring = lambda x: x.value.startswith('\""\""\""') or x.value.startswith(\""'''\"")"",
            ""normalize_string_prefix = lambda x: x"",
            ""normalize_string_quotes = lambda x: x"",
            ""get_string_prefix = lambda x: ''"",
            ""is_multiline_string = lambda x: '\\n' in x.value"",
            ""fix_docstring = lambda x, y: x""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""Preview = type('Preview', (object,), {'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'})"",
            ""class Mode:\n    def __init__(self):\n        self.string_normalization = True\n        self.line_length = 80\n        self.features = [Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline]"",
            ""self = type('Mock', (object,), {'mode': Mode(), 'current_line': type('Line', (object,), {'depth': 1})(), 'visit_default': lambda leaf: None})()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})()"",
            ""is_docstring = lambda leaf: True"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value"",
            ""get_string_prefix = lambda value: '\""\""\""'"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: docstring""
        ]
    },
    {
        ""imports"": [
            ""from typing import List""
        ],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'"",
            ""class Mode:\n    def __init__(self):\n        self.string_normalization = True\n        self.line_length = 80\n        self._flags = [\n            Preview.hex_codes_in_unicode_sequences,\n            Preview.normalize_docstring_quotes_and_prefixes_properly,\n            Preview.long_docstring_quotes_on_newline\n        ]\n\n    def __contains__(self, item):\n        return item in self._flags"",
            ""class MockLine:\n    def __init__(self, depth):\n        self.depth = depth"",
            ""class Self:\n    def __init__(self, mode, current_line):\n        self.mode = mode\n        self.current_line = current_line\n\n    def visit_default(self, leaf):\n        return None"",
            ""self = Self(Mode(), MockLine(1))"",
            ""def normalize_unicode_escape_sequences(leaf):\n    pass"",
            ""leaf = type('Leaf', (object,), {'value': '''\""\""\""Sample docstring\""\""\""'''})()"",
            ""def is_docstring(leaf):\n    return leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"")"",
            ""def normalize_string_prefix(value):\n    return value"",
            ""def normalize_string_quotes(value):\n    return value"",
            ""def get_string_prefix(value):\n    return ''"",
            ""def is_multiline_string(leaf):\n    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring, indent):\n    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'"",
            ""class Mode:\n    def __init__(self):\n        self.string_normalization = True\n        self.line_length = 80\n        self.options = [Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline]\n    def __contains__(self, item):\n        return item in self.options"",
            ""class Leaf:\n    def __init__(self, value):\n        self.value = value"",
            ""class CurrentLine:\n    def __init__(self, depth):\n        self.depth = depth"",
            ""class Self:\n    def __init__(self):\n        self.mode = Mode()\n        self.current_line = CurrentLine(depth=1)\n    def visit_default(self, leaf):\n        pass"",
            ""self = Self()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = Leaf('\""\""\""Example docstring.\""\""\""')"",
            ""is_docstring = lambda leaf: leaf.value.startswith(('\""\""\""', \""'''\""))"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value"",
            ""get_string_prefix = lambda value: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'"",
            ""class Mode:\n    def __init__(self):\n        self.features = [\n            Preview.hex_codes_in_unicode_sequences,\n            Preview.normalize_docstring_quotes_and_prefixes_properly,\n            Preview.long_docstring_quotes_on_newline\n        ]\n        self.string_normalization = True\n        self.line_length = 80"",
            ""class Leaf:\n    def __init__(self, value):\n        self.value = value"",
            ""def normalize_unicode_escape_sequences(leaf):\n    pass"",
            ""leaf = Leaf('''\""\""\""Example docstring\""\""\""''')"",
            ""def is_docstring(leaf):\n    return leaf.value.startswith(('\""\""\""', \""'''\""))"",
            ""def normalize_string_prefix(value):\n    return value"",
            ""def normalize_string_quotes(value):\n    return value"",
            ""def get_string_prefix(value):\n    return ''"",
            ""def is_multiline_string(leaf):\n    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring, indent):\n    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            ""class CurrentLine:\n    def __init__(self, depth):\n        self.depth = depth"",
            ""self = type('SelfMock', (object,), {\n    'mode': Mode(),\n    'current_line': CurrentLine(1),\n    'visit_default': lambda leaf: None\n})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import List""
        ],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'"",
            ""class Mode:\n    def __init__(self):\n        self.string_normalization = True\n        self.line_length = 80\n        self.settings = [Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline]\n\n    def __contains__(self, item):\n        return item in self.settings"",
            ""class Line:\n    def __init__(self, depth):\n        self.depth = depth"",
            ""class Self:\n    def __init__(self):\n        self.mode = Mode()\n        self.current_line = Line(1)\n    def visit_default(self, leaf):\n        pass"",
            ""self = Self()"",
            ""def normalize_unicode_escape_sequences(leaf):\n    pass"",
            ""class Leaf:\n    def __init__(self, value):\n        self.value = value"",
            ""leaf = Leaf('\""\""\""Example docstring.\""\""\""')"",
            ""def is_docstring(leaf):\n    return isinstance(leaf, Leaf) and (leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\""))"",
            ""def normalize_string_prefix(value):\n    return value"",
            ""def normalize_string_quotes(value):\n    return value"",
            ""def get_string_prefix(value):\n    if value.startswith('u') or value.startswith('r') or value.startswith('f'):\n        return value[0] + value[1:3]\n    return value[0:3]"",
            ""def is_multiline_string(leaf):\n    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring, indent):\n    return '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [
            ""from typing import List""
        ],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'"",
            ""class Mode:\n    def __init__(self, features: List[str]):\n        self.features = features\n        self.string_normalization = True\n        self.line_length = 80"",
            ""class Leaf:\n    def __init__(self, value: str):\n        self.value = value"",
            ""def normalize_unicode_escape_sequences(leaf):\n    pass"",
            ""leaf = Leaf('\""\""\""Example docstring.\""\""\""')"",
            ""def is_docstring(leaf: Leaf) -> bool:\n    return leaf.value.startswith(('\""\""\""', \""'''\"")"",
            ""def normalize_string_prefix(value: str) -> str:\n    return value"",
            ""def normalize_string_quotes(value: str) -> str:\n    return value"",
            ""def get_string_prefix(value: str) -> str:\n    return ''"",
            ""def is_multiline_string(leaf: Leaf) -> bool:\n    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring: str, indent: str) -> str:\n    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n'))"",
            ""class CurrentLine:\n    depth = 1"",
            ""class Self:\n    def __init__(self, mode: Mode, current_line: CurrentLine):\n        self.mode = mode\n        self.current_line = current_line\n    def visit_default(self, leaf: Leaf):\n        pass"",
            ""self = Self(Mode([Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline]), CurrentLine())""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import List # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.options = [# pragma: no cover"",
            ""            Preview.hex_codes_in_unicode_sequences,# pragma: no cover"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly,# pragma: no cover"",
            ""            Preview.long_docstring_quotes_on_newline# pragma: no cover"",
            ""        ]# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, value):# pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""leaf = Leaf('''\""\""\""Example docstring\""\""\""''') # pragma: no cover"",
            ""def is_docstring(leaf):# pragma: no cover"",
            ""    return leaf.value.startswith(('\""\""\""', '\\'\\'\\'')) # pragma: no cover"",
            ""def normalize_string_prefix(value):# pragma: no cover"",
            ""    return value # pragma: no cover"",
            ""def normalize_string_quotes(value):# pragma: no cover"",
            ""    return value # pragma: no cover"",
            ""def get_string_prefix(value):# pragma: no cover"",
            ""    return '\""\""\""' if value.startswith('\""\""\""') else '' # pragma: no cover"",
            ""def is_multiline_string(leaf):# pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            ""def fix_docstring(docstring, indent):# pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            ""class CurrentLine:# pragma: no cover"",
            ""    depth = 1 # pragma: no cover"",
            ""class Self:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.mode = Mode()# pragma: no cover"",
            ""        self.current_line = CurrentLine()# pragma: no cover"",
            ""    def visit_default(self, leaf):# pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""self = Self() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80# pragma: no cover"",
            ""        self.active_modes = [# pragma: no cover"",
            ""            Preview.hex_codes_in_unicode_sequences,# pragma: no cover"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly,# pragma: no cover"",
            ""            Preview.long_docstring_quotes_on_newline,# pragma: no cover"",
            ""        ] # pragma: no cover"",
            ""class CurrentLine:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.depth = 1 # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, value):# pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""leaf = Leaf('\""\""\""Sample docstring\""\""\""') # pragma: no cover"",
            ""def is_docstring(leaf):# pragma: no cover"",
            ""    return True # pragma: no cover"",
            ""def normalize_string_prefix(value):# pragma: no cover"",
            ""    return value # pragma: no cover"",
            ""def normalize_string_quotes(value):# pragma: no cover"",
            ""    return value # pragma: no cover"",
            ""def get_string_prefix(value):# pragma: no cover"",
            ""    return '\""\""\""' # pragma: no cover"",
            ""def is_multiline_string(leaf):# pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            ""def fix_docstring(docstring, indent):# pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            ""class Self:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.mode = Mode()# pragma: no cover"",
            ""        self.current_line = CurrentLine()# pragma: no cover"",
            ""    def visit_default(self, leaf):# pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""self = Self() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""Preview = type('Preview', (object,), {'hex_codes_in_unicode_sequences': [], 'normalize_docstring_quotes_and_prefixes_properly': [], 'long_docstring_quotes_on_newline': []}) # pragma: no cover"",
            ""class MockMode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80# pragma: no cover"",
            ""        self.options = [Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline]# pragma: no cover"",
            ""self = type('Mock', (object,), {'mode': MockMode(), 'current_line': type('MockLine', (object,), {'depth': 1})(), 'visit_default': lambda leaf: None})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: True # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value # pragma: no cover"",
            ""get_string_prefix = lambda value: '\""\""\""' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: docstring # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""class Mode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.string_normalization = True # pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            ""        self._options = [ # pragma: no cover"",
            ""            Preview.hex_codes_in_unicode_sequences, # pragma: no cover"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly, # pragma: no cover"",
            ""            Preview.long_docstring_quotes_on_newline # pragma: no cover"",
            ""        ] # pragma: no cover"",
            ""    def __contains__(self, item): # pragma: no cover"",
            ""        return item in self._options # pragma: no cover"",
            ""self = SimpleNamespace( # pragma: no cover"",
            ""    mode=Mode(), # pragma: no cover"",
            ""    current_line=SimpleNamespace(depth=1), # pragma: no cover"",
            ""    visit_default=lambda x: None # pragma: no cover"",
            "") # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda x: None # pragma: no cover"",
            ""leaf = SimpleNamespace( # pragma: no cover"",
            ""    value=''''\""\""\""Sample docstring\""\""\""''' # pragma: no cover"",
            "") # pragma: no cover"",
            ""is_docstring = lambda x: x.value.startswith('\""\""\""') or x.value.startswith(\""'''\"") # pragma: no cover"",
            ""normalize_string_prefix = lambda x: x # pragma: no cover"",
            ""normalize_string_quotes = lambda x: x # pragma: no cover"",
            ""get_string_prefix = lambda x: '' # pragma: no cover"",
            ""is_multiline_string = lambda x: '\\n' in x.value # pragma: no cover"",
            ""fix_docstring = lambda x, y: x # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""Preview = type('Preview', (object,), {'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', 'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', 'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'}) # pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80# pragma: no cover"",
            ""        self.features = [Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline] # pragma: no cover"",
            ""self = type('Mock', (object,), {'mode': Mode(), 'current_line': type('Line', (object,), {'depth': 1})(), 'visit_default': lambda leaf: None})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: True # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value # pragma: no cover"",
            ""get_string_prefix = lambda value: '\""\""\""' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: docstring # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80# pragma: no cover"",
            ""        self._flags = [# pragma: no cover"",
            ""            Preview.hex_codes_in_unicode_sequences,# pragma: no cover"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly,# pragma: no cover"",
            ""            Preview.long_docstring_quotes_on_newline# pragma: no cover"",
            ""        ]# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def __contains__(self, item):# pragma: no cover"",
            ""        return item in self._flags # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, depth):# pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""class Self:# pragma: no cover"",
            ""    def __init__(self, mode, current_line):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.current_line = current_line# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def visit_default(self, leaf):# pragma: no cover"",
            ""        return None # pragma: no cover"",
            ""self = Self(Mode(), MockLine(1)) # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'value': '''\""\""\""Sample docstring\""\""\""'''})() # pragma: no cover"",
            ""def is_docstring(leaf):# pragma: no cover"",
            ""    return leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"") # pragma: no cover"",
            ""def normalize_string_prefix(value):# pragma: no cover"",
            ""    return value # pragma: no cover"",
            ""def normalize_string_quotes(value):# pragma: no cover"",
            ""    return value # pragma: no cover"",
            ""def get_string_prefix(value):# pragma: no cover"",
            ""    return '' # pragma: no cover"",
            ""def is_multiline_string(leaf):# pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            ""def fix_docstring(docstring, indent):# pragma: no cover"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80# pragma: no cover"",
            ""        self.options = [Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline]# pragma: no cover"",
            ""    def __contains__(self, item):# pragma: no cover"",
            ""        return item in self.options # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, value):# pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""class CurrentLine:# pragma: no cover"",
            ""    def __init__(self, depth):# pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""class Self:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.mode = Mode()# pragma: no cover"",
            ""        self.current_line = CurrentLine(depth=1)# pragma: no cover"",
            ""    def visit_default(self, leaf):# pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""self = Self() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = Leaf('\""\""\""Example docstring.\""\""\""') # pragma: no cover"",
            ""is_docstring = lambda leaf: leaf.value.startswith(('\""\""\""', \""'''\"")) # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value # pragma: no cover"",
            ""get_string_prefix = lambda value: '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.features = [# pragma: no cover"",
            ""            Preview.hex_codes_in_unicode_sequences,# pragma: no cover"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly,# pragma: no cover"",
            ""            Preview.long_docstring_quotes_on_newline# pragma: no cover"",
            ""        ]# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, value):# pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""leaf = Leaf('''\""\""\""Example docstring\""\""\""''') # pragma: no cover"",
            ""def is_docstring(leaf):# pragma: no cover"",
            ""    return leaf.value.startswith(('\""\""\""', \""'''\"")) # pragma: no cover"",
            ""def normalize_string_prefix(value):# pragma: no cover"",
            ""    return value # pragma: no cover"",
            ""def normalize_string_quotes(value):# pragma: no cover"",
            ""    return value # pragma: no cover"",
            ""def get_string_prefix(value):# pragma: no cover"",
            ""    return '' # pragma: no cover"",
            ""def is_multiline_string(leaf):# pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            ""def fix_docstring(docstring, indent):# pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            ""class CurrentLine:# pragma: no cover"",
            ""    def __init__(self, depth):# pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""self = type('SelfMock', (object,), {# pragma: no cover"",
            ""    'mode': Mode(),# pragma: no cover"",
            ""    'current_line': CurrentLine(1),# pragma: no cover"",
            ""    'visit_default': lambda leaf: None# pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80# pragma: no cover"",
            ""        self.settings = [Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline]# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def __contains__(self, item):# pragma: no cover"",
            ""        return item in self.settings # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, depth):# pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""class Self:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.mode = Mode()# pragma: no cover"",
            ""        self.current_line = Line(1)# pragma: no cover"",
            ""    def visit_default(self, leaf):# pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""self = Self() # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, value):# pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""leaf = Leaf('\""\""\""Example docstring.\""\""\""') # pragma: no cover"",
            ""def is_docstring(leaf):# pragma: no cover"",
            ""    return isinstance(leaf, Leaf) and (leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"")) # pragma: no cover"",
            ""def normalize_string_prefix(value):# pragma: no cover"",
            ""    return value # pragma: no cover"",
            ""def normalize_string_quotes(value):# pragma: no cover"",
            ""    return value # pragma: no cover"",
            ""def get_string_prefix(value):# pragma: no cover"",
            ""    if value.startswith('u') or value.startswith('r') or value.startswith('f'):# pragma: no cover"",
            ""        return value[0] + value[1:3]# pragma: no cover"",
            ""    return value[0:3] # pragma: no cover"",
            ""def is_multiline_string(leaf):# pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            ""def fix_docstring(docstring, indent):# pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self, features: List[str]):# pragma: no cover"",
            ""        self.features = features# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, value: str):# pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""leaf = Leaf('\""\""\""Example docstring.\""\""\""') # pragma: no cover""
        ]
    }
]",2,6405,0.0032025,3998,0.005997,0.0091995
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 2:
    if Preview.hex_codes_in_unicode_sequences in self.mode:
NameError: name 'Preview' is not defined
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [],
        ""initialization"": [
            ""class Preview:"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'"",
            """",
            ""class Mode:"",
            ""    def __init__(self):"",
            ""        self.active_modes = ["",
            ""            Preview.hex_codes_in_unicode_sequences,"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly,"",
            ""            Preview.long_docstring_quotes_on_newline,"",
            ""        ]"",
            ""        self.string_normalization = True"",
            ""        self.line_length = 80"",
            """",
            ""class CurrentLine:"",
            ""    def __init__(self, depth):"",
            ""        self.depth = depth"",
            """",
            ""class Self:"",
            ""    def __init__(self):"",
            ""        self.mode = Mode()"",
            ""        self.current_line = CurrentLine(1)"",
            """",
            ""    def visit_default(self, leaf):"",
            ""        pass"",
            """",
            ""self = Self()"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""class Leaf:"",
            ""    def __init__(self, value):"",
            ""        self.value = value"",
            """",
            ""leaf = Leaf(\""\""\""Example docstring.\""\""\"")"",
            """",
            ""def is_docstring(leaf):"",
            ""    return isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\"")"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = \""hex\""\n    normalize_docstring_quotes_and_prefixes_properly = \""normalize\""\n    long_docstring_quotes_on_newline = \""newline\""\n"",
            ""class Mode:\n    def __init__(self):\n        self.options = {\n            Preview.hex_codes_in_unicode_sequences: True,\n            Preview.normalize_docstring_quotes_and_prefixes_properly: True,\n            Preview.long_docstring_quotes_on_newline: True\n        }\n        self.string_normalization = True\n        self.line_length = 80\n"",
            ""class CurrentLine:\n    def __init__(self, depth):\n        self.depth = depth\n"",
            ""class Leaf:\n    def __init__(self, value):\n        self.value = value\n"",
            ""class SelfMock:\n    def __init__(self):\n        self.mode = Mode()\n        self.current_line = CurrentLine(1)\n    def visit_default(self, leaf):\n        return None\nself = SelfMock()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = Leaf('\""\""\""This is a docstring.\""\""\""')"",
            ""is_docstring = lambda leaf: leaf.value.startswith(('\""\""\""', \""'''\"", 'r\""\""\""', 'r\""\""\""'))"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value"",
            ""get_string_prefix = lambda value: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'"",
            ""class Mode:\n    def __init__(self):\n        # Defining the required attributes as iterable collections\n        self.features = {\n            Preview.hex_codes_in_unicode_sequences,\n            Preview.normalize_docstring_quotes_and_prefixes_properly,\n            Preview.long_docstring_quotes_on_newline\n        }\n        self.line_length = 80\n        self.string_normalization = True"",
            ""class CurrentLine:\n    depth = 1"",
            ""class Self:\n    def __init__(self):\n        self.mode = Mode()\n        self.current_line = CurrentLine()\n    def visit_default(self, leaf):\n        pass"",
            ""self = Self()"",
            ""def normalize_unicode_escape_sequences(leaf):\n    pass"",
            ""class Leaf:\n    def __init__(self, value):\n        self.value = value"",
            ""leaf = Leaf('\""\""\""Example docstring\""\""\""')"",
            ""def is_docstring(leaf):\n    return isinstance(leaf.value, str) and (leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"")"",
            ""def normalize_string_prefix(value):\n    return value"",
            ""def normalize_string_quotes(value):\n    return value"",
            ""def get_string_prefix(value):\n    return ''"",
            ""def is_multiline_string(leaf):\n    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring, indent):\n    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            ""leaf.value = '\""\""\""Example docstring\""\""\""'""
        ]
    },
    {
        ""imports"": [
            ""import re""
        ],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'"",
            ""class Mode:\n    def __init__(self):\n        self.string_normalization = True\n        self.line_length = 80\n        self.enabled_features = [Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline]\n\n    def __contains__(self, item):\n        return item in self.enabled_features"",
            ""class CurrentLine:\n    def __init__(self, depth=1):\n        self.depth = depth"",
            ""class Self:\n    def __init__(self):\n        self.mode = Mode()\n        self.current_line = CurrentLine(depth=1)\n\n    def visit_default(self, leaf):\n        pass"",
            ""self = Self()"",
            ""def normalize_unicode_escape_sequences(leaf):\n    pass"",
            ""class Leaf:\n    def __init__(self, value):\n        self.value = value"",
            ""leaf = Leaf('\""\""\""This is a test docstring.\""\""\""')"",
            ""def is_docstring(leaf):\n    return isinstance(leaf, Leaf) and (leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"") and leaf.value.endswith('\""\""\""') or leaf.value.endswith(\""'''\"") )"",
            ""def normalize_string_prefix(value):\n    return value"",
            ""def normalize_string_quotes(value):\n    return value.replace(\""'\"", '\""') if value else value"",
            ""def get_string_prefix(value):\n    match = re.match(r'(?:[urUR]{,2}[rRfFbBuU]?)', value)\n    return match.group(0) if match else ''"",
            ""def is_multiline_string(leaf):\n    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring, indent):\n    return '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""class Preview:"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'"",
            """",
            ""class Mode:"",
            ""    def __init__(self):"",
            ""        self.options = [Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline]"",
            ""        self.string_normalization = True"",
            ""        self.line_length = 80"",
            """",
            ""    def __contains__(self, item):"",
            ""        return item in self.options"",
            """",
            ""class CurrentLine:"",
            ""    def __init__(self, depth):"",
            ""        self.depth = depth"",
            """",
            ""class Self:"",
            ""    def __init__(self):"",
            ""        self.mode = Mode()"",
            ""        self.current_line = CurrentLine(depth=1)"",
            """",
            ""    def visit_default(self, leaf):"",
            ""        pass"",
            """",
            ""self = Self()"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""class Leaf:"",
            ""    def __init__(self, value):"",
            ""        self.value = value"",
            """",
            ""leaf = Leaf('\""\""\""Example docstring.\""\""\""')"",
            """",
            ""def is_docstring(leaf):"",
            ""    return isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\""))"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""class Preview:\n    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'\n    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'\n    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'"",
            ""class ModeMock:\n    def __init__(self):\n        self.string_normalization = True\n        self.line_length = 80\n        self.active_modes = {Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline}\n\n    def __contains__(self, item):\n        return item in self.active_modes"",
            ""class CurrentLineMock:\n    def __init__(self):\n        self.depth = 1"",
            ""class SelfMock:\n    def __init__(self):\n        self.mode = ModeMock()\n        self.current_line = CurrentLineMock()\n\n    def visit_default(self, leaf):\n        pass"",
            ""class LeafMock:\n    def __init__(self, value):\n        self.value = value"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""is_docstring = lambda leaf: isinstance(leaf.value, str) and (leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\""))."",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value"",
            ""get_string_prefix = lambda value: '\""\""\""' if value.startswith('\""\""\""') else \""'''\"""",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            ""self = SelfMock()"",
            ""leaf = LeafMock('\""\""\""Example docstring.\""\""\""')""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""Preview = type('MockPreview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': [],"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': [],"",
            ""    'long_docstring_quotes_on_newline': [],"",
            ""})()"",
            ""class MockMode:"",
            ""    def __init__(self):"",
            ""        self.string_normalization = True"",
            ""        self.line_length = 80"",
            ""        self.options = ["",
            ""            Preview.hex_codes_in_unicode_sequences,"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly,"",
            ""            Preview.long_docstring_quotes_on_newline"",
            ""        ]"",
            ""self = type('MockSelf', (object,), {"",
            ""    'mode': MockMode(),"",
            ""    'current_line': type('MockCurrentLine', (object,), {'depth': 1})(),"",
            ""    'visit_default': lambda leaf: None"",
            ""})()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})()"",
            ""is_docstring = lambda leaf: True"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value"",
            ""get_string_prefix = lambda value: '\""\""\""'"",
            ""is_multiline_string = lambda leaf: False"",
            ""fix_docstring = lambda docstring, indent: docstring""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""Preview = type('MockPreview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})"",
            ""class MockMode:"",
            ""    def __init__(self, features):"",
            ""        self.features = features"",
            ""        self.string_normalization = True"",
            ""        self.line_length = 80"",
            ""    def __contains__(self, item):"",
            ""        return item in self.features"",
            ""class MockCurrentLine:"",
            ""    def __init__(self, depth):"",
            ""        self.depth = depth"",
            ""class MockSelf:"",
            ""    def __init__(self):"",
            ""        self.mode = MockMode([Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline])"",
            ""        self.current_line = MockCurrentLine(1)"",
            ""    def visit_default(self, leaf):"",
            ""        pass"",
            ""self = MockSelf()"",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            ""class MockLeaf:"",
            ""    def __init__(self, value):"",
            ""        self.value = value"",
            ""leaf = MockLeaf('\""\""\""This is a docstring.\""\""\""')"",
            ""def is_docstring(leaf):"",
            ""    return leaf.value.startswith(('\""\""\""', \""''''))"",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""Preview = type('MockPreview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})"",
            """",
            ""class MockMode:"",
            ""    def __init__(self):"",
            ""        self.string_normalization = True"",
            ""        self.line_length = 80"",
            ""        self.hex_codes_in_unicode_sequences = [Preview.hex_codes_in_unicode_sequences]"",
            ""        self.normalize_docstring_quotes_and_prefixes_properly = [Preview.normalize_docstring_quotes_and_prefixes_properly]"",
            ""        self.long_docstring_quotes_on_newline = [Preview.long_docstring_quotes_on_newline]"",
            """",
            ""class MockLeaf:"",
            ""    def __init__(self, value):"",
            ""        self.value = value"",
            """",
            ""class MockSelf:"",
            ""    def __init__(self):"",
            ""        self.mode = MockMode()"",
            ""        self.current_line = type('MockCurrentLine', (object,), {'depth': 1})()"",
            ""    def visit_default(self, leaf):"",
            ""        pass"",
            """",
            ""self = MockSelf()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = MockLeaf('\""\""\""Example docstring.\""\""\""')"",
            ""is_docstring = lambda leaf: True"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value"",
            ""get_string_prefix = lambda value: '\""\""\""'"",
            ""is_multiline_string = lambda leaf: False"",
            ""fix_docstring = lambda docstring, indent: docstring""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""Preview = type('Preview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})"",
            """",
            ""class Mode:"",
            ""    def __init__(self):"",
            ""        self.string_normalization = True"",
            ""        self.line_length = 80"",
            ""        self.options = {"",
            ""            'hex_codes_in_unicode_sequences': True,"",
            ""            'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""            'long_docstring_quotes_on_newline': True"",
            ""        }"",
            """",
            ""    def __contains__(self, item):"",
            ""        return item in self.options and self.options[item]"",
            """",
            ""self = type('Mock', (object,), {"",
            ""    'mode': Mode(),"",
            ""    'current_line': type('MockLine', (object,), {"",
            ""        'depth': 1"",
            ""    })(),"",
            ""    'visit_default': lambda self, leaf: None"",
            ""})()"",
            """",
            ""normalize_unicode_escape_sequences = lambda leaf: leaf"",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""Sample docstring.\""\""\""'"",
            ""})()"",
            """",
            ""is_docstring = lambda leaf: True"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value"",
            ""get_string_prefix = lambda value: '\""\""\""'"",
            ""is_multiline_string = lambda leaf: True"",
            ""fix_docstring = lambda docstring, indent: docstring""
        ]
    }
]","[
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""class Preview: # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences' # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly' # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Mode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.active_modes = [ # pragma: no cover"",
            ""            Preview.hex_codes_in_unicode_sequences, # pragma: no cover"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly, # pragma: no cover"",
            ""            Preview.long_docstring_quotes_on_newline, # pragma: no cover"",
            ""        ] # pragma: no cover"",
            ""        self.string_normalization = True # pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CurrentLine: # pragma: no cover"",
            ""    def __init__(self, depth): # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Self: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.mode = Mode() # pragma: no cover"",
            ""        self.current_line = CurrentLine(1) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def visit_default(self, leaf): # pragma: no cover"",
            ""        pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = Self() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, value): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = Leaf(\""\""\""Example docstring.\""\""\"") # pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = \""hex\""# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = \""normalize\""# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = \""newline\""# pragma: no cover"",
            "" # pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.options = {# pragma: no cover"",
            ""            Preview.hex_codes_in_unicode_sequences: True,# pragma: no cover"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly: True,# pragma: no cover"",
            ""            Preview.long_docstring_quotes_on_newline: True# pragma: no cover"",
            ""        }# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80# pragma: no cover"",
            "" # pragma: no cover"",
            ""class CurrentLine:# pragma: no cover"",
            ""    def __init__(self, depth):# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            "" # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, value):# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            "" # pragma: no cover"",
            ""class SelfMock:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.mode = Mode()# pragma: no cover"",
            ""        self.current_line = CurrentLine(1)# pragma: no cover"",
            ""    def visit_default(self, leaf):# pragma: no cover"",
            ""        return None# pragma: no cover"",
            ""self = SelfMock() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = Leaf('\""\""\""This is a docstring.\""\""\""') # pragma: no cover"",
            ""is_docstring = lambda leaf: leaf.value.startswith(('\""\""\""', \""'''\"", 'r\""\""\""', 'r\""\""\""')) # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value # pragma: no cover"",
            ""get_string_prefix = lambda value: '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        # Defining the required attributes as iterable collections# pragma: no cover"",
            ""        self.features = {# pragma: no cover"",
            ""            Preview.hex_codes_in_unicode_sequences,# pragma: no cover"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly,# pragma: no cover"",
            ""            Preview.long_docstring_quotes_on_newline# pragma: no cover"",
            ""        }# pragma: no cover"",
            ""        self.line_length = 80# pragma: no cover"",
            ""        self.string_normalization = True # pragma: no cover"",
            ""class CurrentLine:# pragma: no cover"",
            ""    depth = 1 # pragma: no cover"",
            ""class Self:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.mode = Mode()# pragma: no cover"",
            ""        self.current_line = CurrentLine()# pragma: no cover"",
            ""    def visit_default(self, leaf):# pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""self = Self() # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, value):# pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""leaf = Leaf('\""\""\""Example docstring\""\""\""') # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""class Mode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80# pragma: no cover"",
            ""        self.enabled_features = [Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline]# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def __contains__(self, item):# pragma: no cover"",
            ""        return item in self.enabled_features # pragma: no cover"",
            ""class CurrentLine:# pragma: no cover"",
            ""    def __init__(self, depth=1):# pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""class Self:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.mode = Mode()# pragma: no cover"",
            ""        self.current_line = CurrentLine(depth=1)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def visit_default(self, leaf):# pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""self = Self() # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, value):# pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""leaf = Leaf('\""\""\""This is a test docstring.\""\""\""') # pragma: no cover"",
            ""def is_docstring(leaf):# pragma: no cover"",
            ""    return isinstance(leaf, Leaf) and (leaf.value.startswith('\""\""\""') or leaf.value.startswith(\""'''\"") and leaf.value.endswith('\""\""\""') or leaf.value.endswith(\""'''\"") ) # pragma: no cover"",
            ""def normalize_string_prefix(value):# pragma: no cover"",
            ""    return value # pragma: no cover"",
            ""def normalize_string_quotes(value):# pragma: no cover"",
            ""    return value.replace(\""'\"", '\""') if value else value # pragma: no cover"",
            ""def get_string_prefix(value):# pragma: no cover"",
            ""    match = re.match(r'(?:[urUR]{,2}[rRfFbBuU]?)', value)# pragma: no cover"",
            ""    return match.group(0) if match else '' # pragma: no cover"",
            ""def is_multiline_string(leaf):# pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            ""def fix_docstring(docstring, indent):# pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""class Preview: # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences' # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly' # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Mode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.options = [Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline] # pragma: no cover"",
            ""        self.string_normalization = True # pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def __contains__(self, item): # pragma: no cover"",
            ""        return item in self.options # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CurrentLine: # pragma: no cover"",
            ""    def __init__(self, depth): # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Self: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.mode = Mode() # pragma: no cover"",
            ""        self.current_line = CurrentLine(depth=1) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def visit_default(self, leaf): # pragma: no cover"",
            ""        pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = Self() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, value): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = Leaf('\""\""\""Example docstring.\""\""\""') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\"")) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""class Preview:# pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'# pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'# pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""class ModeMock:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.string_normalization = True# pragma: no cover"",
            ""        self.line_length = 80# pragma: no cover"",
            ""        self.active_modes = {Preview.hex_codes_in_unicode_sequences, Preview.normalize_docstring_quotes_and_prefixes_properly, Preview.long_docstring_quotes_on_newline}# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def __contains__(self, item):# pragma: no cover"",
            ""        return item in self.active_modes # pragma: no cover"",
            ""class CurrentLineMock:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.depth = 1 # pragma: no cover"",
            ""class SelfMock:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.mode = ModeMock()# pragma: no cover"",
            ""        self.current_line = CurrentLineMock()# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def visit_default(self, leaf):# pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""class LeafMock:# pragma: no cover"",
            ""    def __init__(self, value):# pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""Preview = type('MockPreview', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': [], # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': [], # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': [], # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""class MockMode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.string_normalization = True # pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            ""        self.options = [ # pragma: no cover"",
            ""            Preview.hex_codes_in_unicode_sequences, # pragma: no cover"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly, # pragma: no cover"",
            ""            Preview.long_docstring_quotes_on_newline # pragma: no cover"",
            ""        ] # pragma: no cover"",
            ""self = type('MockSelf', (object,), { # pragma: no cover"",
            ""    'mode': MockMode(), # pragma: no cover"",
            ""    'current_line': type('MockCurrentLine', (object,), {'depth': 1})(), # pragma: no cover"",
            ""    'visit_default': lambda leaf: None # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: True # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value # pragma: no cover"",
            ""get_string_prefix = lambda value: '\""\""\""' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: False # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: docstring # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""Preview = type('MockPreview', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockMode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.string_normalization = True # pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            ""        self.hex_codes_in_unicode_sequences = [Preview.hex_codes_in_unicode_sequences] # pragma: no cover"",
            ""        self.normalize_docstring_quotes_and_prefixes_properly = [Preview.normalize_docstring_quotes_and_prefixes_properly] # pragma: no cover"",
            ""        self.long_docstring_quotes_on_newline = [Preview.long_docstring_quotes_on_newline] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, value): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockSelf: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.mode = MockMode() # pragma: no cover"",
            ""        self.current_line = type('MockCurrentLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""    def visit_default(self, leaf): # pragma: no cover"",
            ""        pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = MockSelf() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = MockLeaf('\""\""\""Example docstring.\""\""\""') # pragma: no cover"",
            ""is_docstring = lambda leaf: True # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value # pragma: no cover"",
            ""get_string_prefix = lambda value: '\""\""\""' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: False # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: docstring # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""Preview = type('Preview', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Mode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.string_normalization = True # pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            ""        self.options = { # pragma: no cover"",
            ""            'hex_codes_in_unicode_sequences': True, # pragma: no cover"",
            ""            'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""            'long_docstring_quotes_on_newline': True # pragma: no cover"",
            ""        } # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def __contains__(self, item): # pragma: no cover"",
            ""        return item in self.options and self.options[item] # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), { # pragma: no cover"",
            ""    'mode': Mode(), # pragma: no cover"",
            ""    'current_line': type('MockLine', (object,), { # pragma: no cover"",
            ""        'depth': 1 # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'visit_default': lambda self, leaf: None # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: leaf # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""Sample docstring.\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""is_docstring = lambda leaf: True # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value # pragma: no cover"",
            ""get_string_prefix = lambda value: '\""\""\""' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: True # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: docstring # pragma: no cover""
        ]
    }
]",2,10801,0.0054005,4419,0.0066285,0.012029
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 37:
    if Preview.hex_codes_in_unicode_sequences in self.mode:
TypeError: argument of type 'MockMode' is not iterable
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [],
        ""initialization"": [
            ""Preview = type('Preview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})"",
            """",
            ""class MockMode:"",
            ""    def __init__(self):"",
            ""        self.string_normalization = True"",
            ""        self.line_length = 80"",
            ""        self.configs = ["",
            ""            Preview.hex_codes_in_unicode_sequences,"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly,"",
            ""            Preview.long_docstring_quotes_on_newline"",
            ""        ]"",
            """",
            ""    def __contains__(self, item):"",
            ""        return item in self.configs"",
            """",
            ""class MockCurrentLine:"",
            ""    def __init__(self):"",
            ""        self.depth = 2"",
            """",
            ""class MockSelf:"",
            ""    def __init__(self):"",
            ""        self.mode = MockMode()"",
            ""        self.current_line = MockCurrentLine()"",
            """",
            ""    def visit_default(self, leaf):"",
            ""        pass"",
            """",
            ""self = MockSelf()"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""class MockLeaf:"",
            ""    def __init__(self, value):"",
            ""        self.value = value"",
            """",
            ""leaf = MockLeaf('\""\""\""This is a docstring.\""\""\""')"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return True"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring.strip()""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""class Preview:"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'"",
            """",
            ""class MockMode:"",
            ""    def __init__(self):"",
            ""        self.string_normalization = True"",
            ""        self.line_length = 80"",
            ""        self.options = ["",
            ""            Preview.hex_codes_in_unicode_sequences,"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly,"",
            ""            Preview.long_docstring_quotes_on_newline"",
            ""        ]"",
            """",
            ""    def __contains__(self, item):"",
            ""        return item in self.options"",
            """",
            ""class MockCurrentLine:"",
            ""    def __init__(self, depth):"",
            ""        self.depth = depth"",
            """",
            ""class MockSelf:"",
            ""    def __init__(self):"",
            ""        self.mode = MockMode()"",
            ""        self.current_line = MockCurrentLine(1)"",
            """",
            ""    def visit_default(self, leaf):"",
            ""        pass"",
            """",
            ""self = MockSelf()"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""class MockLeaf:"",
            ""    def __init__(self, value):"",
            ""        self.value = value"",
            """",
            ""leaf = MockLeaf('\""\""\""Example docstring.\""\""\""')"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return True"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring.strip()""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""class Preview:"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'"",
            """",
            ""class MockMode:"",
            ""    def __init__(self):"",
            ""        self.string_normalization = True"",
            ""        self.line_length = 80"",
            ""        self.active_features = {"",
            ""            Preview.hex_codes_in_unicode_sequences,"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly,"",
            ""            Preview.long_docstring_quotes_on_newline"",
            ""        }"",
            """",
            ""    def __contains__(self, item):"",
            ""        return item in self.active_features"",
            """",
            ""class MockCurrentLine:"",
            ""    def __init__(self, depth):"",
            ""        self.depth = depth"",
            """",
            ""class MockSelf:"",
            ""    def __init__(self):"",
            ""        self.mode = MockMode()"",
            ""        self.current_line = MockCurrentLine(1)"",
            """",
            ""    def visit_default(self, leaf):"",
            ""        pass"",
            """",
            ""self = MockSelf()"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""class Leaf:"",
            ""    def __init__(self, value):"",
            ""        self.value = value"",
            """",
            ""leaf = Leaf('\""\""\""Example docstring.\""\""\""')"",
            """",
            ""def is_docstring(leaf):"",
            ""    return leaf.value.startswith(('\""\""\""', \""'''\"")"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring.strip()""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""Preview = type('MockPreview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})"",
            """",
            ""class MockMode:"",
            ""    def __init__(self):"",
            ""        self.options = {"",
            ""            'hex_codes_in_unicode_sequences': True,"",
            ""            'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""            'long_docstring_quotes_on_newline': True,"",
            ""            'string_normalization': True,"",
            ""            'line_length': 80"",
            ""        }"",
            """",
            ""    def __contains__(self, item):"",
            ""        return self.options.get(item, False)"",
            """",
            ""    def __getattr__(self, item):"",
            ""        return self.options.get(item, None)"",
            """",
            ""class MockCurrentLine:"",
            ""    depth = 2"",
            """",
            ""class Mock:"",
            ""    mode = MockMode()"",
            ""    current_line = MockCurrentLine()"",
            """",
            ""    def visit_default(self, leaf):"",
            ""        pass"",
            """",
            ""self = Mock()"",
            """",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            """",
            ""class Leaf:"",
            ""    def __init__(self, value):"",
            ""        self.value = value"",
            """",
            ""leaf = Leaf('\""\""\""Example docstring.\""\""\""')"",
            """",
            ""is_docstring = lambda leaf: True"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value"",
            ""get_string_prefix = lambda value: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: docstring.strip()""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""class Preview:"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'"",
            """",
            ""class Mode:"",
            ""    def __init__(self):"",
            ""        self.string_normalization = True"",
            ""        self.line_length = 80"",
            ""        self.preview_features = ["",
            ""            Preview.hex_codes_in_unicode_sequences,"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly,"",
            ""            Preview.long_docstring_quotes_on_newline"",
            ""        ]"",
            """",
            ""class Leaf:"",
            ""    def __init__(self, value):"",
            ""        self.value = value"",
            """",
            ""class CurrentLine:"",
            ""    def __init__(self, depth):"",
            ""        self.depth = depth"",
            """",
            ""class Self:"",
            ""    def __init__(self):"",
            ""        self.mode = Mode()"",
            ""        self.current_line = CurrentLine(2)"",
            """",
            ""    def visit_default(self, leaf):"",
            ""        pass"",
            """",
            ""self = Self()"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""leaf = Leaf(value='\""\""\""This is a sample docstring.\""\""\""')"",
            """",
            ""def is_docstring(leaf):"",
            ""    return isinstance(leaf.value, str) and leaf.value.startswith(('\""\""\""', \""'''\"")"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value.strip('\""\""\""')"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""Preview = type('Preview', (object,), {"",
            ""  'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""  'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""  'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})"",
            """",
            ""class MockMode:"",
            ""    def __init__(self):"",
            ""        self.string_normalization = True"",
            ""        self.line_length = 80"",
            """",
            ""    def __contains__(self, item):"",
            ""        return item in ["",
            ""            Preview.hex_codes_in_unicode_sequences,"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly,"",
            ""            Preview.long_docstring_quotes_on_newline"",
            ""        ]"",
            """",
            ""class MockCurrentLine:"",
            ""    def __init__(self):"",
            ""        self.depth = 1"",
            """",
            ""class MockSelf:"",
            ""    def __init__(self):"",
            ""        self.mode = MockMode()"",
            ""        self.current_line = MockCurrentLine()"",
            """",
            ""    def visit_default(self, leaf):"",
            ""        pass"",
            """",
            ""self = MockSelf()"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""class MockLeaf:"",
            ""    def __init__(self, value):"",
            ""        self.value = value"",
            """",
            ""leaf = MockLeaf('\""\""\""This is a docstring.\""\""\""')"",
            """",
            ""def is_docstring(leaf):"",
            ""    return leaf.value.startswith(('\""\""\""', \""'''\""))"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n'))""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""Preview = type('MockPreview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})"",
            """",
            ""class MockMode:"",
            ""    def __init__(self):"",
            ""        self.string_normalization = True"",
            ""        self.line_length = 80"",
            ""        self.Options = {"",
            ""            Preview.hex_codes_in_unicode_sequences: True,"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly: True,"",
            ""            Preview.long_docstring_quotes_on_newline: True"",
            ""        }"",
            """",
            ""    def __contains__(self, item):"",
            ""        return self.Options.get(item, False)"",
            """",
            ""self = type('MockSelf', (object,), {"",
            ""    'mode': MockMode(),"",
            ""    'current_line': type('MockLine', (object,), {"",
            ""        'depth': 2"",
            ""    })(),"",
            ""    'visit_default': lambda self, leaf: None"",
            ""})()"",
            """",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            """",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})()"",
            """",
            ""is_docstring = lambda leaf: True"",
            """",
            ""normalize_string_prefix = lambda value: value"",
            """",
            ""normalize_string_quotes = lambda value: value"",
            """",
            ""get_string_prefix = lambda value: ''"",
            """",
            ""is_multiline_string = lambda leaf: False"",
            """",
            ""fix_docstring = lambda docstring, indent: docstring""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""class Preview:"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences'"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly'"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline'"",
            """",
            ""class MockMode:"",
            ""    def __init__(self):"",
            ""        self.string_normalization = True"",
            ""        self.line_length = 80"",
            ""        self.options = {"",
            ""            'hex_codes_in_unicode_sequences': True,"",
            ""            'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""            'long_docstring_quotes_on_newline': True"",
            ""        }"",
            """",
            ""    def __contains__(self, item):"",
            ""        return self.options.get(item, False)"",
            """",
            ""class MockCurrentLine:"",
            ""    def __init__(self):"",
            ""        self.depth = 2"",
            """",
            ""class MockSelf:"",
            ""    def __init__(self):"",
            ""        self.mode = MockMode()"",
            ""        self.current_line = MockCurrentLine()"",
            """",
            ""    def visit_default(self, leaf):"",
            ""        pass"",
            """",
            ""self = MockSelf()"",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            ""leaf = type('Leaf', (object,), {'value': 'mock_docstring'})()"",
            ""is_docstring = lambda leaf: True"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value"",
            ""get_string_prefix = lambda value: ''"",
            ""is_multiline_string = lambda leaf: True"",
            ""fix_docstring = lambda docstring, indent: docstring.strip()""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""Preview = type('Preview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly',"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline'"",
            ""})()"",
            """",
            ""class Mode:"",
            ""    def __init__(self):"",
            ""        self.string_normalization = True"",
            ""        self.line_length = 80"",
            ""        self.options = ["",
            ""            'hex_codes_in_unicode_sequences',"",
            ""            'normalize_docstring_quotes_and_prefixes_properly',"",
            ""            'long_docstring_quotes_on_newline'"",
            ""        ]"",
            ""    def __contains__(self, item):"",
            ""        return item in self.options"",
            """",
            ""class CurrentLine:"",
            ""    def __init__(self, depth):"",
            ""        self.depth = depth"",
            """",
            ""class Self:"",
            ""    def __init__(self):"",
            ""        self.mode = Mode()"",
            ""        self.current_line = CurrentLine(2)"",
            ""    def visit_default(self, leaf):"",
            ""        pass"",
            """",
            ""self = Self()"",
            """",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            """",
            ""class Leaf:"",
            ""    def __init__(self, value):"",
            ""        self.value = value"",
            """",
            ""leaf = Leaf('\""\""\""Example docstring.\""\""\""')"",
            """",
            ""is_docstring = lambda leaf: leaf.value.startswith(('\""\""\""', \""'''\"")"",
            ""normalize_string_prefix = lambda value: value"",
            ""normalize_string_quotes = lambda value: value"",
            ""get_string_prefix = lambda value: ''"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value"",
            ""fix_docstring = lambda docstring, indent: docstring""
        ]
    },
    {
        ""imports"": [],
        ""initialization"": [
            ""Preview = type('Mock', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': 'mock_hex_codes',"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'mock_normalize_prefixes',"",
            ""    'long_docstring_quotes_on_newline': 'mock_long_quotes'"",
            ""})"",
            """",
            ""class MockMode:"",
            ""    def __init__(self):"",
            ""        self.options = ["",
            ""            'hex_codes_in_unicode_sequences',"",
            ""            'normalize_docstring_quotes_and_prefixes_properly',"",
            ""            'long_docstring_quotes_on_newline'"",
            ""        ]"",
            ""        self.string_normalization = True"",
            ""        self.line_length = 80"",
            ""    def __contains__(self, item):"",
            ""        return item in self.options"",
            """",
            ""class MockSelf:"",
            ""    def __init__(self):"",
            ""        self.mode = MockMode()"",
            ""        self.current_line = type('MockLine', (object,), {'depth': 2})()"",
            ""    def visit_default(self, leaf):"",
            ""        return None"",
            """",
            ""self = MockSelf()"",
            """",
            ""normalize_unicode_escape_sequences = lambda leaf: None"",
            """",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Sample docstring.\""\""\""'})()"",
            """",
            ""is_docstring = lambda leaf: True"",
            """",
            ""normalize_string_prefix = lambda value: value"",
            """",
            ""normalize_string_quotes = lambda value: value"",
            """",
            ""get_string_prefix = lambda value: ''"",
            """",
            ""is_multiline_string = lambda leaf: True"",
            """",
            ""fix_docstring = lambda docstring, indent: docstring.strip()""
        ]
    }
]","[
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""Preview = type('Preview', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockMode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.string_normalization = True # pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            ""        self.configs = [ # pragma: no cover"",
            ""            Preview.hex_codes_in_unicode_sequences, # pragma: no cover"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly, # pragma: no cover"",
            ""            Preview.long_docstring_quotes_on_newline # pragma: no cover"",
            ""        ] # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def __contains__(self, item): # pragma: no cover"",
            ""        return item in self.configs # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockCurrentLine: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.depth = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockSelf: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.mode = MockMode() # pragma: no cover"",
            ""        self.current_line = MockCurrentLine() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def visit_default(self, leaf): # pragma: no cover"",
            ""        pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = MockSelf() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, value): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = MockLeaf('\""\""\""This is a docstring.\""\""\""') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring.strip() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""class Preview: # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences' # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly' # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockMode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.string_normalization = True # pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            ""        self.options = [ # pragma: no cover"",
            ""            Preview.hex_codes_in_unicode_sequences, # pragma: no cover"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly, # pragma: no cover"",
            ""            Preview.long_docstring_quotes_on_newline # pragma: no cover"",
            ""        ] # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def __contains__(self, item): # pragma: no cover"",
            ""        return item in self.options # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockCurrentLine: # pragma: no cover"",
            ""    def __init__(self, depth): # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockSelf: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.mode = MockMode() # pragma: no cover"",
            ""        self.current_line = MockCurrentLine(1) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def visit_default(self, leaf): # pragma: no cover"",
            ""        pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = MockSelf() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, value): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = MockLeaf('\""\""\""Example docstring.\""\""\""') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring.strip() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""class Preview: # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences' # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly' # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockMode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.string_normalization = True # pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            ""        self.active_features = { # pragma: no cover"",
            ""            Preview.hex_codes_in_unicode_sequences, # pragma: no cover"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly, # pragma: no cover"",
            ""            Preview.long_docstring_quotes_on_newline # pragma: no cover"",
            ""        } # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def __contains__(self, item): # pragma: no cover"",
            ""        return item in self.active_features # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockCurrentLine: # pragma: no cover"",
            ""    def __init__(self, depth): # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockSelf: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.mode = MockMode() # pragma: no cover"",
            ""        self.current_line = MockCurrentLine(1) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def visit_default(self, leaf): # pragma: no cover"",
            ""        pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = MockSelf() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, value): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = Leaf('\""\""\""Example docstring.\""\""\""') # pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""Preview = type('MockPreview', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockMode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.options = { # pragma: no cover"",
            ""            'hex_codes_in_unicode_sequences': True, # pragma: no cover"",
            ""            'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""            'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""            'string_normalization': True, # pragma: no cover"",
            ""            'line_length': 80 # pragma: no cover"",
            ""        } # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def __contains__(self, item): # pragma: no cover"",
            ""        return self.options.get(item, False) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def __getattr__(self, item): # pragma: no cover"",
            ""        return self.options.get(item, None) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockCurrentLine: # pragma: no cover"",
            ""    depth = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Mock: # pragma: no cover"",
            ""    mode = MockMode() # pragma: no cover"",
            ""    current_line = MockCurrentLine() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def visit_default(self, leaf): # pragma: no cover"",
            ""        pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = Mock() # pragma: no cover"",
            "" # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, value): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = Leaf('\""\""\""Example docstring.\""\""\""') # pragma: no cover"",
            "" # pragma: no cover"",
            ""is_docstring = lambda leaf: True # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value # pragma: no cover"",
            ""get_string_prefix = lambda value: '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: '\\n' in leaf.value # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: docstring.strip() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""class Preview: # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences' # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly' # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Mode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.string_normalization = True # pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            ""        self.preview_features = [ # pragma: no cover"",
            ""            Preview.hex_codes_in_unicode_sequences, # pragma: no cover"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly, # pragma: no cover"",
            ""            Preview.long_docstring_quotes_on_newline # pragma: no cover"",
            ""        ] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, value): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CurrentLine: # pragma: no cover"",
            ""    def __init__(self, depth): # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Self: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.mode = Mode() # pragma: no cover"",
            ""        self.current_line = CurrentLine(2) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def visit_default(self, leaf): # pragma: no cover"",
            ""        pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = Self() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = Leaf(value='\""\""\""This is a sample docstring.\""\""\""') # pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""Preview = type('Preview', (object,), { # pragma: no cover"",
            ""  'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""  'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""  'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockMode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.string_normalization = True # pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def __contains__(self, item): # pragma: no cover"",
            ""        return item in [ # pragma: no cover"",
            ""            Preview.hex_codes_in_unicode_sequences, # pragma: no cover"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly, # pragma: no cover"",
            ""            Preview.long_docstring_quotes_on_newline # pragma: no cover"",
            ""        ] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockCurrentLine: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.depth = 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockSelf: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.mode = MockMode() # pragma: no cover"",
            ""        self.current_line = MockCurrentLine() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def visit_default(self, leaf): # pragma: no cover"",
            ""        pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = MockSelf() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, value): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = MockLeaf('\""\""\""This is a docstring.\""\""\""') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return leaf.value.startswith(('\""\""\""', \""'''\"")) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""Preview = type('MockPreview', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockMode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.string_normalization = True # pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            ""        self.Options = { # pragma: no cover"",
            ""            Preview.hex_codes_in_unicode_sequences: True, # pragma: no cover"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly: True, # pragma: no cover"",
            ""            Preview.long_docstring_quotes_on_newline: True # pragma: no cover"",
            ""        } # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def __contains__(self, item): # pragma: no cover"",
            ""        return self.Options.get(item, False) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('MockSelf', (object,), { # pragma: no cover"",
            ""    'mode': MockMode(), # pragma: no cover"",
            ""    'current_line': type('MockLine', (object,), { # pragma: no cover"",
            ""        'depth': 2 # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'visit_default': lambda self, leaf: None # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""is_docstring = lambda leaf: True # pragma: no cover"",
            "" # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            "" # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value # pragma: no cover"",
            "" # pragma: no cover"",
            ""get_string_prefix = lambda value: '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""is_multiline_string = lambda leaf: False # pragma: no cover"",
            "" # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: docstring # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""class Preview: # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 'hex_codes_in_unicode_sequences' # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 'normalize_docstring_quotes_and_prefixes_properly' # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 'long_docstring_quotes_on_newline' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockMode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.string_normalization = True # pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            ""        self.options = { # pragma: no cover"",
            ""            'hex_codes_in_unicode_sequences': True, # pragma: no cover"",
            ""            'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""            'long_docstring_quotes_on_newline': True # pragma: no cover"",
            ""        } # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def __contains__(self, item): # pragma: no cover"",
            ""        return self.options.get(item, False) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockCurrentLine: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.depth = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockSelf: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.mode = MockMode() # pragma: no cover"",
            ""        self.current_line = MockCurrentLine() # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def visit_default(self, leaf): # pragma: no cover"",
            ""        pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = MockSelf() # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'value': 'mock_docstring'})() # pragma: no cover"",
            ""is_docstring = lambda leaf: True # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value # pragma: no cover"",
            ""get_string_prefix = lambda value: '' # pragma: no cover"",
            ""is_multiline_string = lambda leaf: True # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: docstring.strip() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""Preview = type('Preview', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Mode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.string_normalization = True # pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            ""        self.options = [ # pragma: no cover"",
            ""            'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""            'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""            'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""        ] # pragma: no cover"",
            ""    def __contains__(self, item): # pragma: no cover"",
            ""        return item in self.options # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CurrentLine: # pragma: no cover"",
            ""    def __init__(self, depth): # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Self: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.mode = Mode() # pragma: no cover"",
            ""        self.current_line = CurrentLine(2) # pragma: no cover"",
            ""    def visit_default(self, leaf): # pragma: no cover"",
            ""        pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = Self() # pragma: no cover"",
            "" # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, value): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = Leaf('\""\""\""Example docstring.\""\""\""') # pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""Preview = type('Mock', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': 'mock_hex_codes', # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': 'mock_normalize_prefixes', # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': 'mock_long_quotes' # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockMode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.options = [ # pragma: no cover"",
            ""            'hex_codes_in_unicode_sequences', # pragma: no cover"",
            ""            'normalize_docstring_quotes_and_prefixes_properly', # pragma: no cover"",
            ""            'long_docstring_quotes_on_newline' # pragma: no cover"",
            ""        ] # pragma: no cover"",
            ""        self.string_normalization = True # pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            ""    def __contains__(self, item): # pragma: no cover"",
            ""        return item in self.options # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockSelf: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.mode = MockMode() # pragma: no cover"",
            ""        self.current_line = type('MockLine', (object,), {'depth': 2})() # pragma: no cover"",
            ""    def visit_default(self, leaf): # pragma: no cover"",
            ""        return None # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = MockSelf() # pragma: no cover"",
            "" # pragma: no cover"",
            ""normalize_unicode_escape_sequences = lambda leaf: None # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Sample docstring.\""\""\""'})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""is_docstring = lambda leaf: True # pragma: no cover"",
            "" # pragma: no cover"",
            ""normalize_string_prefix = lambda value: value # pragma: no cover"",
            "" # pragma: no cover"",
            ""normalize_string_quotes = lambda value: value # pragma: no cover"",
            "" # pragma: no cover"",
            ""get_string_prefix = lambda value: '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""is_multiline_string = lambda leaf: True # pragma: no cover"",
            "" # pragma: no cover"",
            ""fix_docstring = lambda docstring, indent: docstring.strip() # pragma: no cover""
        ]
    }
]",2,11434,0.005717,4635,0.0069525,0.0126695
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
if Preview.hex_codes_in_unicode_sequences in self.mode:
    normalize_unicode_escape_sequences(leaf)
if is_docstring(leaf) and ""\\\n"" not in leaf.value:
    # We're ignoring docstrings with backslash newline escapes because changing
    # indentation of those changes the AST representation of the code.
    if Preview.normalize_docstring_quotes_and_prefixes_properly in self.mode:
        # There was a bug where --skip-string-normalization wouldn't stop us
        # from normalizing docstring prefixes. To maintain stability, we can
        # only address this buggy behaviour while the preview style is enabled.
        if self.mode.string_normalization:
            docstring = normalize_string_prefix(leaf.value)
            # visit_default() does handle string normalization for us, but
            # since this method acts differently depending on quote style (ex.
            # see padding logic below), there's a possibility for unstable
            # formatting as visit_default() is called *after*. To avoid a
            # situation where this function formats a docstring differently on
            # the second pass, normalize it early.
            docstring = normalize_string_quotes(docstring)
        else: # uncovered
            docstring = leaf.value
    else: # uncovered
        # ... otherwise, we'll keep the buggy behaviour >.<
        docstring = normalize_string_prefix(leaf.value)
    prefix = get_string_prefix(docstring)
    docstring = docstring[len(prefix) :]  # Remove the prefix
    quote_char = docstring[0]
    # A natural way to remove the outer quotes is to do:
    #   docstring = docstring.strip(quote_char)
    # but that breaks on """"""""""x"""""" (which is '""""x').
    # So we actually need to remove the first character and the next two
    # characters but only if they are the same as the first.
    quote_len = 1 if docstring[1] != quote_char else 3
    docstring = docstring[quote_len:-quote_len]
    docstring_started_empty = not docstring
    indent = "" "" * 4 * self.current_line.depth
    if is_multiline_string(leaf):
        docstring = fix_docstring(docstring, indent)
    else: # uncovered
        docstring = docstring.strip()
    has_trailing_backslash = False
    if docstring:
        # Add some padding if the docstring starts / ends with a quote mark.
        if docstring[0] == quote_char: # uncovered
            docstring = "" "" + docstring # uncovered
        if docstring[-1] == quote_char: # uncovered
            docstring += "" "" # uncovered
        if docstring[-1] == ""\\"": # uncovered
            backslash_count = len(docstring) - len(docstring.rstrip(""\\"")) # uncovered
            if backslash_count % 2: # uncovered
                # Odd number of tailing backslashes, add some padding to
                # avoid escaping the closing string quote.
                docstring += "" "" # uncovered
                has_trailing_backslash = True # uncovered
    elif not docstring_started_empty: # uncovered
        docstring = "" "" # uncovered
    # We could enforce triple quotes at this point.
    quote = quote_char * quote_len
    # It's invalid to put closing single-character quotes on a new line.
    if Preview.long_docstring_quotes_on_newline in self.mode and quote_len == 3:
        # We need to find the length of the last line of the docstring
        # to find if we can add the closing quotes to the line without
        # exceeding the maximum line length.
        # If docstring is one line, we don't put the closing quotes on a
        # separate line because it looks ugly (#3320).
        lines = docstring.splitlines()
        last_line_length = len(lines[-1]) if docstring else 0
        # If adding closing quotes would cause the last line to exceed
        # the maximum line length then put a line break before the
        # closing quotes
        if ( # uncovered
            len(lines) > 1 # uncovered
            and last_line_length + quote_len > self.mode.line_length # uncovered
            and len(indent) + quote_len <= self.mode.line_length # uncovered
            and not has_trailing_backslash # uncovered
        ): # uncovered
            leaf.value = prefix + quote + docstring + ""\n"" + indent + quote # uncovered
        else: # uncovered
            leaf.value = prefix + quote + docstring + quote
    else: # uncovered
        leaf.value = prefix + quote + docstring + quote
aux = self.visit_default(leaf)
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import re"",
            ""from typing import NamedTuple""
        ],
        ""initialization"": [
            ""class Preview(NamedTuple):"",
            ""    hex_codes_in_unicode_sequences: bool = True"",
            ""    normalize_docstring_quotes_and_prefixes_properly: bool = True"",
            ""    long_docstring_quotes_on_newline: bool = True"",
            """",
            ""def normalize_unicode_escape_sequences(string):"",
            ""    return re.sub(r'\\\\u([0-9A-Fa-f]{4})', lambda m: chr(int(m.group(1), 16)), string)"",
            """",
            ""def is_docstring(leaf):"",
            ""    return isinstance(leaf, type('Mock', (object,), {})) and leaf.value.startswith('\""\""\""') and leaf.value.endswith('\""\""\""')"",
            """",
            ""def normalize_string_prefix(string):"",
            ""    return string"",
            """",
            ""def normalize_string_quotes(string):"",
            ""    return string.strip('\""')"",
            """",
            ""def get_string_prefix(string):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n'))"",
            """",
            ""def visit_default(leaf):"",
            ""    pass"",
            """",
            ""self = type('Mock', (object,), {"",
            ""    'mode': Preview(hex_codes_in_unicode_sequences=False, normalize_docstring_quotes_and_prefixes_properly=True, long_docstring_quotes_on_newline=True),"",
            ""    'current_line': type('Mock', (object,), {'depth': 1})(),"",
            ""    'visit_default': visit_default,"",
            ""})()"",
            """",
            ""leaf = type('Mock', (object,), {'value': '\""\""\""This is a test\\ndocstring\""\""\""'})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum"",
            ""class MockMode: pass"",
            ""class MockLeaf: pass"",
            ""class MockCurrentLine: pass"",
            ""def normalize_unicode_escape_sequences(x): pass"",
            ""def is_docstring(x): return True"",
            ""def normalize_string_prefix(x): return x"",
            ""def normalize_string_quotes(x): return x"",
            ""def get_string_prefix(x): return ''"",
            ""def is_multiline_string(x): return False"",
            ""def fix_docstring(x, y): return x""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = MockMode()"",
            ""self.mode.hex_codes_in_unicode_sequences = True"",
            ""self.mode.normalize_docstring_quotes_and_prefixes_properly = True"",
            ""self.mode.long_docstring_quotes_on_newline = True"",
            ""self.mode.line_length = 80"",
            ""self.mode.string_normalization = False"",
            ""self.current_line = MockCurrentLine()"",
            ""self.current_line.depth = 0"",
            ""leaf = MockLeaf()"",
            ""leaf.value = '\""\""\""This is a docstring.\""\""\""'"",
            ""self.visit_default = lambda x: 'default_visited'""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum"",
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            ""class MockMode:"",
            ""    def __init__(self):"",
            ""        self.line_length = 88"",
            ""        self.string_normalization = False""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, value, current_line_depth):"",
            ""        self.value = value"",
            ""        self.current_line = type('CurrentLine', (object,), {'depth': current_line_depth})"",
            ""self = type('Mock', (object,), {"",
            ""    'mode': MockMode(),"",
            ""    'visit_default': lambda leaf: None"",
            ""})()"",
            ""leaf = MockLeaf('\""\""\""Example docstring.\""\""\""', 1)""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum"",
            ""import re""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(string):"",
            ""    return string"",
            """",
            ""def normalize_string_quotes(string):"",
            ""    return string"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""def get_string_prefix(string):"",
            ""    match = re.match(r'^[uUrfRbB]*', string)"",
            ""    return match.group(0) if match else ''"",
            """",
            ""class MockLeaf:"",
            ""    def __init__(self, value):"",
            ""        self.value = value"",
            """",
            ""class MockMode:"",
            ""    def __init__(self):"",
            ""        self.line_length = 80"",
            ""        self.string_normalization = False"",
            """",
            ""class MockSelf:"",
            ""    def __init__(self):"",
            ""        self.mode = {"",
            ""            Preview.hex_codes_in_unicode_sequences: True,"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly: True,"",
            ""            Preview.long_docstring_quotes_on_newline: True"",
            ""        }"",
            ""        self.current_line = type('Line', (object,), {'depth': 1})()"",
            ""    "",
            ""    def visit_default(self, leaf):"",
            ""        return 'default'"",
            """",
            ""self = MockSelf()"",
            ""leaf = MockLeaf('\""\""\""Some example docstring\\nwith multiple lines.\\\""\""\""')""
        ]
    },
    {
        ""imports"": [
            ""import re"",
            ""from enum import Enum"",
            ""from typing import Any, List, Dict, Union""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf: Any) -> None: pass"",
            """",
            ""def is_docstring(leaf: Any) -> bool: return True"",
            """",
            ""def normalize_string_prefix(value: str) -> str: return value"",
            """",
            ""def normalize_string_quotes(value: str) -> str: return value"",
            """",
            ""def get_string_prefix(value: str) -> str: return ''"",
            """",
            ""def is_multiline_string(leaf: Any) -> bool: return False"",
            """",
            ""def fix_docstring(docstring: str, indent: str) -> str: return docstring"",
            """",
            ""class MockLeaf:"",
            ""    def __init__(self, value: str):"",
            ""        self.value = value"",
            """",
            ""class MockMode:"",
            ""    def __init__(self):"",
            ""        self.string_normalization = False"",
            ""        self.line_length = 80"",
            """",
            ""class Mock:"",
            ""    def __init__(self):"",
            ""        self.mode = MockMode()"",
            ""        self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""    def visit_default(self, leaf: Any) -> None: pass"",
            """",
            ""mock = Mock()"",
            ""leaf = MockLeaf('\""\""\""docstring\""\""\""')"",
            """"
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class MockMode:"",
            ""    def __init__(self):"",
            ""        self.hex_codes_in_unicode_sequences = False"",
            ""        self.normalize_docstring_quotes_and_prefixes_properly = True"",
            ""        self.long_docstring_quotes_on_newline = False"",
            ""        self.string_normalization = False"",
            ""        self.line_length = 80"",
            """",
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = auto()"",
            ""    normalize_docstring_quotes_and_prefixes_properly = auto()"",
            ""    long_docstring_quotes_on_newline = auto()"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return \""\"""",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return False"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""class Leaf:"",
            ""    def __init__(self, value):"",
            ""        self.value = value"",
            """",
            ""self = type(\""Mock\"", (object,), {"",
            ""    \""mode\"": MockMode(),"",
            ""    \""current_line\"": type(\""CurrentLine\"", (object,), {\""depth\"": 1})(),"",
            ""    \""visit_default\"": lambda leaf: None"",
            ""})()"",
            """",
            ""leaf = Leaf(\""\""\""\""\""\""Some docstring value\""\""\"")""
        ]
    },
    {
        ""imports"": [
            ""import re"",
            ""from typing import List, Dict, Any, Tuple""
        ],
        ""initialization"": [
            ""class Mock:"",
            ""    def __init__(self, **kwargs):"",
            ""        self.__dict__.update(kwargs)"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf) -> bool:"",
            ""    return isinstance(leaf, Mock) and isinstance(leaf.value, str) and leaf.value.startswith('\""')"",
            """",
            ""def normalize_string_prefix(value: str) -> str:"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value: str) -> str:"",
            ""    return value"",
            """",
            ""def fix_docstring(docstring: str, indent: str) -> str:"",
            ""    return docstring"",
            """",
            ""def is_multiline_string(leaf: Mock) -> bool:"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def get_string_prefix(value: str) -> str:"",
            ""    match = re.match(r'^[ubr]*', value, re.I)"",
            ""    return match.group(0) if match else ''"",
            """",
            ""def visit_default(leaf: Mock):"",
            ""    return leaf"",
            """",
            ""Preview = type('Preview', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': True,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True"",
            ""})"",
            """",
            ""class Mode:"",
            ""    def __init__(self):"",
            ""        self.string_normalization = False"",
            ""        self.line_length = 88"",
            ""        self.hex_codes_in_unicode_sequences = True"",
            ""        self.normalize_docstring_quotes_and_prefixes_properly = True"",
            ""        self.long_docstring_quotes_on_newline = True"",
            """",
            ""self = Mock("",
            ""    mode=Mode(),"",
            ""    current_line=Mock(depth=1),"",
            ""    visit_default=visit_default"",
            "")"",
            """",
            ""leaf = Mock("",
            ""    value='\""\""\""some docstring\""\""\""'"",
            "")""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum"",
            ""import types""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(docstring):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return False"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': Preview.hex_codes_in_unicode_sequences,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': Preview.normalize_docstring_quotes_and_prefixes_properly,"",
            ""    'long_docstring_quotes_on_newline': Preview.long_docstring_quotes_on_newline,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 88"",
            ""})"",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""Sample docstring\""\""\""',"",
            ""    'depth': 1"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""self.visit_default = types.MethodType(lambda self, leaf: None, self)""
        ]
    },
    {
        ""imports"": [
            ""from unittest.mock import Mock""
        ],
        ""initialization"": [
            ""Preview = type('PreviewMock', (object,), {'hex_codes_in_unicode_sequences': 1, 'normalize_docstring_quotes_and_prefixes_properly': 2, 'long_docstring_quotes_on_newline': 3})"",
            ""self = Mock()"",
            ""self.mode = Mock()"",
            ""self.mode.line_length = 79"",
            ""self.mode.string_normalization = False"",
            ""self.current_line = Mock()"",
            ""self.current_line.depth = 1"",
            ""leaf = Mock()"",
            ""leaf.value = '\""\""\""\nThis is a sample docstring.\n\""\""\""'"",
            ""def is_docstring(leaf): return True"",
            ""def is_multiline_string(leaf): return True"",
            ""def fix_docstring(docstring, indent): return docstring"",
            ""def normalize_unicode_escape_sequences(leaf): pass"",
            ""def normalize_string_prefix(value): return value"",
            ""def normalize_string_quotes(value): return value"",
            ""def get_string_prefix(docstring): return ''"",
            ""self.mode.line_length = 79"",
            ""self.visit_default = lambda leaf: None""
        ]
    },
    {
        ""imports"": [
            ""import enum""
        ],
        ""initialization"": [
            ""class Preview(enum.Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            ""class Leaf:"",
            ""    def __init__(self, value, depth=0):"",
            ""        self.value = value"",
            ""        self.depth = depth"",
            ""def is_docstring(leaf):"",
            ""    return leaf.value.startswith('\""\""\""') or leaf.value.startswith('\""')"",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            ""class Mode:"",
            ""    def __init__(self):"",
            ""        self.string_normalization = False"",
            ""        self.line_length = 88"",
            ""self = type('Mock', (object,), {"",
            ""    'mode': Mode(),"",
            ""    'visit_default': lambda leaf: None"",
            ""})()"",
            ""leaf = Leaf('\""\""\""Example docstring\""\""\""')""
        ]
    }
]","[
    {
        ""imports"": [
            ""import re # pragma: no cover"",
            ""from typing import NamedTuple # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(NamedTuple): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences: bool = True # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly: bool = True # pragma: no cover"",
            ""    long_docstring_quotes_on_newline: bool = True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(string): # pragma: no cover"",
            ""    return re.sub(r'\\\\u([0-9A-Fa-f]{4})', lambda m: chr(int(m.group(1), 16)), string) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return isinstance(leaf, type('Mock', (object,), {})) and leaf.value.startswith('\""\""\""') and leaf.value.endswith('\""\""\""') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(string): # pragma: no cover"",
            ""    return string # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(string): # pragma: no cover"",
            ""    return string.strip('\""') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(string): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def visit_default(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), { # pragma: no cover"",
            ""    'mode': Preview(hex_codes_in_unicode_sequences=False, normalize_docstring_quotes_and_prefixes_properly=True, long_docstring_quotes_on_newline=True), # pragma: no cover"",
            ""    'current_line': type('Mock', (object,), {'depth': 1})(), # pragma: no cover"",
            ""    'visit_default': visit_default, # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = type('Mock', (object,), {'value': '\""\""\""This is a test\\ndocstring\""\""\""'})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover"",
            ""class MockMode: pass # pragma: no cover"",
            ""class MockLeaf: pass # pragma: no cover"",
            ""class MockCurrentLine: pass # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(x): pass # pragma: no cover"",
            ""def is_docstring(x): return True # pragma: no cover"",
            ""def normalize_string_prefix(x): return x # pragma: no cover"",
            ""def normalize_string_quotes(x): return x # pragma: no cover"",
            ""def get_string_prefix(x): return '' # pragma: no cover"",
            ""def is_multiline_string(x): return False # pragma: no cover"",
            ""def fix_docstring(x, y): return x # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = MockMode() # pragma: no cover"",
            ""self.mode.hex_codes_in_unicode_sequences = True # pragma: no cover"",
            ""self.mode.normalize_docstring_quotes_and_prefixes_properly = True # pragma: no cover"",
            ""self.mode.long_docstring_quotes_on_newline = True # pragma: no cover"",
            ""self.mode.line_length = 80 # pragma: no cover"",
            ""self.mode.string_normalization = False # pragma: no cover"",
            ""self.current_line = MockCurrentLine() # pragma: no cover"",
            ""self.current_line.depth = 0 # pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.value = '\""\""\""This is a docstring.\""\""\""' # pragma: no cover"",
            ""self.visit_default = lambda x: 'default_visited' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover"",
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            ""class MockMode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.line_length = 88 # pragma: no cover"",
            ""        self.string_normalization = False # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, value, current_line_depth): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.current_line = type('CurrentLine', (object,), {'depth': current_line_depth}) # pragma: no cover"",
            ""self = type('Mock', (object,), { # pragma: no cover"",
            ""    'mode': MockMode(), # pragma: no cover"",
            ""    'visit_default': lambda leaf: None # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""leaf = MockLeaf('\""\""\""Example docstring.\""\""\""', 1) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover"",
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(string): # pragma: no cover"",
            ""    return string # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(string): # pragma: no cover"",
            ""    return string # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(string): # pragma: no cover"",
            ""    match = re.match(r'^[uUrfRbB]*', string) # pragma: no cover"",
            ""    return match.group(0) if match else '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, value): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockMode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            ""        self.string_normalization = False # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockSelf: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.mode = { # pragma: no cover"",
            ""            Preview.hex_codes_in_unicode_sequences: True, # pragma: no cover"",
            ""            Preview.normalize_docstring_quotes_and_prefixes_properly: True, # pragma: no cover"",
            ""            Preview.long_docstring_quotes_on_newline: True # pragma: no cover"",
            ""        } # pragma: no cover"",
            ""        self.current_line = type('Line', (object,), {'depth': 1})() # pragma: no cover"",
            ""     # pragma: no cover"",
            ""    def visit_default(self, leaf): # pragma: no cover"",
            ""        return 'default' # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = MockSelf() # pragma: no cover"",
            ""leaf = MockLeaf('\""\""\""Some example docstring\\nwith multiple lines.\\\""\""\""') # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""from typing import Any, List, Dict, Union # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf: Any) -> None: pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf: Any) -> bool: return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value: str) -> str: return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value: str) -> str: return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value: str) -> str: return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf: Any) -> bool: return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring: str, indent: str) -> str: return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, value: str): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockMode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.string_normalization = False # pragma: no cover"",
            ""        self.line_length = 80 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Mock: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.mode = MockMode() # pragma: no cover"",
            ""        self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""    def visit_default(self, leaf: Any) -> None: pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""mock = Mock() # pragma: no cover"",
            ""leaf = MockLeaf('\""\""\""docstring\""\""\""') # pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover"",
            ""from typing import List, Dict, Any, Tuple # pragma: no cover""
        ],
        ""initialization"": [
            ""class Mock: # pragma: no cover"",
            ""    def __init__(self, **kwargs): # pragma: no cover"",
            ""        self.__dict__.update(kwargs) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf) -> bool: # pragma: no cover"",
            ""    return isinstance(leaf, Mock) and isinstance(leaf.value, str) and leaf.value.startswith('\""') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value: str) -> str: # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value: str) -> str: # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring: str, indent: str) -> str: # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf: Mock) -> bool: # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value: str) -> str: # pragma: no cover"",
            ""    match = re.match(r'^[ubr]*', value, re.I) # pragma: no cover"",
            ""    return match.group(0) if match else '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def visit_default(leaf: Mock): # pragma: no cover"",
            ""    return leaf # pragma: no cover"",
            "" # pragma: no cover"",
            ""Preview = type('Preview', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': True, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Mode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.string_normalization = False # pragma: no cover"",
            ""        self.line_length = 88 # pragma: no cover"",
            ""        self.hex_codes_in_unicode_sequences = True # pragma: no cover"",
            ""        self.normalize_docstring_quotes_and_prefixes_properly = True # pragma: no cover"",
            ""        self.long_docstring_quotes_on_newline = True # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = Mock( # pragma: no cover"",
            ""    mode=Mode(), # pragma: no cover"",
            ""    current_line=Mock(depth=1), # pragma: no cover"",
            ""    visit_default=visit_default # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = Mock( # pragma: no cover"",
            ""    value='\""\""\""some docstring\""\""\""' # pragma: no cover"",
            "") # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover"",
            ""import types # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(docstring): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': Preview.hex_codes_in_unicode_sequences, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': Preview.normalize_docstring_quotes_and_prefixes_properly, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': Preview.long_docstring_quotes_on_newline, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 88 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""Sample docstring\""\""\""', # pragma: no cover"",
            ""    'depth': 1 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""self.visit_default = types.MethodType(lambda self, leaf: None, self) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from unittest.mock import Mock # pragma: no cover""
        ],
        ""initialization"": [
            ""def is_docstring(leaf): return True # pragma: no cover"",
            ""def is_multiline_string(leaf): return True # pragma: no cover"",
            ""def fix_docstring(docstring, indent): return docstring # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): pass # pragma: no cover"",
            ""def normalize_string_prefix(value): return value # pragma: no cover"",
            ""def normalize_string_quotes(value): return value # pragma: no cover"",
            ""def get_string_prefix(docstring): return '' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(enum.Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, value, depth=0): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return leaf.value.startswith('\""\""\""') or leaf.value.startswith('\""') # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            ""class Mode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.string_normalization = False # pragma: no cover"",
            ""        self.line_length = 88 # pragma: no cover"",
            ""self = type('Mock', (object,), { # pragma: no cover"",
            ""    'mode': Mode(), # pragma: no cover"",
            ""    'visit_default': lambda leaf: None # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""leaf = Leaf('\""\""\""Example docstring\""\""\""') # pragma: no cover""
        ]
    }
]",3,1281,0.0006405,3797,0.0056955,0.006336
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
if Preview.hex_codes_in_unicode_sequences in self.mode:
    normalize_unicode_escape_sequences(leaf)
if is_docstring(leaf) and ""\\\n"" not in leaf.value:
    # We're ignoring docstrings with backslash newline escapes because changing
    # indentation of those changes the AST representation of the code.
    if Preview.normalize_docstring_quotes_and_prefixes_properly in self.mode:
        # There was a bug where --skip-string-normalization wouldn't stop us
        # from normalizing docstring prefixes. To maintain stability, we can
        # only address this buggy behaviour while the preview style is enabled.
        if self.mode.string_normalization:
            docstring = normalize_string_prefix(leaf.value)
            # visit_default() does handle string normalization for us, but
            # since this method acts differently depending on quote style (ex.
            # see padding logic below), there's a possibility for unstable
            # formatting as visit_default() is called *after*. To avoid a
            # situation where this function formats a docstring differently on
            # the second pass, normalize it early.
            docstring = normalize_string_quotes(docstring)
        else: # uncovered
            docstring = leaf.value
    else: # uncovered
        # ... otherwise, we'll keep the buggy behaviour >.<
        docstring = normalize_string_prefix(leaf.value)
    prefix = get_string_prefix(docstring)
    docstring = docstring[len(prefix) :]  # Remove the prefix
    quote_char = docstring[0]
    # A natural way to remove the outer quotes is to do:
    #   docstring = docstring.strip(quote_char)
    # but that breaks on """"""""""x"""""" (which is '""""x').
    # So we actually need to remove the first character and the next two
    # characters but only if they are the same as the first.
    quote_len = 1 if docstring[1] != quote_char else 3
    docstring = docstring[quote_len:-quote_len]
    docstring_started_empty = not docstring
    indent = "" "" * 4 * self.current_line.depth
    if is_multiline_string(leaf):
        docstring = fix_docstring(docstring, indent)
    else: # uncovered
        docstring = docstring.strip()
    has_trailing_backslash = False
    if docstring:
        # Add some padding if the docstring starts / ends with a quote mark.
        if docstring[0] == quote_char: # uncovered
            docstring = "" "" + docstring # uncovered
        if docstring[-1] == quote_char: # uncovered
            docstring += "" "" # uncovered
        if docstring[-1] == ""\\"": # uncovered
            backslash_count = len(docstring) - len(docstring.rstrip(""\\"")) # uncovered
            if backslash_count % 2: # uncovered
                # Odd number of tailing backslashes, add some padding to
                # avoid escaping the closing string quote.
                docstring += "" "" # uncovered
                has_trailing_backslash = True # uncovered
    elif not docstring_started_empty: # uncovered
        docstring = "" "" # uncovered
    # We could enforce triple quotes at this point.
    quote = quote_char * quote_len
    # It's invalid to put closing single-character quotes on a new line.
    if Preview.long_docstring_quotes_on_newline in self.mode and quote_len == 3:
        # We need to find the length of the last line of the docstring
        # to find if we can add the closing quotes to the line without
        # exceeding the maximum line length.
        # If docstring is one line, we don't put the closing quotes on a
        # separate line because it looks ugly (#3320).
        lines = docstring.splitlines()
        last_line_length = len(lines[-1]) if docstring else 0
        # If adding closing quotes would cause the last line to exceed
        # the maximum line length then put a line break before the
        # closing quotes
        if ( # uncovered
            len(lines) > 1 # uncovered
            and last_line_length + quote_len > self.mode.line_length # uncovered
            and len(indent) + quote_len <= self.mode.line_length # uncovered
            and not has_trailing_backslash # uncovered
        ): # uncovered
            leaf.value = prefix + quote + docstring + ""\n"" + indent + quote # uncovered
        else: # uncovered
            leaf.value = prefix + quote + docstring + quote
    else: # uncovered
        leaf.value = prefix + quote + docstring + quote
aux = self.visit_default(leaf)
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(docstring):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return False"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': True,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 80"",
            ""})"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""self.visit_default = lambda leaf: None"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""A \""docstring\"" with a backslash at the end\\\\\""\""\""'})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return leaf is not None and isinstance(leaf.value, str) and leaf.value.startswith('\""\""\""')"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {})()"",
            ""self.mode.string_normalization = False"",
            ""self.mode.line_length = 80"",
            ""self.mode.__contains__ = lambda x: True"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""self.visit_default = lambda leaf: 'Visited'"",
            """",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum"",
            ""import re""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return leaf.value.startswith('\""\""\""') and leaf.value.endswith('\""\""\""')"",
            """",
            ""def normalize_string_prefix(string):"",
            ""    return string"",
            """",
            ""def normalize_string_quotes(string):"",
            ""    return string"",
            """",
            ""def get_string_prefix(string):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n'))"",
            """",
            ""def visit_default(leaf):"",
            ""    pass"",
            """",
            ""self = type('Mock', (object,), {"",
            ""    'mode': {"",
            ""        Preview.hex_codes_in_unicode_sequences: False,"",
            ""        Preview.normalize_docstring_quotes_and_prefixes_properly: True,"",
            ""        Preview.long_docstring_quotes_on_newline: True"",
            ""    },"",
            ""    'current_line': type('Mock', (object,), {'depth': 1})(),"",
            ""    'visit_default': visit_default,"",
            ""    'mode.string_normalization': False,"",
            ""    'mode.line_length': 80"",
            ""})()"",
            """",
            ""leaf = type('Mock', (object,), {'value': '\""\""\""This is a test docstring.\""\""\""'})()""
        ]
    },
    {
        ""imports"": [
            ""import re"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return True"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""def visit_default(leaf):"",
            ""    return 'default_visited'"",
            """",
            ""class MockMode:"",
            ""    def __init__(self):"",
            ""        self.line_length = 40"",
            ""        self.string_normalization = False"",
            ""        self.hex_codes_in_unicode_sequences = True"",
            ""        self.normalize_docstring_quotes_and_prefixes_properly = True"",
            ""        self.long_docstring_quotes_on_newline = True"",
            """",
            ""class MockLine:"",
            ""    def __init__(self, depth):"",
            ""        self.depth = depth"",
            """",
            ""class MockLeaf:"",
            ""    def __init__(self, value):"",
            ""        self.value = value"",
            """",
            ""self = type('MockSelf', (object,), {"",
            ""    'mode': MockMode(),"",
            ""    'current_line': MockLine(1),"",
            ""    'visit_default': visit_default"",
            ""})()"",
            """",
            ""leaf = MockLeaf('\""\""\""Sample Docstring Line 1\\n\""\""\""')""
        ]
    },
    {
        ""imports"": [
            ""import re"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return leaf.value.startswith('\""\""\""')"",
            """",
            ""def normalize_string_prefix(string):"",
            ""    return string"",
            """",
            ""def normalize_string_quotes(string):"",
            ""    return string"",
            """",
            ""def get_string_prefix(string):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""def visit_default(leaf):"",
            ""    return 'visited_default'"",
            """",
            ""self = type('Mock', (object,), {"",
            ""    'mode': type('MockMode', (object,), {"",
            ""        'hex_codes_in_unicode_sequences': False,"",
            ""        'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""        'long_docstring_quotes_on_newline': True,"",
            ""        'string_normalization': False,"",
            ""        'line_length': 79"",
            ""    })(),"",
            ""    'current_line': type('CurrentLine', (object,), {'depth': 1})(),"",
            ""    'visit_default': visit_default"",
            ""})()"",
            """",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""sample docstring\""\""\""'})()""
        ]
    },
    {
        ""imports"": [
            ""import re"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return isinstance(leaf, type('Mock', (object,), {})) and leaf.value.startswith('\""\""\""')"",
            """",
            ""def normalize_string_prefix(string):"",
            ""    return string"",
            """",
            ""def normalize_string_quotes(string):"",
            ""    return string.strip('\""')"",
            """",
            ""def get_string_prefix(string):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n'))"",
            """",
            ""def visit_default(leaf):"",
            ""    pass"",
            """",
            ""self = type('Mock', (object,), {"",
            ""    'mode': type('Mode', (object,), {"",
            ""        'hex_codes_in_unicode_sequences': False,"",
            ""        'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""        'long_docstring_quotes_on_newline': True,"",
            ""        'string_normalization': False,"",
            ""        'line_length': 50,"",
            ""    })(),"",
            ""    'current_line': type('Line', (object,), {'depth': 1})(),"",
            ""    'visit_default': visit_default"",
            ""})()"",
            """",
            ""leaf = type('Mock', (object,), {'value': '\""\""\""A short line docstring with long ending part that might need wrapping.\""\""\""'})()""
        ]
    },
    {
        ""imports"": [
            ""import re"",
            ""from typing import Any, Dict""
        ],
        ""initialization"": [
            ""class Preview:"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf: Any) -> None:"",
            ""    pass"",
            """",
            ""def is_docstring(leaf: Any) -> bool:"",
            ""    return isinstance(leaf, type('Mock', (object,), {})) and isinstance(leaf.value, str) and leaf.value.startswith('\""')"",
            """",
            ""def normalize_string_prefix(value: str) -> str:"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value: str) -> str:"",
            ""    return value"",
            """",
            ""def fix_docstring(docstring: str, indent: str) -> str:"",
            ""    return docstring"",
            """",
            ""def get_string_prefix(value: str) -> str:"",
            ""    match = re.match(r'^[ubr]*', value, re.I)"",
            ""    return match.group(0) if match else ''"",
            """",
            ""def is_multiline_string(leaf: Any) -> bool:"",
            ""    return '\\n' in leaf.value"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': Preview.hex_codes_in_unicode_sequences,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': Preview.normalize_docstring_quotes_and_prefixes_properly,"",
            ""    'long_docstring_quotes_on_newline': Preview.long_docstring_quotes_on_newline,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 80"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""self.visit_default = lambda leaf: None"",
            """",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""Example docstring.\""\""\""'"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""import re"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(string):"",
            ""    return string"",
            """",
            ""def normalize_string_quotes(string):"",
            ""    return string.strip('\""')"",
            """",
            ""def get_string_prefix(string):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n'))"",
            """",
            ""def visit_default(leaf):"",
            ""    pass"",
            """",
            ""self = type('Mock', (object,), {"",
            ""    'mode': type('Mode', (object,), {"",
            ""        'hex_codes_in_unicode_sequences': False,"",
            ""        'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""        'long_docstring_quotes_on_newline': True,"",
            ""        'line_length': 80,"",
            ""        'string_normalization': False"",
            ""    })(),"",
            ""    'current_line': type('Line', (object,), {"",
            ""        'depth': 2"",
            ""    })(),"",
            ""    'visit_default': visit_default"",
            ""})()"",
            """",
            ""leaf = type('Leaf', (object,), {"",
            ""    'value': '\""\""\""This is an example docstring.\""\""\""'"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return False"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {"",
            ""    'mode': {"",
            ""        Preview.hex_codes_in_unicode_sequences: False,"",
            ""        Preview.normalize_docstring_quotes_and_prefixes_properly: True,"",
            ""        Preview.long_docstring_quotes_on_newline: True"",
            ""    },"",
            ""    'current_line': type('LineDepth', (object,), {'depth': 1})(),"",
            ""    'visit_default': lambda leaf: None"",
            ""})()"",
            """",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""Some example docstring\\nwith multiple lines.\""\""\""'"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""import re"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return False"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': True,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 80"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})()"",
            ""self.visit_default = lambda leaf: None""
        ]
    }
]","[
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(docstring): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': True, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 80 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: None # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""A \""docstring\"" with a backslash at the end\\\\\""\""\""'})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return leaf is not None and isinstance(leaf.value, str) and leaf.value.startswith('\""\""\""') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), {})() # pragma: no cover"",
            ""self.mode.string_normalization = False # pragma: no cover"",
            ""self.mode.line_length = 80 # pragma: no cover"",
            ""self.mode.__contains__ = lambda x: True # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover"",
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return leaf.value.startswith('\""\""\""') and leaf.value.endswith('\""\""\""') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(string): # pragma: no cover"",
            ""    return string # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(string): # pragma: no cover"",
            ""    return string # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(string): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def visit_default(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), { # pragma: no cover"",
            ""    'mode': { # pragma: no cover"",
            ""        Preview.hex_codes_in_unicode_sequences: False, # pragma: no cover"",
            ""        Preview.normalize_docstring_quotes_and_prefixes_properly: True, # pragma: no cover"",
            ""        Preview.long_docstring_quotes_on_newline: True # pragma: no cover"",
            ""    }, # pragma: no cover"",
            ""    'current_line': type('Mock', (object,), {'depth': 1})(), # pragma: no cover"",
            ""    'visit_default': visit_default, # pragma: no cover"",
            ""    'mode.string_normalization': False, # pragma: no cover"",
            ""    'mode.line_length': 80 # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = type('Mock', (object,), {'value': '\""\""\""This is a test docstring.\""\""\""'})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""def visit_default(leaf): # pragma: no cover"",
            ""    return 'default_visited' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockMode: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.line_length = 40 # pragma: no cover"",
            ""        self.string_normalization = False # pragma: no cover"",
            ""        self.hex_codes_in_unicode_sequences = True # pragma: no cover"",
            ""        self.normalize_docstring_quotes_and_prefixes_properly = True # pragma: no cover"",
            ""        self.long_docstring_quotes_on_newline = True # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLine: # pragma: no cover"",
            ""    def __init__(self, depth): # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, value): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('MockSelf', (object,), { # pragma: no cover"",
            ""    'mode': MockMode(), # pragma: no cover"",
            ""    'current_line': MockLine(1), # pragma: no cover"",
            ""    'visit_default': visit_default # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = MockLeaf('\""\""\""Sample Docstring Line 1\\n\""\""\""') # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return leaf.value.startswith('\""\""\""') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(string): # pragma: no cover"",
            ""    return string # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(string): # pragma: no cover"",
            ""    return string # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(string): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""def visit_default(leaf): # pragma: no cover"",
            ""    return 'visited_default' # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), { # pragma: no cover"",
            ""    'mode': type('MockMode', (object,), { # pragma: no cover"",
            ""        'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""        'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""        'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""        'string_normalization': False, # pragma: no cover"",
            ""        'line_length': 79 # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'current_line': type('CurrentLine', (object,), {'depth': 1})(), # pragma: no cover"",
            ""    'visit_default': visit_default # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""sample docstring\""\""\""'})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return isinstance(leaf, type('Mock', (object,), {})) and leaf.value.startswith('\""\""\""') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(string): # pragma: no cover"",
            ""    return string # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(string): # pragma: no cover"",
            ""    return string.strip('\""') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(string): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def visit_default(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), { # pragma: no cover"",
            ""    'mode': type('Mode', (object,), { # pragma: no cover"",
            ""        'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""        'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""        'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""        'string_normalization': False, # pragma: no cover"",
            ""        'line_length': 50, # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'current_line': type('Line', (object,), {'depth': 1})(), # pragma: no cover"",
            ""    'visit_default': visit_default # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = type('Mock', (object,), {'value': '\""\""\""A short line docstring with long ending part that might need wrapping.\""\""\""'})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover"",
            ""from typing import Any, Dict # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview: # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf: Any) -> None: # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf: Any) -> bool: # pragma: no cover"",
            ""    return isinstance(leaf, type('Mock', (object,), {})) and isinstance(leaf.value, str) and leaf.value.startswith('\""') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value: str) -> str: # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value: str) -> str: # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring: str, indent: str) -> str: # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value: str) -> str: # pragma: no cover"",
            ""    match = re.match(r'^[ubr]*', value, re.I) # pragma: no cover"",
            ""    return match.group(0) if match else '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf: Any) -> bool: # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': Preview.hex_codes_in_unicode_sequences, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': Preview.normalize_docstring_quotes_and_prefixes_properly, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': Preview.long_docstring_quotes_on_newline, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 80 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: None # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""Example docstring.\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(string): # pragma: no cover"",
            ""    return string # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(string): # pragma: no cover"",
            ""    return string.strip('\""') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(string): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def visit_default(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), { # pragma: no cover"",
            ""    'mode': type('Mode', (object,), { # pragma: no cover"",
            ""        'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""        'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""        'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""        'line_length': 80, # pragma: no cover"",
            ""        'string_normalization': False # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'current_line': type('Line', (object,), { # pragma: no cover"",
            ""        'depth': 2 # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'visit_default': visit_default # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = type('Leaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""This is an example docstring.\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), { # pragma: no cover"",
            ""    'mode': { # pragma: no cover"",
            ""        Preview.hex_codes_in_unicode_sequences: False, # pragma: no cover"",
            ""        Preview.normalize_docstring_quotes_and_prefixes_properly: True, # pragma: no cover"",
            ""        Preview.long_docstring_quotes_on_newline: True # pragma: no cover"",
            ""    }, # pragma: no cover"",
            ""    'current_line': type('LineDepth', (object,), {'depth': 1})(), # pragma: no cover"",
            ""    'visit_default': lambda leaf: None # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""Some example docstring\\nwith multiple lines.\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': True, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 80 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring.\""\""\""'})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: None # pragma: no cover""
        ]
    }
]",3,6336,0.003168,4158,0.006237,0.009405
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
if Preview.hex_codes_in_unicode_sequences in self.mode:
    normalize_unicode_escape_sequences(leaf)
if is_docstring(leaf) and ""\\\n"" not in leaf.value:
    # We're ignoring docstrings with backslash newline escapes because changing
    # indentation of those changes the AST representation of the code.
    if Preview.normalize_docstring_quotes_and_prefixes_properly in self.mode:
        # There was a bug where --skip-string-normalization wouldn't stop us
        # from normalizing docstring prefixes. To maintain stability, we can
        # only address this buggy behaviour while the preview style is enabled.
        if self.mode.string_normalization:
            docstring = normalize_string_prefix(leaf.value)
            # visit_default() does handle string normalization for us, but
            # since this method acts differently depending on quote style (ex.
            # see padding logic below), there's a possibility for unstable
            # formatting as visit_default() is called *after*. To avoid a
            # situation where this function formats a docstring differently on
            # the second pass, normalize it early.
            docstring = normalize_string_quotes(docstring)
        else: # uncovered
            docstring = leaf.value
    else: # uncovered
        # ... otherwise, we'll keep the buggy behaviour >.<
        docstring = normalize_string_prefix(leaf.value)
    prefix = get_string_prefix(docstring)
    docstring = docstring[len(prefix) :]  # Remove the prefix
    quote_char = docstring[0]
    # A natural way to remove the outer quotes is to do:
    #   docstring = docstring.strip(quote_char)
    # but that breaks on """"""""""x"""""" (which is '""""x').
    # So we actually need to remove the first character and the next two
    # characters but only if they are the same as the first.
    quote_len = 1 if docstring[1] != quote_char else 3
    docstring = docstring[quote_len:-quote_len]
    docstring_started_empty = not docstring
    indent = "" "" * 4 * self.current_line.depth
    if is_multiline_string(leaf):
        docstring = fix_docstring(docstring, indent)
    else: # uncovered
        docstring = docstring.strip()
    has_trailing_backslash = False
    if docstring:
        # Add some padding if the docstring starts / ends with a quote mark.
        if docstring[0] == quote_char: # uncovered
            docstring = "" "" + docstring # uncovered
        if docstring[-1] == quote_char: # uncovered
            docstring += "" "" # uncovered
        if docstring[-1] == ""\\"": # uncovered
            backslash_count = len(docstring) - len(docstring.rstrip(""\\"")) # uncovered
            if backslash_count % 2: # uncovered
                # Odd number of tailing backslashes, add some padding to
                # avoid escaping the closing string quote.
                docstring += "" "" # uncovered
                has_trailing_backslash = True # uncovered
    elif not docstring_started_empty: # uncovered
        docstring = "" "" # uncovered
    # We could enforce triple quotes at this point.
    quote = quote_char * quote_len
    # It's invalid to put closing single-character quotes on a new line.
    if Preview.long_docstring_quotes_on_newline in self.mode and quote_len == 3:
        # We need to find the length of the last line of the docstring
        # to find if we can add the closing quotes to the line without
        # exceeding the maximum line length.
        # If docstring is one line, we don't put the closing quotes on a
        # separate line because it looks ugly (#3320).
        lines = docstring.splitlines()
        last_line_length = len(lines[-1]) if docstring else 0
        # If adding closing quotes would cause the last line to exceed
        # the maximum line length then put a line break before the
        # closing quotes
        if ( # uncovered
            len(lines) > 1 # uncovered
            and last_line_length + quote_len > self.mode.line_length # uncovered
            and len(indent) + quote_len <= self.mode.line_length # uncovered
            and not has_trailing_backslash # uncovered
        ): # uncovered
            leaf.value = prefix + quote + docstring + ""\n"" + indent + quote # uncovered
        else: # uncovered
            leaf.value = prefix + quote + docstring + quote
    else: # uncovered
        leaf.value = prefix + quote + docstring + quote
aux = self.visit_default(leaf)
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 80"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {"",
            ""    'depth': 1"",
            ""})()"",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""Short\""\""\""'"",
            ""})()"",
            ""self.visit_default = lambda leaf: None""
        ]
    },
    {
        ""imports"": [
            ""import re"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return leaf.value.startswith('\""\""\""') and leaf.value.endswith('\""\""\""')"",
            """",
            ""def normalize_string_prefix(string):"",
            ""    return string"",
            """",
            ""def normalize_string_quotes(string):"",
            ""    return string"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def get_string_prefix(string):"",
            ""    return ''"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n'))"",
            """",
            ""def visit_default(leaf):"",
            ""    return 'visited_default'"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': Preview.hex_codes_in_unicode_sequences,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': Preview.normalize_docstring_quotes_and_prefixes_properly,"",
            ""    'long_docstring_quotes_on_newline': Preview.long_docstring_quotes_on_newline,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 79"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""self.visit_default = visit_default"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""A \""docstring\"" with a backslash at the end\\\\\""\""\""'})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf): pass"",
            """",
            ""def is_docstring(leaf): return True"",
            """",
            ""def normalize_string_prefix(value): return value"",
            """",
            ""def normalize_string_quotes(value): return value"",
            """",
            ""def get_string_prefix(value): return ''"",
            """",
            ""def is_multiline_string(leaf): return False"",
            """",
            ""def fix_docstring(docstring, indent): return docstring"",
            """",
            ""self = type('Mock', (object,), {"",
            ""    'mode': type('MockMode', (object,), {"",
            ""        'hex_codes_in_unicode_sequences': False,"",
            ""        'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""        'long_docstring_quotes_on_newline': True,"",
            ""        'string_normalization': False,"",
            ""        'line_length': 80"",
            ""    })(),"",
            ""    'current_line': type('MockLine', (object,), {'depth': 1})(),"",
            ""    'visit_default': lambda leaf: 'visited'"",
            ""})()"",
            """",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""Sample docstring with trailing backslash.\\\""\""\""'"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""import re"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return leaf.value.startswith('\""\""\""')"",
            """",
            ""def normalize_string_prefix(string):"",
            ""    return string"",
            """",
            ""def normalize_string_quotes(string):"",
            ""    return string"",
            """",
            ""def get_string_prefix(string):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n'))"",
            """",
            ""def visit_default(leaf):"",
            ""    return 'default_visited'"",
            """",
            ""self = type('Mock', (object,), {"",
            ""    'mode': type('Mode', (object,), {"",
            ""        'hex_codes_in_unicode_sequences': False,"",
            ""        'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""        'long_docstring_quotes_on_newline': True,"",
            ""        'string_normalization': False,"",
            ""        'line_length': 60"",
            ""    })(),"",
            ""    'current_line': type('Line', (object,), {"",
            ""        'depth': 1"",
            ""    })(),"",
            ""    'visit_default': visit_default"",
            ""})()"",
            """",
            ""leaf = type('Leaf', (object,), {"",
            ""    'value': '\""\""\""A docstring that is quite long and might need to be wrapped properly.\""\""\""'"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""import re"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return leaf.value.startswith('\""\""\""')"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value.strip('\""')"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {"",
            ""    'mode': type('Mode', (object,), {"",
            ""        'hex_codes_in_unicode_sequences': False,"",
            ""        'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""        'long_docstring_quotes_on_newline': True,"",
            ""        'line_length': 80,"",
            ""        'string_normalization': False"",
            ""    })(),"",
            ""    'current_line': type('Line', (object,), {"",
            ""        'depth': 1"",
            ""    })(),"",
            ""    'visit_default': lambda leaf: None"",
            ""})()"",
            """",
            ""leaf = type('Leaf', (object,), {"",
            ""    'value': '\""\""\""This is a \""docstring\"" with a trailing backslash\\\\\""\""\""'"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum"",
            ""import re""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return leaf.value.startswith('\""\""\""')"",
            """",
            ""def normalize_string_prefix(string):"",
            ""    return string"",
            """",
            ""def normalize_string_quotes(string):"",
            ""    return string.strip('\""')"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""def visit_default(leaf):"",
            ""    return 'visited_default'"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': True,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 80"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""This is a multiline\nsession docstring ending with backslash\\\\\""\""\""'})()"",
            ""self.visit_default = lambda leaf: None""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 40"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""A short docstring with many backslashes.\\\\\""\""\""'})()"",
            ""self.visit_default = lambda leaf: None""
        ]
    },
    {
        ""imports"": [
            ""import re"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return leaf is not None and isinstance(leaf.value, str) and leaf.value.startswith('\""\""\""')"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n'))"",
            """",
            ""def visit_default(leaf):"",
            ""    return 'default_value'"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': True,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 30"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            """",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring with multiple lines that will be long enough to trigger the long_docstring_quotes_on_newline logic.\""\""\""'})()"",
            """",
            ""self.visit_default = lambda leaf: 'visited'""
        ]
    },
    {
        ""imports"": [
            ""import re"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return leaf.value.startswith('\""\""\""') and leaf.value.endswith('\""\""\""')"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value.strip('\""')"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {"",
            ""    'mode': type('MockMode', (object,), {"",
            ""        'hex_codes_in_unicode_sequences': False,"",
            ""        'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""        'long_docstring_quotes_on_newline': True,"",
            ""        'string_normalization': False,"",
            ""        'line_length': 50"",
            ""    })(),"",
            ""    'current_line': type('MockLine', (object,), {"",
            ""        'depth': 1"",
            ""    })(),"",
            ""    'visit_default': lambda leaf: None"",
            ""})()"",
            """",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""This is a long example docstring that needs to be formatted according to the logic.\""\""\""'"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""import re"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return leaf.value.startswith('\""\""\""') and leaf.value.endswith('\""\""\""')"",
            """",
            ""def normalize_string_prefix(string):"",
            ""    return string"",
            """",
            ""def normalize_string_quotes(string):"",
            ""    return string"",
            """",
            ""def get_string_prefix(string):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n'))"",
            """",
            ""def visit_default(leaf):"",
            ""    pass"",
            """",
            ""self = type('Mock', (object,), {"",
            ""    'mode': type('MockMode', (object,), {"",
            ""        'hex_codes_in_unicode_sequences': False,"",
            ""        'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""        'long_docstring_quotes_on_newline': True,"",
            ""        'string_normalization': False,"",
            ""        'line_length': 80"",
            ""    })(),"",
            ""    'current_line': type('MockLine', (object,), {'depth': 1})(),"",
            ""    'visit_default': visit_default"",
            ""})()"",
            """",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Sample docstring with quotes \""\""\""'})()""
        ]
    }
]","[
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 80 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'depth': 1 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""Short\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return leaf.value.startswith('\""\""\""') and leaf.value.endswith('\""\""\""') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(string): # pragma: no cover"",
            ""    return string # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(string): # pragma: no cover"",
            ""    return string # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(string): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def visit_default(leaf): # pragma: no cover"",
            ""    return 'visited_default' # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': Preview.hex_codes_in_unicode_sequences, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': Preview.normalize_docstring_quotes_and_prefixes_properly, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': Preview.long_docstring_quotes_on_newline, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 79 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""self.visit_default = visit_default # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""A \""docstring\"" with a backslash at the end\\\\\""\""\""'})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), { # pragma: no cover"",
            ""    'mode': type('MockMode', (object,), { # pragma: no cover"",
            ""        'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""        'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""        'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""        'string_normalization': False, # pragma: no cover"",
            ""        'line_length': 80 # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'current_line': type('MockLine', (object,), {'depth': 1})(), # pragma: no cover"",
            ""    'visit_default': lambda leaf: 'visited' # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""Sample docstring with trailing backslash.\\\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return leaf.value.startswith('\""\""\""') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(string): # pragma: no cover"",
            ""    return string # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(string): # pragma: no cover"",
            ""    return string # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(string): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def visit_default(leaf): # pragma: no cover"",
            ""    return 'default_visited' # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), { # pragma: no cover"",
            ""    'mode': type('Mode', (object,), { # pragma: no cover"",
            ""        'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""        'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""        'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""        'string_normalization': False, # pragma: no cover"",
            ""        'line_length': 60 # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'current_line': type('Line', (object,), { # pragma: no cover"",
            ""        'depth': 1 # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'visit_default': visit_default # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = type('Leaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""A docstring that is quite long and might need to be wrapped properly.\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return leaf.value.startswith('\""\""\""') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value.strip('\""') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), { # pragma: no cover"",
            ""    'mode': type('Mode', (object,), { # pragma: no cover"",
            ""        'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""        'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""        'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""        'line_length': 80, # pragma: no cover"",
            ""        'string_normalization': False # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'current_line': type('Line', (object,), { # pragma: no cover"",
            ""        'depth': 1 # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'visit_default': lambda leaf: None # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = type('Leaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""This is a \""docstring\"" with a trailing backslash\\\\\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover"",
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 40 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""A short docstring with many backslashes.\\\\\""\""\""'})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return leaf is not None and isinstance(leaf.value, str) and leaf.value.startswith('\""\""\""') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def visit_default(leaf): # pragma: no cover"",
            ""    return 'default_value' # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': True, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 30 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring with multiple lines that will be long enough to trigger the long_docstring_quotes_on_newline logic.\""\""\""'})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'visited' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return leaf.value.startswith('\""\""\""') and leaf.value.endswith('\""\""\""') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value.strip('\""') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), { # pragma: no cover"",
            ""    'mode': type('MockMode', (object,), { # pragma: no cover"",
            ""        'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""        'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""        'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""        'string_normalization': False, # pragma: no cover"",
            ""        'line_length': 50 # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'current_line': type('MockLine', (object,), { # pragma: no cover"",
            ""        'depth': 1 # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'visit_default': lambda leaf: None # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""This is a long example docstring that needs to be formatted according to the logic.\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return leaf.value.startswith('\""\""\""') and leaf.value.endswith('\""\""\""') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(string): # pragma: no cover"",
            ""    return string # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(string): # pragma: no cover"",
            ""    return string # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(string): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def visit_default(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), { # pragma: no cover"",
            ""    'mode': type('MockMode', (object,), { # pragma: no cover"",
            ""        'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""        'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""        'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""        'string_normalization': False, # pragma: no cover"",
            ""        'line_length': 80 # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'current_line': type('MockLine', (object,), {'depth': 1})(), # pragma: no cover"",
            ""    'visit_default': visit_default # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Sample docstring with quotes \""\""\""'})() # pragma: no cover""
        ]
    }
]",3,11752,0.005876,4283,0.0064245,0.0123004999999999
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
if Preview.hex_codes_in_unicode_sequences in self.mode:
    normalize_unicode_escape_sequences(leaf)
if is_docstring(leaf) and ""\\\n"" not in leaf.value:
    # We're ignoring docstrings with backslash newline escapes because changing
    # indentation of those changes the AST representation of the code.
    if Preview.normalize_docstring_quotes_and_prefixes_properly in self.mode:
        # There was a bug where --skip-string-normalization wouldn't stop us
        # from normalizing docstring prefixes. To maintain stability, we can
        # only address this buggy behaviour while the preview style is enabled.
        if self.mode.string_normalization:
            docstring = normalize_string_prefix(leaf.value)
            # visit_default() does handle string normalization for us, but
            # since this method acts differently depending on quote style (ex.
            # see padding logic below), there's a possibility for unstable
            # formatting as visit_default() is called *after*. To avoid a
            # situation where this function formats a docstring differently on
            # the second pass, normalize it early.
            docstring = normalize_string_quotes(docstring)
        else: # uncovered
            docstring = leaf.value
    else: # uncovered
        # ... otherwise, we'll keep the buggy behaviour >.<
        docstring = normalize_string_prefix(leaf.value)
    prefix = get_string_prefix(docstring)
    docstring = docstring[len(prefix) :]  # Remove the prefix
    quote_char = docstring[0]
    # A natural way to remove the outer quotes is to do:
    #   docstring = docstring.strip(quote_char)
    # but that breaks on """"""""""x"""""" (which is '""""x').
    # So we actually need to remove the first character and the next two
    # characters but only if they are the same as the first.
    quote_len = 1 if docstring[1] != quote_char else 3
    docstring = docstring[quote_len:-quote_len]
    docstring_started_empty = not docstring
    indent = "" "" * 4 * self.current_line.depth
    if is_multiline_string(leaf):
        docstring = fix_docstring(docstring, indent)
    else: # uncovered
        docstring = docstring.strip()
    has_trailing_backslash = False
    if docstring:
        # Add some padding if the docstring starts / ends with a quote mark.
        if docstring[0] == quote_char: # uncovered
            docstring = "" "" + docstring # uncovered
        if docstring[-1] == quote_char: # uncovered
            docstring += "" "" # uncovered
        if docstring[-1] == ""\\"": # uncovered
            backslash_count = len(docstring) - len(docstring.rstrip(""\\"")) # uncovered
            if backslash_count % 2: # uncovered
                # Odd number of tailing backslashes, add some padding to
                # avoid escaping the closing string quote.
                docstring += "" "" # uncovered
                has_trailing_backslash = True # uncovered
    elif not docstring_started_empty: # uncovered
        docstring = "" "" # uncovered
    # We could enforce triple quotes at this point.
    quote = quote_char * quote_len
    # It's invalid to put closing single-character quotes on a new line.
    if Preview.long_docstring_quotes_on_newline in self.mode and quote_len == 3:
        # We need to find the length of the last line of the docstring
        # to find if we can add the closing quotes to the line without
        # exceeding the maximum line length.
        # If docstring is one line, we don't put the closing quotes on a
        # separate line because it looks ugly (#3320).
        lines = docstring.splitlines()
        last_line_length = len(lines[-1]) if docstring else 0
        # If adding closing quotes would cause the last line to exceed
        # the maximum line length then put a line break before the
        # closing quotes
        if ( # uncovered
            len(lines) > 1 # uncovered
            and last_line_length + quote_len > self.mode.line_length # uncovered
            and len(indent) + quote_len <= self.mode.line_length # uncovered
            and not has_trailing_backslash # uncovered
        ): # uncovered
            leaf.value = prefix + quote + docstring + ""\n"" + indent + quote # uncovered
        else: # uncovered
            leaf.value = prefix + quote + docstring + quote
    else: # uncovered
        leaf.value = prefix + quote + docstring + quote
aux = self.visit_default(leaf)
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return False"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 80"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\"" A docstring with trailing backslashes\\\\\""\""\""'})()"",
            ""self.visit_default = lambda leaf: None""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf): pass"",
            """",
            ""def is_docstring(leaf): return True"",
            """",
            ""def normalize_string_prefix(value): return value"",
            """",
            ""def normalize_string_quotes(value): return value"",
            """",
            ""def get_string_prefix(value): return ''"",
            """",
            ""def is_multiline_string(leaf): return False"",
            """",
            ""def fix_docstring(docstring, indent): return docstring"",
            """",
            ""self = type('Mock', (object,), {"",
            ""    'mode': type('MockMode', (object,), {"",
            ""        'hex_codes_in_unicode_sequences': False,"",
            ""        'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""        'long_docstring_quotes_on_newline': True,"",
            ""        'string_normalization': False,"",
            ""        'line_length': 80"",
            ""    })(),"",
            ""    'current_line': type('MockLine', (object,), {'depth': 1})(),"",
            ""    'visit_default': lambda leaf: 'visited'"",
            ""})()"",
            """",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""Sample docstring with quotes\\\""\""\""'"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return False"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 80"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {"",
            ""    'depth': 1"",
            ""})()"",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""A\\ndocstring\""\""\""'"",
            ""})()"",
            ""self.visit_default = lambda leaf: 'visited'""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return False"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 80"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {"",
            ""    'depth': 1"",
            ""})()"",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""This is an example docstring with a trailing backslash\\\\\""\""\""'"",
            ""})()"",
            ""self.visit_default = lambda leaf: None""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': Preview.hex_codes_in_unicode_sequences,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': Preview.normalize_docstring_quotes_and_prefixes_properly,"",
            ""    'long_docstring_quotes_on_newline': Preview.long_docstring_quotes_on_newline,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 40"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Short\""\""\""'})()"",
            ""self.visit_default = lambda leaf: None""
        ]
    },
    {
        ""imports"": [
            ""import re"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 50"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 2})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""A short line docstring with long ending part that might need wrapping.\""\""\""'})()"",
            ""self.visit_default = lambda leaf: None""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 20"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""self.visit_default = lambda leaf: None"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""A very very very very very long single line docstring with ending quote \"" and trailing backslash\\\\\""\""\""'})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return False"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 80,"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""self.visit_default = lambda leaf: None"",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""\""\""\""\""\""\""' # Ensures that the code handles docstring appropriately with padding and formatting"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum"",
            ""import re""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return leaf.value.startswith('\""\""\""') and leaf.value.endswith('\""\""\""')"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value.strip('\""')"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {"",
            ""    'mode': type('MockMode', (object,), {"",
            ""        'hex_codes_in_unicode_sequences': False,"",
            ""        'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""        'long_docstring_quotes_on_newline': True,"",
            ""        'string_normalization': False,"",
            ""        'line_length': 40"",
            ""    })(),"",
            ""    'current_line': type('MockLine', (object,), {"",
            ""        'depth': 1"",
            ""    })(),"",
            ""    'visit_default': lambda leaf: None"",
            ""})()"",
            """",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""A really \""docstring\"". long docstring to test wrapping functionality.\""\""\""'"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return isinstance(leaf.value, str) and leaf.value.startswith('\""\""\""')"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value.strip('\""')"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 40"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""self.visit_default = lambda leaf: 'Visited'"",
            """",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""Example multiline\nstring ends with backslash\\\\\""\""\""'"",
            ""})()""
        ]
    }
]","[
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 80 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\"" A docstring with trailing backslashes\\\\\""\""\""'})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), { # pragma: no cover"",
            ""    'mode': type('MockMode', (object,), { # pragma: no cover"",
            ""        'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""        'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""        'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""        'string_normalization': False, # pragma: no cover"",
            ""        'line_length': 80 # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'current_line': type('MockLine', (object,), {'depth': 1})(), # pragma: no cover"",
            ""    'visit_default': lambda leaf: 'visited' # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""Sample docstring with quotes\\\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 80 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'depth': 1 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""A\\ndocstring\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'visited' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 80 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'depth': 1 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""This is an example docstring with a trailing backslash\\\\\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': Preview.hex_codes_in_unicode_sequences, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': Preview.normalize_docstring_quotes_and_prefixes_properly, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': Preview.long_docstring_quotes_on_newline, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 40 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Short\""\""\""'})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import re # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 50 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 2})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""A short line docstring with long ending part that might need wrapping.\""\""\""'})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 20 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: None # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""A very very very very very long single line docstring with ending quote \"" and trailing backslash\\\\\""\""\""'})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 80, # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: None # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""\""\""\""\""\""\""' # Ensures that the code handles docstring appropriately with padding and formatting # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover"",
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return leaf.value.startswith('\""\""\""') and leaf.value.endswith('\""\""\""') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value.strip('\""') # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), { # pragma: no cover"",
            ""    'mode': type('MockMode', (object,), { # pragma: no cover"",
            ""        'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""        'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""        'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""        'string_normalization': False, # pragma: no cover"",
            ""        'line_length': 40 # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'current_line': type('MockLine', (object,), { # pragma: no cover"",
            ""        'depth': 1 # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'visit_default': lambda leaf: None # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""A really \""docstring\"". long docstring to test wrapping functionality.\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    }
]",3,12238,0.006119,3985,0.0059775,0.0120965
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
if Preview.hex_codes_in_unicode_sequences in self.mode:
    normalize_unicode_escape_sequences(leaf)
if is_docstring(leaf) and ""\\\n"" not in leaf.value:
    # We're ignoring docstrings with backslash newline escapes because changing
    # indentation of those changes the AST representation of the code.
    if Preview.normalize_docstring_quotes_and_prefixes_properly in self.mode:
        # There was a bug where --skip-string-normalization wouldn't stop us
        # from normalizing docstring prefixes. To maintain stability, we can
        # only address this buggy behaviour while the preview style is enabled.
        if self.mode.string_normalization:
            docstring = normalize_string_prefix(leaf.value)
            # visit_default() does handle string normalization for us, but
            # since this method acts differently depending on quote style (ex.
            # see padding logic below), there's a possibility for unstable
            # formatting as visit_default() is called *after*. To avoid a
            # situation where this function formats a docstring differently on
            # the second pass, normalize it early.
            docstring = normalize_string_quotes(docstring)
        else: # uncovered
            docstring = leaf.value
    else: # uncovered
        # ... otherwise, we'll keep the buggy behaviour >.<
        docstring = normalize_string_prefix(leaf.value)
    prefix = get_string_prefix(docstring)
    docstring = docstring[len(prefix) :]  # Remove the prefix
    quote_char = docstring[0]
    # A natural way to remove the outer quotes is to do:
    #   docstring = docstring.strip(quote_char)
    # but that breaks on """"""""""x"""""" (which is '""""x').
    # So we actually need to remove the first character and the next two
    # characters but only if they are the same as the first.
    quote_len = 1 if docstring[1] != quote_char else 3
    docstring = docstring[quote_len:-quote_len]
    docstring_started_empty = not docstring
    indent = "" "" * 4 * self.current_line.depth
    if is_multiline_string(leaf):
        docstring = fix_docstring(docstring, indent)
    else: # uncovered
        docstring = docstring.strip()
    has_trailing_backslash = False
    if docstring:
        # Add some padding if the docstring starts / ends with a quote mark.
        if docstring[0] == quote_char: # uncovered
            docstring = "" "" + docstring # uncovered
        if docstring[-1] == quote_char: # uncovered
            docstring += "" "" # uncovered
        if docstring[-1] == ""\\"": # uncovered
            backslash_count = len(docstring) - len(docstring.rstrip(""\\"")) # uncovered
            if backslash_count % 2: # uncovered
                # Odd number of tailing backslashes, add some padding to
                # avoid escaping the closing string quote.
                docstring += "" "" # uncovered
                has_trailing_backslash = True # uncovered
    elif not docstring_started_empty: # uncovered
        docstring = "" "" # uncovered
    # We could enforce triple quotes at this point.
    quote = quote_char * quote_len
    # It's invalid to put closing single-character quotes on a new line.
    if Preview.long_docstring_quotes_on_newline in self.mode and quote_len == 3:
        # We need to find the length of the last line of the docstring
        # to find if we can add the closing quotes to the line without
        # exceeding the maximum line length.
        # If docstring is one line, we don't put the closing quotes on a
        # separate line because it looks ugly (#3320).
        lines = docstring.splitlines()
        last_line_length = len(lines[-1]) if docstring else 0
        # If adding closing quotes would cause the last line to exceed
        # the maximum line length then put a line break before the
        # closing quotes
        if ( # uncovered
            len(lines) > 1 # uncovered
            and last_line_length + quote_len > self.mode.line_length # uncovered
            and len(indent) + quote_len <= self.mode.line_length # uncovered
            and not has_trailing_backslash # uncovered
        ): # uncovered
            leaf.value = prefix + quote + docstring + ""\n"" + indent + quote # uncovered
        else: # uncovered
            leaf.value = prefix + quote + docstring + quote
    else: # uncovered
        leaf.value = prefix + quote + docstring + quote
aux = self.visit_default(leaf)
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 40"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""This docstring ends with a quote character and trailing backslash\\\""\""\""'})()"",
            ""self.visit_default = lambda leaf: 'Visited'""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf): pass"",
            """",
            ""def is_docstring(leaf): return True"",
            """",
            ""def normalize_string_prefix(value): return value"",
            """",
            ""def normalize_string_quotes(value): return value"",
            """",
            ""def get_string_prefix(value): return ''"",
            """",
            ""def is_multiline_string(leaf): return False"",
            """",
            ""def fix_docstring(docstring, indent): return docstring"",
            """",
            ""self = type('Mock', (object,), {"",
            ""    'mode': type('MockMode', (object,), {"",
            ""        'hex_codes_in_unicode_sequences': False,"",
            ""        'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""        'long_docstring_quotes_on_newline': True,"",
            ""        'string_normalization': False,"",
            ""        'line_length': 80"",
            ""    })(),"",
            ""    'current_line': type('MockLine', (object,), {'depth': 1})(),"",
            ""    'visit_default': lambda leaf: 'visited'"",
            ""})()"",
            """",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""Sample docstring with backslash\""\""\""'"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return False"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {"",
            ""    'mode': type('MockMode', (object,), {"",
            ""        'hex_codes_in_unicode_sequences': False,"",
            ""        'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""        'long_docstring_quotes_on_newline': True,"",
            ""        'string_normalization': False,"",
            ""        'line_length': 80"",
            ""    })(),"",
            ""    'current_line': type('MockLine', (object,), {"",
            ""        'depth': 1"",
            ""    })(),"",
            ""    'visit_default': lambda leaf: 'visited'"",
            ""})()"",
            """",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""This is a docstring\""\""\""'"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 10"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""self.visit_default = lambda leaf: 'Visited'"",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""Long docstring ending with a backslash\\\\\""\""\""'"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 60"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""A long example docstring that might need wrapping and ends with a backslash\\\\\""\""\""'})()"",
            ""self.visit_default = lambda leaf: None""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return False"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': Preview.normalize_docstring_quotes_and_prefixes_properly,"",
            ""    'long_docstring_quotes_on_newline': Preview.long_docstring_quotes_on_newline,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 40"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Short\""\""\""'})()"",
            ""self.visit_default = lambda leaf: None""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf): pass"",
            """",
            ""def is_docstring(leaf): return True"",
            """",
            ""def normalize_string_prefix(value): return value"",
            """",
            ""def normalize_string_quotes(value): return value"",
            """",
            ""def get_string_prefix(value): return ''"",
            """",
            ""def is_multiline_string(leaf): return True"",
            """",
            ""def fix_docstring(docstring, indent): return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 80"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""A docstring with\nmultiple lines.\n\""\""\""'})()"",
            ""self.visit_default = lambda leaf: None""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 30"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""A \""docstring\"" with trailing backslashes \\\\ \""\""\""'})()"",
            ""self.visit_default = lambda leaf: 'VisitedDefault'""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return False"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 80"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Short docstring\""\""\""'})()"",
            ""self.visit_default = lambda leaf: 'visited'""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return False"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 80"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Trailing backslash in docstring \\\\\\\""\""\""'})()"",
            ""self.visit_default = lambda leaf: 'Visited'""
        ]
    }
]","[
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 40 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""This docstring ends with a quote character and trailing backslash\\\""\""\""'})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), { # pragma: no cover"",
            ""    'mode': type('MockMode', (object,), { # pragma: no cover"",
            ""        'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""        'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""        'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""        'string_normalization': False, # pragma: no cover"",
            ""        'line_length': 80 # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'current_line': type('MockLine', (object,), {'depth': 1})(), # pragma: no cover"",
            ""    'visit_default': lambda leaf: 'visited' # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""Sample docstring with backslash\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), { # pragma: no cover"",
            ""    'mode': type('MockMode', (object,), { # pragma: no cover"",
            ""        'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""        'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""        'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""        'string_normalization': False, # pragma: no cover"",
            ""        'line_length': 80 # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'current_line': type('MockLine', (object,), { # pragma: no cover"",
            ""        'depth': 1 # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'visit_default': lambda leaf: 'visited' # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""This is a docstring\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 10 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""Long docstring ending with a backslash\\\\\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 60 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""A long example docstring that might need wrapping and ends with a backslash\\\\\""\""\""'})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': Preview.normalize_docstring_quotes_and_prefixes_properly, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': Preview.long_docstring_quotes_on_newline, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 40 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Short\""\""\""'})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 30 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""A \""docstring\"" with trailing backslashes \\\\ \""\""\""'})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'VisitedDefault' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 80 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Short docstring\""\""\""'})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'visited' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 80 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Trailing backslash in docstring \\\\\\\""\""\""'})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover""
        ]
    }
]",3,12065,0.0060325,3824,0.005736,0.0117685
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
if Preview.hex_codes_in_unicode_sequences in self.mode:
    normalize_unicode_escape_sequences(leaf)
if is_docstring(leaf) and ""\\\n"" not in leaf.value:
    # We're ignoring docstrings with backslash newline escapes because changing
    # indentation of those changes the AST representation of the code.
    if Preview.normalize_docstring_quotes_and_prefixes_properly in self.mode:
        # There was a bug where --skip-string-normalization wouldn't stop us
        # from normalizing docstring prefixes. To maintain stability, we can
        # only address this buggy behaviour while the preview style is enabled.
        if self.mode.string_normalization:
            docstring = normalize_string_prefix(leaf.value)
            # visit_default() does handle string normalization for us, but
            # since this method acts differently depending on quote style (ex.
            # see padding logic below), there's a possibility for unstable
            # formatting as visit_default() is called *after*. To avoid a
            # situation where this function formats a docstring differently on
            # the second pass, normalize it early.
            docstring = normalize_string_quotes(docstring)
        else: # uncovered
            docstring = leaf.value
    else: # uncovered
        # ... otherwise, we'll keep the buggy behaviour >.<
        docstring = normalize_string_prefix(leaf.value)
    prefix = get_string_prefix(docstring)
    docstring = docstring[len(prefix) :]  # Remove the prefix
    quote_char = docstring[0]
    # A natural way to remove the outer quotes is to do:
    #   docstring = docstring.strip(quote_char)
    # but that breaks on """"""""""x"""""" (which is '""""x').
    # So we actually need to remove the first character and the next two
    # characters but only if they are the same as the first.
    quote_len = 1 if docstring[1] != quote_char else 3
    docstring = docstring[quote_len:-quote_len]
    docstring_started_empty = not docstring
    indent = "" "" * 4 * self.current_line.depth
    if is_multiline_string(leaf):
        docstring = fix_docstring(docstring, indent)
    else: # uncovered
        docstring = docstring.strip()
    has_trailing_backslash = False
    if docstring:
        # Add some padding if the docstring starts / ends with a quote mark.
        if docstring[0] == quote_char: # uncovered
            docstring = "" "" + docstring # uncovered
        if docstring[-1] == quote_char: # uncovered
            docstring += "" "" # uncovered
        if docstring[-1] == ""\\"": # uncovered
            backslash_count = len(docstring) - len(docstring.rstrip(""\\"")) # uncovered
            if backslash_count % 2: # uncovered
                # Odd number of tailing backslashes, add some padding to
                # avoid escaping the closing string quote.
                docstring += "" "" # uncovered
                has_trailing_backslash = True # uncovered
    elif not docstring_started_empty: # uncovered
        docstring = "" "" # uncovered
    # We could enforce triple quotes at this point.
    quote = quote_char * quote_len
    # It's invalid to put closing single-character quotes on a new line.
    if Preview.long_docstring_quotes_on_newline in self.mode and quote_len == 3:
        # We need to find the length of the last line of the docstring
        # to find if we can add the closing quotes to the line without
        # exceeding the maximum line length.
        # If docstring is one line, we don't put the closing quotes on a
        # separate line because it looks ugly (#3320).
        lines = docstring.splitlines()
        last_line_length = len(lines[-1]) if docstring else 0
        # If adding closing quotes would cause the last line to exceed
        # the maximum line length then put a line break before the
        # closing quotes
        if ( # uncovered
            len(lines) > 1 # uncovered
            and last_line_length + quote_len > self.mode.line_length # uncovered
            and len(indent) + quote_len <= self.mode.line_length # uncovered
            and not has_trailing_backslash # uncovered
        ): # uncovered
            leaf.value = prefix + quote + docstring + ""\n"" + indent + quote # uncovered
        else: # uncovered
            leaf.value = prefix + quote + docstring + quote
    else: # uncovered
        leaf.value = prefix + quote + docstring + quote
aux = self.visit_default(leaf)
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 20"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Short ' + '\""' + '\\\\' + '\""\""\""'})()"",
            ""self.visit_default = lambda leaf: None""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return False"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 50"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""self.visit_default = lambda leaf: 'visited'"",
            """",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""A docstring ending with a quote \\\""\""\""'})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return False"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 40"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 2})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring ending with a quote character\""\""\""'})()"",
            ""self.visit_default = lambda leaf: 'Visited'""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 40"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""self.visit_default = lambda leaf: None"",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""Docstring with trailing backslash\\\\\""\""\""'"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 40"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Docstring ending with a quote character \\\""\""\""'})()"",
            ""self.visit_default = lambda leaf: 'Visited'""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': Preview.hex_codes_in_unicode_sequences,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': Preview.normalize_docstring_quotes_and_prefixes_properly,"",
            ""    'long_docstring_quotes_on_newline': Preview.long_docstring_quotes_on_newline,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 50"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Quote at start and end \""quoted\"" \\\\\\\""\""\""'})()"",
            ""self.visit_default = lambda leaf: 'visited'""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 10"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""Trailing backslash \\\""\""\""'"",
            ""})()"",
            ""self.visit_default = lambda leaf: 'Visited'""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': Preview.long_docstring_quotes_on_newline,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 50"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Spanning multiple lines \\\""\""\""'})()"",
            ""self.visit_default = lambda leaf: 'Visited'""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 40"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""\""\""\""\""\""\""' # Ensures that the code handles docstring appropriately with padding and formatting'})()"",
            ""self.visit_default = lambda leaf: None""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return False"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 40"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), { 'depth': 1 })()"",
            ""leaf = type('MockLeaf', (object,), { 'value': '\""\""\""A docstring with backslashes\\\\\\\\\""\""\""' })()"",
            ""self.visit_default = lambda leaf: 'visited'""
        ]
    }
]","[
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 20 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Short ' + '\""' + '\\\\' + '\""\""\""'})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 50 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'visited' # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""A docstring ending with a quote \\\""\""\""'})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 40 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 2})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Example docstring ending with a quote character\""\""\""'})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 40 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: None # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""Docstring with trailing backslash\\\\\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 40 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Docstring ending with a quote character \\\""\""\""'})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': Preview.hex_codes_in_unicode_sequences, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': Preview.normalize_docstring_quotes_and_prefixes_properly, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': Preview.long_docstring_quotes_on_newline, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 50 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Quote at start and end \""quoted\"" \\\\\\\""\""\""'})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'visited' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 10 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""Trailing backslash \\\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': Preview.long_docstring_quotes_on_newline, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 50 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Spanning multiple lines \\\""\""\""'})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 40 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 40 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), { 'depth': 1 })() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { 'value': '\""\""\""A docstring with backslashes\\\\\\\\\""\""\""' })() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'visited' # pragma: no cover""
        ]
    }
]",3,11606,0.005803,3894,0.005841,0.011644
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
if Preview.hex_codes_in_unicode_sequences in self.mode:
    normalize_unicode_escape_sequences(leaf)
if is_docstring(leaf) and ""\\\n"" not in leaf.value:
    # We're ignoring docstrings with backslash newline escapes because changing
    # indentation of those changes the AST representation of the code.
    if Preview.normalize_docstring_quotes_and_prefixes_properly in self.mode:
        # There was a bug where --skip-string-normalization wouldn't stop us
        # from normalizing docstring prefixes. To maintain stability, we can
        # only address this buggy behaviour while the preview style is enabled.
        if self.mode.string_normalization:
            docstring = normalize_string_prefix(leaf.value)
            # visit_default() does handle string normalization for us, but
            # since this method acts differently depending on quote style (ex.
            # see padding logic below), there's a possibility for unstable
            # formatting as visit_default() is called *after*. To avoid a
            # situation where this function formats a docstring differently on
            # the second pass, normalize it early.
            docstring = normalize_string_quotes(docstring)
        else: # uncovered
            docstring = leaf.value
    else: # uncovered
        # ... otherwise, we'll keep the buggy behaviour >.<
        docstring = normalize_string_prefix(leaf.value)
    prefix = get_string_prefix(docstring)
    docstring = docstring[len(prefix) :]  # Remove the prefix
    quote_char = docstring[0]
    # A natural way to remove the outer quotes is to do:
    #   docstring = docstring.strip(quote_char)
    # but that breaks on """"""""""x"""""" (which is '""""x').
    # So we actually need to remove the first character and the next two
    # characters but only if they are the same as the first.
    quote_len = 1 if docstring[1] != quote_char else 3
    docstring = docstring[quote_len:-quote_len]
    docstring_started_empty = not docstring
    indent = "" "" * 4 * self.current_line.depth
    if is_multiline_string(leaf):
        docstring = fix_docstring(docstring, indent)
    else: # uncovered
        docstring = docstring.strip()
    has_trailing_backslash = False
    if docstring:
        # Add some padding if the docstring starts / ends with a quote mark.
        if docstring[0] == quote_char: # uncovered
            docstring = "" "" + docstring # uncovered
        if docstring[-1] == quote_char: # uncovered
            docstring += "" "" # uncovered
        if docstring[-1] == ""\\"": # uncovered
            backslash_count = len(docstring) - len(docstring.rstrip(""\\"")) # uncovered
            if backslash_count % 2: # uncovered
                # Odd number of tailing backslashes, add some padding to
                # avoid escaping the closing string quote.
                docstring += "" "" # uncovered
                has_trailing_backslash = True # uncovered
    elif not docstring_started_empty: # uncovered
        docstring = "" "" # uncovered
    # We could enforce triple quotes at this point.
    quote = quote_char * quote_len
    # It's invalid to put closing single-character quotes on a new line.
    if Preview.long_docstring_quotes_on_newline in self.mode and quote_len == 3:
        # We need to find the length of the last line of the docstring
        # to find if we can add the closing quotes to the line without
        # exceeding the maximum line length.
        # If docstring is one line, we don't put the closing quotes on a
        # separate line because it looks ugly (#3320).
        lines = docstring.splitlines()
        last_line_length = len(lines[-1]) if docstring else 0
        # If adding closing quotes would cause the last line to exceed
        # the maximum line length then put a line break before the
        # closing quotes
        if ( # uncovered
            len(lines) > 1 # uncovered
            and last_line_length + quote_len > self.mode.line_length # uncovered
            and len(indent) + quote_len <= self.mode.line_length # uncovered
            and not has_trailing_backslash # uncovered
        ): # uncovered
            leaf.value = prefix + quote + docstring + ""\n"" + indent + quote # uncovered
        else: # uncovered
            leaf.value = prefix + quote + docstring + quote
    else: # uncovered
        leaf.value = prefix + quote + docstring + quote
aux = self.visit_default(leaf)
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 30"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""self.visit_default = lambda leaf: 'Visited'"",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""Docstring containing quotes at the start and the end \""\""\""' # Ensures that the code handles docstring appropriately with padding and formatting'})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 20"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Trailing quote character\"" })()"",
            ""self.visit_default = lambda leaf: None""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return True"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 10"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Something end quote\""\""\""'})()"",
            ""self.visit_default = lambda leaf: 'Visited'""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return False"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 40"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Trailing backslash '\\''\""\""\""'})()"",
            ""self.visit_default = lambda leaf: 'visited'""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 5"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""Shortdocstringendoingwithquotecharandbackslash\\\\\""\""\""'"",
            ""})()"",
            ""self.visit_default = lambda leaf: 'Visited'""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 20"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Short docstring ending with \\\""\""\""'})()"",
            ""self.visit_default = lambda leaf: 'visited'""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return True"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 50"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""An example docstring ending with a quote character.\""\""\""\n'})()"",
            ""self.visit_default = lambda leaf: 'visited'""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return True"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 10"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), { 'depth': 1 })()"",
            ""leaf = type('MockLeaf', (object,), { 'value': '\""\""\""Multi-line\ndocstring\ntrailing backslash\\\\\""\""\""' })()"",
            ""self.visit_default = lambda leaf: 'Visited'""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 20"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Short quote characters \""\\\"" end\""\""\""'})()"",
            ""self.visit_default = lambda leaf: None""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            """",
            ""class MockMode:"",
            ""    hex_codes_in_unicode_sequences = False"",
            ""    normalize_docstring_quotes_and_prefixes_properly = True"",
            ""    long_docstring_quotes_on_newline = True"",
            ""    string_normalization = False"",
            ""    line_length = 40"",
            """",
            ""class MockLine:"",
            ""    depth = 1"",
            """",
            ""self = type('Mock', (object,), {"",
            ""    'mode': MockMode(),"",
            ""    'current_line': MockLine(),"",
            ""    'visit_default': lambda leaf: 'Visited'"",
            ""})()"",
            """",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""Trailing backslash\\\\\""\""\""'"",
            ""})()""
        ]
    }
]","[
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 30 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 10 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Something end quote\""\""\""'})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 5 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""Shortdocstringendoingwithquotecharandbackslash\\\\\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 20 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Short docstring ending with \\\""\""\""'})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'visited' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 20 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Short quote characters \""\\\"" end\""\""\""'})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockMode: # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = False # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = True # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = True # pragma: no cover"",
            ""    string_normalization = False # pragma: no cover"",
            ""    line_length = 40 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLine: # pragma: no cover"",
            ""    depth = 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), { # pragma: no cover"",
            ""    'mode': MockMode(), # pragma: no cover"",
            ""    'current_line': MockLine(), # pragma: no cover"",
            ""    'visit_default': lambda leaf: 'Visited' # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""Trailing backslash\\\\\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    }
]",3,11515,0.0057575,3918,0.005877,0.0116344999999999
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
if Preview.hex_codes_in_unicode_sequences in self.mode:
    normalize_unicode_escape_sequences(leaf)
if is_docstring(leaf) and ""\\\n"" not in leaf.value:
    # We're ignoring docstrings with backslash newline escapes because changing
    # indentation of those changes the AST representation of the code.
    if Preview.normalize_docstring_quotes_and_prefixes_properly in self.mode:
        # There was a bug where --skip-string-normalization wouldn't stop us
        # from normalizing docstring prefixes. To maintain stability, we can
        # only address this buggy behaviour while the preview style is enabled.
        if self.mode.string_normalization:
            docstring = normalize_string_prefix(leaf.value)
            # visit_default() does handle string normalization for us, but
            # since this method acts differently depending on quote style (ex.
            # see padding logic below), there's a possibility for unstable
            # formatting as visit_default() is called *after*. To avoid a
            # situation where this function formats a docstring differently on
            # the second pass, normalize it early.
            docstring = normalize_string_quotes(docstring)
        else: # uncovered
            docstring = leaf.value
    else: # uncovered
        # ... otherwise, we'll keep the buggy behaviour >.<
        docstring = normalize_string_prefix(leaf.value)
    prefix = get_string_prefix(docstring)
    docstring = docstring[len(prefix) :]  # Remove the prefix
    quote_char = docstring[0]
    # A natural way to remove the outer quotes is to do:
    #   docstring = docstring.strip(quote_char)
    # but that breaks on """"""""""x"""""" (which is '""""x').
    # So we actually need to remove the first character and the next two
    # characters but only if they are the same as the first.
    quote_len = 1 if docstring[1] != quote_char else 3
    docstring = docstring[quote_len:-quote_len]
    docstring_started_empty = not docstring
    indent = "" "" * 4 * self.current_line.depth
    if is_multiline_string(leaf):
        docstring = fix_docstring(docstring, indent)
    else: # uncovered
        docstring = docstring.strip()
    has_trailing_backslash = False
    if docstring:
        # Add some padding if the docstring starts / ends with a quote mark.
        if docstring[0] == quote_char: # uncovered
            docstring = "" "" + docstring # uncovered
        if docstring[-1] == quote_char: # uncovered
            docstring += "" "" # uncovered
        if docstring[-1] == ""\\"": # uncovered
            backslash_count = len(docstring) - len(docstring.rstrip(""\\"")) # uncovered
            if backslash_count % 2: # uncovered
                # Odd number of tailing backslashes, add some padding to
                # avoid escaping the closing string quote.
                docstring += "" "" # uncovered
                has_trailing_backslash = True # uncovered
    elif not docstring_started_empty: # uncovered
        docstring = "" "" # uncovered
    # We could enforce triple quotes at this point.
    quote = quote_char * quote_len
    # It's invalid to put closing single-character quotes on a new line.
    if Preview.long_docstring_quotes_on_newline in self.mode and quote_len == 3:
        # We need to find the length of the last line of the docstring
        # to find if we can add the closing quotes to the line without
        # exceeding the maximum line length.
        # If docstring is one line, we don't put the closing quotes on a
        # separate line because it looks ugly (#3320).
        lines = docstring.splitlines()
        last_line_length = len(lines[-1]) if docstring else 0
        # If adding closing quotes would cause the last line to exceed
        # the maximum line length then put a line break before the
        # closing quotes
        if ( # uncovered
            len(lines) > 1 # uncovered
            and last_line_length + quote_len > self.mode.line_length # uncovered
            and len(indent) + quote_len <= self.mode.line_length # uncovered
            and not has_trailing_backslash # uncovered
        ): # uncovered
            leaf.value = prefix + quote + docstring + ""\n"" + indent + quote # uncovered
        else: # uncovered
            leaf.value = prefix + quote + docstring + quote
    else: # uncovered
        leaf.value = prefix + quote + docstring + quote
aux = self.visit_default(leaf)
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 30"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""self.visit_default = lambda leaf: 'Visited'"",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""Leading and trailing quote characters \\\""\""\""' # to ensure padding and formatting handling."",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return True"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 30"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Multi-line\\ndocstring with trailing\\nbackslash\\\\\""\""\"" })()"",
            ""self.visit_default = lambda leaf: 'visited'""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return False"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 20"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""self.visit_default = lambda leaf: 'Visited'"",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""Test backslash \\\""\""\""'"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 10"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""self.visit_default = lambda leaf: 'Visited'"",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""A short docstring with a trailing backslash\\\\\""\""\""'"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 30"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""self.visit_default = lambda leaf: 'Visited'"",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""Short \"" docstring with trailing quote\\\""\\\""\""'"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return False"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 20"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Trailingquotecharacterquotecharandbackslash\""\""\""'})()"",
            ""self.visit_default = lambda leaf: 'Visited'""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 20"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""self.visit_default = lambda leaf: 'Visited'"",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""Trailing backslash\\\"" A\""\""\""'"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return False"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 15"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), { 'depth': 1 })()"",
            ""leaf = type('MockLeaf', (object,), { 'value': '\""\""\""Trailing backslash\\\\\""\""\""' })()"",
            ""self.visit_default = lambda leaf: 'Visited'""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 10"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""self.visit_default = lambda leaf: 'Visited'"",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""This is a test docstring\""\""\""' # Ensures that the code handles docstring appropriately with padding and formatting'})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 20"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Docstring with a quote at the end\""\""\""'})()"",
            ""self.visit_default = lambda leaf: 'visited'""
        ]
    }
]","[
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 30 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""Leading and trailing quote characters \\\""\""\""' # to ensure padding and formatting handling. # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 20 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""Test backslash \\\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 10 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""A short docstring with a trailing backslash\\\\\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 30 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""Short \"" docstring with trailing quote\\\""\\\""\""' # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 20 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Trailingquotecharacterquotecharandbackslash\""\""\""'})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 20 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""Trailing backslash\\\"" A\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 15 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), { 'depth': 1 })() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { 'value': '\""\""\""Trailing backslash\\\\\""\""\""' })() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 10 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 20 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Docstring with a quote at the end\""\""\""'})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'visited' # pragma: no cover""
        ]
    }
]",3,11609,0.0058045,3939,0.0059085,0.011713
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
if Preview.hex_codes_in_unicode_sequences in self.mode:
    normalize_unicode_escape_sequences(leaf)
if is_docstring(leaf) and ""\\\n"" not in leaf.value:
    # We're ignoring docstrings with backslash newline escapes because changing
    # indentation of those changes the AST representation of the code.
    if Preview.normalize_docstring_quotes_and_prefixes_properly in self.mode:
        # There was a bug where --skip-string-normalization wouldn't stop us
        # from normalizing docstring prefixes. To maintain stability, we can
        # only address this buggy behaviour while the preview style is enabled.
        if self.mode.string_normalization:
            docstring = normalize_string_prefix(leaf.value)
            # visit_default() does handle string normalization for us, but
            # since this method acts differently depending on quote style (ex.
            # see padding logic below), there's a possibility for unstable
            # formatting as visit_default() is called *after*. To avoid a
            # situation where this function formats a docstring differently on
            # the second pass, normalize it early.
            docstring = normalize_string_quotes(docstring)
        else: # uncovered
            docstring = leaf.value
    else: # uncovered
        # ... otherwise, we'll keep the buggy behaviour >.<
        docstring = normalize_string_prefix(leaf.value)
    prefix = get_string_prefix(docstring)
    docstring = docstring[len(prefix) :]  # Remove the prefix
    quote_char = docstring[0]
    # A natural way to remove the outer quotes is to do:
    #   docstring = docstring.strip(quote_char)
    # but that breaks on """"""""""x"""""" (which is '""""x').
    # So we actually need to remove the first character and the next two
    # characters but only if they are the same as the first.
    quote_len = 1 if docstring[1] != quote_char else 3
    docstring = docstring[quote_len:-quote_len]
    docstring_started_empty = not docstring
    indent = "" "" * 4 * self.current_line.depth
    if is_multiline_string(leaf):
        docstring = fix_docstring(docstring, indent)
    else: # uncovered
        docstring = docstring.strip()
    has_trailing_backslash = False
    if docstring:
        # Add some padding if the docstring starts / ends with a quote mark.
        if docstring[0] == quote_char: # uncovered
            docstring = "" "" + docstring # uncovered
        if docstring[-1] == quote_char: # uncovered
            docstring += "" "" # uncovered
        if docstring[-1] == ""\\"": # uncovered
            backslash_count = len(docstring) - len(docstring.rstrip(""\\"")) # uncovered
            if backslash_count % 2: # uncovered
                # Odd number of tailing backslashes, add some padding to
                # avoid escaping the closing string quote.
                docstring += "" "" # uncovered
                has_trailing_backslash = True # uncovered
    elif not docstring_started_empty: # uncovered
        docstring = "" "" # uncovered
    # We could enforce triple quotes at this point.
    quote = quote_char * quote_len
    # It's invalid to put closing single-character quotes on a new line.
    if Preview.long_docstring_quotes_on_newline in self.mode and quote_len == 3:
        # We need to find the length of the last line of the docstring
        # to find if we can add the closing quotes to the line without
        # exceeding the maximum line length.
        # If docstring is one line, we don't put the closing quotes on a
        # separate line because it looks ugly (#3320).
        lines = docstring.splitlines()
        last_line_length = len(lines[-1]) if docstring else 0
        # If adding closing quotes would cause the last line to exceed
        # the maximum line length then put a line break before the
        # closing quotes
        if ( # uncovered
            len(lines) > 1 # uncovered
            and last_line_length + quote_len > self.mode.line_length # uncovered
            and len(indent) + quote_len <= self.mode.line_length # uncovered
            and not has_trailing_backslash # uncovered
        ): # uncovered
            leaf.value = prefix + quote + docstring + ""\n"" + indent + quote # uncovered
        else: # uncovered
            leaf.value = prefix + quote + docstring + quote
    else: # uncovered
        leaf.value = prefix + quote + docstring + quote
aux = self.visit_default(leaf)
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 20"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""self.visit_default = lambda leaf: 'Visited'"",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""Dummy docstring\""\""\""'"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 20"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""self.visit_default = lambda leaf: 'Visited'"",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""Leading and trailing quote characters\\t\\\""\\\""\""' # to ensure padding and formatting handling."",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 20"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""self.visit_default = lambda leaf: 'Visited'"",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""Trailing quote mark\\\""\\\""\""\""'"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 20"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""Docstring with backslash and quote \\ char\""\""\""'"",
            ""})()"",
            ""self.visit_default = lambda leaf: 'Visited'""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            """",
            ""class MockMode:"",
            ""    hex_codes_in_unicode_sequences = False"",
            ""    normalize_docstring_quotes_and_prefixes_properly = True"",
            ""    long_docstring_quotes_on_newline = True"",
            ""    string_normalization = False"",
            ""    line_length = 30"",
            """",
            ""class MockLine:"",
            ""    depth = 1"",
            """",
            ""self = type('Mock', (object,), {"",
            ""    'mode': MockMode(),"",
            ""    'current_line': MockLine(),"",
            ""    'visit_default': lambda leaf: 'Visited'"",
            ""})()"",
            """",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""Short docstring with a quote \\\"" and backslash\\\""\""\""'"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return False"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 10"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Quote \"" end\""\""\""'})()"",
            ""self.visit_default = lambda leaf: 'Visited'""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 20"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""self.visit_default = lambda leaf: 'Visited'"",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""Test with quote at end\\\""\""\""'"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return True"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 10"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Multi-line\\ndocstring with trailing backslash\\\\\""\""\""'})()"",
            ""self.visit_default = lambda leaf: 'Visited'""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 30"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Multi-line docstring with trailing backslash \\\\\\\""\""\""' })()"",
            ""self.visit_default = lambda leaf: 'visited'""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return False"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 30"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""self.visit_default = lambda leaf: 'Visited'"",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""Leading and trailing quote \\\"" and backslash\\\\\""\""\""'"",
            ""})()""
        ]
    }
]","[
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 20 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""Dummy docstring\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 20 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""Leading and trailing quote characters\\t\\\""\\\""\""' # to ensure padding and formatting handling. # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 20 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""Trailing quote mark\\\""\\\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 20 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""Docstring with backslash and quote \\ char\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockMode: # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = False # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = True # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = True # pragma: no cover"",
            ""    string_normalization = False # pragma: no cover"",
            ""    line_length = 30 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLine: # pragma: no cover"",
            ""    depth = 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), { # pragma: no cover"",
            ""    'mode': MockMode(), # pragma: no cover"",
            ""    'current_line': MockLine(), # pragma: no cover"",
            ""    'visit_default': lambda leaf: 'Visited' # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""Short docstring with a quote \\\"" and backslash\\\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 10 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Quote \"" end\""\""\""'})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 20 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""Test with quote at end\\\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 10 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Multi-line\\ndocstring with trailing backslash\\\\\""\""\""'})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 30 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Multi-line docstring with trailing backslash \\\\\\\""\""\""' })() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'visited' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 30 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""Leading and trailing quote \\\"" and backslash\\\\\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    }
]",3,11654,0.005827,3976,0.005964,0.011791
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
if Preview.hex_codes_in_unicode_sequences in self.mode:
    normalize_unicode_escape_sequences(leaf)
if is_docstring(leaf) and ""\\\n"" not in leaf.value:
    # We're ignoring docstrings with backslash newline escapes because changing
    # indentation of those changes the AST representation of the code.
    if Preview.normalize_docstring_quotes_and_prefixes_properly in self.mode:
        # There was a bug where --skip-string-normalization wouldn't stop us
        # from normalizing docstring prefixes. To maintain stability, we can
        # only address this buggy behaviour while the preview style is enabled.
        if self.mode.string_normalization:
            docstring = normalize_string_prefix(leaf.value)
            # visit_default() does handle string normalization for us, but
            # since this method acts differently depending on quote style (ex.
            # see padding logic below), there's a possibility for unstable
            # formatting as visit_default() is called *after*. To avoid a
            # situation where this function formats a docstring differently on
            # the second pass, normalize it early.
            docstring = normalize_string_quotes(docstring)
        else: # uncovered
            docstring = leaf.value
    else: # uncovered
        # ... otherwise, we'll keep the buggy behaviour >.<
        docstring = normalize_string_prefix(leaf.value)
    prefix = get_string_prefix(docstring)
    docstring = docstring[len(prefix) :]  # Remove the prefix
    quote_char = docstring[0]
    # A natural way to remove the outer quotes is to do:
    #   docstring = docstring.strip(quote_char)
    # but that breaks on """"""""""x"""""" (which is '""""x').
    # So we actually need to remove the first character and the next two
    # characters but only if they are the same as the first.
    quote_len = 1 if docstring[1] != quote_char else 3
    docstring = docstring[quote_len:-quote_len]
    docstring_started_empty = not docstring
    indent = "" "" * 4 * self.current_line.depth
    if is_multiline_string(leaf):
        docstring = fix_docstring(docstring, indent)
    else: # uncovered
        docstring = docstring.strip()
    has_trailing_backslash = False
    if docstring:
        # Add some padding if the docstring starts / ends with a quote mark.
        if docstring[0] == quote_char: # uncovered
            docstring = "" "" + docstring # uncovered
        if docstring[-1] == quote_char: # uncovered
            docstring += "" "" # uncovered
        if docstring[-1] == ""\\"": # uncovered
            backslash_count = len(docstring) - len(docstring.rstrip(""\\"")) # uncovered
            if backslash_count % 2: # uncovered
                # Odd number of tailing backslashes, add some padding to
                # avoid escaping the closing string quote.
                docstring += "" "" # uncovered
                has_trailing_backslash = True # uncovered
    elif not docstring_started_empty: # uncovered
        docstring = "" "" # uncovered
    # We could enforce triple quotes at this point.
    quote = quote_char * quote_len
    # It's invalid to put closing single-character quotes on a new line.
    if Preview.long_docstring_quotes_on_newline in self.mode and quote_len == 3:
        # We need to find the length of the last line of the docstring
        # to find if we can add the closing quotes to the line without
        # exceeding the maximum line length.
        # If docstring is one line, we don't put the closing quotes on a
        # separate line because it looks ugly (#3320).
        lines = docstring.splitlines()
        last_line_length = len(lines[-1]) if docstring else 0
        # If adding closing quotes would cause the last line to exceed
        # the maximum line length then put a line break before the
        # closing quotes
        if ( # uncovered
            len(lines) > 1 # uncovered
            and last_line_length + quote_len > self.mode.line_length # uncovered
            and len(indent) + quote_len <= self.mode.line_length # uncovered
            and not has_trailing_backslash # uncovered
        ): # uncovered
            leaf.value = prefix + quote + docstring + ""\n"" + indent + quote # uncovered
        else: # uncovered
            leaf.value = prefix + quote + docstring + quote
    else: # uncovered
        leaf.value = prefix + quote + docstring + quote
aux = self.visit_default(leaf)
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return False"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 30"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Quote \\ and backslash\\ end\\\""\""\""'})()"",
            ""self.visit_default = lambda leaf: 'Visited'""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 20"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""self.visit_default = lambda leaf: 'Visited'"",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""Multi-line\\nDocstring with short last line and split quotes\""\""\""'"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return False"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 20"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""self.visit_default = lambda leaf: 'Visited'"",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""Trailing backslash \\\\\""\""\""'"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 20"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""self.visit_default = lambda leaf: 'Visited'"",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""Short docstring\\nwith multiple lines\\nand trailing backslash\\\\\""\""\""'"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return False"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 10"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""self.visit_default = lambda leaf: 'Visited'"",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""A docstring with a quote and \\\\\\\""\""\""\""'"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return False"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return docstring"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 50"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""This is a test string with backslash \\\\\""\""\""'})()"",
            ""self.visit_default = lambda leaf: 'Visited'""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 10"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), { 'depth': 1 })()"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Short longdoc with newline\\nof quotes\\nand backslash\\\\\""\""\""'})()"",
            ""self.visit_default = lambda leaf: 'Visited'""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 15"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""A docstring with a trailing backslash\\\\\""\""\""'"",
            ""})()"",
            ""self.visit_default = lambda leaf: 'Visited'""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n'))"",
            """",
            ""self = type('Mock', (object,), {})()"",
            ""self.mode = type('MockMode', (object,), {"",
            ""    'hex_codes_in_unicode_sequences': False,"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True,"",
            ""    'long_docstring_quotes_on_newline': True,"",
            ""    'string_normalization': False,"",
            ""    'line_length': 30"",
            ""})()"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})()"",
            ""self.visit_default = lambda leaf: 'Visited'"",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""Trailing quote mark \\\"" and some text\""\""\""' })()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Preview(Enum):"",
            ""    hex_codes_in_unicode_sequences = 1"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2"",
            ""    long_docstring_quotes_on_newline = 3"",
            """",
            ""def normalize_unicode_escape_sequences(leaf):"",
            ""    pass"",
            """",
            ""def is_docstring(leaf):"",
            ""    return True"",
            """",
            ""def normalize_string_prefix(value):"",
            ""    return value"",
            """",
            ""def normalize_string_quotes(value):"",
            ""    return value"",
            """",
            ""def get_string_prefix(value):"",
            ""    return ''"",
            """",
            ""def is_multiline_string(leaf):"",
            ""    return '\\n' in leaf.value"",
            """",
            ""def fix_docstring(docstring, indent):"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n'))"",
            """",
            ""class MockMode:"",
            ""    hex_codes_in_unicode_sequences = False"",
            ""    normalize_docstring_quotes_and_prefixes_properly = True"",
            ""    long_docstring_quotes_on_newline = True"",
            ""    string_normalization = False"",
            ""    line_length = 30"",
            """",
            ""class MockLine:"",
            ""    depth = 1"",
            """",
            ""self = type('Mock', (object,), {"",
            ""    'mode': MockMode(),"",
            ""    'current_line': MockLine(),"",
            ""    'visit_default': lambda leaf: 'Visited'"",
            ""})()"",
            """",
            ""leaf = type('MockLeaf', (object,), {"",
            ""    'value': '\""\""\""quote\\\""\""\""'"",
            ""})()""
        ]
    }
]","[
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 30 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Quote \\ and backslash\\ end\\\""\""\""'})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 20 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""Multi-line\\nDocstring with short last line and split quotes\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 20 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""Trailing backslash \\\\\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 20 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""Short docstring\\nwith multiple lines\\nand trailing backslash\\\\\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 10 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""A docstring with a quote and \\\\\\\""\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return docstring # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 50 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""This is a test string with backslash \\\\\""\""\""'})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 10 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), { 'depth': 1 })() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'value': '\""\""\""Short longdoc with newline\\nof quotes\\nand backslash\\\\\""\""\""'})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 15 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""A docstring with a trailing backslash\\\\\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line.strip() for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), {})() # pragma: no cover"",
            ""self.mode = type('MockMode', (object,), { # pragma: no cover"",
            ""    'hex_codes_in_unicode_sequences': False, # pragma: no cover"",
            ""    'normalize_docstring_quotes_and_prefixes_properly': True, # pragma: no cover"",
            ""    'long_docstring_quotes_on_newline': True, # pragma: no cover"",
            ""    'string_normalization': False, # pragma: no cover"",
            ""    'line_length': 30 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""self.current_line = type('MockLine', (object,), {'depth': 1})() # pragma: no cover"",
            ""self.visit_default = lambda leaf: 'Visited' # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""Trailing quote mark \\\"" and some text\""\""\""' })() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Preview(Enum): # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = 1 # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = 2 # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_unicode_escape_sequences(leaf): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_docstring(leaf): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_prefix(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def normalize_string_quotes(value): # pragma: no cover"",
            ""    return value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def get_string_prefix(value): # pragma: no cover"",
            ""    return '' # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_multiline_string(leaf): # pragma: no cover"",
            ""    return '\\n' in leaf.value # pragma: no cover"",
            "" # pragma: no cover"",
            ""def fix_docstring(docstring, indent): # pragma: no cover"",
            ""    return '\\n'.join(indent + line for line in docstring.split('\\n')) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockMode: # pragma: no cover"",
            ""    hex_codes_in_unicode_sequences = False # pragma: no cover"",
            ""    normalize_docstring_quotes_and_prefixes_properly = True # pragma: no cover"",
            ""    long_docstring_quotes_on_newline = True # pragma: no cover"",
            ""    string_normalization = False # pragma: no cover"",
            ""    line_length = 30 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLine: # pragma: no cover"",
            ""    depth = 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""self = type('Mock', (object,), { # pragma: no cover"",
            ""    'mode': MockMode(), # pragma: no cover"",
            ""    'current_line': MockLine(), # pragma: no cover"",
            ""    'visit_default': lambda leaf: 'Visited' # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    'value': '\""\""\""quote\\\""\""\""' # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    }
]",3,11712,0.005856,3947,0.0059205,0.0117765
