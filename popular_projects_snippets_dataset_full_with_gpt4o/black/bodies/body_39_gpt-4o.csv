prompt,raw_predictions,predictions,prompt_type,input_size,input_price,output_size,output_price,total_price
"Provide self-contained and concrete Python values to initialize the undefined variables in the code snippet.

# begin code snippet
""""""Split according to delimiters of the highest priority.

    If the appropriate Features are given, the split will add trailing commas
    also in function signatures and calls that contain `*` and `**`.
    """"""
try:
    last_leaf = line.leaves[-1]
except IndexError:
    raise CannotSplit(""Line empty"") from None

bt = line.bracket_tracker
try:
    delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})
except ValueError:
    raise CannotSplit(""No delimiters found"") from None

if delimiter_priority == DOT_PRIORITY:
    if bt.delimiter_count_with_priority(delimiter_priority) == 1:
        raise CannotSplit(""Splitting a single attribute from its owner looks wrong"")

current_line = Line(
    mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets
)
lowest_depth = sys.maxsize
trailing_comma_safe = True

def append_to_line(leaf: Leaf) -> Iterator[Line]:
    """"""Append `leaf` to current line or to new line if appending impossible.""""""
    nonlocal current_line
    try:
        current_line.append_safe(leaf, preformatted=True)
    except ValueError:
        exit(current_line)

        current_line = Line(
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets
        )
        current_line.append(leaf)

for leaf in line.leaves:
    exit(append_to_line(leaf))

    for comment_after in line.comments_after(leaf):
        exit(append_to_line(comment_after))

    lowest_depth = min(lowest_depth, leaf.bracket_depth)
    if leaf.bracket_depth == lowest_depth:
        if is_vararg(leaf, within={syms.typedargslist}):
            trailing_comma_safe = (
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features
            )
        elif is_vararg(leaf, within={syms.arglist, syms.argument}):
            trailing_comma_safe = (
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features
            )

    leaf_priority = bt.delimiters.get(id(leaf))
    if leaf_priority == delimiter_priority:
        exit(current_line)

        current_line = Line(
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets
        )
if current_line:
    if (
        trailing_comma_safe
        and delimiter_priority == COMMA_PRIORITY
        and current_line.leaves[-1].type != token.COMMA
        and current_line.leaves[-1].type != STANDALONE_COMMENT
    ):
        new_comma = Leaf(token.COMMA, "","")
        current_line.append(new_comma)
    exit(current_line)

# end code snippet

# begin undefined variables
line
CannotSplit
DOT_PRIORITY
Line
sys
Leaf
Iterator
is_vararg
syms
Feature
features
COMMA_PRIORITY
token
STANDALONE_COMMENT
# end undefined variables

# begin undefined attributes and methods
line.leaves
line.bracket_tracker
line.mode
line.depth
line.inside_brackets
sys.maxsize
line.comments_after
syms.typedargslist
Feature.TRAILING_COMMA_IN_DEF
syms.arglist
syms.argument
Feature.TRAILING_COMMA_IN_CALL
token.COMMA
# end undefined attributes and methods

Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import List, Iterator, Dict, Set"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), { 'leaves': [Leaf() for _ in range(3)], 'bracket_tracker': type('BracketTrackerMock', (object,), { 'max_delimiter_priority': lambda self, exclude=None: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {} })(), 'mode': 'mode', 'depth': 1, 'inside_brackets': True, 'comments_after': lambda self, leaf: [] })()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""Line = type('Line', (object,), { '__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf) })"",
            ""Leaf = type('Leaf', (object,), { '__init__': lambda self: [setattr(self, attr, val) for attr, val in {'type': token.NAME, 'bracket_depth': 1}.items()] })"",
            ""Iterator = type"",
            ""is_vararg = lambda leaf, within: True"",
            ""syms = type('syms', (object,), { 'typedargslist': 1, 'arglist': 2, 'argument': 3 })"",
            ""Feature = type('Feature', (object,), { 'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2 })"",
            ""features = {1, 2}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 53""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""from collections import namedtuple"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})()], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiters': {id(1): 1}, 'delimiter_count_with_priority': lambda self, priority: 2})(), 'mode': 'mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""Line = namedtuple('Line', ['mode', 'depth', 'inside_brackets'])"",
            ""Leaf = namedtuple('Leaf', ['type', 'value'])"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})()"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call'})()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 'standalone_comment'""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""line = SimpleNamespace("",
            ""    leaves=[],"",
            ""    bracket_tracker=type('BracketTrackerMock', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 0,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 1,"",
            ""        'delimiters': {}"",
            ""    })(),"",
            ""    mode=None,"",
            ""    depth=0,"",
            ""    inside_brackets=False,"",
            ""    comments_after=lambda leaf: []"",
            "")"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""DOT_PRIORITY = 1"",
            """",
            ""Line = type('LineMock', (object,), {"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: None,"",
            ""    'append_safe': lambda self, leaf, preformatted: None,"",
            ""    'append': lambda self, leaf: None,"",
            ""    'leaves': []"",
            ""})"",
            """",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            """",
            ""Iterator = iter([]).__class__"",
            """",
            ""is_vararg = lambda leaf, within: False"",
            """",
            ""syms = type('SymsMock', (object,), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument'"",
            ""})"",
            """",
            ""Feature = type('FeatureMock', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF',"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL'"",
            ""})"",
            """",
            ""features = set()"",
            """",
            ""COMMA_PRIORITY = 2"",
            """",
            ""token = type('TokenMock', (object,), {"",
            ""    'COMMA': 'COMMA',"",
            ""    'STANDALONE_COMMENT': 'STANDALONE_COMMENT'"",
            ""})"",
            """",
            ""STANDALONE_COMMENT = 'STANDALONE_COMMENT'""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from collections import namedtuple""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), {'leaves': [Leaf(type='Leaf', value='mock')], 'bracket_tracker': bt, 'mode': 'mock_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda leaf: []})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 1"",
            ""Line = namedtuple('Line', 'mode, depth, inside_brackets')"",
            ""Leaf = namedtuple('Leaf', 'type, value')"",
            ""bt = type('Mock', (object,), {'max_delimiter_priority': lambda self, exclude=None: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {0: 1}})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('Mock', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})()"",
            ""Feature = type('Mock', (object,), {'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call'})()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 'standalone_comment'""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""DOT_PRIORITY = 10"",
            ""COMMA_PRIORITY = 5"",
            ""STANDALONE_COMMENT = 60"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        type('MockLeaf', (object,), {'bracket_depth': 0})()"",
            ""    ],"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude: 10,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {}"",
            ""    })(),"",
            ""    'mode': 'mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            ""Line = type('MockLineClass', (object,), {"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: None,"",
            ""    'append_safe': lambda self, leaf, preformatted: None,"",
            ""    'append': lambda self, leaf: None"",
            ""})"",
            ""Leaf = type('MockLeaf', (object,), {'bracket_depth': 0})"",
            ""def is_vararg(leaf, within): return False"",
            ""syms = type('MockSyms', (object,), {"",
            ""   'typedargslist': 'typedargslist',"",
            ""   'arglist': 'arglist',"",
            ""   'argument': 'argument'"",
            ""})()"",
            ""Feature = type('MockFeature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF',"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL'"",
            ""})()"",
            ""features = set()"",
            ""token = type('MockToken', (object,), {'COMMA': 44})"",
            ""STANDALONE_COMMENT = 'comment'""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), {'leaves': [type('Leaf', (object,), {'bracket_depth': 1, 'type': token.NAME}), type('Leaf', (object,), {'bracket_depth': 1, 'type': token.NAME})], 'bracket_tracker': type('BracketTracker', (object,), {'max_delimiter_priority': lambda exclude: 1, 'delimiter_count_with_priority': lambda priority: 2, 'delimiters': {}})(), 'mode': 'mode_value', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda leaf: []})"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""Line = type('Line', (object,), {'__init__': lambda self, mode, depth, inside_brackets: setattr(self, 'leaves', []), 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), '__bool__': lambda self: bool(self.leaves), 'append': lambda self, leaf: self.leaves.append(leaf)})"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, token_type, value: None, 'bracket_depth': 1, 'type': token.NAME})"",
            ""Iterator = Iterator"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""features = set()"",
            ""COMMA_PRIORITY = 3"",
            ""STANDALONE_COMMENT = 4""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('MockLeaf', (object,), {'bracket_depth': 0})()], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {}})(), 'mode': 'mock_mode', 'depth': 1, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 1"",
            ""Line = type('Line', (object,), {'__init__': lambda self, mode, depth, inside_brackets: setattr(self, 'leaves', []), 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf)})"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type, value: setattr(self, 'type', type) or setattr(self, 'value', value), 'bracket_depth': 0})"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""features = []"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 999""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {}})(), 'mode': 'mock_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 1"",
            ""Line = type('MockLine', (object,), {'append_safe': lambda self, leaf, preformatted: None, 'append': lambda self, leaf: None, 'leaves': []})"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type, value: None, 'bracket_depth': 0})"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})()"",
            ""features = set()"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""@dataclass\nclass Leaf:\n    type: int\n    value: str\n    bracket_depth: int = 0"",
            ""class Feature(Enum):\n    TRAILING_COMMA_IN_DEF = auto()\n    TRAILING_COMMA_IN_CALL = auto()"",
            ""class CannotSplit(Exception):\n    pass"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 999"",
            ""@dataclass\nclass Line:\n    mode: str\n    depth: int\n    inside_brackets: bool\n    leaves: list = field(default_factory=list)\n    bracket_tracker: object = None\n\n    def append_safe(self, leaf: Leaf, preformatted: bool = False):\n        self.leaves.append(leaf)\n\n    def append(self, leaf: Leaf):\n        self.leaves.append(leaf)"",
            ""line = Line(mode='default', depth=0, inside_brackets=False, leaves=[], bracket_tracker=type('Mock', (object,), {'max_delimiter_priority': lambda exclude: 1, 'delimiter_count_with_priority': lambda priority: 2, 'delimiters': {}}))\nline.leaves = [Leaf(type=1, value='value1', bracket_depth=1), Leaf(type=2, value='value2', bracket_depth=0)]\nline.comments_after = lambda leaf: []"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('Mock', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""token = type('Mock', (object,), {'COMMA': 44})"",
            ""sys.maxsize = 9223372036854775807""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), { 'leaves': [], 'bracket_tracker': type('Mock', (object,), { 'max_delimiter_priority': lambda x, exclude=set(): 1, 'delimiters': {}, 'delimiter_count_with_priority': lambda self, priority: 2 })(), 'mode': 'some_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: [] })()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""Line = type('Line', (object,), { '__init__': lambda self, mode, depth, inside_brackets: None, 'leaves': [], 'append_safe': lambda self, leaf, preformatted: None, 'append': lambda self, leaf: None, '__iter__': lambda self: iter([]) })"",
            ""Leaf = type('Leaf', (object,), { '__init__': lambda self, type, value: None, 'bracket_depth': 0, 'type': 0 })"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('Mock', (object,), { 'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument' })()"",
            ""Feature = type('Feature', (object,), { 'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL' })()"",
            ""features = set()"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 54""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import List, Iterator, Dict, Set # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""Line = type('Line', (object,), { '__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf) }) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), { '__init__': lambda self: [setattr(self, attr, val) for attr, val in {'type': token.NAME, 'bracket_depth': 1}.items()] }) # pragma: no cover"",
            ""Iterator = type # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""syms = type('syms', (object,), { 'typedargslist': 1, 'arglist': 2, 'argument': 3 }) # pragma: no cover"",
            ""Feature = type('Feature', (object,), { 'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2 }) # pragma: no cover"",
            ""features = {1, 2} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 53 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})()], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiters': {id(1): 1}, 'delimiter_count_with_priority': lambda self, priority: 2})(), 'mode': 'mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""Line = namedtuple('Line', ['mode', 'depth', 'inside_brackets']) # pragma: no cover"",
            ""Leaf = namedtuple('Leaf', ['type', 'value']) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})() # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call'})() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""line = SimpleNamespace( # pragma: no cover"",
            ""    leaves=[], # pragma: no cover"",
            ""    bracket_tracker=type('BracketTrackerMock', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 0, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 1, # pragma: no cover"",
            ""        'delimiters': {} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    mode=None, # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    comments_after=lambda leaf: [] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""Line = type('LineMock', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: None, # pragma: no cover"",
            ""    'append_safe': lambda self, leaf, preformatted: None, # pragma: no cover"",
            ""    'append': lambda self, leaf: None, # pragma: no cover"",
            ""    'leaves': [] # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""Iterator = iter([]).__class__ # pragma: no cover"",
            "" # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('SymsMock', (object,), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'argument': 'argument' # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""Feature = type('FeatureMock', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""token = type('TokenMock', (object,), { # pragma: no cover"",
            ""    'COMMA': 'COMMA', # pragma: no cover"",
            ""    'STANDALONE_COMMENT': 'STANDALONE_COMMENT' # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""STANDALONE_COMMENT = 'STANDALONE_COMMENT' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover""
        ],
        ""initialization"": [
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""Line = namedtuple('Line', 'mode, depth, inside_brackets') # pragma: no cover"",
            ""Leaf = namedtuple('Leaf', 'type, value') # pragma: no cover"",
            ""bt = type('Mock', (object,), {'max_delimiter_priority': lambda self, exclude=None: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {0: 1}})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('Mock', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})() # pragma: no cover"",
            ""Feature = type('Mock', (object,), {'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call'})() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""DOT_PRIORITY = 10 # pragma: no cover"",
            ""COMMA_PRIORITY = 5 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        type('MockLeaf', (object,), {'bracket_depth': 0})() # pragma: no cover"",
            ""    ], # pragma: no cover"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude: 10, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""Line = type('MockLineClass', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: None, # pragma: no cover"",
            ""    'append_safe': lambda self, leaf, preformatted: None, # pragma: no cover"",
            ""    'append': lambda self, leaf: None # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Leaf = type('MockLeaf', (object,), {'bracket_depth': 0}) # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""   'typedargslist': 'typedargslist', # pragma: no cover"",
            ""   'arglist': 'arglist', # pragma: no cover"",
            ""   'argument': 'argument' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMA': 44}) # pragma: no cover"",
            ""STANDALONE_COMMENT = 'comment' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), {'leaves': [type('Leaf', (object,), {'bracket_depth': 1, 'type': token.NAME}), type('Leaf', (object,), {'bracket_depth': 1, 'type': token.NAME})], 'bracket_tracker': type('BracketTracker', (object,), {'max_delimiter_priority': lambda exclude: 1, 'delimiter_count_with_priority': lambda priority: 2, 'delimiters': {}})(), 'mode': 'mode_value', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda leaf: []}) # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""Line = type('Line', (object,), {'__init__': lambda self, mode, depth, inside_brackets: setattr(self, 'leaves', []), 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), '__bool__': lambda self: bool(self.leaves), 'append': lambda self, leaf: self.leaves.append(leaf)}) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, token_type, value: None, 'bracket_depth': 1, 'type': token.NAME}) # pragma: no cover"",
            ""Iterator = Iterator # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2}) # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""COMMA_PRIORITY = 3 # pragma: no cover"",
            ""STANDALONE_COMMENT = 4 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('MockLeaf', (object,), {'bracket_depth': 0})()], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {}})(), 'mode': 'mock_mode', 'depth': 1, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""Line = type('Line', (object,), {'__init__': lambda self, mode, depth, inside_brackets: setattr(self, 'leaves', []), 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf)}) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type, value: setattr(self, 'type', type) or setattr(self, 'value', value), 'bracket_depth': 0}) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2}) # pragma: no cover"",
            ""features = [] # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 999 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {}})(), 'mode': 'mock_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""Line = type('MockLine', (object,), {'append_safe': lambda self, leaf, preformatted: None, 'append': lambda self, leaf: None, 'leaves': []}) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type, value: None, 'bracket_depth': 0}) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})() # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""@dataclass# pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    type: int# pragma: no cover"",
            ""    value: str# pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            ""class Feature(Enum):# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto()# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""class CannotSplit(Exception):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 999 # pragma: no cover"",
            ""@dataclass# pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    mode: str# pragma: no cover"",
            ""    depth: int# pragma: no cover"",
            ""    inside_brackets: bool# pragma: no cover"",
            ""    leaves: list = field(default_factory=list)# pragma: no cover"",
            ""    bracket_tracker: object = None# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf: Leaf, preformatted: bool = False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append(self, leaf: Leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""line = Line(mode='default', depth=0, inside_brackets=False, leaves=[], bracket_tracker=type('Mock', (object,), {'max_delimiter_priority': lambda exclude: 1, 'delimiter_count_with_priority': lambda priority: 2, 'delimiters': {}}))# pragma: no cover"",
            ""line.leaves = [Leaf(type=1, value='value1', bracket_depth=1), Leaf(type=2, value='value2', bracket_depth=0)]# pragma: no cover"",
            ""line.comments_after = lambda leaf: [] # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('Mock', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""token = type('Mock', (object,), {'COMMA': 44}) # pragma: no cover"",
            ""sys.maxsize = 9223372036854775807 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), { 'leaves': [], 'bracket_tracker': type('Mock', (object,), { 'max_delimiter_priority': lambda x, exclude=set(): 1, 'delimiters': {}, 'delimiter_count_with_priority': lambda self, priority: 2 })(), 'mode': 'some_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: [] })() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""Line = type('Line', (object,), { '__init__': lambda self, mode, depth, inside_brackets: None, 'leaves': [], 'append_safe': lambda self, leaf, preformatted: None, 'append': lambda self, leaf: None, '__iter__': lambda self: iter([]) }) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), { '__init__': lambda self, type, value: None, 'bracket_depth': 0, 'type': 0 }) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('Mock', (object,), { 'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument' })() # pragma: no cover"",
            ""Feature = type('Feature', (object,), { 'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL' })() # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 54 # pragma: no cover""
        ]
    }
]",1,953,0.0004765,4315,0.0064725,0.006949
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 46:
    ^
SyntaxError: no binding for nonlocal 'current_line' found
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import List, Iterator, Dict, Set"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), { 'leaves': [type('Leaf', (object,), { '__init__': lambda self: [setattr(self, attr, val) for attr, val in {'type': token.NAME, 'bracket_depth': 1}.items()] })() for _ in range(3)], 'bracket_tracker': type('BracketTrackerMock', (object,), { 'max_delimiter_priority': lambda self, exclude=None: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {} })(), 'mode': 'mode', 'depth': 1, 'inside_brackets': True, 'comments_after': lambda self, leaf: [] })()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""Line = type('Line', (object,), { '__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf) })"",
            ""Leaf = type('Leaf', (object,), { '__init__': lambda self: [setattr(self, attr, val) for attr, val in {'type': token.NAME, 'bracket_depth': 1}.items()] })"",
            ""Iterator = type"",
            ""is_vararg = lambda leaf, within: True"",
            ""syms = type('syms', (object,), { 'typedargslist': 1, 'arglist': 2, 'argument': 3 })"",
            ""Feature = type('Feature', (object,), { 'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2 })"",
            ""features = {1, 2}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 53""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Iterator, Dict, Set"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type=token.NAME, bracket_depth=1):"",
            ""        self.type = type"",
            ""        self.bracket_depth = bracket_depth"",
            """",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    "",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        self.leaves.append(leaf)"",
            ""    "",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""class BracketTrackerMock:"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        return 1"",
            """",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 2"",
            """",
            ""    @property"",
            ""    def delimiters(self):"",
            ""        return {}"",
            """",
            ""class LineMock:"",
            ""    leaves = [Leaf() for _ in range(3)]"",
            ""    bracket_tracker = BracketTrackerMock()"",
            ""    mode = 'mode'"",
            ""    depth = 1"",
            ""    inside_brackets = True"",
            ""    @staticmethod"",
            ""    def comments_after(leaf):"",
            ""        return []"",
            """",
            ""line = LineMock()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""is_vararg = lambda leaf, within: True"",
            ""syms = type('syms', (object,), { 'typedargslist': 1, 'arglist': 2, 'argument': 3 })"",
            ""Feature = type('Feature', (object,), { 'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2 })"",
            ""features = {1, 2}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 53""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Iterator, Dict, Set"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), { 'leaves': [type('LeafMock', (object,), { 'bracket_depth': 1 })() for _ in range(3)], 'bracket_tracker': type('BracketTrackerMock', (object,), { 'max_delimiter_priority': lambda self, exclude=None: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {id(None): 1} })(), 'mode': 'mode', 'depth': 1, 'inside_brackets': True, 'comments_after': lambda self, leaf: [] })()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""Line = type('Line', (object,), { '__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf) })"",
            ""Leaf = type('Leaf', (object,), { '__init__': lambda self, token_type=token.NAME, value='': [setattr(self, attr, val) for attr, val in {'type': token_type, 'value': value, 'bracket_depth': 1}.items()] })"",
            ""Iterator = iter"",
            ""is_vararg = lambda leaf, within: True"",
            ""syms = type('syms', (object,), { 'typedargslist': 1, 'arglist': 2, 'argument': 3 })"",
            ""Feature = type('Feature', (object,), { 'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2 })"",
            ""features = {1, 2}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 999""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Iterator, Dict, Set"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self):"",
            ""        self.type = token.NAME"",
            ""        self.bracket_depth = 1"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if preformatted and leaf not in self.leaves:"",
            ""            self.leaves.append(leaf)"",
            ""        else:"",
            ""            raise ValueError"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [Leaf() for _ in range(3)],"",
            ""    'bracket_tracker': type('BracketTrackerMock', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 1,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {}"",
            ""    })(),"",
            ""    'mode': 'mode',"",
            ""    'depth': 1,"",
            ""    'inside_brackets': True,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            ""DOT_PRIORITY = 2"",
            ""sys.maxsize = 9223372036854775807"",
            ""is_vararg = lambda leaf, within: True"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'argument': 3"",
            ""})"",
            ""Feature = type('Feature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 1,"",
            ""    'TRAILING_COMMA_IN_CALL': 2"",
            ""})"",
            ""features = {1, 2}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 53""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Iterator, Dict, Set"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), { 'leaves': [type('Leaf', (object,), {'type': token.NAME, 'bracket_depth': 1})() for _ in range(3)], 'bracket_tracker': type('BracketTrackerMock', (object,), { 'max_delimiter_priority': lambda self, exclude=None: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {} })(), 'mode': 'mode', 'depth': 1, 'inside_brackets': True, 'comments_after': lambda self, leaf: [] })()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""Line = type('Line', (object,), { '__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf) })"",
            ""Leaf = type('Leaf', (object,), {})"",
            ""Iterator = type"",
            ""is_vararg = lambda leaf, within: True"",
            ""syms = type('syms', (object,), { 'typedargslist': 1, 'arglist': 2, 'argument': 3 })"",
            ""Feature = type('Feature', (object,), { 'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2 })"",
            ""features = {1, 2}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 53""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Iterator, Dict, Set"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), { 'leaves': [type('Leaf', (object,), { 'bracket_depth': 1 })() for _ in range(3)], 'bracket_tracker': type('BracketTrackerMock', (object,), { 'max_delimiter_priority': lambda self, exclude=None: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {} })(), 'mode': 'mode', 'depth': 1, 'inside_brackets': True, 'comments_after': lambda self, leaf: [] })()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""Line = type('Line', (object,), { '__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf) if len(self.leaves) < 3 else (_ for _ in ()).throw(ValueError()), 'append': lambda self, leaf: self.leaves.append(leaf) })"",
            ""Leaf = type('Leaf', (object,), { '__init__': lambda self, value='': [setattr(self, attr, val) for attr, val in {'type': token.NAME, 'bracket_depth': 1, 'value': value}.items()] })"",
            ""Iterator = iter"",
            ""is_vararg = lambda leaf, within: True"",
            ""syms = type('syms', (object,), { 'typedargslist': 1, 'arglist': 2, 'argument': 3 })"",
            ""Feature = type('Feature', (object,), { 'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2 })"",
            ""features = {1, 2}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 53"",
            ""sys.maxsize = 9223372036854775807""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Iterator, Dict, Set"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), { 'leaves': [type('LeafMock', (object,), {'type': token.NAME, 'bracket_depth': 1})() for _ in range(3)], 'bracket_tracker': type('BracketTrackerMock', (object,), { 'max_delimiter_priority': lambda self, exclude=None: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {} })(), 'mode': 'mode', 'depth': 1, 'inside_brackets': True, 'comments_after': lambda self, leaf: [] })()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""Line = type('Line', (object,), { '__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf) })"",
            ""Leaf = type('Leaf', (object,), { '__init__': lambda self: [setattr(self, attr, val) for attr, val in {'type': token.NAME, 'bracket_depth': 1}.items()] })"",
            ""Iterator = type"",
            ""is_vararg = lambda leaf, within: True"",
            ""syms = type('syms', (object,), { 'typedargslist': 1, 'arglist': 2, 'argument': 3 })"",
            ""Feature = type('Feature', (object,), { 'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2 })"",
            ""features = {1, 2}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 53""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Iterator, Dict, Set"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), { 'leaves': [type('Leaf', (object,), { '__init__': lambda self: [setattr(self, attr, val) for attr, val in {'type': token.NAME, 'bracket_depth': 1, 'value': ''}.items()] })() for _ in range(3)], 'bracket_tracker': type('BracketTrackerMock', (object,), { 'max_delimiter_priority': lambda self, exclude=None: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {}})(), 'mode': 'mode', 'depth': 1, 'inside_brackets': True, 'comments_after': lambda self, leaf: [] })()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""Line = type('Line', (object,), { '__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf) })"",
            ""Leaf = type('Leaf', (object,), { '__init__': lambda self: [setattr(self, attr, val) for attr, val in {'type': token.NAME, 'bracket_depth': 1, 'value': ''}.items()] })"",
            ""Iterator = type"",
            ""is_vararg = lambda leaf, within: True"",
            ""syms = type('syms', (object,), { 'typedargslist': 1, 'arglist': 2, 'argument': 3 })"",
            ""Feature = type('Feature', (object,), { 'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2 })"",
            ""features = {1, 2}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 53""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Iterator, Dict, Set"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 53"",
            ""Leaf = type('Leaf', (object,), { '__init__': lambda self, type=token.NAME, bracket_depth=1: (setattr(self, 'type', type), setattr(self, 'bracket_depth', bracket_depth)) })"",
            ""Line = type('Line', (object,), { '__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf) })"",
            ""BracketTrackerMock = type('BracketTrackerMock', (object,), { 'max_delimiter_priority': lambda self, exclude=None: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {} })"",
            ""line = type('Mock', (object,), { 'leaves': [Leaf() for _ in range(3)], 'bracket_tracker': BracketTrackerMock(), 'mode': 'mode', 'depth': 1, 'inside_brackets': True, 'comments_after': lambda self, leaf: [] })()"",
            ""Iterator = type"",
            ""is_vararg = lambda leaf, within: True"",
            ""syms = type('syms', (object,), { 'typedargslist': 1, 'arglist': 2, 'argument': 3 })"",
            ""Feature = type('Feature', (object,), { 'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2 })"",
            ""features = {1, 2}""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Iterator, Dict, Set"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), { 'leaves': [type('LeafMock', (object,), {'bracket_depth': 1})() for _ in range(3)], 'bracket_tracker': type('BracketTrackerMock', (object,), { 'max_delimiter_priority': lambda self, exclude=None: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {} })(), 'mode': 'mode', 'depth': 1, 'inside_brackets': True, 'comments_after': lambda self, leaf: [] })()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""Line = type('Line', (object,), { '__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf) })"",
            ""Leaf = type('Leaf', (object,), { '__init__': lambda self, type=token.NAME, value='': [setattr(self, attr, val) for attr, val in {'type': type, 'value': value, 'bracket_depth': 1}.items()] })"",
            ""Iterator = type"",
            ""is_vararg = lambda leaf, within: True"",
            ""syms = type('syms', (object,), { 'typedargslist': 1, 'arglist': 2, 'argument': 3 })"",
            ""Feature = type('Feature', (object,), { 'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2 })"",
            ""features = {1, 2}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 53""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import List, Iterator, Dict, Set # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""Line = type('Line', (object,), { '__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf) }) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), { '__init__': lambda self: [setattr(self, attr, val) for attr, val in {'type': token.NAME, 'bracket_depth': 1}.items()] }) # pragma: no cover"",
            ""Iterator = type # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""syms = type('syms', (object,), { 'typedargslist': 1, 'arglist': 2, 'argument': 3 }) # pragma: no cover"",
            ""Feature = type('Feature', (object,), { 'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2 }) # pragma: no cover"",
            ""features = {1, 2} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 53 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Iterator, Dict, Set # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type=token.NAME, bracket_depth=1): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""     # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""     # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTrackerMock: # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""    @property # pragma: no cover"",
            ""    def delimiters(self): # pragma: no cover"",
            ""        return {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""class LineMock: # pragma: no cover"",
            ""    leaves = [Leaf() for _ in range(3)] # pragma: no cover"",
            ""    bracket_tracker = BracketTrackerMock() # pragma: no cover"",
            ""    mode = 'mode' # pragma: no cover"",
            ""    depth = 1 # pragma: no cover"",
            ""    inside_brackets = True # pragma: no cover"",
            ""    @staticmethod # pragma: no cover"",
            ""    def comments_after(leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = LineMock() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""syms = type('syms', (object,), { 'typedargslist': 1, 'arglist': 2, 'argument': 3 }) # pragma: no cover"",
            ""Feature = type('Feature', (object,), { 'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2 }) # pragma: no cover"",
            ""features = {1, 2} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 53 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Iterator, Dict, Set # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), { 'leaves': [type('LeafMock', (object,), { 'bracket_depth': 1 })() for _ in range(3)], 'bracket_tracker': type('BracketTrackerMock', (object,), { 'max_delimiter_priority': lambda self, exclude=None: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {id(None): 1} })(), 'mode': 'mode', 'depth': 1, 'inside_brackets': True, 'comments_after': lambda self, leaf: [] })() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""Line = type('Line', (object,), { '__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf) }) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), { '__init__': lambda self, token_type=token.NAME, value='': [setattr(self, attr, val) for attr, val in {'type': token_type, 'value': value, 'bracket_depth': 1}.items()] }) # pragma: no cover"",
            ""Iterator = iter # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""syms = type('syms', (object,), { 'typedargslist': 1, 'arglist': 2, 'argument': 3 }) # pragma: no cover"",
            ""Feature = type('Feature', (object,), { 'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2 }) # pragma: no cover"",
            ""features = {1, 2} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 999 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Iterator, Dict, Set # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.type = token.NAME # pragma: no cover"",
            ""        self.bracket_depth = 1 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if preformatted and leaf not in self.leaves: # pragma: no cover"",
            ""            self.leaves.append(leaf) # pragma: no cover"",
            ""        else: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [Leaf() for _ in range(3)], # pragma: no cover"",
            ""    'bracket_tracker': type('BracketTrackerMock', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 1, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mode', # pragma: no cover"",
            ""    'depth': 1, # pragma: no cover"",
            ""    'inside_brackets': True, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""sys.maxsize = 9223372036854775807 # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'argument': 3 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Feature = type('Feature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 1, # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 2 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""features = {1, 2} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 53 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Iterator, Dict, Set # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), { 'leaves': [type('Leaf', (object,), {'type': token.NAME, 'bracket_depth': 1})() for _ in range(3)], 'bracket_tracker': type('BracketTrackerMock', (object,), { 'max_delimiter_priority': lambda self, exclude=None: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {} })(), 'mode': 'mode', 'depth': 1, 'inside_brackets': True, 'comments_after': lambda self, leaf: [] })() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""Line = type('Line', (object,), { '__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf) }) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), {}) # pragma: no cover"",
            ""Iterator = type # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""syms = type('syms', (object,), { 'typedargslist': 1, 'arglist': 2, 'argument': 3 }) # pragma: no cover"",
            ""Feature = type('Feature', (object,), { 'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2 }) # pragma: no cover"",
            ""features = {1, 2} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 53 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Iterator, Dict, Set # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), { 'leaves': [type('Leaf', (object,), { 'bracket_depth': 1 })() for _ in range(3)], 'bracket_tracker': type('BracketTrackerMock', (object,), { 'max_delimiter_priority': lambda self, exclude=None: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {} })(), 'mode': 'mode', 'depth': 1, 'inside_brackets': True, 'comments_after': lambda self, leaf: [] })() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""Line = type('Line', (object,), { '__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf) if len(self.leaves) < 3 else (_ for _ in ()).throw(ValueError()), 'append': lambda self, leaf: self.leaves.append(leaf) }) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), { '__init__': lambda self, value='': [setattr(self, attr, val) for attr, val in {'type': token.NAME, 'bracket_depth': 1, 'value': value}.items()] }) # pragma: no cover"",
            ""Iterator = iter # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""syms = type('syms', (object,), { 'typedargslist': 1, 'arglist': 2, 'argument': 3 }) # pragma: no cover"",
            ""Feature = type('Feature', (object,), { 'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2 }) # pragma: no cover"",
            ""features = {1, 2} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 53 # pragma: no cover"",
            ""sys.maxsize = 9223372036854775807 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Iterator, Dict, Set # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), { 'leaves': [type('LeafMock', (object,), {'type': token.NAME, 'bracket_depth': 1})() for _ in range(3)], 'bracket_tracker': type('BracketTrackerMock', (object,), { 'max_delimiter_priority': lambda self, exclude=None: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {} })(), 'mode': 'mode', 'depth': 1, 'inside_brackets': True, 'comments_after': lambda self, leaf: [] })() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""Line = type('Line', (object,), { '__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf) }) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), { '__init__': lambda self: [setattr(self, attr, val) for attr, val in {'type': token.NAME, 'bracket_depth': 1}.items()] }) # pragma: no cover"",
            ""Iterator = type # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""syms = type('syms', (object,), { 'typedargslist': 1, 'arglist': 2, 'argument': 3 }) # pragma: no cover"",
            ""Feature = type('Feature', (object,), { 'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2 }) # pragma: no cover"",
            ""features = {1, 2} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 53 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Iterator, Dict, Set # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""Line = type('Line', (object,), { '__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf) }) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), { '__init__': lambda self: [setattr(self, attr, val) for attr, val in {'type': token.NAME, 'bracket_depth': 1, 'value': ''}.items()] }) # pragma: no cover"",
            ""Iterator = type # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""syms = type('syms', (object,), { 'typedargslist': 1, 'arglist': 2, 'argument': 3 }) # pragma: no cover"",
            ""Feature = type('Feature', (object,), { 'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2 }) # pragma: no cover"",
            ""features = {1, 2} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 53 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Iterator, Dict, Set # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 53 # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), { '__init__': lambda self, type=token.NAME, bracket_depth=1: (setattr(self, 'type', type), setattr(self, 'bracket_depth', bracket_depth)) }) # pragma: no cover"",
            ""Line = type('Line', (object,), { '__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf) }) # pragma: no cover"",
            ""BracketTrackerMock = type('BracketTrackerMock', (object,), { 'max_delimiter_priority': lambda self, exclude=None: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {} }) # pragma: no cover"",
            ""Iterator = type # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""syms = type('syms', (object,), { 'typedargslist': 1, 'arglist': 2, 'argument': 3 }) # pragma: no cover"",
            ""Feature = type('Feature', (object,), { 'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2 }) # pragma: no cover"",
            ""features = {1, 2} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Iterator, Dict, Set # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), { 'leaves': [type('LeafMock', (object,), {'bracket_depth': 1})() for _ in range(3)], 'bracket_tracker': type('BracketTrackerMock', (object,), { 'max_delimiter_priority': lambda self, exclude=None: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {} })(), 'mode': 'mode', 'depth': 1, 'inside_brackets': True, 'comments_after': lambda self, leaf: [] })() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""Line = type('Line', (object,), { '__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf) }) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), { '__init__': lambda self, type=token.NAME, value='': [setattr(self, attr, val) for attr, val in {'type': type, 'value': value, 'bracket_depth': 1}.items()] }) # pragma: no cover"",
            ""Iterator = type # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""syms = type('syms', (object,), { 'typedargslist': 1, 'arglist': 2, 'argument': 3 }) # pragma: no cover"",
            ""Feature = type('Feature', (object,), { 'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2 }) # pragma: no cover"",
            ""features = {1, 2} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 53 # pragma: no cover""
        ]
    }
]",2,1697,0.0008485,4929,0.0073935,0.008242
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 47:
    ^
SyntaxError: no binding for nonlocal 'current_line' found
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""DOT_PRIORITY = 2"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 53"",
            ""class Leaf: def __init__(self, type, value): self.type = type; self.value = value; self.bracket_depth = 1"",
            ""class Line: def __init__(self, mode, depth, inside_brackets): self.mode = mode; self.depth = depth; self.inside_brackets = inside_brackets; self.leaves = []; def append_safe(self, leaf, preformatted): self.leaves.append(leaf); def append(self, leaf): self.leaves.append(leaf)"",
            ""class MockBracketTracker: def max_delimiter_priority(self, exclude): return 1; def delimiter_count_with_priority(self, priority): return 2; delimiters = {}"",
            ""line = type('MockLine', (object,), {'leaves': [Leaf(token.NAME, 'a')], 'bracket_tracker': MockBracketTracker(), 'mode': 'mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})"",
            ""class syms: typedargslist = 1; arglist = 2; argument = 3"",
            ""class Feature: TRAILING_COMMA_IN_DEF = 1; TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""is_vararg = lambda leaf, within: False"",
            ""sys.maxsize = 9223372036854775807""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockBracketTracker:"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        return 1"",
            """",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 2"",
            """",
            ""    delimiters = {}"",
            """",
            ""class MockLeaf:"",
            ""    def __init__(self):"",
            ""        self.bracket_depth = 1"",
            ""        self.type = token.NAME"",
            """",
            ""class MockLine:"",
            ""    def __init__(self, leaves, bracket_tracker, mode, depth, inside_brackets):"",
            ""        self.leaves = leaves"",
            ""        self.bracket_tracker = bracket_tracker"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            """",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            """",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""line = MockLine([MockLeaf() for _ in range(3)], MockBracketTracker(), 'mode', 0, False)"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""Leaf = type('Leaf', (object,), {'type': token.NAME, 'value': ','})"",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            ""syms = type('syms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})()"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call'})()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 'standalone_comment'""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator, List"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})(), type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})()], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude={}: 1, 'delimiters': {}, 'delimiter_count_with_priority': lambda self, priority: 2})(), 'mode': 'mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""Line = type('Line', (object,), {'__init__': lambda self, mode, depth, inside_brackets: [setattr(self, k, v) for k, v in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf)})"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type, value: [setattr(self, k, v) for k, v in {'type': type, 'value': value, 'bracket_depth': 0}.items()]})"",
            ""Iterator = type('Iterator', (object,), {})"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})()"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL'})"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 53""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})()], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiters': {}, 'delimiter_count_with_priority': lambda self, priority: 2})(), 'mode': 'mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""Line = type('Line', (object,), {'__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: True if leaf else False, 'append': lambda self, leaf: self.leaves.append(leaf)})"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type, value: [setattr(self, attr, val) for attr, val in {'type': type, 'value': value, 'bracket_depth': 1}.items()], '__repr__': lambda self: f'Leaf(type={self.type}, value={self.value})'})"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""features = {1, 2}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = token.COMMENT""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})()], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiters': {id(type('MockLeaf', (object,), {})) : 1}, 'delimiter_count_with_priority': lambda self, priority: 2})(), 'mode': 'mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""Line = type('Line', (object,), {'__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf)})"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, typ=token.NAME, value=',': [setattr(self, attr, val) for attr, val in {'type': typ, 'value': value, 'bracket_depth': 1}.items()]})"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})()"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call'})()"",
            ""features = {'trailing_comma_in_def', 'trailing_comma_in_call'}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 'standalone_comment'""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""from collections import namedtuple"",
            ""import token""
        ],
        ""initialization"": [
            ""class MockLine:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = [MockLeaf()]"",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""class MockLeaf:"",
            ""    def __init__(self):"",
            ""        self.type = token.NAME"",
            ""        self.bracket_depth = 1"",
            ""class MockBracketTracker:"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        return 1"",
            ""    def delimiters(self):"",
            ""        return {id(1): 1}"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 2"",
            ""line = MockLine('mode', 0, False)"",
            ""line.bracket_tracker = MockBracketTracker()"",
            ""line.comments_after = lambda leaf: []"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""Line = MockLine"",
            ""Leaf = MockLeaf"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})()"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call'})()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 'standalone_comment'""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), { 'leaves': [type('Leaf', (object,), {'type': token.NAME, 'bracket_depth': 1})()], 'bracket_tracker': type('BracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude=None: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {}})(), 'mode': 'mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: [] })()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""Line = type('Line', (object,), {'__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted=False: self.leaves.append(leaf) if preformatted else self.leaves.append(leaf) if leaf.type != token.COMMA else None, 'append': lambda self, leaf: self.leaves.append(leaf) })"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type, value: [setattr(self, attr, val) for attr, val in {'type': type, 'value': value, 'bracket_depth': 1}.items()]})"",
            ""Iterator = iter"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""features = {1, 2}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 53""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        if not isinstance(leaf, Leaf):"",
            ""            raise ValueError('Invalid leaf')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""class Leaf:"",
            ""    def __init__(self):"",
            ""        self.type = token.NAME"",
            ""        self.bracket_depth = 1"",
            ""class BracketTracker:"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        return 1"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 2"",
            ""    delimiters = {}"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [Leaf(), Leaf(), Leaf()], "",
            ""    'bracket_tracker': BracketTracker(),"",
            ""    'mode': 'mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: [],"",
            ""})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'argument': 3,"",
            ""})()"",
            ""Feature = type('Feature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def',"",
            ""    'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call'"",
            ""})()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""sys.maxsize = 9223372036854775807""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})()], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiters': {id(1): 1}, 'delimiter_count_with_priority': lambda self, priority: 2})(), 'mode': 'mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""Line = type('Line', (object,), {'__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf) if preformatted else None, 'append': lambda self, leaf: self.leaves.append(leaf)})"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type=token.NAME, value='': [setattr(self, attr, val) for attr, val in {'type': type, 'value': value, 'bracket_depth': 0}.items()]})"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})()"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call'})()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 'standalone_comment'""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLeaf: pass"",
            ""line = type('MockLine', (object,), { 'leaves': [MockLeaf(), MockLeaf()], 'bracket_tracker': type('MockBracketTracker', (object,), { 'max_delimiter_priority': lambda self, exclude: 1, 'delimiters': {id(MockLeaf()): 1}, 'delimiter_count_with_priority': lambda self, priority: 2})(), 'mode': 'mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})"",
            ""DOT_PRIORITY = 2"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""sys.modules['MockLine'] = line"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, leaf_type=token.NAME, value='': [setattr(self, attr, val) for attr, val in {'type': leaf_type, 'value': value, 'bracket_depth': 0}.items()]})"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('MockSyms', (object,), { 'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument' })()"",
            ""Feature = type('Feature', (object,), { 'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call' })()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 53""
        ]
    }
]","[
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 53 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockBracketTracker: # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""    delimiters = {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.bracket_depth = 1 # pragma: no cover"",
            ""        self.type = token.NAME # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLine: # pragma: no cover"",
            ""    def __init__(self, leaves, bracket_tracker, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.leaves = leaves # pragma: no cover"",
            ""        self.bracket_tracker = bracket_tracker # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = MockLine([MockLeaf() for _ in range(3)], MockBracketTracker(), 'mode', 0, False) # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), {'type': token.NAME, 'value': ','}) # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})() # pragma: no cover"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call'})() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator, List # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})(), type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})()], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude={}: 1, 'delimiters': {}, 'delimiter_count_with_priority': lambda self, priority: 2})(), 'mode': 'mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""Line = type('Line', (object,), {'__init__': lambda self, mode, depth, inside_brackets: [setattr(self, k, v) for k, v in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf)}) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type, value: [setattr(self, k, v) for k, v in {'type': type, 'value': value, 'bracket_depth': 0}.items()]}) # pragma: no cover"",
            ""Iterator = type('Iterator', (object,), {}) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})() # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL'}) # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 53 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})()], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiters': {}, 'delimiter_count_with_priority': lambda self, priority: 2})(), 'mode': 'mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""Line = type('Line', (object,), {'__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: True if leaf else False, 'append': lambda self, leaf: self.leaves.append(leaf)}) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type, value: [setattr(self, attr, val) for attr, val in {'type': type, 'value': value, 'bracket_depth': 1}.items()], '__repr__': lambda self: f'Leaf(type={self.type}, value={self.value})'}) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2}) # pragma: no cover"",
            ""features = {1, 2} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = token.COMMENT # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})()], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiters': {id(type('MockLeaf', (object,), {})) : 1}, 'delimiter_count_with_priority': lambda self, priority: 2})(), 'mode': 'mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""Line = type('Line', (object,), {'__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf)}) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, typ=token.NAME, value=',': [setattr(self, attr, val) for attr, val in {'type': typ, 'value': value, 'bracket_depth': 1}.items()]}) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})() # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call'})() # pragma: no cover"",
            ""features = {'trailing_comma_in_def', 'trailing_comma_in_call'} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLine: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [MockLeaf()] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.type = token.NAME # pragma: no cover"",
            ""        self.bracket_depth = 1 # pragma: no cover"",
            ""class MockBracketTracker: # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    def delimiters(self): # pragma: no cover"",
            ""        return {id(1): 1} # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""line = MockLine('mode', 0, False) # pragma: no cover"",
            ""line.bracket_tracker = MockBracketTracker() # pragma: no cover"",
            ""line.comments_after = lambda leaf: [] # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""Line = MockLine # pragma: no cover"",
            ""Leaf = MockLeaf # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})() # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call'})() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), { 'leaves': [type('Leaf', (object,), {'type': token.NAME, 'bracket_depth': 1})()], 'bracket_tracker': type('BracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude=None: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {}})(), 'mode': 'mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: [] })() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""Line = type('Line', (object,), {'__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted=False: self.leaves.append(leaf) if preformatted else self.leaves.append(leaf) if leaf.type != token.COMMA else None, 'append': lambda self, leaf: self.leaves.append(leaf) }) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type, value: [setattr(self, attr, val) for attr, val in {'type': type, 'value': value, 'bracket_depth': 1}.items()]}) # pragma: no cover"",
            ""Iterator = iter # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2}) # pragma: no cover"",
            ""features = {1, 2} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 53 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): # pragma: no cover"",
            ""        if not isinstance(leaf, Leaf): # pragma: no cover"",
            ""            raise ValueError('Invalid leaf') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.type = token.NAME # pragma: no cover"",
            ""        self.bracket_depth = 1 # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    delimiters = {} # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [Leaf(), Leaf(), Leaf()],  # pragma: no cover"",
            ""    'bracket_tracker': BracketTracker(), # pragma: no cover"",
            ""    'mode': 'mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [], # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'argument': 3, # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""Feature = type('Feature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""sys.maxsize = 9223372036854775807 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})()], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiters': {id(1): 1}, 'delimiter_count_with_priority': lambda self, priority: 2})(), 'mode': 'mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""Line = type('Line', (object,), {'__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf) if preformatted else None, 'append': lambda self, leaf: self.leaves.append(leaf)}) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type=token.NAME, value='': [setattr(self, attr, val) for attr, val in {'type': type, 'value': value, 'bracket_depth': 0}.items()]}) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})() # pragma: no cover"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call'})() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLeaf: pass # pragma: no cover"",
            ""line = type('MockLine', (object,), { 'leaves': [MockLeaf(), MockLeaf()], 'bracket_tracker': type('MockBracketTracker', (object,), { 'max_delimiter_priority': lambda self, exclude: 1, 'delimiters': {id(MockLeaf()): 1}, 'delimiter_count_with_priority': lambda self, priority: 2})(), 'mode': 'mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: []}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""sys.modules['MockLine'] = line # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, leaf_type=token.NAME, value='': [setattr(self, attr, val) for attr, val in {'type': leaf_type, 'value': value, 'bracket_depth': 0}.items()]}) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { 'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument' })() # pragma: no cover"",
            ""Feature = type('Feature', (object,), { 'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call' })() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 53 # pragma: no cover""
        ]
    }
]",2,2363,0.0011815,4988,0.007482,0.0086635
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 91:
    ^
SyntaxError: no binding for nonlocal 'current_line' found
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})()], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiters': {}, 'delimiter_count_with_priority': lambda self, priority: 2})(), 'mode': 'mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""Line = type('Line', (object,), {'__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf)})"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type=token.NAME, value='': [setattr(self, attr, val) for attr, val in {'type': type, 'value': value, 'bracket_depth': 1}.items()]})"",
            ""Iterator = iter([]).__class__"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})()"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call'})()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = token.N_TOKENS""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""from types import SimpleNamespace"",
            ""import token""
        ],
        ""initialization"": [
            ""line = SimpleNamespace("",
            ""    leaves=[SimpleNamespace(bracket_depth=0, type=token.NAME) for _ in range(3)],"",
            ""    bracket_tracker=SimpleNamespace("",
            ""        max_delimiter_priority=lambda exclude: 1,"",
            ""        delimiter_count_with_priority=lambda priority: 2,"",
            ""        delimiters={}"",
            ""    ),"",
            ""    mode='mode',"",
            ""    depth=0,"",
            ""    inside_brackets=False,"",
            ""    comments_after=lambda leaf: []"",
            "")"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""DOT_PRIORITY = 1"",
            """",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            """",
            ""is_vararg = lambda leaf, within: False"",
            """",
            ""syms = SimpleNamespace("",
            ""    typedargslist=1,"",
            ""    arglist=2,"",
            ""    argument=3"",
            "")"",
            """",
            ""Feature = SimpleNamespace("",
            ""    TRAILING_COMMA_IN_DEF=1,"",
            ""    TRAILING_COMMA_IN_CALL=2"",
            "")"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            """",
            ""STANDALONE_COMMENT = 53""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [type('MockLeaf', (object,), {"",
            ""        'bracket_depth': 1,"",
            ""        'type': token.NAME"",
            ""    })()],"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude: 1,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {id(1): 1}"",
            ""    })(),"",
            ""    'mode': 'mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""DOT_PRIORITY = 2"",
            """",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        if not preformatted:"",
            ""            raise ValueError"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""class Leaf:"",
            ""    def __init__(self, type=token.NAME, value='value'):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            """",
            ""Iterator = iter([]).__class__"",
            """",
            ""is_vararg = lambda leaf, within: False"",
            """",
            ""syms = type('MockSyms', (object,), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument'"",
            ""})"",
            """",
            ""Feature = type('MockFeature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF',"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL'"",
            ""})"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            """",
            ""token = type('TokenMock', (object,), {"",
            ""    'COMMA': 'COMMA',"",
            ""    'STANDALONE_COMMENT': 'STANDALONE_COMMENT'"",
            ""})"",
            """",
            ""STANDALONE_COMMENT = 'STANDALONE_COMMENT'""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""from types import SimpleNamespace"",
            ""import token""
        ],
        ""initialization"": [
            ""line = SimpleNamespace("",
            ""    leaves=[SimpleNamespace(bracket_depth=0, type=token.NAME) for _ in range(3)],"",
            ""    bracket_tracker=SimpleNamespace("",
            ""        max_delimiter_priority=lambda exclude=None: 1,"",
            ""        delimiters={},"",
            ""        delimiter_count_with_priority=lambda priority: 2"",
            ""    ),"",
            ""    mode=None,"",
            ""    depth=0,"",
            ""    inside_brackets=False,"",
            ""    comments_after=lambda leaf: []"",
            "")"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""DOT_PRIORITY = 2"",
            """",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            """",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            """",
            ""is_vararg = lambda leaf, within: False"",
            """",
            ""syms = SimpleNamespace("",
            ""    typedargslist='typedargslist',"",
            ""    arglist='arglist',"",
            ""    argument='argument'"",
            "")"",
            """",
            ""Feature = SimpleNamespace("",
            ""    TRAILING_COMMA_IN_DEF='TRAILING_COMMA_IN_DEF',"",
            ""    TRAILING_COMMA_IN_CALL='TRAILING_COMMA_IN_CALL'"",
            "")"",
            """",
            ""features = set()"",
            """",
            ""COMMA_PRIORITY = 1"",
            """",
            ""STANDALONE_COMMENT = 'STANDALONE_COMMENT'""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""sys = type('MockSys', (object,), {'maxsize': 9223372036854775807})"",
            ""Leaf = type('Leaf', (object,), {"",
            ""    '__init__': lambda self, type=token.NAME, value='value': [setattr(self, k, v) for k, v in {'type': type, 'value': value, 'bracket_depth': 0}.items()]"",
            ""})"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""features = {1, 2}"",
            ""is_vararg = lambda leaf, within: False"",
            ""Line = type('Line', (object,), {"",
            ""    '__init__': lambda self, mode=None, depth=0, inside_brackets=False: [setattr(self, k, v) for k, v in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()],"",
            ""    'append_safe': lambda self, leaf, preformatted=False: self.leaves.append(leaf) if preformatted else ValueError('cannot append'),"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf)"",
            ""})"",
            ""line = type('line', (object,), {"",
            ""    'leaves': [Leaf() for _ in range(3)],"",
            ""    'bracket_tracker': type('BracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude=None: COMMA_PRIORITY,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {id(Leaf()): COMMA_PRIORITY, id(Leaf()): DOT_PRIORITY}"",
            ""    })(),"",
            ""    'mode': 'mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""from types import SimpleNamespace"",
            ""import token""
        ],
        ""initialization"": [
            ""line = SimpleNamespace("",
            ""    leaves=[SimpleNamespace(bracket_depth=0, type=token.NAME)],"",
            ""    bracket_tracker=SimpleNamespace("",
            ""        max_delimiter_priority=lambda exclude=None: 1,"",
            ""        delimiter_count_with_priority=lambda priority: 2,"",
            ""        delimiters={}"",
            ""    ),"",
            ""    mode=None,"",
            ""    depth=0,"",
            ""    inside_brackets=False,"",
            ""    comments_after=lambda leaf: []"",
            "")"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""DOT_PRIORITY = 1"",
            """",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            """",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            """",
            ""is_vararg = lambda leaf, within: False"",
            """",
            ""syms = SimpleNamespace("",
            ""    typedargslist='typedargslist',"",
            ""    arglist='arglist',"",
            ""    argument='argument'"",
            "")"",
            """",
            ""Feature = SimpleNamespace("",
            ""    TRAILING_COMMA_IN_DEF='TRAILING_COMMA_IN_DEF',"",
            ""    TRAILING_COMMA_IN_CALL='TRAILING_COMMA_IN_CALL'"",
            "")"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 2"",
            """",
            ""STANDALONE_COMMENT = 'standalone_comment'""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})()], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiters': {id(1): 1}, 'delimiter_count_with_priority': lambda self, priority: 2})(), 'mode': 'mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""Line = type('Line', (object,), {'__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf)})"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self: [setattr(self, attr, val) for attr, val in {'type': token.NAME, 'bracket_depth': 1}.items()]})"",
            ""Iterator = type"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})()"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call'})()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 'standalone_comment'""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [type('Leaf', (object,), {"",
            ""        'bracket_depth': 1,"",
            ""        'type': token.NAME"",
            ""    })()],"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 1,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {}"",
            ""    })(),"",
            ""    'mode': 'mode',"",
            ""    'depth': 1,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            """",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            """",
            ""DOT_PRIORITY = 2"",
            """",
            ""Line = type('Line', (object,), {"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: ["",
            ""        setattr(self, attr, val) for attr, val in {"",
            ""            'mode': mode,"",
            ""            'depth': depth,"",
            ""            'inside_brackets': inside_brackets,"",
            ""            'leaves': []"",
            ""        }.items()"",
            ""    ],"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf),"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf)"",
            ""})"",
            """",
            ""Leaf = type('Leaf', (object,), {"",
            ""    '__init__': lambda self, type=token.NAME, value=1: ["",
            ""        setattr(self, attr, val) for attr, val in {"",
            ""            'type': type,"",
            ""            'value': value,"",
            ""            'bracket_depth': 1"",
            ""        }.items()"",
            ""    ]"",
            ""})"",
            """",
            ""Iterator = lambda: iter([])"",
            """",
            ""is_vararg = lambda leaf, within: False"",
            """",
            ""syms = type('Syms', (object,), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument'"",
            ""})()"",
            """",
            ""Feature = type('Feature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF',"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL'"",
            ""})()"",
            """",
            ""features = {"",
            ""    Feature.TRAILING_COMMA_IN_DEF,"",
            ""    Feature.TRAILING_COMMA_IN_CALL"",
            ""}"",
            """",
            ""COMMA_PRIORITY = 1"",
            """",
            ""token = type('Token', (object,), {"",
            ""    'COMMA': 'COMMA',"",
            ""    'NAME': 'NAME',"",
            ""    'STANDALONE_COMMENT': 'STANDALONE_COMMENT'"",
            ""})"",
            """",
            ""STANDALONE_COMMENT = 'STANDALONE_COMMENT'""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""from types import SimpleNamespace"",
            ""import token""
        ],
        ""initialization"": [
            ""line = SimpleNamespace("",
            ""    leaves=["",
            ""        SimpleNamespace(type=token.NAME, bracket_depth=1),"",
            ""        SimpleNamespace(type=token.NAME, bracket_depth=0),"",
            ""        SimpleNamespace(type=token.COMMA, bracket_depth=0),"",
            ""    ],"",
            ""    bracket_tracker=SimpleNamespace("",
            ""        max_delimiter_priority=lambda self, exclude=None: 1,"",
            ""        delimiter_count_with_priority=lambda self, priority: 2,"",
            ""        delimiters={}  # Use `id(leaf)` mapping for delimiters as needed"",
            ""    ),"",
            ""    mode='mode',"",
            ""    depth=0,"",
            ""    inside_brackets=True,"",
            ""    comments_after=lambda leaf: []"",
            "")"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""DOT_PRIORITY = 2"",
            """",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""class Leaf:"",
            ""    def __init__(self, leaf_type, value):"",
            ""        self.type = leaf_type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            """",
            ""Iterator = iter([]).__class__"",
            """",
            ""is_vararg = lambda leaf, within: False"",
            """",
            ""syms = SimpleNamespace("",
            ""    typedargslist='typedargslist',"",
            ""    arglist='arglist',"",
            ""    argument='argument'"",
            "")"",
            """",
            ""Feature = SimpleNamespace("",
            ""    TRAILING_COMMA_IN_DEF='TRAILING_COMMA_IN_DEF',"",
            ""    TRAILING_COMMA_IN_CALL='TRAILING_COMMA_IN_CALL'"",
            "")"",
            """",
            ""features = {"",
            ""    Feature.TRAILING_COMMA_IN_DEF,"",
            ""    Feature.TRAILING_COMMA_IN_CALL"",
            ""}"",
            """",
            ""COMMA_PRIORITY = 1"",
            """",
            ""STANDALONE_COMMENT = 'STANDALONE_COMMENT'""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, value, bracket_depth=0):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = bracket_depth"",
            """",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            """",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [Leaf(token.NAME, 'value', 1)],"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude: 1,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {}"",
            ""    })(),"",
            ""    'mode': 'mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            """",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 1"",
            ""sys.maxsize = 9223372036854775807"",
            """",
            ""is_vararg = lambda leaf, within: False"",
            """",
            ""syms = type('MockSyms', (object,), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument'"",
            ""})()"",
            """",
            ""Feature = type('MockFeature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': object(),"",
            ""    'TRAILING_COMMA_IN_CALL': object()"",
            ""})()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 59""
        ]
    }
]","[
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})()], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiters': {}, 'delimiter_count_with_priority': lambda self, priority: 2})(), 'mode': 'mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""Line = type('Line', (object,), {'__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf)}) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type=token.NAME, value='': [setattr(self, attr, val) for attr, val in {'type': type, 'value': value, 'bracket_depth': 1}.items()]}) # pragma: no cover"",
            ""Iterator = iter([]).__class__ # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})() # pragma: no cover"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call'})() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = token.N_TOKENS # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = SimpleNamespace( # pragma: no cover"",
            ""    leaves=[SimpleNamespace(bracket_depth=0, type=token.NAME) for _ in range(3)], # pragma: no cover"",
            ""    bracket_tracker=SimpleNamespace( # pragma: no cover"",
            ""        max_delimiter_priority=lambda exclude: 1, # pragma: no cover"",
            ""        delimiter_count_with_priority=lambda priority: 2, # pragma: no cover"",
            ""        delimiters={} # pragma: no cover"",
            ""    ), # pragma: no cover"",
            ""    mode='mode', # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    comments_after=lambda leaf: [] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = SimpleNamespace( # pragma: no cover"",
            ""    typedargslist=1, # pragma: no cover"",
            ""    arglist=2, # pragma: no cover"",
            ""    argument=3 # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""Feature = SimpleNamespace( # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF=1, # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL=2 # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""STANDALONE_COMMENT = 53 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [type('MockLeaf', (object,), { # pragma: no cover"",
            ""        'bracket_depth': 1, # pragma: no cover"",
            ""        'type': token.NAME # pragma: no cover"",
            ""    })()], # pragma: no cover"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude: 1, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {id(1): 1} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): # pragma: no cover"",
            ""        if not preformatted: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type=token.NAME, value='value'): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""Iterator = iter([]).__class__ # pragma: no cover"",
            "" # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'argument': 'argument' # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""token = type('TokenMock', (object,), { # pragma: no cover"",
            ""    'COMMA': 'COMMA', # pragma: no cover"",
            ""    'STANDALONE_COMMENT': 'STANDALONE_COMMENT' # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""STANDALONE_COMMENT = 'STANDALONE_COMMENT' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = SimpleNamespace( # pragma: no cover"",
            ""    leaves=[SimpleNamespace(bracket_depth=0, type=token.NAME) for _ in range(3)], # pragma: no cover"",
            ""    bracket_tracker=SimpleNamespace( # pragma: no cover"",
            ""        max_delimiter_priority=lambda exclude=None: 1, # pragma: no cover"",
            ""        delimiters={}, # pragma: no cover"",
            ""        delimiter_count_with_priority=lambda priority: 2 # pragma: no cover"",
            ""    ), # pragma: no cover"",
            ""    mode=None, # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    comments_after=lambda leaf: [] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = SimpleNamespace( # pragma: no cover"",
            ""    typedargslist='typedargslist', # pragma: no cover"",
            ""    arglist='arglist', # pragma: no cover"",
            ""    argument='argument' # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""Feature = SimpleNamespace( # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF='TRAILING_COMMA_IN_DEF', # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL='TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""STANDALONE_COMMENT = 'STANDALONE_COMMENT' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = SimpleNamespace( # pragma: no cover"",
            ""    leaves=[SimpleNamespace(bracket_depth=0, type=token.NAME)], # pragma: no cover"",
            ""    bracket_tracker=SimpleNamespace( # pragma: no cover"",
            ""        max_delimiter_priority=lambda exclude=None: 1, # pragma: no cover"",
            ""        delimiter_count_with_priority=lambda priority: 2, # pragma: no cover"",
            ""        delimiters={} # pragma: no cover"",
            ""    ), # pragma: no cover"",
            ""    mode=None, # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    comments_after=lambda leaf: [] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = SimpleNamespace( # pragma: no cover"",
            ""    typedargslist='typedargslist', # pragma: no cover"",
            ""    arglist='arglist', # pragma: no cover"",
            ""    argument='argument' # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""Feature = SimpleNamespace( # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF='TRAILING_COMMA_IN_DEF', # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL='TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})()], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiters': {id(1): 1}, 'delimiter_count_with_priority': lambda self, priority: 2})(), 'mode': 'mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""Line = type('Line', (object,), {'__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf)}) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self: [setattr(self, attr, val) for attr, val in {'type': token.NAME, 'bracket_depth': 1}.items()]}) # pragma: no cover"",
            ""Iterator = type # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})() # pragma: no cover"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call'})() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = SimpleNamespace( # pragma: no cover"",
            ""    leaves=[ # pragma: no cover"",
            ""        SimpleNamespace(type=token.NAME, bracket_depth=1), # pragma: no cover"",
            ""        SimpleNamespace(type=token.NAME, bracket_depth=0), # pragma: no cover"",
            ""        SimpleNamespace(type=token.COMMA, bracket_depth=0), # pragma: no cover"",
            ""    ], # pragma: no cover"",
            ""    bracket_tracker=SimpleNamespace( # pragma: no cover"",
            ""        max_delimiter_priority=lambda self, exclude=None: 1, # pragma: no cover"",
            ""        delimiter_count_with_priority=lambda self, priority: 2, # pragma: no cover"",
            ""        delimiters={}  # Use `id(leaf)` mapping for delimiters as needed # pragma: no cover"",
            ""    ), # pragma: no cover"",
            ""    mode='mode', # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    comments_after=lambda leaf: [] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, leaf_type, value): # pragma: no cover"",
            ""        self.type = leaf_type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""Iterator = iter([]).__class__ # pragma: no cover"",
            "" # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = SimpleNamespace( # pragma: no cover"",
            ""    typedargslist='typedargslist', # pragma: no cover"",
            ""    arglist='arglist', # pragma: no cover"",
            ""    argument='argument' # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""Feature = SimpleNamespace( # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF='TRAILING_COMMA_IN_DEF', # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL='TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = { # pragma: no cover"",
            ""    Feature.TRAILING_COMMA_IN_DEF, # pragma: no cover"",
            ""    Feature.TRAILING_COMMA_IN_CALL # pragma: no cover"",
            ""} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""STANDALONE_COMMENT = 'STANDALONE_COMMENT' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value, bracket_depth=0): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [Leaf(token.NAME, 'value', 1)], # pragma: no cover"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude: 1, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""sys.maxsize = 9223372036854775807 # pragma: no cover"",
            "" # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'argument': 'argument' # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': object(), # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': object() # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 59 # pragma: no cover""
        ]
    }
]",2,3203,0.0016015,5623,0.0084345,0.010036
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 47:
    ^
SyntaxError: no binding for nonlocal 'current_line' found
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""class Leaf:"",
            ""    def __init__(self, type=token.NAME, value=''):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            """",
            ""class BracketTrackerMock:"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        return 1"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 2"",
            ""    delimiters = {}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [Leaf()],"",
            ""    'bracket_tracker': BracketTrackerMock(),"",
            ""    'mode': 'mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            """",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 1"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument'"",
            ""})"",
            ""Feature = type('Feature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF',"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL'"",
            ""})"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 'standalone_comment'""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator, List, Set""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            """",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""class BracketTrackerMock:"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        return 1"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 2"",
            ""    delimiters = {id(1): 1}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [Leaf(token.NAME, 'mock_leaf')],"",
            ""    'bracket_tracker': BracketTrackerMock(),"",
            ""    'mode': 'mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda leaf: []"",
            ""})()"",
            """",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 1"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('SymsMock', (object,), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument'"",
            ""})"",
            ""Feature = type('FeatureMock', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def',"",
            ""    'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call'"",
            ""})"",
            ""features = {"",
            ""    Feature.TRAILING_COMMA_IN_DEF,"",
            ""    Feature.TRAILING_COMMA_IN_CALL"",
            ""}"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 'standalone_comment'""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from collections import namedtuple""
        ],
        ""initialization"": [
            ""class MockLine:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""class MockLeaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            """",
            ""class BracketTracker:"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        return 0"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            ""    delimiters = {}"",
            """",
            ""line = type('MockLineWrapper', (object,), {"",
            ""    'leaves': [MockLeaf(token.NAME, 'leaf')],"",
            ""    'bracket_tracker': BracketTracker(),"",
            ""    'mode': 'mock_mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda leaf: []"",
            ""})()"",
            """",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 1"",
            ""Line = MockLine"",
            ""Leaf = MockLeaf"",
            ""Iterator = iter([]).__class__"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('SymsMock', (object,), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument'"",
            ""})"",
            ""Feature = type('FeatureMock', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF',"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL'"",
            ""})"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 'STANDALONE_COMMENT'""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [type('MockLeaf', (object,), {'type': token.NAME, 'bracket_depth': 0}) for _ in range(3)],"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude=set(): 1,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 1,"",
            ""        'delimiters': {id(object()): 1}"",
            ""    })(),"",
            ""    'mode': 'mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 1"",
            ""Line = type('Line', (object,), {"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()],"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf),"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf)"",
            ""})"",
            ""Leaf = type('Leaf', (object,), {"",
            ""    '__init__': lambda self, type=token.COMMA, value=',': [setattr(self, attr, val) for attr, val in {'type': type, 'value': value, 'bracket_depth': 0}.items()]}"",
            "")"",
            ""Iterator = iter"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'argument': 3"",
            ""})()"",
            ""Feature = type('Feature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 1,"",
            ""    'TRAILING_COMMA_IN_CALL': 2"",
            ""})()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 'standalone_comment'""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from collections import namedtuple""
        ],
        ""initialization"": [
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            """",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""class Leaf:"",
            ""    def __init__(self):"",
            ""        self.type = token.NAME"",
            ""        self.bracket_depth = 1"",
            """",
            ""bt = type('BracketTrackerMock', (object,), {"",
            ""    'max_delimiter_priority': lambda self, exclude=None: 1,"",
            ""    'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""    'delimiters': {}"",
            ""})()"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [Leaf() for _ in range(3)],"",
            ""    'bracket_tracker': bt,"",
            ""    'mode': 'mode',"",
            ""    'depth': 1,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            """",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            """",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument'"",
            ""})"",
            """",
            ""Feature = type('Feature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF',"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL'"",
            ""})"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 53""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from collections import namedtuple""
        ],
        ""initialization"": [
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            """",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [Leaf(token.NAME, 'leaf1'), Leaf(token.NAME, 'leaf2')],"",
            ""    'bracket_tracker': type('BracketTrackerMock', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 1,"",
            ""        'delimiters': {},"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2"",
            ""    })(),"",
            ""    'mode': 'mode',"",
            ""    'depth': 1,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            """",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            """",
            ""sys.maxsize = 9223372036854775807"",
            """",
            ""is_vararg = lambda leaf, within: False"",
            """",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument'"",
            ""})()"",
            """",
            ""Feature = type('Feature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def',"",
            ""    'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call'"",
            ""})"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            """",
            ""STANDALONE_COMMENT = 'standalone_comment'""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type, value, bracket_depth=0):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = bracket_depth"",
            """",
            ""class MockLine:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            """",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)  # Mock implementation; in reality, might raise ValueError"",
            """",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""class MockBracketTracker:"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        return 1"",
            """",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 2"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [MockLeaf(token.NAME, 'value')] * 3,"",
            ""    'bracket_tracker': MockBracketTracker(),"",
            ""    'mode': 'mock_mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            """",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""Line = MockLine"",
            ""Leaf = MockLeaf"",
            ""Iterator = iter([]).__class__"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), { 'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument' })()"",
            ""Feature = type('Feature', (object,), { 'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call' })()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = token.N_TOKENS""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [type('MockLeaf', (object,), {'type': token.NAME, 'bracket_depth': 1})() for _ in range(3)],"",
            ""    'bracket_tracker': type('BracketTrackerMock', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 1,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {}"",
            ""    })(),"",
            ""    'mode': 'mode',"",
            ""    'depth': 1,"",
            ""    'inside_brackets': True,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""Line = type('MockLine', (object,), {"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: setattr(self, 'leaves', []) or setattr(self, 'mode', mode) or setattr(self, 'depth', depth) or setattr(self, 'inside_brackets', inside_brackets),"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf),"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf)"",
            ""})"",
            ""Leaf = type('MockLeaf', (object,), {"",
            ""    '__init__': lambda self, type=token.NAME, value='value': setattr(self, 'type', type) or setattr(self, 'value', value) or setattr(self, 'bracket_depth', 0)"",
            ""})"",
            ""Iterator = type('MockIterator', (object,), {})"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('MockSyms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'argument': 3"",
            ""})()"",
            ""Feature = type('MockFeature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 1,"",
            ""    'TRAILING_COMMA_IN_CALL': 2"",
            ""})()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 53""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [Leaf(token.NAME, 'leaf')],"",
            ""    'bracket_tracker': type('BracketTrackerMock', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 1,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {id('leaf'): 1}"",
            ""    })(),"",
            ""    'mode': 'mock_mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            """",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""Iterator = iter([]).__class__"",
            ""is_vararg = lambda leaf, within: False"",
            """",
            ""syms = type('MockSyms', (object,), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument'"",
            ""})()"",
            """",
            ""Feature = type('MockFeature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def',"",
            ""    'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call'"",
            ""})()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 'standalone_comment'""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), {"",
            ""    'leaves': [type('LeafMock', (object,), {'bracket_depth': 1, 'type': token.NAME})],"",
            ""    'bracket_tracker': type('BracketTrackerMock', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 2,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {}})(),"",
            ""    'mode': 'mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: [] })()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 1"",
            """",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode;"",
            ""        self.depth = depth;"",
            ""        self.inside_brackets = inside_brackets;"",
            ""        self.leaves = [];"",
            """",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        if preformatted:"",
            ""            self.leaves.append(leaf);"",
            ""        else:"",
            ""            raise ValueError('Cannot append leaf');"",
            """",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf);"",
            """",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self: ["",
            ""    setattr(self, attr, val) for attr, val in {'type': token.NAME, 'bracket_depth': 1}.items()] })"",
            """",
            ""Iterator = iter([]).__class__"",
            """",
            ""is_vararg = lambda leaf, within: False"",
            """",
            ""syms = type('MockSyms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'argument': 3 })()"",
            """",
            ""Feature = type('MockFeature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 1,"",
            ""    'TRAILING_COMMA_IN_CALL': 2 })()"",
            """",
            ""features = set([1, 2])"",
            """",
            ""COMMA_PRIORITY = 2"",
            """",
            ""STANDALONE_COMMENT = 'standalone_comment'""
        ]
    }
]","[
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type=token.NAME, value=''): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTrackerMock: # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    delimiters = {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [Leaf()], # pragma: no cover"",
            ""    'bracket_tracker': BracketTrackerMock(), # pragma: no cover"",
            ""    'mode': 'mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'argument': 'argument' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Feature = type('Feature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator, List, Set # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTrackerMock: # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    delimiters = {id(1): 1} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [Leaf(token.NAME, 'mock_leaf')], # pragma: no cover"",
            ""    'bracket_tracker': BracketTrackerMock(), # pragma: no cover"",
            ""    'mode': 'mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('SymsMock', (object,), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'argument': 'argument' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Feature = type('FeatureMock', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""features = { # pragma: no cover"",
            ""    Feature.TRAILING_COMMA_IN_DEF, # pragma: no cover"",
            ""    Feature.TRAILING_COMMA_IN_CALL # pragma: no cover"",
            ""} # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLine: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        return 0 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    delimiters = {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLineWrapper', (object,), { # pragma: no cover"",
            ""    'leaves': [MockLeaf(token.NAME, 'leaf')], # pragma: no cover"",
            ""    'bracket_tracker': BracketTracker(), # pragma: no cover"",
            ""    'mode': 'mock_mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""Line = MockLine # pragma: no cover"",
            ""Leaf = MockLeaf # pragma: no cover"",
            ""Iterator = iter([]).__class__ # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('SymsMock', (object,), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'argument': 'argument' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Feature = type('FeatureMock', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 'STANDALONE_COMMENT' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [type('MockLeaf', (object,), {'type': token.NAME, 'bracket_depth': 0}) for _ in range(3)], # pragma: no cover"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude=set(): 1, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 1, # pragma: no cover"",
            ""        'delimiters': {id(object()): 1} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""Line = type('Line', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], # pragma: no cover"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), # pragma: no cover"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf) # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, type=token.COMMA, value=',': [setattr(self, attr, val) for attr, val in {'type': type, 'value': value, 'bracket_depth': 0}.items()]} # pragma: no cover"",
            "") # pragma: no cover"",
            ""Iterator = iter # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'argument': 3 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""Feature = type('Feature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 1, # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 2 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover""
        ],
        ""initialization"": [
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.type = token.NAME # pragma: no cover"",
            ""        self.bracket_depth = 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""bt = type('BracketTrackerMock', (object,), { # pragma: no cover"",
            ""    'max_delimiter_priority': lambda self, exclude=None: 1, # pragma: no cover"",
            ""    'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""    'delimiters': {} # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [Leaf() for _ in range(3)], # pragma: no cover"",
            ""    'bracket_tracker': bt, # pragma: no cover"",
            ""    'mode': 'mode', # pragma: no cover"",
            ""    'depth': 1, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'argument': 'argument' # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""Feature = type('Feature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 53 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover""
        ],
        ""initialization"": [
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [Leaf(token.NAME, 'leaf1'), Leaf(token.NAME, 'leaf2')], # pragma: no cover"",
            ""    'bracket_tracker': type('BracketTrackerMock', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 1, # pragma: no cover"",
            ""        'delimiters': {}, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2 # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mode', # pragma: no cover"",
            ""    'depth': 1, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""sys.maxsize = 9223372036854775807 # pragma: no cover"",
            "" # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'argument': 'argument' # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""Feature = type('Feature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call' # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type, value, bracket_depth=0): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLine: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf)  # Mock implementation; in reality, might raise ValueError # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockBracketTracker: # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [MockLeaf(token.NAME, 'value')] * 3, # pragma: no cover"",
            ""    'bracket_tracker': MockBracketTracker(), # pragma: no cover"",
            ""    'mode': 'mock_mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""Line = MockLine # pragma: no cover"",
            ""Leaf = MockLeaf # pragma: no cover"",
            ""Iterator = iter([]).__class__ # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), { 'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument' })() # pragma: no cover"",
            ""Feature = type('Feature', (object,), { 'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call' })() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = token.N_TOKENS # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [type('MockLeaf', (object,), {'type': token.NAME, 'bracket_depth': 1})() for _ in range(3)], # pragma: no cover"",
            ""    'bracket_tracker': type('BracketTrackerMock', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 1, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mode', # pragma: no cover"",
            ""    'depth': 1, # pragma: no cover"",
            ""    'inside_brackets': True, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""Line = type('MockLine', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: setattr(self, 'leaves', []) or setattr(self, 'mode', mode) or setattr(self, 'depth', depth) or setattr(self, 'inside_brackets', inside_brackets), # pragma: no cover"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), # pragma: no cover"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf) # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, type=token.NAME, value='value': setattr(self, 'type', type) or setattr(self, 'value', value) or setattr(self, 'bracket_depth', 0) # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Iterator = type('MockIterator', (object,), {}) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'argument': 3 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 1, # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 2 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 53 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [Leaf(token.NAME, 'leaf')], # pragma: no cover"",
            ""    'bracket_tracker': type('BracketTrackerMock', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 1, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {id('leaf'): 1} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mock_mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""Iterator = iter([]).__class__ # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'argument': 'argument' # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call' # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), { # pragma: no cover"",
            ""    'leaves': [type('LeafMock', (object,), {'bracket_depth': 1, 'type': token.NAME})], # pragma: no cover"",
            ""    'bracket_tracker': type('BracketTrackerMock', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 2, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {}})(), # pragma: no cover"",
            ""    'mode': 'mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] })() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode; # pragma: no cover"",
            ""        self.depth = depth; # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets; # pragma: no cover"",
            ""        self.leaves = []; # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): # pragma: no cover"",
            ""        if preformatted: # pragma: no cover"",
            ""            self.leaves.append(leaf); # pragma: no cover"",
            ""        else: # pragma: no cover"",
            ""            raise ValueError('Cannot append leaf'); # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf); # pragma: no cover"",
            "" # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self: [ # pragma: no cover"",
            ""    setattr(self, attr, val) for attr, val in {'type': token.NAME, 'bracket_depth': 1}.items()] }) # pragma: no cover"",
            "" # pragma: no cover"",
            ""Iterator = iter([]).__class__ # pragma: no cover"",
            "" # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'argument': 3 })() # pragma: no cover"",
            "" # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 1, # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 2 })() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = set([1, 2]) # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover""
        ]
    }
]",2,3853,0.0019265,5713,0.0085695,0.010496
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 72:
    ^
SyntaxError: no binding for nonlocal 'current_line' found
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""DOT_PRIORITY = 10"",
            ""COMMA_PRIORITY = 5"",
            ""STANDALONE_COMMENT = 60"",
            ""sys.maxsize = float('inf')"",
            ""features = set()"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [type('MockLeaf', (object,), {'bracket_depth': 1, 'type': 1})()],"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 10,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 1,"",
            ""        'delimiters': {}"",
            ""    })(),"",
            ""    'mode': 'MODE',"",
            ""    'depth': 1,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            ""Line = type('MockLineClass', (object,), {"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: [setattr(self, k, v) for k, v in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()],"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf),"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf)"",
            ""})"",
            ""Leaf = type('MockLeaf', (object,), {"",
            ""    '__init__': lambda self, type, value: [setattr(self, k, v) for k, v in {'type': type, 'value': value, 'bracket_depth': 1}.items()]"",
            ""})"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('MockSyms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'argument': 3"",
            ""})"",
            ""Feature = type('MockFeature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 1,"",
            ""    'TRAILING_COMMA_IN_CALL': 2"",
            ""})"",
            ""token = type('MockToken', (object,), {"",
            ""    'COMMA': 44"",
            ""})""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})()], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {0: 1}})(), 'mode': 'mock_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda leaf: []})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 1"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""Leaf = type('MockLeaf', (object,), {'__init__': lambda self, type=token.NAME, value='': [setattr(self, 'type', type), setattr(self, 'value', value), setattr(self, 'bracket_depth', 0)]})"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 60""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, value, bracket_depth=0):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = bracket_depth"",
            """",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets, leaves=None):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        if leaves is None:"",
            ""            self.leaves = []"",
            ""        else:"",
            ""            self.leaves = leaves"",
            """",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""class MockBracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            """",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        return DOT_PRIORITY"",
            """",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""class MockLine:"",
            ""    leaves = [Leaf(type=token.NAME, value='name')]"",
            ""    bracket_tracker = MockBracketTracker()"",
            ""    mode = 'mode'"",
            ""    depth = 0"",
            ""    inside_brackets = False"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""line = MockLine()"",
            """",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 10"",
            ""COMMA_PRIORITY = 5"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('MockSyms', (object,), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument'"",
            ""})"",
            ""Feature = type('MockFeature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF',"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL'"",
            ""})"",
            ""features = set()""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        type('MockLeaf', (object,), {"",
            ""            'bracket_depth': 0, 'type': 0"",
            ""        })()"",
            ""    ],"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 0,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 1,"",
            ""        'delimiters': {}"",
            ""    })(),"",
            ""    'mode': None,"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""DOT_PRIORITY = 1"",
            """",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            """",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            """",
            ""Iterator = iter([]).__class__"",
            """",
            ""is_vararg = lambda leaf, within: False"",
            """",
            ""syms = type('MockSyms', (object,), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument'"",
            ""})"",
            """",
            ""Feature = type('MockFeature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def',"",
            ""    'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call'"",
            ""})"",
            """",
            ""features = set()"",
            """",
            ""COMMA_PRIORITY = 2"",
            """",
            ""token = type('MockToken', (object,), {"",
            ""    'COMMA': 44"",
            ""})"",
            """",
            ""STANDALONE_COMMENT = 'comment'""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""DOT_PRIORITY = 10"",
            ""COMMA_PRIORITY = 5"",
            ""STANDALONE_COMMENT = 60"",
            ""Leaf = type('MockLeaf', (object,), {"",
            ""    '__init__': lambda self, type=token.NAME, value='mock_value': None,"",
            ""    'type': token.NAME,"",
            ""    'bracket_depth': 0"",
            ""})"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [Leaf()],"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude: 10,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {}"",
            ""    })(),"",
            ""    'mode': 'mock_mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            ""Line = type('MockLineClass', (object,), {"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: ["",
            ""        setattr(self, 'mode', mode),"",
            ""        setattr(self, 'depth', depth),"",
            ""        setattr(self, 'inside_brackets', inside_brackets),"",
            ""        setattr(self, 'leaves', [])"",
            ""    ],"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf),"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf),"",
            ""    '__bool__': lambda self: bool(self.leaves),"",
            ""})"",
            ""def is_vararg(leaf, within): return False"",
            ""syms = type('MockSyms', (object,), {"",
            ""   'typedargslist': 'typedargslist',"",
            ""   'arglist': 'arglist',"",
            ""   'argument': 'argument'"",
            ""})()"",
            ""Feature = type('MockFeature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF',"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL'"",
            ""})()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""token = type('MockToken', (object,), {'COMMA': 44, 'NAME': 1})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""DOT_PRIORITY = 10"",
            ""COMMA_PRIORITY = 5"",
            ""STANDALONE_COMMENT = 60"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [type('MockLeaf', (object,), {'bracket_depth': 0, 'type': token.NAME})()],"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude: 10,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {0: 10}"",
            ""    })(),"",
            ""    'mode': 'mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            ""Line = type('MockLineClass', (object,), {"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: ["",
            ""        setattr(self, 'mode', mode),"",
            ""        setattr(self, 'depth', depth),"",
            ""        setattr(self, 'inside_brackets', inside_brackets),"",
            ""        setattr(self, 'leaves', [])"",
            ""    ],"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf),"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf)"",
            ""})"",
            ""Leaf = type('MockLeaf', (object,), {"",
            ""    '__init__': lambda self, type, value: ["",
            ""        setattr(self, 'type', type),"",
            ""        setattr(self, 'value', value),"",
            ""        setattr(self, 'bracket_depth', 0)"",
            ""    ]"",
            ""})"",
            ""def is_vararg(leaf, within): return False"",
            ""syms = type('MockSyms', (object,), {"",
            ""   'typedargslist': 'typedargslist',"",
            ""   'arglist': 'arglist',"",
            ""   'argument': 'argument'"",
            ""})()"",
            ""Feature = type('MockFeature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF',"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL'"",
            ""})()"",
            ""features = set()"",
            ""token = type('MockToken', (object,), {'COMMA': 44, 'NAME': 1})"",
            ""STANDALONE_COMMENT = 'comment'""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""DOT_PRIORITY = 10"",
            ""COMMA_PRIORITY = 5"",
            ""STANDALONE_COMMENT = 60"",
            ""line = type('Mock', (object,), {"",
            ""    'leaves': ["",
            ""        type('Leaf', (object,), {"",
            ""            '__init__': lambda self: None,"",
            ""            'bracket_depth': 0,"",
            ""            'type': token.NAME"",
            ""        })()"",
            ""    ],"",
            ""    'bracket_tracker': type('BracketTrackerMock', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude: DOT_PRIORITY,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {"",
            ""            id(line.leaves[-1]): DOT_PRIORITY"",
            ""        }"",
            ""    })(),"",
            ""    'mode': 'mock_mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            ""Line = type('Line', (object,), {"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: ["",
            ""        setattr(self, 'mode', mode),"",
            ""        setattr(self, 'depth', depth),"",
            ""        setattr(self, 'inside_brackets', inside_brackets),"",
            ""        setattr(self, 'leaves', [])"",
            ""    ],"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf),"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf)"",
            ""})"",
            ""Leaf = type('Leaf', (object,), {"",
            ""    '__init__': lambda self, type_, value: ["",
            ""        setattr(self, 'type', type_),"",
            ""        setattr(self, 'value', value),"",
            ""        setattr(self, 'bracket_depth', 0)"",
            ""    ]"",
            ""})"",
            ""def is_vararg(leaf, within): return False"",
            ""syms = type('SymsMock', (object,), {"",
            ""   'typedargslist': 'typedargslist',"",
            ""   'arglist': 'arglist',"",
            ""   'argument': 'argument'"",
            ""})()"",
            ""Feature = type('FeatureMock', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF',"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL'"",
            ""})()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""token = type('TokenMock', (object,), {'COMMA': 44, 'NAME': 1})"",
            ""STANDALONE_COMMENT = 'standalone_comment'""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List, Set"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""DOT_PRIORITY = 10"",
            ""COMMA_PRIORITY = 5"",
            ""STANDALONE_COMMENT = 60"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        type('MockLeaf', (object,), {'bracket_depth': 0, 'type': token.NAME})(),"",
            ""        type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})(),"",
            ""        type('MockLeaf', (object,), {'bracket_depth': 2, 'type': token.NAME})()"",
            ""    ],"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 10,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {id(1): 1}"",
            ""    })(),"",
            ""    'mode': 'mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""Leaf = type('MockLeaf', (object,), {'__init__': lambda self, type, value: setattr(self, 'type', type) or setattr(self, 'value', value) or setattr(self, 'bracket_depth', 0)})"",
            ""def is_vararg(leaf, within): return False"",
            ""syms = type('MockSyms', (object,), {"",
            ""   'typedargslist': 'typedargslist',"",
            ""   'arglist': 'arglist',"",
            ""   'argument': 'argument'"",
            ""})()"",
            ""Feature = type('MockFeature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF',"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL'"",
            ""})()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""token = type('MockToken', (object,), {'COMMA': 44, 'NAME': 1})"",
            ""STANDALONE_COMMENT = 'comment'""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""DOT_PRIORITY = 10"",
            ""COMMA_PRIORITY = 5"",
            ""STANDALONE_COMMENT = 60"",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""line = type('Mock', (object,), {"",
            ""    'leaves': [Leaf(token.NAME, 'leaf1'), Leaf(token.NAME, 'leaf2')],"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude: 10,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {}"",
            ""    })(),"",
            ""    'mode': 'mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""def is_vararg(leaf, within): return False"",
            ""syms = type('Mock', (object,), {"",
            ""   'typedargslist': 1,"",
            ""   'arglist': 2,"",
            ""   'argument': 3"",
            ""})()"",
            ""Feature = type('Mock', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 1,"",
            ""    'TRAILING_COMMA_IN_CALL': 2"",
            ""})()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""token = type('MockToken', (object,), {'COMMA': 44, 'STANDALONE_COMMENT': 60})"",
            ""STANDALONE_COMMENT = 60""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""DOT_PRIORITY = 10"",
            ""COMMA_PRIORITY = 5"",
            ""STANDALONE_COMMENT = 60"",
            ""sys.maxsize = 9223372036854775807"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        type('MockLeaf', (object,), {'bracket_depth': 0, 'type': token.NAME})()"",
            ""    ],"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude: 10,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {}"",
            ""    })(),"",
            ""    'mode': 'mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""Leaf = type('MockLeaf', (object,), {'bracket_depth': 0, '__init__': lambda self, type, value: [setattr(self, 'type', type), setattr(self, 'value', value)]})"",
            ""def is_vararg(leaf, within): return False"",
            ""syms = type('MockSyms', (object,), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument'"",
            ""})()"",
            ""Feature = type('MockFeature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF',"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL'"",
            ""})()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""token = type('MockToken', (object,), {'NAME': 1, 'COMMA': 44})"",
            ""STANDALONE_COMMENT = 60""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""DOT_PRIORITY = 10 # pragma: no cover"",
            ""COMMA_PRIORITY = 5 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""sys.maxsize = float('inf') # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [type('MockLeaf', (object,), {'bracket_depth': 1, 'type': 1})()], # pragma: no cover"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 10, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 1, # pragma: no cover"",
            ""        'delimiters': {} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'MODE', # pragma: no cover"",
            ""    'depth': 1, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""Line = type('MockLineClass', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: [setattr(self, k, v) for k, v in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], # pragma: no cover"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), # pragma: no cover"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf) # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, type, value: [setattr(self, k, v) for k, v in {'type': type, 'value': value, 'bracket_depth': 1}.items()] # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'argument': 3 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 1, # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 2 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""token = type('MockToken', (object,), { # pragma: no cover"",
            ""    'COMMA': 44 # pragma: no cover"",
            ""}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})()], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {0: 1}})(), 'mode': 'mock_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda leaf: []})() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""Leaf = type('MockLeaf', (object,), {'__init__': lambda self, type=token.NAME, value='': [setattr(self, 'type', type), setattr(self, 'value', value), setattr(self, 'bracket_depth', 0)]}) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value, bracket_depth=0): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets, leaves=None): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        if leaves is None: # pragma: no cover"",
            ""            self.leaves = [] # pragma: no cover"",
            ""        else: # pragma: no cover"",
            ""            self.leaves = leaves # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockBracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        return DOT_PRIORITY # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLine: # pragma: no cover"",
            ""    leaves = [Leaf(type=token.NAME, value='name')] # pragma: no cover"",
            ""    bracket_tracker = MockBracketTracker() # pragma: no cover"",
            ""    mode = 'mode' # pragma: no cover"",
            ""    depth = 0 # pragma: no cover"",
            ""    inside_brackets = False # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = MockLine() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 10 # pragma: no cover"",
            ""COMMA_PRIORITY = 5 # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'argument': 'argument' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""features = set() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        type('MockLeaf', (object,), { # pragma: no cover"",
            ""            'bracket_depth': 0, 'type': 0 # pragma: no cover"",
            ""        })() # pragma: no cover"",
            ""    ], # pragma: no cover"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 0, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 1, # pragma: no cover"",
            ""        'delimiters': {} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': None, # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""Iterator = iter([]).__class__ # pragma: no cover"",
            "" # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'argument': 'argument' # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call' # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""token = type('MockToken', (object,), { # pragma: no cover"",
            ""    'COMMA': 44 # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""STANDALONE_COMMENT = 'comment' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""DOT_PRIORITY = 10 # pragma: no cover"",
            ""COMMA_PRIORITY = 5 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""Leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, type=token.NAME, value='mock_value': None, # pragma: no cover"",
            ""    'type': token.NAME, # pragma: no cover"",
            ""    'bracket_depth': 0 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [Leaf()], # pragma: no cover"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude: 10, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mock_mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""Line = type('MockLineClass', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: [ # pragma: no cover"",
            ""        setattr(self, 'mode', mode), # pragma: no cover"",
            ""        setattr(self, 'depth', depth), # pragma: no cover"",
            ""        setattr(self, 'inside_brackets', inside_brackets), # pragma: no cover"",
            ""        setattr(self, 'leaves', []) # pragma: no cover"",
            ""    ], # pragma: no cover"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), # pragma: no cover"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf), # pragma: no cover"",
            ""    '__bool__': lambda self: bool(self.leaves), # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""   'typedargslist': 'typedargslist', # pragma: no cover"",
            ""   'arglist': 'arglist', # pragma: no cover"",
            ""   'argument': 'argument' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMA': 44, 'NAME': 1}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""DOT_PRIORITY = 10 # pragma: no cover"",
            ""COMMA_PRIORITY = 5 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [type('MockLeaf', (object,), {'bracket_depth': 0, 'type': token.NAME})()], # pragma: no cover"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude: 10, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {0: 10} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""Line = type('MockLineClass', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: [ # pragma: no cover"",
            ""        setattr(self, 'mode', mode), # pragma: no cover"",
            ""        setattr(self, 'depth', depth), # pragma: no cover"",
            ""        setattr(self, 'inside_brackets', inside_brackets), # pragma: no cover"",
            ""        setattr(self, 'leaves', []) # pragma: no cover"",
            ""    ], # pragma: no cover"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), # pragma: no cover"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf) # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, type, value: [ # pragma: no cover"",
            ""        setattr(self, 'type', type), # pragma: no cover"",
            ""        setattr(self, 'value', value), # pragma: no cover"",
            ""        setattr(self, 'bracket_depth', 0) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""   'typedargslist': 'typedargslist', # pragma: no cover"",
            ""   'arglist': 'arglist', # pragma: no cover"",
            ""   'argument': 'argument' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMA': 44, 'NAME': 1}) # pragma: no cover"",
            ""STANDALONE_COMMENT = 'comment' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List, Set # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""DOT_PRIORITY = 10 # pragma: no cover"",
            ""COMMA_PRIORITY = 5 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        type('MockLeaf', (object,), {'bracket_depth': 0, 'type': token.NAME})(), # pragma: no cover"",
            ""        type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})(), # pragma: no cover"",
            ""        type('MockLeaf', (object,), {'bracket_depth': 2, 'type': token.NAME})() # pragma: no cover"",
            ""    ], # pragma: no cover"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 10, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {id(1): 1} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""Leaf = type('MockLeaf', (object,), {'__init__': lambda self, type, value: setattr(self, 'type', type) or setattr(self, 'value', value) or setattr(self, 'bracket_depth', 0)}) # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""   'typedargslist': 'typedargslist', # pragma: no cover"",
            ""   'arglist': 'arglist', # pragma: no cover"",
            ""   'argument': 'argument' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMA': 44, 'NAME': 1}) # pragma: no cover"",
            ""STANDALONE_COMMENT = 'comment' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""DOT_PRIORITY = 10 # pragma: no cover"",
            ""COMMA_PRIORITY = 5 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""line = type('Mock', (object,), { # pragma: no cover"",
            ""    'leaves': [Leaf(token.NAME, 'leaf1'), Leaf(token.NAME, 'leaf2')], # pragma: no cover"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude: 10, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""syms = type('Mock', (object,), { # pragma: no cover"",
            ""   'typedargslist': 1, # pragma: no cover"",
            ""   'arglist': 2, # pragma: no cover"",
            ""   'argument': 3 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""Feature = type('Mock', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 1, # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 2 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMA': 44, 'STANDALONE_COMMENT': 60}) # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""DOT_PRIORITY = 10 # pragma: no cover"",
            ""COMMA_PRIORITY = 5 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""sys.maxsize = 9223372036854775807 # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        type('MockLeaf', (object,), {'bracket_depth': 0, 'type': token.NAME})() # pragma: no cover"",
            ""    ], # pragma: no cover"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude: 10, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""Leaf = type('MockLeaf', (object,), {'bracket_depth': 0, '__init__': lambda self, type, value: [setattr(self, 'type', type), setattr(self, 'value', value)]}) # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'argument': 'argument' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""token = type('MockToken', (object,), {'NAME': 1, 'COMMA': 44}) # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover""
        ]
    }
]",2,4650,0.002325,6044,0.009066,0.0113909999999999
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 47:
    ^
SyntaxError: no binding for nonlocal 'current_line' found
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Iterator, NamedTuple, List"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""DOT_PRIORITY = 10"",
            ""COMMA_PRIORITY = 5"",
            ""STANDALONE_COMMENT = 60"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        type('MockLeaf', (object,), {"",
            ""            'bracket_depth': 0,"",
            ""            'type': token.NAME"",
            ""        })()"",
            ""    ],"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 10,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {}"",
            ""    })(),"",
            ""    'mode': 'mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""Line = Line"",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('MockSyms', (object,), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument'"",
            ""})()"",
            ""Feature = type('MockFeature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def',"",
            ""    'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call'"",
            ""})()"",
            ""features = set()"",
            ""token = type('MockToken', (object,), {"",
            ""    'COMMA': 'COMMA',"",
            ""    'STANDALONE_COMMENT': 'STANDALONE_COMMENT'"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            ""class Leaf:"",
            ""    def __init__(self, type=token.NAME, value='value'):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode=None, depth=0, inside_brackets=False):"",
            ""        self.leaves = []"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def __bool__(self):"",
            ""        return bool(self.leaves)"",
            ""class MockBracketTracker:"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        return 1"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 2"",
            ""    delimiters = {}"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [Leaf()],"",
            ""    'bracket_tracker': MockBracketTracker(),"",
            ""    'mode': 'mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('Syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""from collections import namedtuple"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        type('MockLeaf', (object,), {'type': token.NAME, 'bracket_depth': 1})(),"",
            ""        type('MockLeaf', (object,), {'type': token.NAME, 'bracket_depth': 1})()"",
            ""    ],"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude: 1,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {}"",
            ""    })(),"",
            ""    'mode': 'mode_value',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            """",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            """",
            ""DOT_PRIORITY = 2"",
            """",
            ""Line = type('MockLineClass', (object,), {"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()],"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf),"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf),"",
            ""    '__bool__': lambda self: bool(self.leaves)"",
            ""})"",
            """",
            ""Leaf = namedtuple('Leaf', ['type', 'value'])"",
            """",
            ""Iterator = iter([]).__class__"",
            """",
            ""is_vararg = lambda leaf, within: leaf.bracket_depth > 0"",
            """",
            ""syms = type('MockSyms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'argument': 3"",
            ""})()"",
            """",
            ""Feature = type('MockFeature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 1,"",
            ""    'TRAILING_COMMA_IN_CALL': 2"",
            ""})"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            """",
            ""STANDALONE_COMMENT = 60""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [type('Leaf', (object,), {'bracket_depth': 0, 'type': token.NAME})() for _ in range(3)],"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude: 1,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {}"",
            ""    })(),"",
            ""    'mode': 'mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            ""class CannotSplit(Exception): pass"",
            ""DOT_PRIORITY = 2"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def __bool__(self):"",
            ""        return bool(self.leaves)"",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('MockSyms', (object,), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument'"",
            ""})()"",
            ""Feature = type('MockFeature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def',"",
            ""    'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call'"",
            ""})()"",
            ""features = set()"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 4""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""DOT_PRIORITY = 10"",
            ""COMMA_PRIORITY = 5"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""Leaf = type('Leaf', (object,), {"",
            ""    '__init__': lambda self, type, value: (setattr(self, 'type', type), setattr(self, 'value', value), setattr(self, 'bracket_depth', 0)),"",
            ""})"",
            """",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            """",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def __bool__(self):"",
            ""        return bool(self.leaves)"",
            """",
            ""line = type('Mock', (object,), {"",
            ""    'leaves': [Leaf(token.NAME, 'name1'), Leaf(token.NAME, 'name2')],"",
            ""    'bracket_tracker': type('BracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 10,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {}"",
            ""    })(),"",
            ""    'mode': 'mode_value',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument'"",
            ""})"",
            """",
            ""Feature = type('Feature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF',"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL'"",
            ""})"",
            """",
            ""features = set()""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""DOT_PRIORITY = 2"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def __bool__(self):"",
            ""        return bool(self.leaves)"",
            ""class Leaf:"",
            ""    def __init__(self, type=token.NAME, value=''):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""Iterator = iter([]).__class__"",
            ""def is_vararg(leaf, within): return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument'"",
            ""})"",
            ""Feature = type('Feature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def',"",
            ""    'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call'"",
            ""})"",
            ""features = set()"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 60"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [Leaf()],"",
            ""    'bracket_tracker': type('BracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 1,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {id(Leaf()): 1}"",
            ""    })(),"",
            ""    'mode': 'mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 5"",
            ""STANDALONE_COMMENT = 60"",
            ""Leaf = type('MockLeaf', (object,), {"",
            ""    '__init__': lambda self: None,"",
            ""    'bracket_depth': 0,"",
            ""    'type': token.NAME"",
            ""})"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [Leaf(), Leaf(), Leaf()],"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 0,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 1,"",
            ""        'delimiters': {}"",
            ""    })(),"",
            ""    'mode': 'mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def exit(self):"",
            ""        return self"",
            ""class MockToken:"",
            ""    COMMA = 44"",
            ""token = MockToken"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('MockSyms', (object,), {"",
            ""   'typedargslist': 'typedargslist',"",
            ""   'arglist': 'arglist',"",
            ""   'argument': 'argument'"",
            ""})()"",
            ""Feature = type('MockFeature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF',"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL'"",
            ""})()"",
            ""features = set()""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), {"",
            ""    'leaves': [type('Leaf', (object,), {'bracket_depth': 1, 'type': token.NAME})(),"",
            ""               type('Leaf', (object,), {'bracket_depth': 1, 'type': token.NAME})()],"",
            ""    'bracket_tracker': type('BracketTrackerMock', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude={}: 1,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {}})(),"",
            ""    'mode': 'mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def __bool__(self):"",
            ""        return bool(self.leaves)"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, token_type, value: None, 'bracket_depth': 1, 'type': token.NAME})"",
            ""Iterator = iter([None]).__class__"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""features = set()"",
            ""COMMA_PRIORITY = 3"",
            ""STANDALONE_COMMENT = 4""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""last_leaf = type('Leaf', (object,), {'bracket_depth': 0, 'type': token.NAME})()"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [last_leaf],"",
            ""    'bracket_tracker': type('BracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude: 1,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {id(last_leaf): 1}"",
            ""    })(),"",
            ""    'mode': 'mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def __bool__(self):"",
            ""        return bool(self.leaves)"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, token_type, value: None, 'bracket_depth': 0, 'type': token.NAME})"",
            ""Iterator = Iterator"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""features = set()"",
            ""COMMA_PRIORITY = 3"",
            ""STANDALONE_COMMENT = 4""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""DOT_PRIORITY = 10"",
            ""COMMA_PRIORITY = 5"",
            ""STANDALONE_COMMENT = 60"",
            ""features = set()"",
            """",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            """",
            ""class syms:"",
            ""    typedargslist = 1"",
            ""    arglist = 2"",
            ""    argument = 3"",
            """",
            ""class Leaf:"",
            ""    def __init__(self, token_type=token.NAME, value='value'):"",
            ""        self.type = token_type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            """",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def __bool__(self):"",
            ""        return bool(self.leaves)"",
            """",
            ""class BracketTracker:"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        return 10"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 2"",
            ""    delimiters = {}"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [Leaf(), Leaf()],"",
            ""    'bracket_tracker': BracketTracker(),"",
            ""    'mode': 'mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda leaf: []"",
            ""})()"",
            """",
            ""is_vararg = lambda leaf, within: False""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Iterator, NamedTuple, List # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""DOT_PRIORITY = 10 # pragma: no cover"",
            ""COMMA_PRIORITY = 5 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        type('MockLeaf', (object,), { # pragma: no cover"",
            ""            'bracket_depth': 0, # pragma: no cover"",
            ""            'type': token.NAME # pragma: no cover"",
            ""        })() # pragma: no cover"",
            ""    ], # pragma: no cover"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 10, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""Line = Line # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'argument': 'argument' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""token = type('MockToken', (object,), { # pragma: no cover"",
            ""    'COMMA': 'COMMA', # pragma: no cover"",
            ""    'STANDALONE_COMMENT': 'STANDALONE_COMMENT' # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type=token.NAME, value='value'): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode=None, depth=0, inside_brackets=False): # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def __bool__(self): # pragma: no cover"",
            ""        return bool(self.leaves) # pragma: no cover"",
            ""class MockBracketTracker: # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    delimiters = {} # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [Leaf()], # pragma: no cover"",
            ""    'bracket_tracker': MockBracketTracker(), # pragma: no cover"",
            ""    'mode': 'mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('Syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2}) # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        type('MockLeaf', (object,), {'type': token.NAME, 'bracket_depth': 1})(), # pragma: no cover"",
            ""        type('MockLeaf', (object,), {'type': token.NAME, 'bracket_depth': 1})() # pragma: no cover"",
            ""    ], # pragma: no cover"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude: 1, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mode_value', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""Line = type('MockLineClass', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], # pragma: no cover"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), # pragma: no cover"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf), # pragma: no cover"",
            ""    '__bool__': lambda self: bool(self.leaves) # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""Leaf = namedtuple('Leaf', ['type', 'value']) # pragma: no cover"",
            "" # pragma: no cover"",
            ""Iterator = iter([]).__class__ # pragma: no cover"",
            "" # pragma: no cover"",
            ""is_vararg = lambda leaf, within: leaf.bracket_depth > 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'argument': 3 # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 1, # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 2 # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [type('Leaf', (object,), {'bracket_depth': 0, 'type': token.NAME})() for _ in range(3)], # pragma: no cover"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude: 1, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def __bool__(self): # pragma: no cover"",
            ""        return bool(self.leaves) # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'argument': 'argument' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 4 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def __bool__(self): # pragma: no cover"",
            ""        return bool(self.leaves) # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type=token.NAME, value=''): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""Iterator = iter([]).__class__ # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'argument': 'argument' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Feature = type('Feature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [Leaf()], # pragma: no cover"",
            ""    'bracket_tracker': type('BracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 1, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {id(Leaf()): 1} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 5 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""Leaf = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self: None, # pragma: no cover"",
            ""    'bracket_depth': 0, # pragma: no cover"",
            ""    'type': token.NAME # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [Leaf(), Leaf(), Leaf()], # pragma: no cover"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 0, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 1, # pragma: no cover"",
            ""        'delimiters': {} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""        return self # pragma: no cover"",
            ""class MockToken: # pragma: no cover"",
            ""    COMMA = 44 # pragma: no cover"",
            ""token = MockToken # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""   'typedargslist': 'typedargslist', # pragma: no cover"",
            ""   'arglist': 'arglist', # pragma: no cover"",
            ""   'argument': 'argument' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""features = set() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), { # pragma: no cover"",
            ""    'leaves': [type('Leaf', (object,), {'bracket_depth': 1, 'type': token.NAME})(), # pragma: no cover"",
            ""               type('Leaf', (object,), {'bracket_depth': 1, 'type': token.NAME})()], # pragma: no cover"",
            ""    'bracket_tracker': type('BracketTrackerMock', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude={}: 1, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {}})(), # pragma: no cover"",
            ""    'mode': 'mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def __bool__(self): # pragma: no cover"",
            ""        return bool(self.leaves) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, token_type, value: None, 'bracket_depth': 1, 'type': token.NAME}) # pragma: no cover"",
            ""Iterator = iter([None]).__class__ # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2}) # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""COMMA_PRIORITY = 3 # pragma: no cover"",
            ""STANDALONE_COMMENT = 4 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            ""last_leaf = type('Leaf', (object,), {'bracket_depth': 0, 'type': token.NAME})() # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [last_leaf], # pragma: no cover"",
            ""    'bracket_tracker': type('BracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude: 1, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {id(last_leaf): 1} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def __bool__(self): # pragma: no cover"",
            ""        return bool(self.leaves) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, token_type, value: None, 'bracket_depth': 0, 'type': token.NAME}) # pragma: no cover"",
            ""Iterator = Iterator # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2}) # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""COMMA_PRIORITY = 3 # pragma: no cover"",
            ""STANDALONE_COMMENT = 4 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""DOT_PRIORITY = 10 # pragma: no cover"",
            ""COMMA_PRIORITY = 5 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class syms: # pragma: no cover"",
            ""    typedargslist = 1 # pragma: no cover"",
            ""    arglist = 2 # pragma: no cover"",
            ""    argument = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, token_type=token.NAME, value='value'): # pragma: no cover"",
            ""        self.type = token_type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def __bool__(self): # pragma: no cover"",
            ""        return bool(self.leaves) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        return 10 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    delimiters = {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [Leaf(), Leaf()], # pragma: no cover"",
            ""    'bracket_tracker': BracketTracker(), # pragma: no cover"",
            ""    'mode': 'mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover""
        ]
    }
]",2,5378,0.002689,5543,0.0083145,0.0110035
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 46:
    ^
SyntaxError: no binding for nonlocal 'current_line' found
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('MockLeaf', (object,), {'bracket_depth': 0, 'type': token.NAME})()], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {}})(), 'mode': 'mock_mode', 'depth': 1, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 1"",
            ""Line = type('Line', (object,), {"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: (setattr(self, 'mode', mode), setattr(self, 'depth', depth), setattr(self, 'inside_brackets', inside_brackets), setattr(self, 'leaves', [])),"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf),"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf),"",
            ""    '__bool__': lambda self: bool(self.leaves),"",
            ""    'leaves': []"",
            ""})"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type, value: setattr(self, 'type', type) or setattr(self, 'value', value), 'bracket_depth': 0})"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""features = set()"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 999""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from collections import deque"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""DOT_PRIORITY = 10"",
            ""COMMA_PRIORITY = 5"",
            ""STANDALONE_COMMENT = 60"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = deque()"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def __bool__(self):"",
            ""        return bool(self.leaves)"",
            ""Leaf = type('MockLeaf', (object,), {'__init__': lambda self, type, value: setattr(self, 'type', type) or setattr(self, 'value', value), 'bracket_depth': 0})"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [Leaf(token.NAME, 'name1'), Leaf(token.NAME, 'name2')],"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude: 1,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {}"",
            ""    })(),"",
            ""    'mode': 'mock_mode',"",
            ""    'depth': 1,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""features = set()""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""DOT_PRIORITY = 10"",
            ""COMMA_PRIORITY = 5"",
            ""STANDALONE_COMMENT = 60"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        type('MockLeaf', (object,), {'bracket_depth': 0, 'type': token.NAME, 'value': 'value1'})(),"",
            ""        type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME, 'value': 'value2'})()"",
            ""    ],"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 10,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {}"",
            ""    })(),"",
            ""    'mode': 'mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            ""Line = type('MockLineClass', (object,), {"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: ["",
            ""        setattr(self, 'mode', mode),"",
            ""        setattr(self, 'depth', depth),"",
            ""        setattr(self, 'inside_brackets', inside_brackets),"",
            ""        setattr(self, 'leaves', [])"",
            ""    ],"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf),"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf),"",
            ""    '__bool__': lambda self: bool(self.leaves)"",
            ""})"",
            ""Leaf = type('MockLeafClass', (object,), {"",
            ""    '__init__': lambda self, token_type, value: [setattr(self, 'type', token_type), setattr(self, 'value', value)],"",
            ""    'bracket_depth': 0"",
            ""})"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('MockSyms', (object,), {"",
            ""   'typedargslist': 'typedargslist',"",
            ""   'arglist': 'arglist',"",
            ""   'argument': 'argument'"",
            ""})()"",
            ""Feature = type('MockFeature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF',"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL'"",
            ""})()"",
            ""features = set([Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL])"",
            ""token = type('MockToken', (object,), {'COMMA': 44, 'NAME': 1})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            ""Line = type('Line', (object,), {"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: ["",
            ""        setattr(self, 'mode', mode),"",
            ""        setattr(self, 'depth', depth),"",
            ""        setattr(self, 'inside_brackets', inside_brackets),"",
            ""        setattr(self, 'leaves', []),"",
            ""        None"",
            ""    ][-1],"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf),"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf),"",
            ""    '__bool__': lambda self: bool(self.leaves)"",
            ""})"",
            ""Leaf = type('Leaf', (object,), {"",
            ""    '__init__': lambda self, type, value: ["",
            ""        setattr(self, 'type', type),"",
            ""        setattr(self, 'value', value),"",
            ""        setattr(self, 'bracket_depth', 0),"",
            ""        None"",
            ""    ][-1],"",
            ""})"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument'"",
            ""})()"",
            ""Feature = type('Feature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF',"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL'"",
            ""})()"",
            ""features = set()"",
            ""line = type('line', (object,), {"",
            ""    'leaves': [Leaf(token.NAME, 'a'), Leaf(token.NAME, 'b')],"",
            ""    'bracket_tracker': type('BracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 1,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {}"",
            ""    })(),"",
            ""    'mode': 'sample_mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('MockLeaf', (object,), {'bracket_depth': 0, 'type': token.NAME, 'value': 'a'})()], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {id(last_leaf): 1}})(), 'mode': 'mock_mode', 'depth': 1, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 1"",
            ""Line = type('MockLineClass', (object,), {'__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf), '__bool__': lambda self: bool(self.leaves)})"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type, value: [setattr(self, attr, val) for attr, val in {'type': type, 'value': value, 'bracket_depth': 0}.items()]})"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})()"",
            ""features = set()"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 999""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""DOT_PRIORITY = 10"",
            ""COMMA_PRIORITY = 5"",
            ""STANDALONE_COMMENT = 60"",
            ""class MockLine:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def __bool__(self):"",
            ""        return bool(self.leaves)"",
            ""Line = MockLine"",
            ""class MockLeaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""Leaf = MockLeaf"",
            ""class MockBracketTracker:"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        return 10"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            ""bt = MockBracketTracker()"",
            ""line = type('MockLineInstance', (object,), {"",
            ""    'leaves': [Leaf(token.NAME, 'value1'), Leaf(token.NAME, 'value2')],"",
            ""    'bracket_tracker': bt,"",
            ""    'mode': 'mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda leaf: []"",
            ""})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('MockSyms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'argument': 3"",
            ""})"",
            ""Feature = type('MockFeature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 1,"",
            ""    'TRAILING_COMMA_IN_CALL': 2"",
            ""})"",
            ""features = set()""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('MockLeaf', (object,), {'bracket_depth': 0, 'type': token.NAME})()], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {}})(), 'mode': 'mock_mode', 'depth': 1, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 1"",
            ""Line = type('Line', (object,), {'__init__': lambda self, mode, depth, inside_brackets: setattr(self, 'leaves', []) or setattr(self, 'mode', mode) or setattr(self, 'depth', depth) or setattr(self, 'inside_brackets', inside_brackets), 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf), '__bool__': lambda self: True})"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type, value: setattr(self, 'type', type) or setattr(self, 'value', value), 'bracket_depth': 0})"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""features = {1, 2}"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = token.COMMENT""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})()], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {}})(), 'mode': 'mode', 'depth': 1, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 1"",
            ""Line = type('Line', (object,), {'__init__': lambda self, mode, depth, inside_brackets: setattr(self, 'leaves', []), 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf)})"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type, value: setattr(self, 'type', type) or setattr(self, 'value', value), 'bracket_depth': 1, 'type': token.NAME})"",
            ""Iterator = iter([]).__class__"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""features = [Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL]"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = token.COMMENT"",
            ""token = token""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""DOT_PRIORITY = 10"",
            ""COMMA_PRIORITY = 5"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type, value: None, 'type': token.NAME, 'bracket_depth': 1})"",
            """",
            ""class MockBracketTracker:"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        return 1"",
            """",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 2"",
            """",
            ""    delimiters = {}"",
            """",
            ""bt = MockBracketTracker()"",
            """",
            ""line = type('MockLine', (object,), {'leaves': [Leaf(token.NAME, 'mock')], 'bracket_tracker': bt, 'mode': 'mock_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda leaf: []})()"",
            """",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            """",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def __bool__(self):"",
            ""        return bool(self.leaves)"",
            """",
            ""is_vararg = lambda leaf, within: False"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call'})"",
            ""features = set()""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [type('MockLeaf', (object,), {'bracket_depth': 0, 'type': token.NAME})()],"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude: 1,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {}"",
            ""    })(),"",
            ""    'mode': 'mock_mode',"",
            ""    'depth': 1,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 999"",
            ""current_line = type('Mock', (object,), {"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: ["",
            ""        setattr(self, 'mode', mode),"",
            ""        setattr(self, 'depth', depth),"",
            ""        setattr(self, 'inside_brackets', inside_brackets),"",
            ""        setattr(self, 'leaves', [])"",
            ""    ],"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf),"",
            ""    '__bool__': lambda self: bool(self.leaves),"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf)"",
            ""})('mock_mode', 1, False)"",
            ""Line = current_line.__class__"",
            ""Leaf = type('Leaf', (object,), {"",
            ""    '__init__': lambda self, token_type, value: ["",
            ""        setattr(self, 'type', token_type),"",
            ""        setattr(self, 'value', value)"",
            ""    ],"",
            ""    'bracket_depth': 0"",
            ""})"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'argument': 3"",
            ""})()"",
            ""Feature = type('Feature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 1,"",
            ""    'TRAILING_COMMA_IN_CALL': 2"",
            ""})()"",
            ""features = set()""
        ]
    }
]","[
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('MockLeaf', (object,), {'bracket_depth': 0, 'type': token.NAME})()], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {}})(), 'mode': 'mock_mode', 'depth': 1, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""Line = type('Line', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: (setattr(self, 'mode', mode), setattr(self, 'depth', depth), setattr(self, 'inside_brackets', inside_brackets), setattr(self, 'leaves', [])), # pragma: no cover"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), # pragma: no cover"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf), # pragma: no cover"",
            ""    '__bool__': lambda self: bool(self.leaves), # pragma: no cover"",
            ""    'leaves': [] # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type, value: setattr(self, 'type', type) or setattr(self, 'value', value), 'bracket_depth': 0}) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2}) # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 999 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from collections import deque # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""DOT_PRIORITY = 10 # pragma: no cover"",
            ""COMMA_PRIORITY = 5 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = deque() # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def __bool__(self): # pragma: no cover"",
            ""        return bool(self.leaves) # pragma: no cover"",
            ""Leaf = type('MockLeaf', (object,), {'__init__': lambda self, type, value: setattr(self, 'type', type) or setattr(self, 'value', value), 'bracket_depth': 0}) # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [Leaf(token.NAME, 'name1'), Leaf(token.NAME, 'name2')], # pragma: no cover"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude: 1, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mock_mode', # pragma: no cover"",
            ""    'depth': 1, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2}) # pragma: no cover"",
            ""features = set() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""DOT_PRIORITY = 10 # pragma: no cover"",
            ""COMMA_PRIORITY = 5 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        type('MockLeaf', (object,), {'bracket_depth': 0, 'type': token.NAME, 'value': 'value1'})(), # pragma: no cover"",
            ""        type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME, 'value': 'value2'})() # pragma: no cover"",
            ""    ], # pragma: no cover"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 10, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""Line = type('MockLineClass', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: [ # pragma: no cover"",
            ""        setattr(self, 'mode', mode), # pragma: no cover"",
            ""        setattr(self, 'depth', depth), # pragma: no cover"",
            ""        setattr(self, 'inside_brackets', inside_brackets), # pragma: no cover"",
            ""        setattr(self, 'leaves', []) # pragma: no cover"",
            ""    ], # pragma: no cover"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), # pragma: no cover"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf), # pragma: no cover"",
            ""    '__bool__': lambda self: bool(self.leaves) # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Leaf = type('MockLeafClass', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, token_type, value: [setattr(self, 'type', token_type), setattr(self, 'value', value)], # pragma: no cover"",
            ""    'bracket_depth': 0 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""   'typedargslist': 'typedargslist', # pragma: no cover"",
            ""   'arglist': 'arglist', # pragma: no cover"",
            ""   'argument': 'argument' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""features = set([Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL]) # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMA': 44, 'NAME': 1}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""Line = type('Line', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: [ # pragma: no cover"",
            ""        setattr(self, 'mode', mode), # pragma: no cover"",
            ""        setattr(self, 'depth', depth), # pragma: no cover"",
            ""        setattr(self, 'inside_brackets', inside_brackets), # pragma: no cover"",
            ""        setattr(self, 'leaves', []), # pragma: no cover"",
            ""        None # pragma: no cover"",
            ""    ][-1], # pragma: no cover"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), # pragma: no cover"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf), # pragma: no cover"",
            ""    '__bool__': lambda self: bool(self.leaves) # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, type, value: [ # pragma: no cover"",
            ""        setattr(self, 'type', type), # pragma: no cover"",
            ""        setattr(self, 'value', value), # pragma: no cover"",
            ""        setattr(self, 'bracket_depth', 0), # pragma: no cover"",
            ""        None # pragma: no cover"",
            ""    ][-1], # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'argument': 'argument' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""Feature = type('Feature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""line = type('line', (object,), { # pragma: no cover"",
            ""    'leaves': [Leaf(token.NAME, 'a'), Leaf(token.NAME, 'b')], # pragma: no cover"",
            ""    'bracket_tracker': type('BracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 1, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'sample_mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""Line = type('MockLineClass', (object,), {'__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf), '__bool__': lambda self: bool(self.leaves)}) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type, value: [setattr(self, attr, val) for attr, val in {'type': type, 'value': value, 'bracket_depth': 0}.items()]}) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})() # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 999 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""DOT_PRIORITY = 10 # pragma: no cover"",
            ""COMMA_PRIORITY = 5 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""class MockLine: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def __bool__(self): # pragma: no cover"",
            ""        return bool(self.leaves) # pragma: no cover"",
            ""Line = MockLine # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""Leaf = MockLeaf # pragma: no cover"",
            ""class MockBracketTracker: # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        return 10 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""bt = MockBracketTracker() # pragma: no cover"",
            ""line = type('MockLineInstance', (object,), { # pragma: no cover"",
            ""    'leaves': [Leaf(token.NAME, 'value1'), Leaf(token.NAME, 'value2')], # pragma: no cover"",
            ""    'bracket_tracker': bt, # pragma: no cover"",
            ""    'mode': 'mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'argument': 3 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 1, # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 2 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""features = set() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('MockLeaf', (object,), {'bracket_depth': 0, 'type': token.NAME})()], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {}})(), 'mode': 'mock_mode', 'depth': 1, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""Line = type('Line', (object,), {'__init__': lambda self, mode, depth, inside_brackets: setattr(self, 'leaves', []) or setattr(self, 'mode', mode) or setattr(self, 'depth', depth) or setattr(self, 'inside_brackets', inside_brackets), 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf), '__bool__': lambda self: True}) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type, value: setattr(self, 'type', type) or setattr(self, 'value', value), 'bracket_depth': 0}) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2}) # pragma: no cover"",
            ""features = {1, 2} # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = token.COMMENT # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})()], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {}})(), 'mode': 'mode', 'depth': 1, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""Line = type('Line', (object,), {'__init__': lambda self, mode, depth, inside_brackets: setattr(self, 'leaves', []), 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf)}) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type, value: setattr(self, 'type', type) or setattr(self, 'value', value), 'bracket_depth': 1, 'type': token.NAME}) # pragma: no cover"",
            ""Iterator = iter([]).__class__ # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2}) # pragma: no cover"",
            ""features = [Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL] # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = token.COMMENT # pragma: no cover"",
            ""token = token # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""DOT_PRIORITY = 10 # pragma: no cover"",
            ""COMMA_PRIORITY = 5 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type, value: None, 'type': token.NAME, 'bracket_depth': 1}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockBracketTracker: # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""    delimiters = {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""bt = MockBracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), {'leaves': [Leaf(token.NAME, 'mock')], 'bracket_tracker': bt, 'mode': 'mock_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda leaf: []})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def __bool__(self): # pragma: no cover"",
            ""        return bool(self.leaves) # pragma: no cover"",
            "" # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'}) # pragma: no cover"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call'}) # pragma: no cover"",
            ""features = set() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [type('MockLeaf', (object,), {'bracket_depth': 0, 'type': token.NAME})()], # pragma: no cover"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude: 1, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mock_mode', # pragma: no cover"",
            ""    'depth': 1, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 999 # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, token_type, value: [ # pragma: no cover"",
            ""        setattr(self, 'type', token_type), # pragma: no cover"",
            ""        setattr(self, 'value', value) # pragma: no cover"",
            ""    ], # pragma: no cover"",
            ""    'bracket_depth': 0 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'argument': 3 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""Feature = type('Feature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 1, # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 2 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""features = set() # pragma: no cover""
        ]
    }
]",2,6078,0.003039,5363,0.0080445,0.0110835
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 46:
    ^
SyntaxError: no binding for nonlocal 'current_line' found
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [type('MockLeaf', (object,), { 'bracket_depth': 1, 'type': token.NAME })() for _ in range(3)],"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 1,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {}"",
            ""    })(),"",
            ""    'mode': 'mock_mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 1"",
            ""Line = type('Line', (object,), {"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: setattr(self, 'leaves', []),"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf),"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf),"",
            ""    '__iter__': lambda self: iter(self.leaves),"",
            ""    '__bool__': lambda self: bool(self.leaves),"",
            ""})"",
            ""Leaf = type('Leaf', (object,), {"",
            ""    '__init__': lambda self, type, value: ("",
            ""        setattr(self, 'type', type),"",
            ""        setattr(self, 'value', value),"",
            ""        setattr(self, 'bracket_depth', 1)"",
            ""    )"",
            ""})"",
            ""Iterator = type('Iterator', (object,), {})  # To mimic the Iterator type"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument'"",
            ""})()"",
            ""Feature = type('Feature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF',"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL'"",
            ""})()"",
            ""features = set([Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL])"",
            ""COMMA_PRIORITY = 1"",
            ""token = type('token', (object,), {"",
            ""    'COMMA': 'COMMA',"",
            ""    'NAME': 'NAME'"",
            ""})"",
            ""STANDALONE_COMMENT = 'STANDALONE_COMMENT'""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('MockLeaf', (object,), {'bracket_depth': 0, 'type': token.NAME})()], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {}})(), 'mode': 'mock_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 1"",
            ""Line = type('MockLineClass', (object,), {"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()],"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf),"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf)"",
            ""})"",
            ""leaf_mock = type('MockLeaf', (object,), {"",
            ""    '__init__': lambda self, type, value: [setattr(self, attr, val) for attr, val in {'type': type, 'value': value, 'bracket_depth': 0}.items()]"",
            ""})"",
            ""Leaf = leaf_mock(token.NAME, 'value')"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})()"",
            ""features = set()"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 3"",
            """",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            """",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def __bool__(self):"",
            ""        return bool(self.leaves)"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        return DOT_PRIORITY"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 2"",
            """",
            ""class MockLine:"",
            ""    leaves = [Leaf(token.NAME, 'name')]"",
            ""    bracket_tracker = BracketTracker()"",
            ""    mode = None"",
            ""    depth = 0"",
            ""    inside_brackets = False"",
            ""    @staticmethod"",
            ""    def comments_after(leaf):"",
            ""        return []"",
            """",
            ""line = MockLine()"",
            """",
            ""is_vararg = lambda leaf, within: False"",
            """",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument'"",
            ""})()"",
            """",
            ""Feature = type('Feature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF',"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL'"",
            ""})()"",
            """",
            ""features = set()"",
            """",
            ""sys.maxsize = 9223372036854775807""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('Leaf', (object,), {'type': token.NAME, 'bracket_depth': 0, '__repr__': lambda self: '<Leaf>'})()], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {}})(), 'mode': 'mock_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 1"",
            ""Line = type('Line', (object,), {"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: setattr(self, 'leaves', []),"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf),"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf),"",
            ""    '__bool__': lambda self: bool(self.leaves),"",
            ""    '__repr__': lambda self: '<Line>'"",
            ""})"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type, value: setattr(self, 'type', type) or setattr(self, 'value', value), 'bracket_depth': 0, '__repr__': lambda self: '<Leaf>'})"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""features = set()"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""DOT_PRIORITY = 2"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 999"",
            ""Leaf = type('Leaf', (object,), {"",
            ""    '__init__': lambda self, type=token.NAME, value='': setattr(self, 'type', type) or setattr(self, 'value', value) or setattr(self, 'bracket_depth', 0),"",
            ""    'type': token.NAME,"",
            ""    'value': '',"",
            ""    'bracket_depth': 0"",
            ""})"",
            ""Line = type('Line', (object,), {"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: setattr(self, 'leaves', []) or setattr(self, 'mode', mode) or setattr(self, 'depth', depth) or setattr(self, 'inside_brackets', inside_brackets),"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf) if preformatted else None,"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf),"",
            ""    '__bool__': lambda self: bool(self.leaves)"",
            ""})"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [Leaf()],"",
            ""    'bracket_tracker': type('BracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 1,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {id(Leaf()): 1}"",
            ""    })(),"",
            ""    'mode': 'mock_mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""features = set()""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('MockLeaf', (object,), {'bracket_depth': 0, 'type': token.NAME}), type('MockLeaf', (object,), {'bracket_depth': 0, 'type': token.NAME})], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude=None: 2, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {id(type('MockLeaf', (object,), {})): 2}})(), 'mode': 'mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""Line = type('Line', (object,), {'__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf)})"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type, value: [setattr(self, attr, val) for attr, val in {'type': type, 'value': value, 'bracket_depth': 0}.items()]})"",
            ""Iterator = iter([]).__class__"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 999""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            """",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [Leaf(token.NAME, 'a'), Leaf(token.NAME, 'b'), Leaf(token.NAME, 'c')],"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 1,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {id(Leaf(token.NAME, 'a')): 1, id(Leaf(token.NAME, 'b')): 2}"",
            ""    })(),"",
            ""    'mode': 'mode_value',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""DOT_PRIORITY = 1"",
            """",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            """",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        if len(self.leaves) > 5:"",
            ""            raise ValueError('Too many leaves')"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def __bool__(self):"",
            ""        return bool(self.leaves)"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""syms = type('MockSyms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'argument': 3"",
            ""})()"",
            """",
            ""Feature = type('MockFeature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 1,"",
            ""    'TRAILING_COMMA_IN_CALL': 2"",
            ""})()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 2"",
            """",
            ""STANDALONE_COMMENT = 60""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})(),"",
            ""        type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})()"",
            ""    ],"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 1,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {}"",
            ""    })(),"",
            ""    'mode': 'mock_mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""Line = type('Line', (object,), {"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: setattr(self, 'leaves', []),"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf),"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf),"",
            ""    '__len__': lambda self: len(self.leaves),"",
            ""    '__bool__': lambda self: bool(self.leaves)"",
            ""})"",
            ""Leaf = type('Leaf', (object,), {"",
            ""    '__init__': lambda self, token_type, value: setattr(self, 'type', token_type) or setattr(self, 'value', value),"",
            ""    'bracket_depth': 1"",
            ""})"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'argument': 3"",
            ""})()"",
            ""Feature = type('Feature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 1,"",
            ""    'TRAILING_COMMA_IN_CALL': 2"",
            ""})()"",
            ""features = set()"",
            ""COMMA_PRIORITY = 3"",
            ""STANDALONE_COMMENT = 4""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [type('Leaf', (object,), {"",
            ""        'bracket_depth': 1,"",
            ""        'type': token.NAME"",
            ""    })()],"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude: 1,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {}"",
            ""    })(),"",
            ""    'mode': 'mock_mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 1"",
            ""Line = type('Line', (object,), {"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: ["",
            ""        setattr(self, 'mode', mode),"",
            ""        setattr(self, 'depth', depth),"",
            ""        setattr(self, 'inside_brackets', inside_brackets),"",
            ""        setattr(self, 'leaves', [])"",
            ""    ],"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf),"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf)"",
            ""})"",
            ""Leaf = type('Leaf', (object,), {"",
            ""    '__init__': lambda self, type, value: ["",
            ""        setattr(self, 'type', type),"",
            ""        setattr(self, 'value', value),"",
            ""        setattr(self, 'bracket_depth', 0)"",
            ""    ]"",
            ""})"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'argument': 3"",
            ""})()"",
            ""Feature = type('Feature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 1,"",
            ""    'TRAILING_COMMA_IN_CALL': 2"",
            ""})()"",
            ""features = set()"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [type('MockLeaf', (object,), {'bracket_depth': 0})()],"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 1,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {}"",
            ""    })(),"",
            ""    'mode': 'mock_mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 1"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def __bool__(self):"",
            ""        return bool(self.leaves)"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, token_type, value: None, 'bracket_depth': 0})"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})()"",
            ""features = set()"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 60""
        ]
    }
]","[
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [type('MockLeaf', (object,), { 'bracket_depth': 1, 'type': token.NAME })() for _ in range(3)], # pragma: no cover"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 1, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mock_mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""Line = type('Line', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: setattr(self, 'leaves', []), # pragma: no cover"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), # pragma: no cover"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf), # pragma: no cover"",
            ""    '__iter__': lambda self: iter(self.leaves), # pragma: no cover"",
            ""    '__bool__': lambda self: bool(self.leaves), # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, type, value: ( # pragma: no cover"",
            ""        setattr(self, 'type', type), # pragma: no cover"",
            ""        setattr(self, 'value', value), # pragma: no cover"",
            ""        setattr(self, 'bracket_depth', 1) # pragma: no cover"",
            ""    ) # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Iterator = type('Iterator', (object,), {})  # To mimic the Iterator type # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'argument': 'argument' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""Feature = type('Feature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""features = set([Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL]) # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""token = type('token', (object,), { # pragma: no cover"",
            ""    'COMMA': 'COMMA', # pragma: no cover"",
            ""    'NAME': 'NAME' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STANDALONE_COMMENT = 'STANDALONE_COMMENT' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('MockLeaf', (object,), {'bracket_depth': 0, 'type': token.NAME})()], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {}})(), 'mode': 'mock_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""Line = type('MockLineClass', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], # pragma: no cover"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), # pragma: no cover"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf) # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""leaf_mock = type('MockLeaf', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, type, value: [setattr(self, attr, val) for attr, val in {'type': type, 'value': value, 'bracket_depth': 0}.items()] # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})() # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def __bool__(self): # pragma: no cover"",
            ""        return bool(self.leaves) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        return DOT_PRIORITY # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLine: # pragma: no cover"",
            ""    leaves = [Leaf(token.NAME, 'name')] # pragma: no cover"",
            ""    bracket_tracker = BracketTracker() # pragma: no cover"",
            ""    mode = None # pragma: no cover"",
            ""    depth = 0 # pragma: no cover"",
            ""    inside_brackets = False # pragma: no cover"",
            ""    @staticmethod # pragma: no cover"",
            ""    def comments_after(leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = MockLine() # pragma: no cover"",
            "" # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'argument': 'argument' # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""Feature = type('Feature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            "" # pragma: no cover"",
            ""sys.maxsize = 9223372036854775807 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('Leaf', (object,), {'type': token.NAME, 'bracket_depth': 0, '__repr__': lambda self: '<Leaf>'})()], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {}})(), 'mode': 'mock_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""Line = type('Line', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: setattr(self, 'leaves', []), # pragma: no cover"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), # pragma: no cover"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf), # pragma: no cover"",
            ""    '__bool__': lambda self: bool(self.leaves), # pragma: no cover"",
            ""    '__repr__': lambda self: '<Line>' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type, value: setattr(self, 'type', type) or setattr(self, 'value', value), 'bracket_depth': 0, '__repr__': lambda self: '<Leaf>'}) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2}) # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 999 # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, type=token.NAME, value='': setattr(self, 'type', type) or setattr(self, 'value', value) or setattr(self, 'bracket_depth', 0), # pragma: no cover"",
            ""    'type': token.NAME, # pragma: no cover"",
            ""    'value': '', # pragma: no cover"",
            ""    'bracket_depth': 0 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Line = type('Line', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: setattr(self, 'leaves', []) or setattr(self, 'mode', mode) or setattr(self, 'depth', depth) or setattr(self, 'inside_brackets', inside_brackets), # pragma: no cover"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf) if preformatted else None, # pragma: no cover"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf), # pragma: no cover"",
            ""    '__bool__': lambda self: bool(self.leaves) # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [Leaf()], # pragma: no cover"",
            ""    'bracket_tracker': type('BracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 1, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {id(Leaf()): 1} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mock_mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2}) # pragma: no cover"",
            ""features = set() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [type('MockLeaf', (object,), {'bracket_depth': 0, 'type': token.NAME}), type('MockLeaf', (object,), {'bracket_depth': 0, 'type': token.NAME})], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude=None: 2, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {id(type('MockLeaf', (object,), {})): 2}})(), 'mode': 'mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""Line = type('Line', (object,), {'__init__': lambda self, mode, depth, inside_brackets: [setattr(self, attr, val) for attr, val in {'mode': mode, 'depth': depth, 'inside_brackets': inside_brackets, 'leaves': []}.items()], 'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), 'append': lambda self, leaf: self.leaves.append(leaf)}) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type, value: [setattr(self, attr, val) for attr, val in {'type': type, 'value': value, 'bracket_depth': 0}.items()]}) # pragma: no cover"",
            ""Iterator = iter([]).__class__ # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 999 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [Leaf(token.NAME, 'a'), Leaf(token.NAME, 'b'), Leaf(token.NAME, 'c')], # pragma: no cover"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 1, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {id(Leaf(token.NAME, 'a')): 1, id(Leaf(token.NAME, 'b')): 2} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mode_value', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        if len(self.leaves) > 5: # pragma: no cover"",
            ""            raise ValueError('Too many leaves') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def __bool__(self): # pragma: no cover"",
            ""        return bool(self.leaves) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'argument': 3 # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 1, # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 2 # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})(), # pragma: no cover"",
            ""        type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})() # pragma: no cover"",
            ""    ], # pragma: no cover"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 1, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mock_mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""Line = type('Line', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: setattr(self, 'leaves', []), # pragma: no cover"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), # pragma: no cover"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf), # pragma: no cover"",
            ""    '__len__': lambda self: len(self.leaves), # pragma: no cover"",
            ""    '__bool__': lambda self: bool(self.leaves) # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, token_type, value: setattr(self, 'type', token_type) or setattr(self, 'value', value), # pragma: no cover"",
            ""    'bracket_depth': 1 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'argument': 3 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""Feature = type('Feature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 1, # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 2 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""COMMA_PRIORITY = 3 # pragma: no cover"",
            ""STANDALONE_COMMENT = 4 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [type('Leaf', (object,), { # pragma: no cover"",
            ""        'bracket_depth': 1, # pragma: no cover"",
            ""        'type': token.NAME # pragma: no cover"",
            ""    })()], # pragma: no cover"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude: 1, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mock_mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""Line = type('Line', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: [ # pragma: no cover"",
            ""        setattr(self, 'mode', mode), # pragma: no cover"",
            ""        setattr(self, 'depth', depth), # pragma: no cover"",
            ""        setattr(self, 'inside_brackets', inside_brackets), # pragma: no cover"",
            ""        setattr(self, 'leaves', []) # pragma: no cover"",
            ""    ], # pragma: no cover"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), # pragma: no cover"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf) # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, type, value: [ # pragma: no cover"",
            ""        setattr(self, 'type', type), # pragma: no cover"",
            ""        setattr(self, 'value', value), # pragma: no cover"",
            ""        setattr(self, 'bracket_depth', 0) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'argument': 3 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""Feature = type('Feature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 1, # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 2 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [type('MockLeaf', (object,), {'bracket_depth': 0})()], # pragma: no cover"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 1, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mock_mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def __bool__(self): # pragma: no cover"",
            ""        return bool(self.leaves) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, token_type, value: None, 'bracket_depth': 0}) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})() # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover""
        ]
    }
]",2,6722,0.003361,5618,0.008427,0.011788
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 70:
    ^
SyntaxError: no binding for nonlocal 'current_line' found
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum, auto"",
            ""import token""
        ],
        ""initialization"": [
            ""@dataclass\nclass Leaf:\n    type: int\n    value: str\n    bracket_depth: int = 0"",
            ""class Feature(Enum):\n    TRAILING_COMMA_IN_DEF = auto()\n    TRAILING_COMMA_IN_CALL = auto()"",
            ""class CannotSplit(Exception):\n    pass"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 999"",
            ""@dataclass\nclass Line:\n    mode: str\n    depth: int\n    inside_brackets: bool\n    leaves: list = field(default_factory=list)\n    bracket_tracker: object = None\n\n    def append_safe(self, leaf: Leaf, preformatted: bool = False):\n        self.leaves.append(leaf)\n\n    def append(self, leaf: Leaf):\n        self.leaves.append(leaf)"",
            ""def create_line_with_leaves():\n    line = Line(mode='default', depth=0, inside_brackets=False, leaves=[], bracket_tracker=type('Mock', (object,), {'max_delimiter_priority': lambda exclude: 1, 'delimiter_count_with_priority': lambda priority: 2, 'delimiters': {}}))\n    line.leaves = [Leaf(type=token.NAME, value='value1', bracket_depth=1), Leaf(type=token.NAME, value='value2', bracket_depth=0)]\n    line.comments_after = lambda leaf: []\n    return line"",
            ""line = create_line_with_leaves()"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('Mock', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""sys.maxsize = 9223372036854775807""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""@dataclass\nclass Leaf:\n    type: int\n    value: str\n    bracket_depth: int = 0"",
            ""class Feature(Enum):\n    TRAILING_COMMA_IN_DEF = auto()\n    TRAILING_COMMA_IN_CALL = auto()"",
            ""class CannotSplit(Exception):\n    pass"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 999"",
            ""@dataclass\nclass Line:\n    mode: str\n    depth: int\n    inside_brackets: bool\n    leaves: list = field(default_factory=list)\n    bracket_tracker: object = None\n\n    def append_safe(self, leaf: Leaf, preformatted: bool = False):\n        self.leaves.append(leaf)\n\n    def append(self, leaf: Leaf):\n        self.leaves.append(leaf)"",
            ""line = Line(mode='default', depth=0, inside_brackets=False, leaves=[], bracket_tracker=type('Mock', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {}})())\nline.leaves = [Leaf(type=1, value='value1', bracket_depth=1), Leaf(type=2, value='value2', bracket_depth=0)]\nline.comments_after = lambda leaf: []"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('Mock', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""token = type('Mock', (object,), {'COMMA': 44})"",
            ""sys.maxsize = 9223372036854775807""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""@dataclass\nclass Leaf:\n    type: int\n    value: str\n    bracket_depth: int = 0"",
            ""class Feature(Enum):\n    TRAILING_COMMA_IN_DEF = auto()\n    TRAILING_COMMA_IN_CALL = auto()"",
            ""class CannotSplit(Exception):\n    pass"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 999"",
            ""@dataclass\nclass Line:\n    mode: str\n    depth: int\n    inside_brackets: bool\n    leaves: list = field(default_factory=list)\n\n    def append_safe(self, leaf: Leaf, preformatted: bool = False):\n        self.leaves.append(leaf)\n\n    def append(self, leaf: Leaf):\n        self.leaves.append(leaf)\n\n    def __bool__(self):\n        return bool(self.leaves)"",
            ""line = Line(mode='default', depth=0, inside_brackets=False, leaves=[Leaf(type=1, value='value1', bracket_depth=1), Leaf(type=2, value='value2', bracket_depth=0)])\nline.bracket_tracker = type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude=None: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {}})()\nline.comments_after = lambda leaf: []"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""token = type('Mock', (object,), {'COMMA': 44})"",
            ""sys.maxsize = 9223372036854775807""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator, List, Dict"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum, auto"",
            ""import token""
        ],
        ""initialization"": [
            ""@dataclass\nclass Leaf:\n    type: int\n    value: str\n    bracket_depth: int = 0"",
            ""class Feature(Enum):\n    TRAILING_COMMA_IN_DEF = auto()\n    TRAILING_COMMA_IN_CALL = auto()"",
            ""class CannotSplit(Exception):\n    pass"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 999"",
            ""@dataclass\nclass Line:\n    mode: str\n    depth: int\n    inside_brackets: bool\n    leaves: List[Leaf] = field(default_factory=list)\n    bracket_tracker: object = None\n\n    def append_safe(self, leaf: Leaf, preformatted: bool = False):\n        if len(self.leaves) > 100:  # arbitrary condition to simulate ValueError\n            raise ValueError('Too many leaves')\n        self.leaves.append(leaf)\n\n    def append(self, leaf: Leaf):\n        self.leaves.append(leaf)"",
            ""line = Line(\n    mode='default',\n    depth=0,\n    inside_brackets=False,\n    leaves=[Leaf(type=token.NAME, value='value1', bracket_depth=1), Leaf(type=token.NAME, value='value2', bracket_depth=0)],\n    bracket_tracker=type('MockBracketTracker', (object,), {\n        'max_delimiter_priority': lambda self, exclude: DOT_PRIORITY,\n        'delimiter_count_with_priority': lambda self, priority: 2,\n        'delimiters': {}\n    })()\n)\nline.comments_after = lambda leaf: []"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""sys.maxsize = 9223372036854775807""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator, List, Set"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""@dataclass\nclass Leaf:\n    type: int\n    value: str\n    bracket_depth: int = 0"",
            ""class Feature(Enum):\n    TRAILING_COMMA_IN_DEF = auto()\n    TRAILING_COMMA_IN_CALL = auto()"",
            ""class CannotSplit(Exception):\n    pass"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 999"",
            ""@dataclass\nclass Line:\n    mode: str\n    depth: int\n    inside_brackets: bool\n    leaves: List[Leaf] = field(default_factory=list)\n\n    def append_safe(self, leaf: Leaf, preformatted: bool = False):\n        self.leaves.append(leaf)\n\n    def append(self, leaf: Leaf):\n        self.leaves.append(leaf)\n\n    def __bool__(self):\n        return bool(self.leaves)"",
            ""line = Line(mode='default', depth=0, inside_brackets=False)\nline.bracket_tracker = type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {}})()\nline.leaves = [Leaf(type=1, value='value1', bracket_depth=1), Leaf(type=2, value='value2', bracket_depth=0)]\nline.comments_after = lambda leaf: []"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""token = type('MockToken', (object,), {'COMMA': 44})"",
            ""sys.maxsize = 9223372036854775807""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        type('Leaf', (object,), {'bracket_depth': 1, 'type': token.NAME})()"",
            ""    ],"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude: 1,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {}"",
            ""    })(),"",
            ""    'mode': 'mode_value',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def __bool__(self):"",
            ""        return bool(self.leaves)"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type, value: setattr(self, 'type', type) or setattr(self, 'value', value), 'bracket_depth': 0})"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""features = set()"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 999"",
            ""sys.maxsize = 9223372036854775807""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 3"",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""bt = type('MockBT', (object,), {"",
            ""    'max_delimiter_priority': lambda self, exclude=None: 1,"",
            ""    'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""    'delimiters': {id(Leaf(token.COMMA, ',')): 2}"",
            ""})()"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [Leaf(token.NAME, 'mock')],"",
            ""    'bracket_tracker': bt,"",
            ""    'mode': 'mock_mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': True,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            ""def is_vararg(leaf, within): return False"",
            ""syms = type('MockSyms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'argument': 3"",
            ""})()"",
            ""sys.maxsize = 9223372036854775807""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator, List"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""@dataclass\nclass Leaf:\n    type: int\n    value: str\n    bracket_depth: int = 0"",
            ""class Feature(Enum):\n    TRAILING_COMMA_IN_DEF = auto()\n    TRAILING_COMMA_IN_CALL = auto()"",
            ""class CannotSplit(Exception):\n    pass"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 999"",
            ""@dataclass\nclass Line:\n    mode: str\n    depth: int\n    inside_brackets: bool\n    leaves: List[Leaf] = field(default_factory=list)\n\n    def append_safe(self, leaf: Leaf, preformatted: bool = False):\n        self.leaves.append(leaf)\n\n    def append(self, leaf: Leaf):\n        self.leaves.append(leaf)"",
            ""line = type('MockLine', (object,), {'leaves': [Leaf(type=1, value='value1', bracket_depth=1), Leaf(type=2, value='value2', bracket_depth=0)], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {}})(), 'mode': 'mock_mode', 'depth': 1, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})()"",
            ""def is_vararg(leaf, within): return False"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""token = type('MockToken', (object,), {'COMMA': 44})"",
            ""sys.maxsize = 9223372036854775807""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator, List"",
            ""import token""
        ],
        ""initialization"": [
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def __bool__(self):"",
            ""        return bool(self.leaves)"",
            ""class BracketTracker:"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        return 1"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 2"",
            ""line = Line('mock_mode', 1, False)"",
            ""line.leaves = [Leaf(token.NAME, 'value1'), Leaf(token.NAME, 'value2')]"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.comments_after = lambda leaf: []"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 1"",
            ""sys.maxsize = 9223372036854775807"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 999""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            ""sys.maxsize = 9223372036854775807"",
            ""class Feature(Enum): \n    TRAILING_COMMA_IN_DEF = auto() \n    TRAILING_COMMA_IN_CALL = auto()"",
            ""@dataclass class Leaf: \n    type: int \n    value: str \n    bracket_depth: int = 0"",
            ""@dataclass class Line: \n    mode: str \n    depth: int \n    inside_brackets: bool \n    leaves: list = field(default_factory=list) \n    def append_safe(self, leaf: Leaf, preformatted: bool = False): \n        self.leaves.append(leaf) \n    def append(self, leaf: Leaf): \n        self.leaves.append(leaf)"",
            ""line = Line(mode='default', depth=0, inside_brackets=False, leaves=[], bracket_tracker=type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {}})())\nline.leaves = [Leaf(type=1, value='value1', bracket_depth=1), Leaf(type=2, value='value2', bracket_depth=0)]\nline.comments_after = lambda leaf: []"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""token = type('MockToken', (object,), {'COMMA': 44, 'STANDALONE_COMMENT': 60})""
        ]
    }
]","[
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""@dataclass# pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    type: int# pragma: no cover"",
            ""    value: str# pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            ""class Feature(Enum):# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto()# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""class CannotSplit(Exception):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 999 # pragma: no cover"",
            ""@dataclass# pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    mode: str# pragma: no cover"",
            ""    depth: int# pragma: no cover"",
            ""    inside_brackets: bool# pragma: no cover"",
            ""    leaves: list = field(default_factory=list)# pragma: no cover"",
            ""    bracket_tracker: object = None# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf: Leaf, preformatted: bool = False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append(self, leaf: Leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""def create_line_with_leaves():# pragma: no cover"",
            ""    line = Line(mode='default', depth=0, inside_brackets=False, leaves=[], bracket_tracker=type('Mock', (object,), {'max_delimiter_priority': lambda exclude: 1, 'delimiter_count_with_priority': lambda priority: 2, 'delimiters': {}}))# pragma: no cover"",
            ""    line.leaves = [Leaf(type=token.NAME, value='value1', bracket_depth=1), Leaf(type=token.NAME, value='value2', bracket_depth=0)]# pragma: no cover"",
            ""    line.comments_after = lambda leaf: []# pragma: no cover"",
            ""    return line # pragma: no cover"",
            ""line = create_line_with_leaves() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('Mock', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""sys.maxsize = 9223372036854775807 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""@dataclass# pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    type: int# pragma: no cover"",
            ""    value: str# pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            ""class Feature(Enum):# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto()# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""class CannotSplit(Exception):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 999 # pragma: no cover"",
            ""@dataclass# pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    mode: str# pragma: no cover"",
            ""    depth: int# pragma: no cover"",
            ""    inside_brackets: bool# pragma: no cover"",
            ""    leaves: list = field(default_factory=list)# pragma: no cover"",
            ""    bracket_tracker: object = None# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf: Leaf, preformatted: bool = False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append(self, leaf: Leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""line = Line(mode='default', depth=0, inside_brackets=False, leaves=[], bracket_tracker=type('Mock', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {}})())# pragma: no cover"",
            ""line.leaves = [Leaf(type=1, value='value1', bracket_depth=1), Leaf(type=2, value='value2', bracket_depth=0)]# pragma: no cover"",
            ""line.comments_after = lambda leaf: [] # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('Mock', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""token = type('Mock', (object,), {'COMMA': 44}) # pragma: no cover"",
            ""sys.maxsize = 9223372036854775807 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""@dataclass# pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    type: int# pragma: no cover"",
            ""    value: str# pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            ""class Feature(Enum):# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto()# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""class CannotSplit(Exception):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 999 # pragma: no cover"",
            ""@dataclass# pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    mode: str# pragma: no cover"",
            ""    depth: int# pragma: no cover"",
            ""    inside_brackets: bool# pragma: no cover"",
            ""    leaves: list = field(default_factory=list)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf: Leaf, preformatted: bool = False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append(self, leaf: Leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def __bool__(self):# pragma: no cover"",
            ""        return bool(self.leaves) # pragma: no cover"",
            ""line = Line(mode='default', depth=0, inside_brackets=False, leaves=[Leaf(type=1, value='value1', bracket_depth=1), Leaf(type=2, value='value2', bracket_depth=0)])# pragma: no cover"",
            ""line.bracket_tracker = type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude=None: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {}})()# pragma: no cover"",
            ""line.comments_after = lambda leaf: [] # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""token = type('Mock', (object,), {'COMMA': 44}) # pragma: no cover"",
            ""sys.maxsize = 9223372036854775807 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator, List, Dict # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""@dataclass# pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    type: int# pragma: no cover"",
            ""    value: str# pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            ""class Feature(Enum):# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto()# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""class CannotSplit(Exception):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 999 # pragma: no cover"",
            ""@dataclass# pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    mode: str# pragma: no cover"",
            ""    depth: int# pragma: no cover"",
            ""    inside_brackets: bool# pragma: no cover"",
            ""    leaves: List[Leaf] = field(default_factory=list)# pragma: no cover"",
            ""    bracket_tracker: object = None# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf: Leaf, preformatted: bool = False):# pragma: no cover"",
            ""        if len(self.leaves) > 100:  # arbitrary condition to simulate ValueError# pragma: no cover"",
            ""            raise ValueError('Too many leaves')# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append(self, leaf: Leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""line = Line(# pragma: no cover"",
            ""    mode='default',# pragma: no cover"",
            ""    depth=0,# pragma: no cover"",
            ""    inside_brackets=False,# pragma: no cover"",
            ""    leaves=[Leaf(type=token.NAME, value='value1', bracket_depth=1), Leaf(type=token.NAME, value='value2', bracket_depth=0)],# pragma: no cover"",
            ""    bracket_tracker=type('MockBracketTracker', (object,), {# pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude: DOT_PRIORITY,# pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,# pragma: no cover"",
            ""        'delimiters': {}# pragma: no cover"",
            ""    })()# pragma: no cover"",
            "")# pragma: no cover"",
            ""line.comments_after = lambda leaf: [] # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""sys.maxsize = 9223372036854775807 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator, List, Set # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""@dataclass# pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    type: int# pragma: no cover"",
            ""    value: str# pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            ""class Feature(Enum):# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto()# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""class CannotSplit(Exception):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 999 # pragma: no cover"",
            ""@dataclass# pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    mode: str# pragma: no cover"",
            ""    depth: int# pragma: no cover"",
            ""    inside_brackets: bool# pragma: no cover"",
            ""    leaves: List[Leaf] = field(default_factory=list)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf: Leaf, preformatted: bool = False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append(self, leaf: Leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def __bool__(self):# pragma: no cover"",
            ""        return bool(self.leaves) # pragma: no cover"",
            ""line = Line(mode='default', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.bracket_tracker = type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {}})()# pragma: no cover"",
            ""line.leaves = [Leaf(type=1, value='value1', bracket_depth=1), Leaf(type=2, value='value2', bracket_depth=0)]# pragma: no cover"",
            ""line.comments_after = lambda leaf: [] # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMA': 44}) # pragma: no cover"",
            ""sys.maxsize = 9223372036854775807 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        type('Leaf', (object,), {'bracket_depth': 1, 'type': token.NAME})() # pragma: no cover"",
            ""    ], # pragma: no cover"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude: 1, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mode_value', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def __bool__(self): # pragma: no cover"",
            ""        return bool(self.leaves) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), {'__init__': lambda self, type, value: setattr(self, 'type', type) or setattr(self, 'value', value), 'bracket_depth': 0}) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2}) # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 999 # pragma: no cover"",
            ""sys.maxsize = 9223372036854775807 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 3 # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""bt = type('MockBT', (object,), { # pragma: no cover"",
            ""    'max_delimiter_priority': lambda self, exclude=None: 1, # pragma: no cover"",
            ""    'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""    'delimiters': {id(Leaf(token.COMMA, ',')): 2} # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [Leaf(token.NAME, 'mock')], # pragma: no cover"",
            ""    'bracket_tracker': bt, # pragma: no cover"",
            ""    'mode': 'mock_mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': True, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'argument': 3 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""sys.maxsize = 9223372036854775807 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator, List # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""@dataclass# pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    type: int# pragma: no cover"",
            ""    value: str# pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            ""class Feature(Enum):# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto()# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""class CannotSplit(Exception):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 999 # pragma: no cover"",
            ""@dataclass# pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    mode: str# pragma: no cover"",
            ""    depth: int# pragma: no cover"",
            ""    inside_brackets: bool# pragma: no cover"",
            ""    leaves: List[Leaf] = field(default_factory=list)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf: Leaf, preformatted: bool = False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append(self, leaf: Leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""line = type('MockLine', (object,), {'leaves': [Leaf(type=1, value='value1', bracket_depth=1), Leaf(type=2, value='value2', bracket_depth=0)], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {}})(), 'mode': 'mock_mode', 'depth': 1, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})() # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMA': 44}) # pragma: no cover"",
            ""sys.maxsize = 9223372036854775807 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator, List # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def __bool__(self): # pragma: no cover"",
            ""        return bool(self.leaves) # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""line = Line('mock_mode', 1, False) # pragma: no cover"",
            ""line.leaves = [Leaf(token.NAME, 'value1'), Leaf(token.NAME, 'value2')] # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.comments_after = lambda leaf: [] # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""sys.maxsize = 9223372036854775807 # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2}) # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 999 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    }
]",2,7467,0.0037335,4905,0.0073575,0.011091
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 46:
    ^
SyntaxError: no binding for nonlocal 'current_line' found
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})()"",
            ""    ],"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 1,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {}"",
            ""    })(),"",
            ""    'mode': 'mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 1"",
            """",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('SymsMock', (object,), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument'"",
            ""})()"",
            ""Feature = type('FeatureMock', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 1,"",
            ""    'TRAILING_COMMA_IN_CALL': 2"",
            ""})()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""token = type('TokenMock', (object,), {"",
            ""    'COMMA': 44"",
            ""})"",
            ""sys.maxsize = 9223372036854775807""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception):\n    pass"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 3"",
            ""sys.maxsize = 9223372036854775807"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n    def append(self, leaf):\n        self.leaves.append(leaf)\n    def __bool__(self):\n        return bool(self.leaves)"",
            ""class BracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 2\n    delimiters = {}"",
            ""line = type('MockLine', (object,), {\n    'leaves': [Leaf(token.NAME, 'mock_leaf')],\n    'bracket_tracker': BracketTracker(),\n    'mode': 'mock_mode',\n    'depth': 0,\n    'inside_brackets': False,\n    'comments_after': lambda self, leaf: []\n})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""class Syms:\n    typedargslist = 1\n    arglist = 2\n    argument = 3"",
            ""syms = Syms()"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 999"",
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': [type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})()],"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 1,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {}"",
            ""    })(),"",
            ""    'mode': 'mock_mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""class Leaf:"",
            ""    def __init__(self, token_type, value):"",
            ""        self.type = token_type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('MockSyms', (object,), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'argument': 'argument'"",
            ""})()"",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            ""features = set()"",
            ""sys.maxsize = 9223372036854775807""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception):\n    pass"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 999"",
            ""class BracketTrackerMock:\n    def max_delimiter_priority(self, exclude=None):\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 2\n    delimiters = {}"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n    def append(self, leaf):\n        self.leaves.append(leaf)\n    def __bool__(self):\n        return bool(self.leaves)"",
            ""line = Line('mock_mode', 0, False)\nline.bracket_tracker = BracketTrackerMock()\nline.leaves = [Leaf(token.NAME, 'leaf1'), Leaf(token.NAME, 'leaf2')]\nline.comments_after = lambda leaf: []"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""sys.maxsize = 9223372036854775807""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), {"",
            ""    'leaves': [type('MockLeaf', (object,), {'bracket_depth': 0})(),"",
            ""                type('MockLeaf', (object,), {'bracket_depth': 0})()],"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 1,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {id(type('MockLeaf', (object,), {'bracket_depth': 0})()): 1}})(),"",
            ""    'mode': 'default',"",
            ""    'depth': 1,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: [] })()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""Line = type('Line', (object,), {"",
            ""    '__init__': lambda self, mode, depth, inside_brackets, leaves=None: ["",
            ""        setattr(self, 'mode', mode),"",
            ""        setattr(self, 'depth', depth),"",
            ""        setattr(self, 'inside_brackets', inside_brackets),"",
            ""        setattr(self, 'leaves', leaves or [])],"",
            ""    'append_safe': lambda self, leaf, preformatted=False: self.leaves.append(leaf),"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf),"",
            ""    '__bool__': lambda self: bool(self.leaves) })"",
            ""Leaf = type('Leaf', (object,), {"",
            ""    '__init__': lambda self, type, value: ["",
            ""        setattr(self, 'type', type),"",
            ""        setattr(self, 'value', value)],"",
            ""    'bracket_depth': 0 })"",
            ""iterator_to_list = lambda it: list(it)"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 3"",
            ""STANDALONE_COMMENT = 60""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), {"",
            ""    'leaves': ["",
            ""        type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})(),"",
            ""        type('MockLeaf', (object,), {'bracket_depth': 2, 'type': token.NAME})()"",
            ""    ],"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude: 1,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {}"",
            ""    })(),"",
            ""    'mode': 'mode_value',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda leaf: []"",
            ""})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""Line = type('Line', (object,), {"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: ["",
            ""        setattr(self, 'mode', mode),"",
            ""        setattr(self, 'depth', depth),"",
            ""        setattr(self, 'inside_brackets', inside_brackets),"",
            ""        setattr(self, 'leaves', [])"",
            ""    ],"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf),"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf),"",
            ""    '__bool__': lambda self: True if self.leaves else False"",
            ""})"",
            ""Leaf = type('Leaf', (object,), {"",
            ""    '__init__': lambda self, type, value: ["",
            ""        setattr(self, 'type', type),"",
            ""        setattr(self, 'value', value),"",
            ""        setattr(self, 'bracket_depth', 1)"",
            ""    ]"",
            ""})"",
            ""Iterator = Iterator"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'argument': 3"",
            ""})"",
            ""Feature = type('Feature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 1,"",
            ""    'TRAILING_COMMA_IN_CALL': 2"",
            ""})"",
            ""features = set()"",
            ""COMMA_PRIORITY = 3"",
            ""STANDALONE_COMMENT = 4""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {"",
            ""    'leaves': ["",
            ""        type('MockLeaf', (object,), {"",
            ""            'bracket_depth': 0,"",
            ""            'type': token.NAME,"",
            ""            'value': 'value1'"",
            ""        })(),"",
            ""        type('MockLeaf', (object,), {"",
            ""            'bracket_depth': 1,"",
            ""            'type': token.NAME,"",
            ""            'value': 'value2'"",
            ""        })()"",
            ""    ],"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude: 1,"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""        'delimiters': {}"",
            ""    })(),"",
            ""    'mode': 'mock_mode',"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 1"",
            ""Line = type('Line', (object,), {"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: [setattr(self, 'mode', mode), setattr(self, 'depth', depth), setattr(self, 'inside_brackets', inside_brackets), setattr(self, 'leaves', [])],"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf),"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf),"",
            ""    '__bool__': lambda self: bool(self.leaves)"",
            ""})"",
            ""Leaf = type('Leaf', (object,), {"",
            ""    '__init__': lambda self, type, value: [setattr(self, 'type', type), setattr(self, 'value', value)],"",
            ""    'bracket_depth': 0"",
            ""})"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'argument': 3"",
            ""})"",
            ""Feature = type('Feature', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 1,"",
            ""    'TRAILING_COMMA_IN_CALL': 2"",
            ""})"",
            ""features = set()"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 999""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 5"",
            ""STANDALONE_COMMENT = 60"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""class Leaf:"",
            ""    def __init__(self, token_type=token.NAME, value=''):"",
            ""        self.type = token_type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL'})"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""line = Line('default_mode', 0, False)"",
            ""line.leaves = [Leaf(token.NAME, 'x'), Leaf(token.NAME, 'y')]"",
            ""line.bracket_tracker = type('BracketTracker', (object,), {"",
            ""    'max_delimiter_priority': lambda self, exclude: 1,"",
            ""    'delimiter_count_with_priority': lambda self, priority: 1,"",
            ""    'delimiters': {id(line.leaves[0]): 1, id(line.leaves[1]): 1}"",
            ""})()"",
            ""line.comments_after = lambda leaf: []""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 999"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def __bool__(self):"",
            ""        return bool(self.leaves)"",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""line = type('Mock', (object,), {"",
            ""    'leaves': [Leaf(token.NAME, 'a'), Leaf(token.NAME, 'b')],"",
            ""    'bracket_tracker': type('MockTracker', (object,), {"",
            ""        'max_delimiter_priority': lambda self, exclude=set(): DOT_PRIORITY,"",
            ""        'delimiters': {"",
            ""            id(Leaf(token.NAME, 'a')): DOT_PRIORITY,"",
            ""            id(Leaf(token.NAME, 'b')): DOT_PRIORITY"",
            ""        },"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2"",
            ""    })(),"",
            ""    'mode': 'default',"",
            ""    'depth': 1,"",
            ""    'inside_brackets': True,"",
            ""    'comments_after': lambda self, leaf: []"",
            ""})"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('Mock', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'argument': 3"",
            ""})()"",
            ""Feature = type('Mock', (object,), {"",
            ""    'TRAILING_COMMA_IN_DEF': 1,"",
            ""    'TRAILING_COMMA_IN_CALL': 2"",
            ""})()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""sys.maxsize = 2**63 - 1""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), {"",
            ""  'leaves': [type('MockLeaf', (object,), {'bracket_depth': 0, 'type': token.NAME})()],"",
            ""  'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""    'max_delimiter_priority': lambda self, exclude=None: 1,"",
            ""    'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""    'delimiters': {id(1): 1}"",
            ""  })(),"",
            ""  'mode': 'mode',"",
            ""  'depth': 0,"",
            ""  'inside_brackets': False,"",
            ""  'comments_after': lambda leaf: []"",
            ""})()"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""DOT_PRIORITY = 2"",
            ""Line = type('Line', (object,), {"",
            ""  '__init__': lambda self, mode, depth, inside_brackets: ["",
            ""    setattr(self, 'mode', mode),"",
            ""    setattr(self, 'depth', depth),"",
            ""    setattr(self, 'inside_brackets', inside_brackets),"",
            ""    setattr(self, 'leaves', [])"",
            ""  ],"",
            ""  'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf),"",
            ""  'append': lambda self, leaf: self.leaves.append(leaf)"",
            ""})"",
            ""Leaf = type('Leaf', (object,), {"",
            ""  '__init__': lambda self, type, value: ["",
            ""    setattr(self, 'type', type),"",
            ""    setattr(self, 'value', value),"",
            ""    setattr(self, 'bracket_depth', 0)"",
            ""  ]"",
            ""})"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('syms', (object,), {"",
            ""  'typedargslist': 1,"",
            ""  'arglist': 2,"",
            ""  'argument': 3"",
            ""})"",
            ""Feature = type('Feature', (object,), {"",
            ""  'TRAILING_COMMA_IN_DEF': 1,"",
            ""  'TRAILING_COMMA_IN_CALL': 2"",
            ""})"",
            ""features = {1, 2}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 53""
        ]
    }
]","[
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})() # pragma: no cover"",
            ""    ], # pragma: no cover"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 1, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('SymsMock', (object,), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'argument': 'argument' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""Feature = type('FeatureMock', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 1, # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 2 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""token = type('TokenMock', (object,), { # pragma: no cover"",
            ""    'COMMA': 44 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""sys.maxsize = 9223372036854775807 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 3 # pragma: no cover"",
            ""sys.maxsize = 9223372036854775807 # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def append(self, leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def __bool__(self):# pragma: no cover"",
            ""        return bool(self.leaves) # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 2# pragma: no cover"",
            ""    delimiters = {} # pragma: no cover"",
            ""line = type('MockLine', (object,), {# pragma: no cover"",
            ""    'leaves': [Leaf(token.NAME, 'mock_leaf')],# pragma: no cover"",
            ""    'bracket_tracker': BracketTracker(),# pragma: no cover"",
            ""    'mode': 'mock_mode',# pragma: no cover"",
            ""    'depth': 0,# pragma: no cover"",
            ""    'inside_brackets': False,# pragma: no cover"",
            ""    'comments_after': lambda self, leaf: []# pragma: no cover"",
            ""})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""class Syms:# pragma: no cover"",
            ""    typedargslist = 1# pragma: no cover"",
            ""    arglist = 2# pragma: no cover"",
            ""    argument = 3 # pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 999 # pragma: no cover"",
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})()], # pragma: no cover"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 1, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mock_mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, token_type, value): # pragma: no cover"",
            ""        self.type = token_type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'argument': 'argument' # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""sys.maxsize = 9223372036854775807 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception):# pragma: no cover"",
            ""    pass # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 999 # pragma: no cover"",
            ""class BracketTrackerMock:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 2# pragma: no cover"",
            ""    delimiters = {} # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def append(self, leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def __bool__(self):# pragma: no cover"",
            ""        return bool(self.leaves) # pragma: no cover"",
            ""line = Line('mock_mode', 0, False)# pragma: no cover"",
            ""line.bracket_tracker = BracketTrackerMock()# pragma: no cover"",
            ""line.leaves = [Leaf(token.NAME, 'leaf1'), Leaf(token.NAME, 'leaf2')]# pragma: no cover"",
            ""line.comments_after = lambda leaf: [] # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2}) # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""sys.maxsize = 9223372036854775807 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), { # pragma: no cover"",
            ""    'leaves': [type('MockLeaf', (object,), {'bracket_depth': 0})(), # pragma: no cover"",
            ""                type('MockLeaf', (object,), {'bracket_depth': 0})()], # pragma: no cover"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude=None: 1, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {id(type('MockLeaf', (object,), {'bracket_depth': 0})()): 1}})(), # pragma: no cover"",
            ""    'mode': 'default', # pragma: no cover"",
            ""    'depth': 1, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] })() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""Line = type('Line', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, mode, depth, inside_brackets, leaves=None: [ # pragma: no cover"",
            ""        setattr(self, 'mode', mode), # pragma: no cover"",
            ""        setattr(self, 'depth', depth), # pragma: no cover"",
            ""        setattr(self, 'inside_brackets', inside_brackets), # pragma: no cover"",
            ""        setattr(self, 'leaves', leaves or [])], # pragma: no cover"",
            ""    'append_safe': lambda self, leaf, preformatted=False: self.leaves.append(leaf), # pragma: no cover"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf), # pragma: no cover"",
            ""    '__bool__': lambda self: bool(self.leaves) }) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, type, value: [ # pragma: no cover"",
            ""        setattr(self, 'type', type), # pragma: no cover"",
            ""        setattr(self, 'value', value)], # pragma: no cover"",
            ""    'bracket_depth': 0 }) # pragma: no cover"",
            ""iterator_to_list = lambda it: list(it) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 3 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        type('MockLeaf', (object,), {'bracket_depth': 1, 'type': token.NAME})(), # pragma: no cover"",
            ""        type('MockLeaf', (object,), {'bracket_depth': 2, 'type': token.NAME})() # pragma: no cover"",
            ""    ], # pragma: no cover"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude: 1, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mode_value', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""Line = type('Line', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: [ # pragma: no cover"",
            ""        setattr(self, 'mode', mode), # pragma: no cover"",
            ""        setattr(self, 'depth', depth), # pragma: no cover"",
            ""        setattr(self, 'inside_brackets', inside_brackets), # pragma: no cover"",
            ""        setattr(self, 'leaves', []) # pragma: no cover"",
            ""    ], # pragma: no cover"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), # pragma: no cover"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf), # pragma: no cover"",
            ""    '__bool__': lambda self: True if self.leaves else False # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, type, value: [ # pragma: no cover"",
            ""        setattr(self, 'type', type), # pragma: no cover"",
            ""        setattr(self, 'value', value), # pragma: no cover"",
            ""        setattr(self, 'bracket_depth', 1) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Iterator = Iterator # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'argument': 3 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Feature = type('Feature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 1, # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 2 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""COMMA_PRIORITY = 3 # pragma: no cover"",
            ""STANDALONE_COMMENT = 4 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), { # pragma: no cover"",
            ""    'leaves': [ # pragma: no cover"",
            ""        type('MockLeaf', (object,), { # pragma: no cover"",
            ""            'bracket_depth': 0, # pragma: no cover"",
            ""            'type': token.NAME, # pragma: no cover"",
            ""            'value': 'value1' # pragma: no cover"",
            ""        })(), # pragma: no cover"",
            ""        type('MockLeaf', (object,), { # pragma: no cover"",
            ""            'bracket_depth': 1, # pragma: no cover"",
            ""            'type': token.NAME, # pragma: no cover"",
            ""            'value': 'value2' # pragma: no cover"",
            ""        })() # pragma: no cover"",
            ""    ], # pragma: no cover"",
            ""    'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude: 1, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""        'delimiters': {} # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'mock_mode', # pragma: no cover"",
            ""    'depth': 0, # pragma: no cover"",
            ""    'inside_brackets': False, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""Line = type('Line', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, mode, depth, inside_brackets: [setattr(self, 'mode', mode), setattr(self, 'depth', depth), setattr(self, 'inside_brackets', inside_brackets), setattr(self, 'leaves', [])], # pragma: no cover"",
            ""    'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), # pragma: no cover"",
            ""    'append': lambda self, leaf: self.leaves.append(leaf), # pragma: no cover"",
            ""    '__bool__': lambda self: bool(self.leaves) # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), { # pragma: no cover"",
            ""    '__init__': lambda self, type, value: [setattr(self, 'type', type), setattr(self, 'value', value)], # pragma: no cover"",
            ""    'bracket_depth': 0 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'argument': 3 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Feature = type('Feature', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 1, # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 2 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 999 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 5 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, token_type=token.NAME, value=''): # pragma: no cover"",
            ""        self.type = token_type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'}) # pragma: no cover"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL'}) # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""line = Line('default_mode', 0, False) # pragma: no cover"",
            ""line.leaves = [Leaf(token.NAME, 'x'), Leaf(token.NAME, 'y')] # pragma: no cover"",
            ""line.bracket_tracker = type('BracketTracker', (object,), { # pragma: no cover"",
            ""    'max_delimiter_priority': lambda self, exclude: 1, # pragma: no cover"",
            ""    'delimiter_count_with_priority': lambda self, priority: 1, # pragma: no cover"",
            ""    'delimiters': {id(line.leaves[0]): 1, id(line.leaves[1]): 1} # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""line.comments_after = lambda leaf: [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 999 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def __bool__(self): # pragma: no cover"",
            ""        return bool(self.leaves) # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""line = type('Mock', (object,), { # pragma: no cover"",
            ""    'leaves': [Leaf(token.NAME, 'a'), Leaf(token.NAME, 'b')], # pragma: no cover"",
            ""    'bracket_tracker': type('MockTracker', (object,), { # pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude=set(): DOT_PRIORITY, # pragma: no cover"",
            ""        'delimiters': { # pragma: no cover"",
            ""            id(Leaf(token.NAME, 'a')): DOT_PRIORITY, # pragma: no cover"",
            ""            id(Leaf(token.NAME, 'b')): DOT_PRIORITY # pragma: no cover"",
            ""        }, # pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 2 # pragma: no cover"",
            ""    })(), # pragma: no cover"",
            ""    'mode': 'default', # pragma: no cover"",
            ""    'depth': 1, # pragma: no cover"",
            ""    'inside_brackets': True, # pragma: no cover"",
            ""    'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('Mock', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'argument': 3 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""Feature = type('Mock', (object,), { # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 1, # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 2 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""sys.maxsize = 2**63 - 1 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), { # pragma: no cover"",
            ""  'leaves': [type('MockLeaf', (object,), {'bracket_depth': 0, 'type': token.NAME})()], # pragma: no cover"",
            ""  'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""    'max_delimiter_priority': lambda self, exclude=None: 1, # pragma: no cover"",
            ""    'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""    'delimiters': {id(1): 1} # pragma: no cover"",
            ""  })(), # pragma: no cover"",
            ""  'mode': 'mode', # pragma: no cover"",
            ""  'depth': 0, # pragma: no cover"",
            ""  'inside_brackets': False, # pragma: no cover"",
            ""  'comments_after': lambda leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""Line = type('Line', (object,), { # pragma: no cover"",
            ""  '__init__': lambda self, mode, depth, inside_brackets: [ # pragma: no cover"",
            ""    setattr(self, 'mode', mode), # pragma: no cover"",
            ""    setattr(self, 'depth', depth), # pragma: no cover"",
            ""    setattr(self, 'inside_brackets', inside_brackets), # pragma: no cover"",
            ""    setattr(self, 'leaves', []) # pragma: no cover"",
            ""  ], # pragma: no cover"",
            ""  'append_safe': lambda self, leaf, preformatted: self.leaves.append(leaf), # pragma: no cover"",
            ""  'append': lambda self, leaf: self.leaves.append(leaf) # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Leaf = type('Leaf', (object,), { # pragma: no cover"",
            ""  '__init__': lambda self, type, value: [ # pragma: no cover"",
            ""    setattr(self, 'type', type), # pragma: no cover"",
            ""    setattr(self, 'value', value), # pragma: no cover"",
            ""    setattr(self, 'bracket_depth', 0) # pragma: no cover"",
            ""  ] # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""  'typedargslist': 1, # pragma: no cover"",
            ""  'arglist': 2, # pragma: no cover"",
            ""  'argument': 3 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""Feature = type('Feature', (object,), { # pragma: no cover"",
            ""  'TRAILING_COMMA_IN_DEF': 1, # pragma: no cover"",
            ""  'TRAILING_COMMA_IN_CALL': 2 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""features = {1, 2} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 53 # pragma: no cover""
        ]
    }
]",2,8158,0.004079,5605,0.0084075,0.0124865
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Split according to delimiters of the highest priority.
    If the appropriate Features are given, the split will add trailing commas
    also in function signatures and calls that contain `*` and `**`.
    """"""
try: # uncovered
    last_leaf = line.leaves[-1] # uncovered
except IndexError: # uncovered
    raise CannotSplit(""Line empty"") from None # uncovered
bt = line.bracket_tracker # uncovered
try: # uncovered
    delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)}) # uncovered
except ValueError: # uncovered
    raise CannotSplit(""No delimiters found"") from None # uncovered
if delimiter_priority == DOT_PRIORITY: # uncovered
    if bt.delimiter_count_with_priority(delimiter_priority) == 1: # uncovered
        raise CannotSplit(""Splitting a single attribute from its owner looks wrong"") # uncovered
current_line = Line( # uncovered
    mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
) # uncovered
lowest_depth = sys.maxsize # uncovered
trailing_comma_safe = True # uncovered
def append_to_line(leaf: Leaf) -> Iterator[Line]: # uncovered
    """"""Append `leaf` to current line or to new line if appending impossible.""""""
    nonlocal current_line # uncovered
    try: # uncovered
        current_line.append_safe(leaf, preformatted=True) # uncovered
    except ValueError: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
        current_line.append(leaf) # uncovered
for leaf in line.leaves: # uncovered
    aux = append_to_line(leaf) # uncovered
    exit(aux) # uncovered
    for comment_after in line.comments_after(leaf): # uncovered
        aux = append_to_line(comment_after) # uncovered
        exit(aux) # uncovered
    lowest_depth = min(lowest_depth, leaf.bracket_depth) # uncovered
    if leaf.bracket_depth == lowest_depth: # uncovered
        if is_vararg(leaf, within={syms.typedargslist}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features # uncovered
            ) # uncovered
        elif is_vararg(leaf, within={syms.arglist, syms.argument}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features # uncovered
            ) # uncovered
    leaf_priority = bt.delimiters.get(id(leaf)) # uncovered
    if leaf_priority == delimiter_priority: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
if current_line: # uncovered
    if ( # uncovered
        trailing_comma_safe # uncovered
        and delimiter_priority == COMMA_PRIORITY # uncovered
        and current_line.leaves[-1].type != token.COMMA # uncovered
        and current_line.leaves[-1].type != STANDALONE_COMMENT # uncovered
    ): # uncovered
        new_comma = Leaf(token.COMMA, "","") # uncovered
        current_line.append(new_comma) # uncovered
    aux = current_line # uncovered
    exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator, List"",
            ""from black.lines import Line"",
            ""from black.nodes import Leaf"",
            ""from black.brackets import BracketTracker"",
            ""from black.mode import Mode"",
            ""from black.const import DOT_PRIORITY, COMMA_PRIORITY, STANDALONE_COMMENT"",
            ""from black.feature import Feature"",
            ""from black.errors import CannotSplit"",
            ""from black.linegen import is_vararg"",
            ""from black import token""
        ],
        ""initialization"": [
            ""class MockLine:"",
            ""    def __init__(self):"",
            ""        self.leaves = [Leaf(token.NAME, 'a'), Leaf(token.DOT, '.'), Leaf(token.NAME, 'b')]"",
            ""        self.mode = Mode()"",
            ""        self.depth = 0"",
            ""        self.inside_brackets = False"",
            ""        self.bracket_tracker = BracketTracker()"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            ""line = MockLine()"",
            ""class MockBracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(line.leaves[1]): DOT_PRIORITY}"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        return DOT_PRIORITY"",
            ""    def delimiter_count_with_priority(self, delimiter_priority):"",
            ""        return 1"",
            ""line.bracket_tracker = MockBracketTracker()"",
            ""line.bracket_tracker.__class__ = BracketTracker"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('syms', (object,), { 'typedargslist': 1, 'arglist': 2, 'argument': 3 })""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""from black import Line, Leaf, CannotSplit, Feature"",
            ""from black.mode import TargetVersion"",
            ""from black.line import Line"",
            ""from black.nodes import syms, STANDALONE_COMMENT"",
            ""from black.const import DOT_PRIORITY, COMMA_PRIORITY"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), {"",
            ""    'leaves': [Leaf(token.NAME, 'a'), Leaf(token.DOT, '.'), Leaf(token.NAME, 'b')],"",
            ""    'mode': TargetVersion.PY27,"",
            ""    'depth': 0,"",
            ""    'inside_brackets': False,"",
            ""    'bracket_tracker': type('Mock', (object,), {"",
            ""        'delimiters': {id(Leaf(token.DOT, '.')): DOT_PRIORITY, id(Leaf(token.NAME, 'b')): COMMA_PRIORITY},"",
            ""        'max_delimiter_priority': lambda exclude: DOT_PRIORITY,"",
            ""        'delimiter_count_with_priority': lambda priority: 1"",
            ""    })(),"",
            ""    'comments_after': lambda leaf: []"",
            ""})()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            ""def exit(line):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""@dataclass\nclass Leaf:\n    type: int\n    bracket_depth: int\n    value: str = field(default=\""\"")"",
            ""@dataclass\nclass Line:\n    mode: str\n    depth: int\n    inside_brackets: bool\n    leaves: list = field(default_factory=list)\n\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n\n    def append(self, leaf):\n        self.leaves.append(leaf)"",
            ""class CannotSplit(Exception):\n    def __init__(self, message):\n        super().__init__(message)"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""class syms:\n    typedargslist = 1\n    arglist = 2\n    argument = 3"",
            ""class token:\n    COMMA = 1\n    STANDALONE_COMMENT = 2"",
            ""class BracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return 1\n\n    def delimiter_count_with_priority(self, priority):\n        return 1\n\n    def __init__(self):\n        self.delimiters = {}"",
            ""def is_vararg(leaf, within):\n    return False"",
            ""line = Line(mode='mode', depth=0, inside_brackets=False, leaves=[Leaf(type=1, bracket_depth=1)])"",
            ""line.bracket_tracker = BracketTracker()"",
            ""features = set()"",
            ""DOT_PRIORITY = 0\nCOMMA_PRIORITY = 1""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator, List"",
            ""from collections import namedtuple"",
            ""import token"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""Line = namedtuple('Line', ['leaves', 'mode', 'depth', 'inside_brackets', 'append', 'append_safe', 'comments_after'])"",
            ""Leaf = namedtuple('Leaf', ['bracket_depth', 'type'])"",
            ""Feature = Enum('Feature', 'TRAILING_COMMA_IN_DEF TRAILING_COMMA_IN_CALL')"",
            ""syms = type('syms', (), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""line = Line(leaves=[Leaf(0, token.NAME)], mode=None, depth=0, inside_brackets=False, append=lambda x: None, append_safe=lambda x, preformatted=False: None, comments_after=lambda x: [])"",
            ""line.mode = type('Mode', (), {})"",
            ""line.bracket_tracker = type('BracketTracker', (), {'max_delimiter_priority': lambda self, exclude=None: 0, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {}})()"",
            ""COMMA_PRIORITY = 0"",
            ""DOT_PRIORITY = 1"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""is_vararg = lambda leaf, within: False""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from blib2to3.pgen2 import token"",
            ""from blib2to3.pytree import Leaf"",
            ""from some_module import CannotSplit, Feature, Line, syms""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), {"",
            ""  'leaves': [Leaf(token.NAME, 'name')],"",
            ""  'bracket_tracker': type('MockBracketTracker', (object,), {"",
            ""    'max_delimiter_priority': lambda self, exclude: 1,"",
            ""    'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""    'delimiters': {0: 1}"",
            ""  })(),"",
            ""  'mode': None,"",
            ""  'depth': 0,"",
            ""  'inside_brackets': False,"",
            ""  'comments_after': lambda self, leaf: []"",
            ""})()"",
            """",
            ""bt = line.bracket_tracker"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""Feature = type('Feature', (object,), {"",
            ""  'TRAILING_COMMA_IN_DEF': 1,"",
            ""  'TRAILING_COMMA_IN_CALL': 2"",
            ""})()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""syms = type('MockSyms', (object,), {"",
            ""  'typedargslist': 1,"",
            ""  'arglist': 2,"",
            ""  'argument': 3"",
            ""})()"",
            ""def is_vararg(leaf, within):"",
            ""    return True if leaf.type in within else False""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""from my_fake_module import Line, Leaf, CannotSplit, Feature, syms, token"",
            ""from my_fake_module import DOT_PRIORITY, COMMA_PRIORITY, STANDALONE_COMMENT""
        ],
        ""initialization"": [
            ""class MockBracketTracker:"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        return COMMA_PRIORITY"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            ""    delimiters = {}"",
            ""line = type("",
            ""    'Line',"",
            ""    (object,),"",
            ""    {"",
            ""        'leaves': [MockLeaf()],"",
            ""        'bracket_tracker': MockBracketTracker(),"",
            ""        'mode': None,"",
            ""        'depth': 0,"",
            ""        'inside_brackets': False,"",
            ""        'comments_after': lambda x: []"",
            ""    }"",
            "")()"",
            ""class MockLeaf:"",
            ""    def __init__(self):"",
            ""        self.bracket_depth = 1"",
            ""class MockLine:"",
            ""    def __init__(self, mode=None, depth=0, inside_brackets=False):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        pass"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token"",
            ""import enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Feature(enum.Enum): TRAILING_COMMA_IN_DEF = 1; TRAILING_COMMA_IN_CALL = 2"",
            ""class TokenType(enum.Enum): COMMA = 44; STANDALONE_COMMENT = 99"",
            ""token = TokenType"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""def is_vararg(leaf, within): return True # mock implementation"",
            ""class Leaf:\n    def __init__(self, type_, value):\n        self.type = type_\n        self.value = value\n        self.bracket_depth = 0\n\nclass BracketTracker:\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 2\n    def delimiters(self): return {1: COMMA_PRIORITY}\n\nclass Line:\n    def __init__(self, mode=None, depth=0, inside_brackets=False):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]\n    def append_safe(self, leaf, preformatted=False): pass\n    def append(self, leaf): pass\n    def comments_after(self, leaf): return []\n\nline = Line()\nline.bracket_tracker = BracketTracker()\nfeatures = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Iterator"",
            ""import sys"",
            ""import token"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""@dataclass"",
            ""class Features:"",
            ""    TRAILING_COMMA_IN_DEF: bool = True"",
            ""    TRAILING_COMMA_IN_CALL: bool = True"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""class Leaf:"",
            ""    def __init__(self, token_type, value, bracket_depth=0):"",
            ""        self.type = token_type"",
            ""        self.value = value"",
            ""        self.bracket_depth = bracket_depth"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: List[Leaf] = field(default_factory=list)"",
            ""    def append_safe(self, leaf: Leaf, preformatted: bool = False):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf: Leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf: Leaf) -> List[Leaf]:"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude=set()):"",
            ""        return 1"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 2"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line(mode='example', depth=0, inside_brackets=False, leaves=[Leaf(token.COMMA, ',', 1), Leaf(token.COMMA, ',', 2)])"",
            ""line.bracket_tracker = BracketTracker()"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 1"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""features = Features()""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""from black import Line, CannotSplit"",
            ""from black.nodes import Leaf"",
            ""from black.const import COMMA_PRIORITY, DOT_PRIORITY, STANDALONE_COMMENT"",
            ""from black.trans import Feature"",
            ""from black.mode import PythonMode"",
            ""from black.linegen import BracketTracker""
        ],
        ""initialization"": [
            ""class MockLine:  # To simulate the 'line' object with necessary attributes and methods"",
            ""    def __init__(self):"",
            ""        self.leaves = [Leaf(1, 'example')]"",
            ""        self.mode = PythonMode()"",
            ""        self.depth = 0"",
            ""        self.inside_brackets = 0"",
            ""        self.bracket_tracker = BracketTracker(self)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class MockBracketTracker:  # To simulate the 'bracket_tracker' object with necessary methods"",
            ""    def __init__(self, line):"",
            ""        self.line = line"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        return 100"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""class MockLeaf:  # To simulate the 'Leaf' object"",
            ""    def __init__(self, token_type, value):"",
            ""        self.type = token_type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            """",
            ""def is_vararg(leaf, within):  # Dummy function for 'is_vararg'"",
            ""    return False"",
            """",
            ""line = MockLine()"",
            ""bt = MockBracketTracker(line)"",
            ""line.bracket_tracker = bt"",
            ""features = set()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    bracket_depth: int"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    leaves: list = field(default_factory=list)"",
            ""    comments_after_leaves: dict = field(default_factory=dict)"",
            ""    mode: str = ''"",
            ""    depth: int = 0"",
            ""    inside_brackets: bool = False"",
            """",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 3:  # arbitrary condition to raise ValueError"",
            ""            raise ValueError"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def comments_after(self, leaf):"",
            ""        return self.comments_after_leaves.get(leaf, [])"",
            """",
            ""class BracketTracker:"",
            ""    def max_delimiter_priority(self, exclude=set()):"",
            ""        if exclude:"",
            ""            raise ValueError"",
            ""        return 1"",
            """",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""bt = BracketTracker()"",
            ""last_leaf = Leaf(token.DOT, 0)"",
            ""line = Line"",
            ""line.leaves = [Leaf(token.NAME, 0), last_leaf]"",
            ""line.bracket_tracker = bt"",
            ""line.mode = 'default'"",
            ""line.depth = 0"",
            ""line.inside_brackets = True"",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = object()"",
            ""    TRAILING_COMMA_IN_CALL = object()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""def is_vararg(leaf, within):"",
            ""    return False  # Placeholder implementation"",
            ""COMMA_PRIORITY = 5"",
            ""DOT_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 60""
        ]
    }
]","[
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator, List # pragma: no cover"",
            ""from black.lines import Line # pragma: no cover"",
            ""from black.nodes import Leaf # pragma: no cover"",
            ""from black.brackets import BracketTracker # pragma: no cover"",
            ""from black.mode import Mode # pragma: no cover"",
            ""from black.linegen import is_vararg # pragma: no cover"",
            ""from black import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLine: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.leaves = [Leaf(token.NAME, 'a'), Leaf(token.DOT, '.'), Leaf(token.NAME, 'b')] # pragma: no cover"",
            ""        self.mode = Mode() # pragma: no cover"",
            ""        self.depth = 0 # pragma: no cover"",
            ""        self.inside_brackets = False # pragma: no cover"",
            ""        self.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""line = MockLine() # pragma: no cover"",
            ""class MockBracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        pass"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        return DOT_PRIORITY # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, delimiter_priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""line.bracket_tracker = MockBracketTracker() # pragma: no cover"",
            ""syms = type('syms', (object,), { 'typedargslist': 1, 'arglist': 2, 'argument': 3 }) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from black.mode import TargetVersion # pragma: no cover"",
            ""from black.nodes import syms, STANDALONE_COMMENT # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""@dataclass# pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    type: int# pragma: no cover"",
            ""    bracket_depth: int# pragma: no cover"",
            ""    value: str = field(default=\""\"") # pragma: no cover"",
            ""@dataclass# pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    mode: str# pragma: no cover"",
            ""    depth: int# pragma: no cover"",
            ""    inside_brackets: bool# pragma: no cover"",
            ""    leaves: list = field(default_factory=list)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append(self, leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""class CannotSplit(Exception):# pragma: no cover"",
            ""    def __init__(self, message):# pragma: no cover"",
            ""        super().__init__(message) # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""class syms:# pragma: no cover"",
            ""    typedargslist = 1# pragma: no cover"",
            ""    arglist = 2# pragma: no cover"",
            ""    argument = 3 # pragma: no cover"",
            ""class token:# pragma: no cover"",
            ""    COMMA = 1# pragma: no cover"",
            ""    STANDALONE_COMMENT = 2 # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""def is_vararg(leaf, within):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""line = Line(mode='mode', depth=0, inside_brackets=False, leaves=[Leaf(type=1, bracket_depth=1)]) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""DOT_PRIORITY = 0# pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator, List # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""Line = namedtuple('Line', ['leaves', 'mode', 'depth', 'inside_brackets', 'append', 'append_safe', 'comments_after']) # pragma: no cover"",
            ""Leaf = namedtuple('Leaf', ['bracket_depth', 'type']) # pragma: no cover"",
            ""Feature = Enum('Feature', 'TRAILING_COMMA_IN_DEF TRAILING_COMMA_IN_CALL') # pragma: no cover"",
            ""syms = type('syms', (), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""line = Line(leaves=[Leaf(0, token.NAME)], mode=None, depth=0, inside_brackets=False, append=lambda x: None, append_safe=lambda x, preformatted=False: None, comments_after=lambda x: []) # pragma: no cover"",
            ""COMMA_PRIORITY = 0 # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from blib2to3.pgen2 import token # pragma: no cover"",
            ""from blib2to3.pytree import Leaf # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), { # pragma: no cover"",
            ""  'leaves': [Leaf(token.NAME, 'name')], # pragma: no cover"",
            ""  'bracket_tracker': type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""    'max_delimiter_priority': lambda self, exclude: 1, # pragma: no cover"",
            ""    'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""    'delimiters': {0: 1} # pragma: no cover"",
            ""  })(), # pragma: no cover"",
            ""  'mode': None, # pragma: no cover"",
            ""  'depth': 0, # pragma: no cover"",
            ""  'inside_brackets': False, # pragma: no cover"",
            ""  'comments_after': lambda self, leaf: [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            "" # pragma: no cover"",
            ""bt = line.bracket_tracker # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""Feature = type('Feature', (object,), { # pragma: no cover"",
            ""  'TRAILING_COMMA_IN_DEF': 1, # pragma: no cover"",
            ""  'TRAILING_COMMA_IN_CALL': 2 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""  'typedargslist': 1, # pragma: no cover"",
            ""  'arglist': 2, # pragma: no cover"",
            ""  'argument': 3 # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return True if leaf.type in within else False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Feature(enum.Enum): TRAILING_COMMA_IN_DEF = 1; TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""class TokenType(enum.Enum): COMMA = 44; STANDALONE_COMMENT = 99 # pragma: no cover"",
            ""token = TokenType # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""def is_vararg(leaf, within): return True # mock implementation # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type_, value):# pragma: no cover"",
            ""        self.type = type_# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0# pragma: no cover"",
            ""# pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2# pragma: no cover"",
            ""    def delimiters(self): return {1: COMMA_PRIORITY}# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode=None, depth=0, inside_brackets=False):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): pass# pragma: no cover"",
            ""    def append(self, leaf): pass# pragma: no cover"",
            ""    def comments_after(self, leaf): return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""line = Line()# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker()# pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""@dataclass # pragma: no cover"",
            ""class Features: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF: bool = True # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL: bool = True # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, token_type, value, bracket_depth=0): # pragma: no cover"",
            ""        self.type = token_type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: List[Leaf] = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf: Leaf, preformatted: bool = False): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf: Leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf: Leaf) -> List[Leaf]: # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line(mode='example', depth=0, inside_brackets=False, leaves=[Leaf(token.COMMA, ',', 1), Leaf(token.COMMA, ',', 2)]) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""features = Features() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from black.nodes import Leaf # pragma: no cover"",
            ""from black.trans import Feature # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLine:  # To simulate the 'line' object with necessary attributes and methods # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.leaves = [Leaf(1, 'example')] # pragma: no cover"",
            ""        self.depth = 0 # pragma: no cover"",
            ""        self.inside_brackets = 0 # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockBracketTracker:  # To simulate the 'bracket_tracker' object with necessary methods # pragma: no cover"",
            ""    def __init__(self, line): # pragma: no cover"",
            ""        self.line = line # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        return 100 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLeaf:  # To simulate the 'Leaf' object # pragma: no cover"",
            ""    def __init__(self, token_type, value): # pragma: no cover"",
            ""        self.type = token_type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within):  # Dummy function for 'is_vararg' # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = MockLine() # pragma: no cover"",
            ""bt = MockBracketTracker(line) # pragma: no cover"",
            ""line.bracket_tracker = bt # pragma: no cover"",
            ""features = set() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    bracket_depth: int # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    comments_after_leaves: dict = field(default_factory=dict) # pragma: no cover"",
            ""    mode: str = '' # pragma: no cover"",
            ""    depth: int = 0 # pragma: no cover"",
            ""    inside_brackets: bool = False # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 3:  # arbitrary condition to raise ValueError # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return self.comments_after_leaves.get(leaf, []) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""bt = BracketTracker() # pragma: no cover"",
            ""last_leaf = Leaf(token.DOT, 0) # pragma: no cover"",
            ""line = Line # pragma: no cover"",
            ""line.leaves = [Leaf(token.NAME, 0), last_leaf] # pragma: no cover"",
            ""line.bracket_tracker = bt # pragma: no cover"",
            ""line.mode = 'default' # pragma: no cover"",
            ""line.depth = 0 # pragma: no cover"",
            ""line.inside_brackets = True # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = object() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = object() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False  # Placeholder implementation # pragma: no cover"",
            ""COMMA_PRIORITY = 5 # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover""
        ]
    }
]",3,1052,0.000526,4112,0.006168,0.006694
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Split according to delimiters of the highest priority.
    If the appropriate Features are given, the split will add trailing commas
    also in function signatures and calls that contain `*` and `**`.
    """"""
try: # uncovered
    last_leaf = line.leaves[-1] # uncovered
except IndexError: # uncovered
    raise CannotSplit(""Line empty"") from None # uncovered
bt = line.bracket_tracker # uncovered
try: # uncovered
    delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)}) # uncovered
except ValueError: # uncovered
    raise CannotSplit(""No delimiters found"") from None # uncovered
if delimiter_priority == DOT_PRIORITY: # uncovered
    if bt.delimiter_count_with_priority(delimiter_priority) == 1: # uncovered
        raise CannotSplit(""Splitting a single attribute from its owner looks wrong"") # uncovered
current_line = Line( # uncovered
    mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
) # uncovered
lowest_depth = sys.maxsize # uncovered
trailing_comma_safe = True # uncovered
def append_to_line(leaf: Leaf) -> Iterator[Line]: # uncovered
    """"""Append `leaf` to current line or to new line if appending impossible.""""""
    nonlocal current_line # uncovered
    try: # uncovered
        current_line.append_safe(leaf, preformatted=True) # uncovered
    except ValueError: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
        current_line.append(leaf) # uncovered
for leaf in line.leaves: # uncovered
    aux = append_to_line(leaf) # uncovered
    exit(aux) # uncovered
    for comment_after in line.comments_after(leaf): # uncovered
        aux = append_to_line(comment_after) # uncovered
        exit(aux) # uncovered
    lowest_depth = min(lowest_depth, leaf.bracket_depth) # uncovered
    if leaf.bracket_depth == lowest_depth: # uncovered
        if is_vararg(leaf, within={syms.typedargslist}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features # uncovered
            ) # uncovered
        elif is_vararg(leaf, within={syms.arglist, syms.argument}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features # uncovered
            ) # uncovered
    leaf_priority = bt.delimiters.get(id(leaf)) # uncovered
    if leaf_priority == delimiter_priority: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
if current_line: # uncovered
    if ( # uncovered
        trailing_comma_safe # uncovered
        and delimiter_priority == COMMA_PRIORITY # uncovered
        and current_line.leaves[-1].type != token.COMMA # uncovered
        and current_line.leaves[-1].type != STANDALONE_COMMENT # uncovered
    ): # uncovered
        new_comma = Leaf(token.COMMA, "","") # uncovered
        current_line.append(new_comma) # uncovered
    aux = current_line # uncovered
    exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from collections import namedtuple""
        ],
        ""initialization"": [
            ""CannotSplit = type('CannotSplit', (Exception,), {})"",
            ""Feature = namedtuple('Feature', ['TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL'])(1, 2)"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""def is_vararg(leaf, within): return False"",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class BracketTracker:"",
            ""    def max_delimiter_priority(self, exclude=set()):"",
            ""        if exclude:"",
            ""            raise ValueError"",
            ""        return 1"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            ""    delimiters = {id(Leaf(token.DOT, '.')): 1}"",
            ""class Line:"",
            ""    def __init__(self):"",
            ""        self.leaves = [Leaf(token.NAME, 'name'), Leaf(token.DOT, '.'), Leaf(token.NAME, 'attr')]"",
            ""        self.mode = 'mode'"",
            ""        self.depth = 0"",
            ""        self.inside_brackets = False"",
            ""        self.bracket_tracker = BracketTracker()"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 3:"",
            ""            raise ValueError"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""line = Line()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator, List, Set"",
            ""from enum import Enum"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Feature(Enum):\n  TRAILING_COMMA_IN_DEF = 1\n  TRAILING_COMMA_IN_CALL = 2"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 3"",
            ""def is_vararg(leaf, within): return leaf.type in within"",
            ""class Leaf:\n  def __init__(self, tok_type: int, value: str):\n    self.type = tok_type\n    self.value = value\n    self.bracket_depth = 0"",
            ""class Line:\n  def __init__(self, mode: str, depth: int, inside_brackets: bool, leaves: List[Leaf] = None):\n    self.mode = mode\n    self.depth = depth\n    self.inside_brackets = inside_brackets\n    self.leaves = leaves if leaves else []\n  def append_safe(self, leaf: Leaf, preformatted=False):\n    self.leaves.append(leaf)\n  def append(self, leaf: Leaf):\n    self.leaves.append(leaf)\n  def comments_after(self, leaf: Leaf) -> List[Leaf]:\n    return []"",
            ""class BracketTracker:\n  def __init__(self):\n    self.delimiters = {}\n  def max_delimiter_priority(self, exclude: Set[int] = None) -> int:\n    if exclude:\n      raise ValueError\n    return 1\n  def delimiter_count_with_priority(self, priority: int) -> int:\n    return 1"",
            ""line = Line(mode='default', depth=0, inside_brackets=False, leaves=[Leaf(token.NAME, 'a')])"",
            ""bt = BracketTracker()"",
            ""line.bracket_tracker = bt"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing-comma-in-def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing-comma-in-call'"",
            """",
            ""class Leaf:"",
            ""    def __init__(self, token_type, value, bracket_depth=0):"",
            ""        self.type = token_type"",
            ""        self.value = value"",
            ""        self.bracket_depth = bracket_depth"",
            """",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 3:"",
            ""            raise ValueError"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude=set()):"",
            ""        if exclude:"",
            ""            raise ValueError"",
            ""        return COMMA_PRIORITY"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line('mode', 0, False)"",
            ""last_leaf = Leaf(token.DOT, '.', 0)"",
            ""line.leaves.append(Leaf(token.NAME, 'a', 1))"",
            ""line.leaves.append(last_leaf)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""bt = line.bracket_tracker"",
            ""bt.delimiters = {id(last_leaf): COMMA_PRIORITY}"",
            """",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator, List"",
            ""from dataclasses import dataclass, field"",
            ""import token""
        ],
        ""initialization"": [
            ""@dataclass\nclass Leaf:\n    type: int\n    bracket_depth: int\n    value: str = \""\""\n\n@dataclass\nclass Line:\n    leaves: List[Leaf] = field(default_factory=list)\n    mode: str = \""\""\n    depth: int = 0\n    inside_brackets: bool = False\n    def append_safe(self, leaf: Leaf, preformatted: bool = False):\n        if len(self.leaves) > 1:  # mock the condition to raise ValueError\n            raise ValueError\n        self.leaves.append(leaf)\n    def append(self, leaf: Leaf):\n        self.leaves.append(leaf)\n    def comments_after(self, leaf: Leaf) -> List[Leaf]:\n        return []\n\nclass BracketTracker:\n    def __init__(self):\n        self.delimiters = {}\n    def max_delimiter_priority(self, exclude=set()):\n        if exclude:\n            raise ValueError\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1\n\nclass Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2\n\nclass CannotSplit(Exception):\n    pass\n\nCOMMA_PRIORITY = 1\nDOT_PRIORITY = 2\nSTANDALONE_COMMENT = 99\n\nsyms = type(\""syms\"", (object,), {\""typedargslist\"": 1, \""arglist\"": 2, \""argument\"": 3})\n\nline = Line(\n    leaves=[Leaf(token.COMMA, 1), Leaf(token.DOT, 2)],\n    mode=\""default\"",\n    depth=0,\n    inside_brackets=False\n)\nline.bracket_tracker = BracketTracker()\nfeatures = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}\n\ndef is_vararg(leaf, within):\n    return False\n\ndef exit(line):\n    pass""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""@dataclass\nclass Leaf:\n    type: int\n    bracket_depth: int\n    value: str = ''\n"",
            ""@dataclass\nclass Line:\n    mode: str\n    depth: int\n    inside_brackets: bool\n    leaves: list = field(default_factory=list)\n\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n        if len(self.leaves) > 2:\n            raise ValueError('Too many leaves')\n\n    def append(self, leaf):\n        self.leaves.append(leaf)\n\n    def comments_after(self, leaf):\n        return []\n"",
            ""class BracketTracker:\n    def max_delimiter_priority(self, exclude):\n        if exclude:\n            return COMMA_PRIORITY\n        return 0\n\n    def delimiter_count_with_priority(self, priority):\n        return 2\n\n    delimiters = {id(Leaf(token.COMMA, 0)): COMMA_PRIORITY}\n"",
            ""class CannotSplit(Exception):\n    pass\n"",
            ""COMMA_PRIORITY = 1\nDOT_PRIORITY = 2\nSTANDALONE_COMMENT = 99\n"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})\n"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2\n"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}\n"",
            ""def is_vararg(leaf, within):\n    return False  # Mock implementation\n"",
            ""line = Line('example_mode', 0, False, [Leaf(token.COMMA, 1)])\nline.bracket_tracker = BracketTracker()\n""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    bracket_depth: int"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    comments_after_leaves: dict = field(default_factory=dict)"",
            """",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 3:  # arbitrary condition to raise ValueError"",
            ""            raise ValueError"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def comments_after(self, leaf):"",
            ""        return self.comments_after_leaves.get(leaf, [])"",
            """",
            ""class BracketTracker:"",
            ""    def max_delimiter_priority(self, exclude=set()):"",
            ""        if exclude:"",
            ""            raise ValueError"",
            ""        return 1"",
            """",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            ""    delimiters = {}"",
            """",
            ""line = Line(mode='default', depth=0, inside_brackets=False, leaves=[Leaf(token.COMMA, 1), Leaf(token.NAME, 0), Leaf(token.DOT, 1)])"",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = object()"",
            ""    TRAILING_COMMA_IN_CALL = object()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""class syms:"",
            ""    typedargslist = 1"",
            ""    arglist = 2"",
            ""    argument = 3"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False  # Placeholder implementation"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""class Leaf:"",
            ""    def __init__(self, token_type, value, bracket_depth=0):"",
            ""        self.type = token_type"",
            ""        self.value = value"",
            ""        self.bracket_depth = bracket_depth"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',', 0)): COMMA_PRIORITY}"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        if exclude:"",
            ""            raise ValueError"",
            ""        return COMMA_PRIORITY"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 2"",
            ""class Line:"",
            ""    def __init__(self, mode='', depth=0, inside_brackets=False):"",
            ""        self.leaves = [Leaf(token.COMMA, ',', 0)]"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        raise ValueError"",
            ""    def append(self, leaf):"",
            ""        pass"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            ""line = Line()"",
            ""bt = BracketTracker()"",
            ""line.bracket_tracker = bt"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""def is_vararg(leaf, within):"",
            ""    return leaf.bracket_depth == 0"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from collections import namedtuple"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Feature(Enum): TRAILING_COMMA_IN_DEF = 1; TRAILING_COMMA_IN_CALL = 2"",
            ""class TokenType(Enum): COMMA = 44; STANDALONE_COMMENT = 99"",
            ""token = TokenType"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""def is_vararg(leaf, within): return True if leaf.type in within else False"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value, bracket_depth=0):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = bracket_depth"",
            ""class Line:"",
            ""    def __init__(self, mode=None, depth=0, inside_brackets=False):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if leaf.value == 'raise_error':"",
            ""            raise ValueError"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude=set()):"",
            ""        if exclude:"",
            ""            raise ValueError"",
            ""        return DOT_PRIORITY"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            ""line = Line(mode='default', depth=0, inside_brackets=False)"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.DOT, '.', 1), Leaf(token.NAME, 'name')]"",
            ""line.bracket_tracker = BracketTracker()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator, List"",
            ""from enum import Enum"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception):"",
            ""    pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: List[Leaf] = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) > 1:  # Condition to trigger ValueError"",
            ""            raise ValueError()"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return [Leaf(token.COMMA, ',')] if leaf.value == 'b' else []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        return COMMA_PRIORITY if exclude else DOT_PRIORITY"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return leaf.value == '*'"",
            """",
            ""line = Line(mode='mode', depth=0, inside_brackets=False, leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'b')])"",
            ""line.bracket_tracker = BracketTracker()"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""@dataclass\nclass Leaf:\n    type: int\n    value: str\n    bracket_depth: int = 0"",
            ""@dataclass\nclass Line:\n    mode: str\n    depth: int\n    inside_brackets: bool\n    leaves: list = field(default_factory=list)\n\n    def append_safe(self, leaf, preformatted=False):\n        if len(self.leaves) >= 1:  # this will cause the ValueError to be raised\n            raise ValueError\n        self.leaves.append(leaf)\n\n    def append(self, leaf):\n        self.leaves.append(leaf)\n\n    def comments_after(self, leaf):\n        return []"",
            ""class BracketTracker:\n    def __init__(self):\n        self.delimiters = {id(leaf): 1}\n    def max_delimiter_priority(self, exclude):\n        if exclude:\n            raise ValueError  # This will raise the ValueError for the uncovered line\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1"",
            ""line = Line(mode='default', depth=0, inside_brackets=False, leaves=[Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')])"",
            ""line.bracket_tracker = BracketTracker()"",
            ""def is_vararg(leaf, within):\n    return leaf.type in within"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""COMMA_PRIORITY = 1\nDOT_PRIORITY = 2"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""STANDALONE_COMMENT = 60\nCannotSplit = type('CannotSplit', (Exception,), {})"",
            ""aux = []"",
            ""def exit(line):\n    pass""
        ]
    }
]","[
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover""
        ],
        ""initialization"": [
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""Feature = namedtuple('Feature', ['TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL'])(1, 2) # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    delimiters = {id(Leaf(token.DOT, '.')): 1} # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.leaves = [Leaf(token.NAME, 'name'), Leaf(token.DOT, '.'), Leaf(token.NAME, 'attr')] # pragma: no cover"",
            ""        self.mode = 'mode' # pragma: no cover"",
            ""        self.depth = 0 # pragma: no cover"",
            ""        self.inside_brackets = False # pragma: no cover"",
            ""        self.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 3: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""line = Line() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator, List, Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Feature(Enum):# pragma: no cover"",
            ""  TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""  TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 3 # pragma: no cover"",
            ""def is_vararg(leaf, within): return leaf.type in within # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""  def __init__(self, tok_type: int, value: str):# pragma: no cover"",
            ""    self.type = tok_type# pragma: no cover"",
            ""    self.value = value# pragma: no cover"",
            ""    self.bracket_depth = 0 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""  def __init__(self, mode: str, depth: int, inside_brackets: bool, leaves: List[Leaf] = None):# pragma: no cover"",
            ""    self.mode = mode# pragma: no cover"",
            ""    self.depth = depth# pragma: no cover"",
            ""    self.inside_brackets = inside_brackets# pragma: no cover"",
            ""    self.leaves = leaves if leaves else []# pragma: no cover"",
            ""  def append_safe(self, leaf: Leaf, preformatted=False):# pragma: no cover"",
            ""    self.leaves.append(leaf)# pragma: no cover"",
            ""  def append(self, leaf: Leaf):# pragma: no cover"",
            ""    self.leaves.append(leaf)# pragma: no cover"",
            ""  def comments_after(self, leaf: Leaf) -> List[Leaf]:# pragma: no cover"",
            ""    return [] # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""  def __init__(self):# pragma: no cover"",
            ""    self.delimiters = {}# pragma: no cover"",
            ""  def max_delimiter_priority(self, exclude: Set[int] = None) -> int:# pragma: no cover"",
            ""    if exclude:# pragma: no cover"",
            ""      raise ValueError# pragma: no cover"",
            ""    return 1# pragma: no cover"",
            ""  def delimiter_count_with_priority(self, priority: int) -> int:# pragma: no cover"",
            ""    return 1 # pragma: no cover"",
            ""line = Line(mode='default', depth=0, inside_brackets=False, leaves=[Leaf(token.NAME, 'a')]) # pragma: no cover"",
            ""bt = BracketTracker() # pragma: no cover"",
            ""line.bracket_tracker = bt # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing-comma-in-def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing-comma-in-call' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, token_type, value, bracket_depth=0): # pragma: no cover"",
            ""        self.type = token_type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 3: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        return COMMA_PRIORITY # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line('mode', 0, False) # pragma: no cover"",
            ""last_leaf = Leaf(token.DOT, '.', 0) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'a', 1)) # pragma: no cover"",
            ""line.leaves.append(last_leaf) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""bt = line.bracket_tracker # pragma: no cover"",
            "" # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator, List # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""@dataclass# pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    type: int# pragma: no cover"",
            ""    bracket_depth: int# pragma: no cover"",
            ""    value: str = \""\""# pragma: no cover"",
            ""# pragma: no cover"",
            ""@dataclass# pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    leaves: List[Leaf] = field(default_factory=list)# pragma: no cover"",
            ""    mode: str = \""\""# pragma: no cover"",
            ""    depth: int = 0# pragma: no cover"",
            ""    inside_brackets: bool = False# pragma: no cover"",
            ""    def append_safe(self, leaf: Leaf, preformatted: bool = False):# pragma: no cover"",
            ""        if len(self.leaves) > 1:  # mock the condition to raise ValueError# pragma: no cover"",
            ""            raise ValueError# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def append(self, leaf: Leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def comments_after(self, leaf: Leaf) -> List[Leaf]:# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {}# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()):# pragma: no cover"",
            ""        if exclude:# pragma: no cover"",
            ""            raise ValueError# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2# pragma: no cover"",
            ""# pragma: no cover"",
            ""class CannotSplit(Exception):# pragma: no cover"",
            ""    pass# pragma: no cover"",
            ""# pragma: no cover"",
            ""COMMA_PRIORITY = 1# pragma: no cover"",
            ""DOT_PRIORITY = 2# pragma: no cover"",
            ""STANDALONE_COMMENT = 99# pragma: no cover"",
            ""# pragma: no cover"",
            ""syms = type(\""syms\"", (object,), {\""typedargslist\"": 1, \""arglist\"": 2, \""argument\"": 3})# pragma: no cover"",
            ""# pragma: no cover"",
            ""line = Line(# pragma: no cover"",
            ""    leaves=[Leaf(token.COMMA, 1), Leaf(token.DOT, 2)],# pragma: no cover"",
            ""    mode=\""default\"",# pragma: no cover"",
            ""    depth=0,# pragma: no cover"",
            ""    inside_brackets=False# pragma: no cover"",
            "")# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker()# pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}# pragma: no cover"",
            ""# pragma: no cover"",
            ""def is_vararg(leaf, within):# pragma: no cover"",
            ""    return False# pragma: no cover"",
            ""# pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""@dataclass# pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    type: int# pragma: no cover"",
            ""    bracket_depth: int# pragma: no cover"",
            ""    value: str = ''# pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass# pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    mode: str# pragma: no cover"",
            ""    depth: int# pragma: no cover"",
            ""    inside_brackets: bool# pragma: no cover"",
            ""    leaves: list = field(default_factory=list)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""        if len(self.leaves) > 2:# pragma: no cover"",
            ""            raise ValueError('Too many leaves')# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append(self, leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        if exclude:# pragma: no cover"",
            ""            return COMMA_PRIORITY# pragma: no cover"",
            ""        return 0# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception):# pragma: no cover"",
            ""    pass# pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1# pragma: no cover"",
            ""DOT_PRIORITY = 2# pragma: no cover"",
            ""STANDALONE_COMMENT = 99# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})# pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within):# pragma: no cover"",
            ""    return False  # Mock implementation# pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line('example_mode', 0, False, [Leaf(token.COMMA, 1)])# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker()# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    bracket_depth: int # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    comments_after_leaves: dict = field(default_factory=dict) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 3:  # arbitrary condition to raise ValueError # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return self.comments_after_leaves.get(leaf, []) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    delimiters = {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line(mode='default', depth=0, inside_brackets=False, leaves=[Leaf(token.COMMA, 1), Leaf(token.NAME, 0), Leaf(token.DOT, 1)]) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = object() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = object() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""class syms: # pragma: no cover"",
            ""    typedargslist = 1 # pragma: no cover"",
            ""    arglist = 2 # pragma: no cover"",
            ""    argument = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False  # Placeholder implementation # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, token_type, value, bracket_depth=0): # pragma: no cover"",
            ""        self.type = token_type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        pass"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        return COMMA_PRIORITY # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode='', depth=0, inside_brackets=False): # pragma: no cover"",
            ""        self.leaves = [Leaf(token.COMMA, ',', 0)] # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        raise ValueError # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""line = Line() # pragma: no cover"",
            ""bt = BracketTracker() # pragma: no cover"",
            ""line.bracket_tracker = bt # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return leaf.bracket_depth == 0 # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Feature(Enum): TRAILING_COMMA_IN_DEF = 1; TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""class TokenType(Enum): COMMA = 44; STANDALONE_COMMENT = 99 # pragma: no cover"",
            ""token = TokenType # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""def is_vararg(leaf, within): return True if leaf.type in within else False # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, bracket_depth=0): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode=None, depth=0, inside_brackets=False): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if leaf.value == 'raise_error': # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        return DOT_PRIORITY # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""line = Line(mode='default', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator, List # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): # pragma: no cover"",
            ""    pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: List[Leaf] = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) > 1:  # Condition to trigger ValueError # pragma: no cover"",
            ""            raise ValueError() # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [Leaf(token.COMMA, ',')] if leaf.value == 'b' else [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        return COMMA_PRIORITY if exclude else DOT_PRIORITY # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return leaf.value == '*' # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line(mode='mode', depth=0, inside_brackets=False, leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'b')]) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""@dataclass# pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    type: int# pragma: no cover"",
            ""    value: str# pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            ""@dataclass# pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    mode: str# pragma: no cover"",
            ""    depth: int# pragma: no cover"",
            ""    inside_brackets: bool# pragma: no cover"",
            ""    leaves: list = field(default_factory=list)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        if len(self.leaves) >= 1:  # this will cause the ValueError to be raised# pragma: no cover"",
            ""            raise ValueError# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append(self, leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        pass"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        if exclude:# pragma: no cover"",
            ""            raise ValueError  # This will raise the ValueError for the uncovered line# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""line = Line(mode='default', depth=0, inside_brackets=False, leaves=[Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""def is_vararg(leaf, within):# pragma: no cover"",
            ""    return leaf.type in within # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""COMMA_PRIORITY = 1# pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""STANDALONE_COMMENT = 60# pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    }
]",3,6193,0.0030965,5094,0.007641,0.0107375
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Split according to delimiters of the highest priority.
    If the appropriate Features are given, the split will add trailing commas
    also in function signatures and calls that contain `*` and `**`.
    """"""
try: # uncovered
    last_leaf = line.leaves[-1] # uncovered
except IndexError: # uncovered
    raise CannotSplit(""Line empty"") from None # uncovered
bt = line.bracket_tracker # uncovered
try: # uncovered
    delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)}) # uncovered
except ValueError: # uncovered
    raise CannotSplit(""No delimiters found"") from None # uncovered
if delimiter_priority == DOT_PRIORITY: # uncovered
    if bt.delimiter_count_with_priority(delimiter_priority) == 1: # uncovered
        raise CannotSplit(""Splitting a single attribute from its owner looks wrong"") # uncovered
current_line = Line( # uncovered
    mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
) # uncovered
lowest_depth = sys.maxsize # uncovered
trailing_comma_safe = True # uncovered
def append_to_line(leaf: Leaf) -> Iterator[Line]: # uncovered
    """"""Append `leaf` to current line or to new line if appending impossible.""""""
    nonlocal current_line # uncovered
    try: # uncovered
        current_line.append_safe(leaf, preformatted=True) # uncovered
    except ValueError: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
        current_line.append(leaf) # uncovered
for leaf in line.leaves: # uncovered
    aux = append_to_line(leaf) # uncovered
    exit(aux) # uncovered
    for comment_after in line.comments_after(leaf): # uncovered
        aux = append_to_line(comment_after) # uncovered
        exit(aux) # uncovered
    lowest_depth = min(lowest_depth, leaf.bracket_depth) # uncovered
    if leaf.bracket_depth == lowest_depth: # uncovered
        if is_vararg(leaf, within={syms.typedargslist}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features # uncovered
            ) # uncovered
        elif is_vararg(leaf, within={syms.arglist, syms.argument}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features # uncovered
            ) # uncovered
    leaf_priority = bt.delimiters.get(id(leaf)) # uncovered
    if leaf_priority == delimiter_priority: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
if current_line: # uncovered
    if ( # uncovered
        trailing_comma_safe # uncovered
        and delimiter_priority == COMMA_PRIORITY # uncovered
        and current_line.leaves[-1].type != token.COMMA # uncovered
        and current_line.leaves[-1].type != STANDALONE_COMMENT # uncovered
    ): # uncovered
        new_comma = Leaf(token.COMMA, "","") # uncovered
        current_line.append(new_comma) # uncovered
    aux = current_line # uncovered
    exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""@dataclass\nclass Leaf:\n    type: int\n    value: str\n    bracket_depth: int = 0"",
            ""@dataclass\nclass Line:\n    mode: str\n    depth: int\n    inside_brackets: bool\n    leaves: list = field(default_factory=list)\n\n    def append_safe(self, leaf, preformatted=False):\n        if len(self.leaves) >= 1:  # condition to hit ValueError\n            raise ValueError\n        self.leaves.append(leaf)\n\n    def append(self, leaf):\n        self.leaves.append(leaf)\n\n    def comments_after(self, leaf):\n        return []"",
            ""class BracketTracker:\n    def __init__(self):\n        self.delimiters = {id(leaf): 1}\n    def max_delimiter_priority(self, exclude):\n        if exclude:\n            raise ValueError  # condition to hit ValueError\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1"",
            ""line = Line(mode='default', depth=0, inside_brackets=False, leaves=[Leaf(token.DOT, '.'), Leaf(token.DOT, '.')])"",
            ""line.bracket_tracker = BracketTracker()"",
            ""def is_vararg(leaf, within):\n    return False"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""COMMA_PRIORITY = 1\nDOT_PRIORITY = 2"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""STANDALONE_COMMENT = 60\nCannotSplit = type('CannotSplit', (Exception,), {})"",
            ""def exit(line):\n    pass""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""class Leaf:"",
            ""    def __init__(self, token_type, value, bracket_depth=0):"",
            ""        self.type = token_type"",
            ""        self.value = value"",
            ""        self.bracket_depth = bracket_depth"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude=set()):"",
            ""        if len(exclude) > 0:"",
            ""            raise ValueError"",
            ""        return 1"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = [Leaf(token.NAME, 'a'), Leaf(token.DOT, '.'), Leaf(token.NAME, 'b')]"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        raise ValueError"",
            ""    def append(self, leaf):"",
            ""        pass"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            ""line = Line('default', 0, False)"",
            ""bt = BracketTracker()"",
            ""line.bracket_tracker = bt"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value, bracket_depth=0):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = bracket_depth"",
            ""class BracketTracker:"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if isinstance(exclude, set) and len(exclude) > 0:"",
            ""            raise ValueError"",
            ""        return COMMA_PRIORITY"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            ""    delimiters = {}"",
            ""class Line:"",
            ""    def __init__(self, mode='', depth=0, inside_brackets=False):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = [Leaf(token.NAME, 'a'), Leaf(token.DOT, '.'), Leaf(token.NAME, 'b')]"",
            ""        self.bracket_tracker = BracketTracker()"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        raise ValueError"",
            ""    def append(self, leaf):"",
            ""        pass"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            ""features = {'trailing_comma_in_def', 'trailing_comma_in_call'}"",
            ""syms = SimpleNamespace(typedargslist=1, arglist=2, argument=3)"",
            ""def is_vararg(leaf, within): return False"",
            ""line = Line()"",
            ""def exit(aux): pass""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""@dataclass\nclass Leaf:\n    type: int\n    value: str\n    bracket_depth: int = 0"",
            ""@dataclass\nclass Line:\n    mode: str\n    depth: int\n    inside_brackets: bool\n    leaves: list = field(default_factory=list)\n\n    def append_safe(self, leaf, preformatted=False):\n        if len(self.leaves) >= 1:  # this will cause the ValueError to be raised\n            raise ValueError\n        self.leaves.append(leaf)\n\n    def append(self, leaf):\n        self.leaves.append(leaf)\n\n    def comments_after(self, leaf):\n        return []"",
            ""class BracketTracker:\n    def __init__(self):\n        self.delimiters = {id(leaf): 1}\n    def max_delimiter_priority(self, exclude):\n        if exclude:\n            raise ValueError  # This will raise the ValueError for the uncovered line\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1"",
            ""line = Line(mode='default', depth=0, inside_brackets=False, leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')])"",
            ""line.bracket_tracker = BracketTracker()"",
            ""def is_vararg(leaf, within):\n    return leaf.type in within"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""COMMA_PRIORITY = 1\nDOT_PRIORITY = 2"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""STANDALONE_COMMENT = 60\nCannotSplit = type('CannotSplit', (Exception,), {})"",
            ""aux = []"",
            ""def exit(line):\n    pass""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            """",
            ""class Leaf:"",
            ""    def __init__(self, token_type, value, bracket_depth=0):"",
            ""        self.type = token_type"",
            ""        self.value = value"",
            ""        self.bracket_depth = bracket_depth"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude=set()):"",
            ""        if exclude:"",
            ""            raise ValueError"",
            ""        return 1"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""class Line:"",
            ""    def __init__(self, mode='', depth=0, inside_brackets=False):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) > 2:"",
            ""            raise ValueError"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 3"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return leaf.value in ('*', '**')"",
            """",
            ""line = Line(mode='default', depth=0, inside_brackets=False)"",
            ""line.leaves = [Leaf(token.NAME, 'a'), Leaf(token.DOT, '.'), Leaf(token.NAME, 'b')]"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.bracket_tracker.delimiters = {id(leaf): COMMA_PRIORITY for leaf in line.leaves}"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""from typing import Iterator"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""class Leaf:"",
            ""    def __init__(self, token_type, value, bracket_depth=0):"",
            ""        self.type = token_type"",
            ""        self.value = value"",
            ""        self.bracket_depth = bracket_depth"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.NAME, 'a')): 1}"",
            ""    def max_delimiter_priority(self, exclude=set()):"",
            ""        if exclude:"",
            ""            raise ValueError"",
            ""        return 1"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            ""class Line:"",
            ""    def __init__(self, mode='', depth=0, inside_brackets=False):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = [Leaf(token.NAME, 'a'), Leaf(token.DOT, '.'), Leaf(token.NAME, 'b')]"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 2:"",
            ""            raise ValueError"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            ""line = Line('mode', 0, False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""def is_vararg(leaf, within):"",
            ""    return leaf.type in within"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 3""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Feature: TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'"",
            ""class Leaf:"",
            ""    def __init__(self, token_type, value, bracket_depth=0):"",
            ""        self.type = token_type"",
            ""        self.value = value"",
            ""        self.bracket_depth = bracket_depth"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude=set()):"",
            ""        if exclude:"",
            ""            raise ValueError"",
            ""        return COMMA_PRIORITY"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""class Line:"",
            ""    def __init__(self, mode='', depth=0, inside_brackets=False):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = [Leaf(token.NAME, 'a'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'b')]"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) > 1:  # condition to ensure ValueError is raised"",
            ""            raise ValueError"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""line = Line(mode='default', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""bt = line.bracket_tracker"",
            ""bt.delimiters = {id(line.leaves[1]): COMMA_PRIORITY}"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator, List"",
            ""from enum import Enum"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: List[Leaf] = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if leaf.type == token.DOT:  # Condition to trigger ValueError"",
            ""            raise ValueError()"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if exclude:"",
            ""            return COMMA_PRIORITY"",
            ""        return DOT_PRIORITY"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='default',"",
            ""    depth=0,"",
            ""    inside_brackets=False,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'attr')]"",
            "")"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.bracket_tracker.delimiters = {id(line.leaves[-1]): COMMA_PRIORITY}"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""class Leaf:"",
            ""    def __init__(self, token_type, value, bracket_depth=0):"",
            ""        self.type = token_type"",
            ""        self.value = value"",
            ""        self.bracket_depth = bracket_depth"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        if exclude:"",
            ""            raise ValueError"",
            ""        return COMMA_PRIORITY"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            ""class Line:"",
            ""    def __init__(self, mode='', depth=0, inside_brackets=False):"",
            ""        self.leaves = [Leaf(token.COMMA, ','), Leaf(token.NAME, 'name', 0)]"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        raise ValueError"",
            ""    def append(self, leaf):"",
            ""        pass"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            ""line = Line()"",
            ""bt = BracketTracker()"",
            ""line.bracket_tracker = bt"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""def is_vararg(leaf, within):"",
            ""    return leaf.bracket_depth == 0"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""aux = []"",
            ""def exit(line):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from enum import Enum"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Feature(Enum): TRAILING_COMMA_IN_DEF = 1; TRAILING_COMMA_IN_CALL = 2"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 99"",
            ""@dataclass\nclass Leaf:\n    type: int\n    value: str\n    bracket_depth: int = 0"",
            ""@dataclass\nclass Line:\n    mode: str\n    depth: int\n    inside_brackets: bool\n    leaves: list = field(default_factory=list)\n\n    def append_safe(self, leaf, preformatted=False):\n        if len(self.leaves) >= 1:  # this will cause the ValueError to be raised\n            raise ValueError\n        self.leaves.append(leaf)\n\n    def append(self, leaf):\n        self.leaves.append(leaf)\n\n    def comments_after(self, leaf):\n        return []"",
            ""class BracketTracker:\n    def __init__(self):\n        self.delimiters = {id(Leaf(token.COMMA, ',')): COMMA_PRIORITY}\n    def max_delimiter_priority(self, exclude):\n        if exclude:\n            raise ValueError  # This will raise the ValueError for the uncovered line\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1"",
            ""line = Line(mode='default', depth=0, inside_brackets=False, leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')])"",
            ""line.bracket_tracker = BracketTracker()"",
            ""def is_vararg(leaf, within):\n    return leaf.type in within"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}""
        ]
    }
]","[
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""@dataclass# pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    type: int# pragma: no cover"",
            ""    value: str# pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            ""@dataclass# pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    mode: str# pragma: no cover"",
            ""    depth: int# pragma: no cover"",
            ""    inside_brackets: bool# pragma: no cover"",
            ""    leaves: list = field(default_factory=list)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        if len(self.leaves) >= 1:  # condition to hit ValueError# pragma: no cover"",
            ""            raise ValueError# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append(self, leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        pass"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        if exclude:# pragma: no cover"",
            ""            raise ValueError  # condition to hit ValueError# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""line = Line(mode='default', depth=0, inside_brackets=False, leaves=[Leaf(token.DOT, '.'), Leaf(token.DOT, '.')]) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""def is_vararg(leaf, within):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""COMMA_PRIORITY = 1# pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""STANDALONE_COMMENT = 60# pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, token_type, value, bracket_depth=0): # pragma: no cover"",
            ""        self.type = token_type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        if len(exclude) > 0: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [Leaf(token.NAME, 'a'), Leaf(token.DOT, '.'), Leaf(token.NAME, 'b')] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        raise ValueError # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""line = Line('default', 0, False) # pragma: no cover"",
            ""bt = BracketTracker() # pragma: no cover"",
            ""line.bracket_tracker = bt # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value, bracket_depth=0): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if isinstance(exclude, set) and len(exclude) > 0: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        return COMMA_PRIORITY # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    delimiters = {} # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode='', depth=0, inside_brackets=False): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [Leaf(token.NAME, 'a'), Leaf(token.DOT, '.'), Leaf(token.NAME, 'b')] # pragma: no cover"",
            ""        self.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        raise ValueError # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""features = {'trailing_comma_in_def', 'trailing_comma_in_call'} # pragma: no cover"",
            ""syms = SimpleNamespace(typedargslist=1, arglist=2, argument=3) # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""line = Line() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""@dataclass# pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    type: int# pragma: no cover"",
            ""    value: str# pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            ""@dataclass# pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    mode: str# pragma: no cover"",
            ""    depth: int# pragma: no cover"",
            ""    inside_brackets: bool# pragma: no cover"",
            ""    leaves: list = field(default_factory=list)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        if len(self.leaves) >= 1:  # this will cause the ValueError to be raised# pragma: no cover"",
            ""            raise ValueError# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append(self, leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        pass"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        if exclude:# pragma: no cover"",
            ""            raise ValueError  # This will raise the ValueError for the uncovered line# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""line = Line(mode='default', depth=0, inside_brackets=False, leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')]) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""def is_vararg(leaf, within):# pragma: no cover"",
            ""    return leaf.type in within # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""COMMA_PRIORITY = 1# pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""STANDALONE_COMMENT = 60# pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, token_type, value, bracket_depth=0): # pragma: no cover"",
            ""        self.type = token_type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode='', depth=0, inside_brackets=False): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) > 2: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 3 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return leaf.value in ('*', '**') # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line(mode='default', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.leaves = [Leaf(token.NAME, 'a'), Leaf(token.DOT, '.'), Leaf(token.NAME, 'b')] # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.bracket_tracker.delimiters = {id(leaf): COMMA_PRIORITY for leaf in line.leaves} # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, token_type, value, bracket_depth=0): # pragma: no cover"",
            ""        self.type = token_type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.NAME, 'a')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode='', depth=0, inside_brackets=False): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [Leaf(token.NAME, 'a'), Leaf(token.DOT, '.'), Leaf(token.NAME, 'b')] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 2: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""line = Line('mode', 0, False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return leaf.type in within # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 3 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Feature: TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, token_type, value, bracket_depth=0): # pragma: no cover"",
            ""        self.type = token_type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        return COMMA_PRIORITY # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode='', depth=0, inside_brackets=False): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [Leaf(token.NAME, 'a'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'b')] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) > 1:  # condition to ensure ValueError is raised # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line(mode='default', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""bt = line.bracket_tracker # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator, List # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: List[Leaf] = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if leaf.type == token.DOT:  # Condition to trigger ValueError # pragma: no cover"",
            ""            raise ValueError() # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            return COMMA_PRIORITY # pragma: no cover"",
            ""        return DOT_PRIORITY # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='default', # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'attr')] # pragma: no cover"",
            "") # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, token_type, value, bracket_depth=0): # pragma: no cover"",
            ""        self.type = token_type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        return COMMA_PRIORITY # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode='', depth=0, inside_brackets=False): # pragma: no cover"",
            ""        self.leaves = [Leaf(token.COMMA, ','), Leaf(token.NAME, 'name', 0)] # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        raise ValueError # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        pass # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""line = Line() # pragma: no cover"",
            ""bt = BracketTracker() # pragma: no cover"",
            ""line.bracket_tracker = bt # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return leaf.bracket_depth == 0 # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Feature(Enum): TRAILING_COMMA_IN_DEF = 1; TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 99 # pragma: no cover"",
            ""@dataclass# pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    type: int# pragma: no cover"",
            ""    value: str# pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            ""@dataclass# pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    mode: str# pragma: no cover"",
            ""    depth: int# pragma: no cover"",
            ""    inside_brackets: bool# pragma: no cover"",
            ""    leaves: list = field(default_factory=list)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        if len(self.leaves) >= 1:  # this will cause the ValueError to be raised# pragma: no cover"",
            ""            raise ValueError# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append(self, leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): COMMA_PRIORITY}# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        if exclude:# pragma: no cover"",
            ""            raise ValueError  # This will raise the ValueError for the uncovered line# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""line = Line(mode='default', depth=0, inside_brackets=False, leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')]) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""def is_vararg(leaf, within):# pragma: no cover"",
            ""    return leaf.type in within # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover""
        ]
    }
]",3,7175,0.0035875,5061,0.0075915,0.011179
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Split according to delimiters of the highest priority.
    If the appropriate Features are given, the split will add trailing commas
    also in function signatures and calls that contain `*` and `**`.
    """"""
try: # uncovered
    last_leaf = line.leaves[-1] # uncovered
except IndexError: # uncovered
    raise CannotSplit(""Line empty"") from None # uncovered
bt = line.bracket_tracker # uncovered
try: # uncovered
    delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)}) # uncovered
except ValueError: # uncovered
    raise CannotSplit(""No delimiters found"") from None # uncovered
if delimiter_priority == DOT_PRIORITY: # uncovered
    if bt.delimiter_count_with_priority(delimiter_priority) == 1: # uncovered
        raise CannotSplit(""Splitting a single attribute from its owner looks wrong"") # uncovered
current_line = Line( # uncovered
    mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
) # uncovered
lowest_depth = sys.maxsize # uncovered
trailing_comma_safe = True # uncovered
def append_to_line(leaf: Leaf) -> Iterator[Line]: # uncovered
    """"""Append `leaf` to current line or to new line if appending impossible.""""""
    nonlocal current_line # uncovered
    try: # uncovered
        current_line.append_safe(leaf, preformatted=True) # uncovered
    except ValueError: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
        current_line.append(leaf) # uncovered
for leaf in line.leaves: # uncovered
    aux = append_to_line(leaf) # uncovered
    exit(aux) # uncovered
    for comment_after in line.comments_after(leaf): # uncovered
        aux = append_to_line(comment_after) # uncovered
        exit(aux) # uncovered
    lowest_depth = min(lowest_depth, leaf.bracket_depth) # uncovered
    if leaf.bracket_depth == lowest_depth: # uncovered
        if is_vararg(leaf, within={syms.typedargslist}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features # uncovered
            ) # uncovered
        elif is_vararg(leaf, within={syms.arglist, syms.argument}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features # uncovered
            ) # uncovered
    leaf_priority = bt.delimiters.get(id(leaf)) # uncovered
    if leaf_priority == delimiter_priority: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
if current_line: # uncovered
    if ( # uncovered
        trailing_comma_safe # uncovered
        and delimiter_priority == COMMA_PRIORITY # uncovered
        and current_line.leaves[-1].type != token.COMMA # uncovered
        and current_line.leaves[-1].type != STANDALONE_COMMENT # uncovered
    ): # uncovered
        new_comma = Leaf(token.COMMA, "","") # uncovered
        current_line.append(new_comma) # uncovered
    aux = current_line # uncovered
    exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from enum import Enum"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 2:"",
            ""            raise ValueError"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if exclude:"",
            ""            raise ValueError"",
            ""        return DOT_PRIORITY"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""line = Line(mode='default', depth=0, inside_brackets=False, leaves=[Leaf(token.DOT, ','), Leaf(token.NAME, 'attr')])"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.bracket_tracker.delimiters = {id(line.leaves[-1]): DOT_PRIORITY}"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""@dataclass\nclass Leaf:\n    type: int\n    value: str\n    bracket_depth: int = 0"",
            ""@dataclass\nclass Line:\n    mode: str\n    depth: int\n    inside_brackets: bool\n    leaves: list = field(default_factory=list)\n\n    def append_safe(self, leaf, preformatted=False):\n        if len(self.leaves) >= 1:  # condition to hit ValueError\n            raise ValueError\n        self.leaves.append(leaf)\n\n    def append(self, leaf):\n        self.leaves.append(leaf)\n\n    def comments_after(self, leaf):\n        return []"",
            ""class BracketTracker:\n    def __init__(self):\n        self.delimiters = {id(Leaf(token.DOT, '.')): 1}\n    def max_delimiter_priority(self, exclude):\n        if exclude:\n            raise ValueError  # condition to hit ValueError\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1"",
            ""line = Line(mode='default', depth=0, inside_brackets=False, leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ',')])"",
            ""line.bracket_tracker = BracketTracker()"",
            ""def is_vararg(leaf, within):\n    return False"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""COMMA_PRIORITY = 1\nDOT_PRIORITY = 2"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""STANDALONE_COMMENT = 60\nCannotSplit = type('CannotSplit', (Exception,), {})"",
            ""aux = []"",
            ""def exit(line):\n    aux.append(line)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""class Leaf:"",
            ""    def __init__(self, token_type, value, bracket_depth=0):"",
            ""        self.type = token_type"",
            ""        self.value = value"",
            ""        self.bracket_depth = bracket_depth"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if exclude:"",
            ""            raise ValueError"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            ""class Line:"",
            ""    def __init__(self, mode='', depth=0, inside_brackets=False):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = [Leaf(token.NAME, 'a'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'b')]"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 3:"",
            ""            raise ValueError"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            ""line = Line('default', 0, False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 99"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from types import SimpleNamespace"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:"",
            ""            raise ValueError"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        if exclude:"",
            ""            raise ValueError"",
            ""        return COMMA_PRIORITY"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""features = {1, 2}"",
            """",
            ""line = Line("",
            ""    mode='default',"",
            ""    depth=0,"",
            ""    inside_brackets=False,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'a')]"",
            "")"",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 99"",
            ""syms = SimpleNamespace(typedargslist=1, arglist=2, argument=3)"",
            ""def exit(aux): pass""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from enum import Enum"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""@dataclass"",
            ""class Leaf: type: int; value: str; bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str;"",
            ""    depth: int;"",
            ""    inside_brackets: bool;"",
            ""    leaves: list = field(default_factory=list);"",
            """",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if any(l.type == token.DOT for l in self.leaves):"",
            ""            raise ValueError;"",
            ""        self.leaves.append(leaf);"",
            """",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf);"",
            """",
            ""    def comments_after(self, leaf):"",
            ""        return [];"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): COMMA_PRIORITY};"",
            """",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if exclude:"",
            ""            raise ValueError;"",
            ""        return COMMA_PRIORITY;"",
            """",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1;"",
            """",
            ""line = Line("",
            ""    mode='default',"",
            ""    depth=0,"",
            ""    inside_brackets=False,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')]"",
            "")"",
            ""line.bracket_tracker = BracketTracker();"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False;"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL};""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            """",
            ""class Leaf:"",
            ""    def __init__(self, token_type, value, bracket_depth=0):"",
            ""        self.type = token_type"",
            ""        self.value = value"",
            ""        self.bracket_depth = bracket_depth"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude=set()):"",
            ""        if exclude:"",
            ""            raise ValueError"",
            ""        return COMMA_PRIORITY"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""class Line:"",
            ""    def __init__(self, mode='', depth=0, inside_brackets=False):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = [Leaf(token.NAME, 'a'), Leaf(token.DOT, '.'), Leaf(token.NAME, 'b')]"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 2:  # condition to ensure ValueError is raised"",
            ""            raise ValueError"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            ""line = Line('mode', 0, False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""def is_vararg(leaf, within):"",
            ""    return leaf.type in within"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""class Leaf:"",
            ""    def __init__(self, token_type, value, bracket_depth=0):"",
            ""        self.type = token_type"",
            ""        self.value = value"",
            ""        self.bracket_depth = bracket_depth"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.NAME, 'a')): 1}"",
            ""    def max_delimiter_priority(self, exclude=set()):"",
            ""        if exclude:"",
            ""            raise ValueError"",
            ""        return 1"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            ""class Line:"",
            ""    def __init__(self, mode='', depth=0, inside_brackets=False):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = [Leaf(token.NAME, 'a'), Leaf(token.DOT, '.'), Leaf(token.NAME, 'b')]"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:  # this will cause the ValueError to be raised"",
            ""            raise ValueError"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            ""line = Line('default', 0, False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""def is_vararg(leaf, within):"",
            ""    return leaf.type in within"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""class Leaf:"",
            ""    def __init__(self, token_type, value, bracket_depth=0):"",
            ""        self.type = token_type"",
            ""        self.value = value"",
            ""        self.bracket_depth = bracket_depth"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.NAME, 'a')): 1}"",
            ""    def max_delimiter_priority(self, exclude=set()):"",
            ""        if exclude:"",
            ""            raise ValueError"",
            ""        return 1"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            ""class Line:"",
            ""    def __init__(self, mode='', depth=0, inside_brackets=False):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = [Leaf(token.NAME, 'a'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'b')]"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 2:"",
            ""            raise ValueError"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            ""line = Line('mode', 0, False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""def is_vararg(leaf, within):"",
            ""    return leaf.type in within"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 3"",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) > 1:"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if exclude:"",
            ""            raise ValueError('Delimiter conflict.')"",
            ""        return COMMA_PRIORITY"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'b'), Leaf(token.DOT, '.')])"",
            """",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.bracket_tracker.delimiters = {id(leaf): COMMA_PRIORITY for leaf in line.leaves[:2]}"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""def exit(line):"",
            ""    print('Exit called with:', line)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            """",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) > 0:"",
            ""            raise ValueError()  # raises ValueError to hit uncovered path"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            """",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if exclude:"",
            ""            raise ValueError()"",
            ""        return 1"",
            """",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""line = Line(mode='default', depth=0, inside_brackets=False, leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')])"",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""def exit(aux): pass""
        ]
    }
]","[
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 2: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        return DOT_PRIORITY # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line(mode='default', depth=0, inside_brackets=False, leaves=[Leaf(token.DOT, ','), Leaf(token.NAME, 'attr')]) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""@dataclass# pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    type: int# pragma: no cover"",
            ""    value: str# pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            ""@dataclass# pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    mode: str# pragma: no cover"",
            ""    depth: int# pragma: no cover"",
            ""    inside_brackets: bool# pragma: no cover"",
            ""    leaves: list = field(default_factory=list)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        if len(self.leaves) >= 1:  # condition to hit ValueError# pragma: no cover"",
            ""            raise ValueError# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append(self, leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 1}# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        if exclude:# pragma: no cover"",
            ""            raise ValueError  # condition to hit ValueError# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""line = Line(mode='default', depth=0, inside_brackets=False, leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ',')]) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""def is_vararg(leaf, within):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""COMMA_PRIORITY = 1# pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""STANDALONE_COMMENT = 60# pragma: no cover"",
            ""CannotSplit = type('CannotSplit', (Exception,), {}) # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, token_type, value, bracket_depth=0): # pragma: no cover"",
            ""        self.type = token_type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode='', depth=0, inside_brackets=False): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [Leaf(token.NAME, 'a'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'b')] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 3: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""line = Line('default', 0, False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 99 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        return COMMA_PRIORITY # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {1, 2} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='default', # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'a')] # pragma: no cover"",
            "") # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 99 # pragma: no cover"",
            ""syms = SimpleNamespace(typedargslist=1, arglist=2, argument=3) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: type: int; value: str; bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str; # pragma: no cover"",
            ""    depth: int; # pragma: no cover"",
            ""    inside_brackets: bool; # pragma: no cover"",
            ""    leaves: list = field(default_factory=list); # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if any(l.type == token.DOT for l in self.leaves): # pragma: no cover"",
            ""            raise ValueError; # pragma: no cover"",
            ""        self.leaves.append(leaf); # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf); # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return []; # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): COMMA_PRIORITY}; # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError; # pragma: no cover"",
            ""        return COMMA_PRIORITY; # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1; # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='default', # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')] # pragma: no cover"",
            "") # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker(); # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False; # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}; # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, token_type, value, bracket_depth=0): # pragma: no cover"",
            ""        self.type = token_type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        return COMMA_PRIORITY # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode='', depth=0, inside_brackets=False): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [Leaf(token.NAME, 'a'), Leaf(token.DOT, '.'), Leaf(token.NAME, 'b')] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 2:  # condition to ensure ValueError is raised # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""line = Line('mode', 0, False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return leaf.type in within # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, token_type, value, bracket_depth=0): # pragma: no cover"",
            ""        self.type = token_type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.NAME, 'a')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode='', depth=0, inside_brackets=False): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [Leaf(token.NAME, 'a'), Leaf(token.DOT, '.'), Leaf(token.NAME, 'b')] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1:  # this will cause the ValueError to be raised # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""line = Line('default', 0, False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return leaf.type in within # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, token_type, value, bracket_depth=0): # pragma: no cover"",
            ""        self.type = token_type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.NAME, 'a')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode='', depth=0, inside_brackets=False): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [Leaf(token.NAME, 'a'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'b')] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 2: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""line = Line('mode', 0, False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return leaf.type in within # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 3 # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) > 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('Delimiter conflict.') # pragma: no cover"",
            ""        return COMMA_PRIORITY # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'b'), Leaf(token.DOT, '.')]) # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) > 0: # pragma: no cover"",
            ""            raise ValueError()  # raises ValueError to hit uncovered path # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError() # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line(mode='default', depth=0, inside_brackets=False, leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')]) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover""
        ]
    }
]",3,7142,0.003571,5272,0.007908,0.011479
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Split according to delimiters of the highest priority.
    If the appropriate Features are given, the split will add trailing commas
    also in function signatures and calls that contain `*` and `**`.
    """"""
try: # uncovered
    last_leaf = line.leaves[-1] # uncovered
except IndexError: # uncovered
    raise CannotSplit(""Line empty"") from None # uncovered
bt = line.bracket_tracker # uncovered
try: # uncovered
    delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)}) # uncovered
except ValueError: # uncovered
    raise CannotSplit(""No delimiters found"") from None # uncovered
if delimiter_priority == DOT_PRIORITY: # uncovered
    if bt.delimiter_count_with_priority(delimiter_priority) == 1: # uncovered
        raise CannotSplit(""Splitting a single attribute from its owner looks wrong"") # uncovered
current_line = Line( # uncovered
    mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
) # uncovered
lowest_depth = sys.maxsize # uncovered
trailing_comma_safe = True # uncovered
def append_to_line(leaf: Leaf) -> Iterator[Line]: # uncovered
    """"""Append `leaf` to current line or to new line if appending impossible.""""""
    nonlocal current_line # uncovered
    try: # uncovered
        current_line.append_safe(leaf, preformatted=True) # uncovered
    except ValueError: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
        current_line.append(leaf) # uncovered
for leaf in line.leaves: # uncovered
    aux = append_to_line(leaf) # uncovered
    exit(aux) # uncovered
    for comment_after in line.comments_after(leaf): # uncovered
        aux = append_to_line(comment_after) # uncovered
        exit(aux) # uncovered
    lowest_depth = min(lowest_depth, leaf.bracket_depth) # uncovered
    if leaf.bracket_depth == lowest_depth: # uncovered
        if is_vararg(leaf, within={syms.typedargslist}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features # uncovered
            ) # uncovered
        elif is_vararg(leaf, within={syms.arglist, syms.argument}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features # uncovered
            ) # uncovered
    leaf_priority = bt.delimiters.get(id(leaf)) # uncovered
    if leaf_priority == delimiter_priority: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
if current_line: # uncovered
    if ( # uncovered
        trailing_comma_safe # uncovered
        and delimiter_priority == COMMA_PRIORITY # uncovered
        and current_line.leaves[-1].type != token.COMMA # uncovered
        and current_line.leaves[-1].type != STANDALONE_COMMENT # uncovered
    ): # uncovered
        new_comma = Leaf(token.COMMA, "","") # uncovered
        current_line.append(new_comma) # uncovered
    aux = current_line # uncovered
    exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            """",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) > 0:"",
            ""            raise ValueError()  # raises ValueError to hit uncovered path"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            """",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if exclude:"",
            ""            raise ValueError()"",
            ""        return 1"",
            """",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""line = Line(mode='default', depth=0, inside_brackets=False, leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')])"",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""def exit(aux): pass""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from enum import Enum"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            """",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if any(l.type == token.DOT for l in self.leaves):"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if exclude:"",
            ""            raise ValueError('Delimiter conflict.')"",
            ""        return DOT_PRIORITY"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')]"",
            "")"",
            """",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.bracket_tracker.delimiters = {id(leaf): DOT_PRIORITY for leaf in line.leaves}"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(line):"",
            ""    aux.append(line)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            """",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        raise ValueError('Force ValueError for testing')"",
            """",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            """",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        return 1"",
            """",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""line = Line("",
            ""    mode='default',"",
            ""    depth=0,"",
            ""    inside_brackets=False,"",
            ""    leaves=[Leaf(token.NAME, 'a'), Leaf(token.DOT, '.'), Leaf(token.NAME, 'b')]"",
            "")"",
            """",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.bracket_tracker.delimiters = {id(line.leaves[0]): 1}"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from enum import Enum"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) > 0:"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2}"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if exclude:"",
            ""            raise ValueError('Delimiter conflict.')"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""line = Line("",
            ""    mode='default',"",
            ""    depth=0,"",
            ""    inside_brackets=False,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'attr')]"",
            "")"",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(line): aux.append(line)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:"",
            ""            raise ValueError()  # raises ValueError to hit uncovered path"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if exclude:"",
            ""            raise ValueError()  # raises ValueError to hit uncovered path"",
            ""        return COMMA_PRIORITY"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='default',"",
            ""    depth=0,"",
            ""    inside_brackets=False,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')]"",
            "")"",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            """",
            ""class Leaf:"",
            ""    def __init__(self, token_type, value, bracket_depth=0):"",
            ""        self.type = token_type"",
            ""        self.value = value"",
            ""        self.bracket_depth = bracket_depth"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude=set()):"",
            ""        if exclude:"",
            ""            raise ValueError"",
            ""        return 1"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""class Line:"",
            ""    def __init__(self, mode='', depth=0, inside_brackets=False):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = [Leaf(token.NAME, 'a')]"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:  # this will cause the ValueError to be raised"",
            ""            raise ValueError"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""line = Line('default', 0, False)"",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) > 1:"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if exclude:"",
            ""            raise ValueError('Delimiter conflict.')"",
            ""        return COMMA_PRIORITY"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'b')]"",
            "")"",
            """",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.bracket_tracker.delimiters = {id(leaf): DOT_PRIORITY for leaf in line.leaves}"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""def exit(aux): pass""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) > 1:"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): COMMA_PRIORITY}"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if exclude:"",
            ""            raise ValueError('Delimiter conflict.')"",
            ""        return COMMA_PRIORITY"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'a')]"",
            "")"",
            """",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""def exit(aux): pass""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            """",
            ""class Leaf:"",
            ""    def __init__(self, token_type, value, bracket_depth=0):"",
            ""        self.type = token_type"",
            ""        self.value = value"",
            ""        self.bracket_depth = bracket_depth"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, 'attr')): 2}"",
            ""    def max_delimiter_priority(self, exclude=set()):"",
            ""        if exclude:"",
            ""            raise ValueError"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""class Line:"",
            ""    def __init__(self, mode='', depth=0, inside_brackets=False):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = [Leaf(token.NAME, 'a'), Leaf(token.DOT, 'attr')]"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 2:  # ensures ValueError is raised"",
            ""            raise ValueError"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""line = Line('mode', 0, False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""def is_vararg(leaf, within):"",
            ""    return leaf.type in within"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 99"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            """",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:"",
            ""            raise ValueError()  # this will raise ValueError and hit the uncovered path"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            """",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if exclude:"",
            ""            raise ValueError()  # this will raise ValueError and hit the uncovered path"",
            ""        return 1"",
            """",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""line = Line("",
            ""    mode='default',"",
            ""    depth=0,"",
            ""    inside_brackets=False,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')]"",
            "")"",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""def exit(aux): pass""
        ]
    }
]","[
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) > 0: # pragma: no cover"",
            ""            raise ValueError()  # raises ValueError to hit uncovered path # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError() # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line(mode='default', depth=0, inside_brackets=False, leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')]) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if any(l.type == token.DOT for l in self.leaves): # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('Delimiter conflict.') # pragma: no cover"",
            ""        return DOT_PRIORITY # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        raise ValueError('Force ValueError for testing') # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='default', # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    leaves=[Leaf(token.NAME, 'a'), Leaf(token.DOT, '.'), Leaf(token.NAME, 'b')] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.bracket_tracker.delimiters = {id(line.leaves[0]): 1} # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) > 0: # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('Delimiter conflict.') # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='default', # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'attr')] # pragma: no cover"",
            "") # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: # pragma: no cover"",
            ""            raise ValueError()  # raises ValueError to hit uncovered path # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError()  # raises ValueError to hit uncovered path # pragma: no cover"",
            ""        return COMMA_PRIORITY # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='default', # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')] # pragma: no cover"",
            "") # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, token_type, value, bracket_depth=0): # pragma: no cover"",
            ""        self.type = token_type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode='', depth=0, inside_brackets=False): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [Leaf(token.NAME, 'a')] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1:  # this will cause the ValueError to be raised # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line('default', 0, False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) > 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('Delimiter conflict.') # pragma: no cover"",
            ""        return COMMA_PRIORITY # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'b')] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.bracket_tracker.delimiters = {id(leaf): DOT_PRIORITY for leaf in line.leaves} # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) > 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        pass"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('Delimiter conflict.') # pragma: no cover"",
            ""        return COMMA_PRIORITY # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'a')] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, token_type, value, bracket_depth=0): # pragma: no cover"",
            ""        self.type = token_type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, 'attr')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode='', depth=0, inside_brackets=False): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [Leaf(token.NAME, 'a'), Leaf(token.DOT, 'attr')] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 2:  # ensures ValueError is raised # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line('mode', 0, False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return leaf.type in within # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 99 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: # pragma: no cover"",
            ""            raise ValueError()  # this will raise ValueError and hit the uncovered path # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError()  # this will raise ValueError and hit the uncovered path # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='default', # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')] # pragma: no cover"",
            "") # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover""
        ]
    }
]",3,7353,0.0036765,5655,0.0084825,0.012159
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Split according to delimiters of the highest priority.
    If the appropriate Features are given, the split will add trailing commas
    also in function signatures and calls that contain `*` and `**`.
    """"""
try: # uncovered
    last_leaf = line.leaves[-1] # uncovered
except IndexError: # uncovered
    raise CannotSplit(""Line empty"") from None # uncovered
bt = line.bracket_tracker # uncovered
try: # uncovered
    delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)}) # uncovered
except ValueError: # uncovered
    raise CannotSplit(""No delimiters found"") from None # uncovered
if delimiter_priority == DOT_PRIORITY: # uncovered
    if bt.delimiter_count_with_priority(delimiter_priority) == 1: # uncovered
        raise CannotSplit(""Splitting a single attribute from its owner looks wrong"") # uncovered
current_line = Line( # uncovered
    mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
) # uncovered
lowest_depth = sys.maxsize # uncovered
trailing_comma_safe = True # uncovered
def append_to_line(leaf: Leaf) -> Iterator[Line]: # uncovered
    """"""Append `leaf` to current line or to new line if appending impossible.""""""
    nonlocal current_line # uncovered
    try: # uncovered
        current_line.append_safe(leaf, preformatted=True) # uncovered
    except ValueError: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
        current_line.append(leaf) # uncovered
for leaf in line.leaves: # uncovered
    aux = append_to_line(leaf) # uncovered
    exit(aux) # uncovered
    for comment_after in line.comments_after(leaf): # uncovered
        aux = append_to_line(comment_after) # uncovered
        exit(aux) # uncovered
    lowest_depth = min(lowest_depth, leaf.bracket_depth) # uncovered
    if leaf.bracket_depth == lowest_depth: # uncovered
        if is_vararg(leaf, within={syms.typedargslist}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features # uncovered
            ) # uncovered
        elif is_vararg(leaf, within={syms.arglist, syms.argument}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features # uncovered
            ) # uncovered
    leaf_priority = bt.delimiters.get(id(leaf)) # uncovered
    if leaf_priority == delimiter_priority: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
if current_line: # uncovered
    if ( # uncovered
        trailing_comma_safe # uncovered
        and delimiter_priority == COMMA_PRIORITY # uncovered
        and current_line.leaves[-1].type != token.COMMA # uncovered
        and current_line.leaves[-1].type != STANDALONE_COMMENT # uncovered
    ): # uncovered
        new_comma = Leaf(token.COMMA, "","") # uncovered
        current_line.append(new_comma) # uncovered
    aux = current_line # uncovered
    exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from enum import Enum"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) > 1:"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2}"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if exclude:"",
            ""            raise ValueError('Delimiter conflict.')"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'b')]"",
            "")"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.bracket_tracker.delimiters = {id(leaf): 2 for leaf in line.leaves}"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""def exit(aux): pass""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        raise ValueError()  # reliably trigger the uncovered path in append_safe"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2}"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        if exclude:"",
            ""            raise ValueError()  # reliably trigger the uncovered path in max_delimiter_priority"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'a'), Leaf(token.COMMA, ',')]"",
            "")"",
            """",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.bracket_tracker.delimiters = {id(leaf): 2 for leaf in line.leaves}"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(line): aux.append(line)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) > 0:"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2}"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if exclude:"",
            ""            raise ValueError('Delimiter conflict.')"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'a')]"",
            "")"",
            """",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.bracket_tracker.delimiters[id(line.leaves[0])] = 2"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(line): aux.append(line)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            """",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) > 1:  # triggers the ValueError to hit the uncovered path"",
            ""            raise ValueError()"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            """",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if exclude:"",
            ""            raise ValueError('Delimiter conflict.')  # triggers the ValueError to hit the uncovered path"",
            ""        return COMMA_PRIORITY"",
            """",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='default',"",
            ""    depth=0,"",
            ""    inside_brackets=False,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')]"",
            "")"",
            """",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.bracket_tracker.delimiters = {id(line.leaves[0]): 1, id(line.leaves[1]): 1}"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""def exit(item): pass""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        if exclude:"",
            ""            raise ValueError('Delimiter conflict.')"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return len([k for k, v in self.delimiters.items() if v == priority])"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) > 1:"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a'), Leaf(token.DOT, '.')]"",
            "")"",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            """",
            ""class Leaf:"",
            ""    def __init__(self, token_type, value, bracket_depth=0):"",
            ""        self.type = token_type"",
            ""        self.value = value"",
            ""        self.bracket_depth = bracket_depth"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): COMMA_PRIORITY, id(Leaf(token.COMMA, ',')): COMMA_PRIORITY}"",
            ""    def max_delimiter_priority(self, exclude=set()):"",
            ""        if exclude:"",
            ""            raise ValueError"",
            ""        return 1"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""class Line:"",
            ""    def __init__(self, mode='', depth=0, inside_brackets=False):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = [Leaf(token.NAME, 'a'), Leaf(token.COMMA, ','), Leaf(token.DOT, 'attr')]"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 2:"",
            ""            raise ValueError"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""line = Line('mode', 0, False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""def is_vararg(leaf, within):"",
            ""    return leaf.type in within"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 99"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) > 0:  # Simulate a situation where append_safe raises ValueError"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if exclude:"",
            ""            raise ValueError('Delimiter conflict.')"",
            ""        return COMMA_PRIORITY"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='default',"",
            ""    depth=0,"",
            ""    inside_brackets=False,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')]"",
            "")"",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            """",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:  # this will raise ValueError and hit the uncovered path"",
            ""            raise ValueError()"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            """",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if exclude:"",
            ""            raise ValueError()  # raise ValueError to explore uncovered path"",
            ""        return 1"",
            """",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""line = Line("",
            ""    mode='default',"",
            ""    depth=0,"",
            ""    inside_brackets=False,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')]"",
            "")"",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            """",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) > 1:"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2}"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if exclude:"",
            ""            raise ValueError('Delimiter conflict.')"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='default',"",
            ""    depth=0,"",
            ""    inside_brackets=False,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'attr')]"",
            "")"",
            """",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            """",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:"",
            ""            raise ValueError()  # Raise ValueError to execute the exception path"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            """",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        if exclude:"",
            ""            raise ValueError()  # Raise ValueError to execute the exception path"",
            ""        return 1"",
            """",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='test_mode',"",
            ""    depth=0,"",
            ""    inside_brackets=False,"",
            ""    leaves=[Leaf(token.NAME, 'a'), Leaf(token.DOT, '.'), Leaf(token.NAME, 'b')]"",
            "")"",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    }
]","[
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) > 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('Delimiter conflict.') # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'b')] # pragma: no cover"",
            "") # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.bracket_tracker.delimiters = {id(leaf): 2 for leaf in line.leaves} # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        raise ValueError()  # reliably trigger the uncovered path in append_safe # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError()  # reliably trigger the uncovered path in max_delimiter_priority # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'a'), Leaf(token.COMMA, ',')] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.bracket_tracker.delimiters = {id(leaf): 2 for leaf in line.leaves} # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) > 0: # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('Delimiter conflict.') # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'a')] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.bracket_tracker.delimiters[id(line.leaves[0])] = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) > 1:  # triggers the ValueError to hit the uncovered path # pragma: no cover"",
            ""            raise ValueError() # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('Delimiter conflict.')  # triggers the ValueError to hit the uncovered path # pragma: no cover"",
            ""        return COMMA_PRIORITY # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='default', # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.bracket_tracker.delimiters = {id(line.leaves[0]): 1, id(line.leaves[1]): 1} # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('Delimiter conflict.') # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return len([k for k, v in self.delimiters.items() if v == priority]) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) > 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a'), Leaf(token.DOT, '.')] # pragma: no cover"",
            "") # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, token_type, value, bracket_depth=0): # pragma: no cover"",
            ""        self.type = token_type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        pass"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode='', depth=0, inside_brackets=False): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [Leaf(token.NAME, 'a'), Leaf(token.COMMA, ','), Leaf(token.DOT, 'attr')] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 2: # pragma: no cover"",
            ""            raise ValueError # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line('mode', 0, False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return leaf.type in within # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 99 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) > 0:  # Simulate a situation where append_safe raises ValueError # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('Delimiter conflict.') # pragma: no cover"",
            ""        return COMMA_PRIORITY # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='default', # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')] # pragma: no cover"",
            "") # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1:  # this will raise ValueError and hit the uncovered path # pragma: no cover"",
            ""            raise ValueError() # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError()  # raise ValueError to explore uncovered path # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='default', # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')] # pragma: no cover"",
            "") # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) > 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('Delimiter conflict.') # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='default', # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'attr')] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: # pragma: no cover"",
            ""            raise ValueError()  # Raise ValueError to execute the exception path # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError()  # Raise ValueError to execute the exception path # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='test_mode', # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    leaves=[Leaf(token.NAME, 'a'), Leaf(token.DOT, '.'), Leaf(token.NAME, 'b')] # pragma: no cover"",
            "") # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    }
]",3,7736,0.003868,5891,0.0088365,0.0127045
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Split according to delimiters of the highest priority.
    If the appropriate Features are given, the split will add trailing commas
    also in function signatures and calls that contain `*` and `**`.
    """"""
try: # uncovered
    last_leaf = line.leaves[-1] # uncovered
except IndexError: # uncovered
    raise CannotSplit(""Line empty"") from None # uncovered
bt = line.bracket_tracker # uncovered
try: # uncovered
    delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)}) # uncovered
except ValueError: # uncovered
    raise CannotSplit(""No delimiters found"") from None # uncovered
if delimiter_priority == DOT_PRIORITY: # uncovered
    if bt.delimiter_count_with_priority(delimiter_priority) == 1: # uncovered
        raise CannotSplit(""Splitting a single attribute from its owner looks wrong"") # uncovered
current_line = Line( # uncovered
    mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
) # uncovered
lowest_depth = sys.maxsize # uncovered
trailing_comma_safe = True # uncovered
def append_to_line(leaf: Leaf) -> Iterator[Line]: # uncovered
    """"""Append `leaf` to current line or to new line if appending impossible.""""""
    nonlocal current_line # uncovered
    try: # uncovered
        current_line.append_safe(leaf, preformatted=True) # uncovered
    except ValueError: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
        current_line.append(leaf) # uncovered
for leaf in line.leaves: # uncovered
    aux = append_to_line(leaf) # uncovered
    exit(aux) # uncovered
    for comment_after in line.comments_after(leaf): # uncovered
        aux = append_to_line(comment_after) # uncovered
        exit(aux) # uncovered
    lowest_depth = min(lowest_depth, leaf.bracket_depth) # uncovered
    if leaf.bracket_depth == lowest_depth: # uncovered
        if is_vararg(leaf, within={syms.typedargslist}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features # uncovered
            ) # uncovered
        elif is_vararg(leaf, within={syms.arglist, syms.argument}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features # uncovered
            ) # uncovered
    leaf_priority = bt.delimiters.get(id(leaf)) # uncovered
    if leaf_priority == delimiter_priority: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
if current_line: # uncovered
    if ( # uncovered
        trailing_comma_safe # uncovered
        and delimiter_priority == COMMA_PRIORITY # uncovered
        and current_line.leaves[-1].type != token.COMMA # uncovered
        and current_line.leaves[-1].type != STANDALONE_COMMENT # uncovered
    ): # uncovered
        new_comma = Leaf(token.COMMA, "","") # uncovered
        current_line.append(new_comma) # uncovered
    aux = current_line # uncovered
    exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) > 1:"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2}"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if exclude:"",
            ""            raise ValueError('Delimiter conflict.')"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'a'), Leaf(token.COMMA, ',')]"",
            "")"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.bracket_tracker.delimiters = {id(leaf): 2 for leaf in line.leaves}"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            """",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) > 1:"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1, id(Leaf(token.NAME, 'a')): 1}"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        if exclude:"",
            ""            raise ValueError('Delimiter conflict.')"",
            ""        return max(self.delimiters.values())"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return list(self.delimiters.values()).count(priority)"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'a'), Leaf(token.COMMA, ',')]"",
            "")"",
            """",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:  # Raise ValueError to hit uncovered path"",
            ""            raise ValueError()"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if exclude:"",
            ""            raise ValueError()  # Raise ValueError to hit uncovered path"",
            ""        return 1"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""line = Line("",
            ""    mode='default',"",
            ""    depth=0,"",
            ""    inside_brackets=False,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')]"",
            "")"",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) > 0:  # Trigger ValueError to explore uncovered path"",
            ""            raise ValueError()"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 1}"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if exclude:"",
            ""            raise ValueError('No delimiters found')  # Trigger ValueError to explore uncovered path"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'a')]"",
            "")"",
            """",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.bracket_tracker.delimiters[id(line.leaves[0])] = 1"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 2:  # Ensures that the uncovered path in append_safe is executed"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2}"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if exclude:"",
            ""            raise ValueError('Delimiter conflict.')  # Ensures the ValueError is raised for max_delimiter_priority"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')]"",
            "")"",
            """",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) > 1:  # Simulate a condition to throw ValueError"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2}"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if exclude:"",
            ""            raise ValueError('Delimiter conflict.')"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')]"",
            "")"",
            """",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.bracket_tracker.delimiters = {id(leaf): 2 for leaf in line.leaves}"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""def exit(item):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) > 1:  # Raise ValueError to execute the exception path"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude=set()):"",
            ""        if exclude:"",
            ""            raise ValueError('Delimiter conflict.')"",
            ""        return COMMA_PRIORITY"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')]"",
            "")"",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""def exit(aux): pass""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if any(exclude):"",
            ""            raise ValueError('Delimiter conflict.')"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a'), Leaf(token.COMMA, ',')]"",
            "")"",
            """",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:  # reliably trigger the uncovered path in append_safe"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2}"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if exclude:"",
            ""            raise ValueError()  # reliably trigger the uncovered path in max_delimiter_priority"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'b')]"",
            "")"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.bracket_tracker.delimiters = {id(leaf): 2 for leaf in line.leaves}"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(line): aux.append(line)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            """",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:"",
            ""            raise ValueError()  # Raise ValueError to execute the exception path"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            """",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        if exclude:"",
            ""            raise ValueError()  # Raise ValueError to execute the exception path"",
            ""        return 1"",
            """",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='test_mode',"",
            ""    depth=0,"",
            ""    inside_brackets=False,"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a'), Leaf(token.DOT, '.')]"",
            "")"",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    }
]","[
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) > 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('Delimiter conflict.') # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'a'), Leaf(token.COMMA, ',')] # pragma: no cover"",
            "") # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.bracket_tracker.delimiters = {id(leaf): 2 for leaf in line.leaves} # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) > 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1, id(Leaf(token.NAME, 'a')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('Delimiter conflict.') # pragma: no cover"",
            ""        return max(self.delimiters.values()) # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return list(self.delimiters.values()).count(priority) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'a'), Leaf(token.COMMA, ',')] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1:  # Raise ValueError to hit uncovered path # pragma: no cover"",
            ""            raise ValueError() # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError()  # Raise ValueError to hit uncovered path # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='default', # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')] # pragma: no cover"",
            "") # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) > 0:  # Trigger ValueError to explore uncovered path # pragma: no cover"",
            ""            raise ValueError() # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('No delimiters found')  # Trigger ValueError to explore uncovered path # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'a')] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.bracket_tracker.delimiters[id(line.leaves[0])] = 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 2:  # Ensures that the uncovered path in append_safe is executed # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('Delimiter conflict.')  # Ensures the ValueError is raised for max_delimiter_priority # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) > 1:  # Simulate a condition to throw ValueError # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('Delimiter conflict.') # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.bracket_tracker.delimiters = {id(leaf): 2 for leaf in line.leaves} # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) > 1:  # Raise ValueError to execute the exception path # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('Delimiter conflict.') # pragma: no cover"",
            ""        return COMMA_PRIORITY # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')] # pragma: no cover"",
            "") # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if any(exclude): # pragma: no cover"",
            ""            raise ValueError('Delimiter conflict.') # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a'), Leaf(token.COMMA, ',')] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1:  # reliably trigger the uncovered path in append_safe # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError()  # reliably trigger the uncovered path in max_delimiter_priority # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'b')] # pragma: no cover"",
            "") # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.bracket_tracker.delimiters = {id(leaf): 2 for leaf in line.leaves} # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: # pragma: no cover"",
            ""            raise ValueError()  # Raise ValueError to execute the exception path # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError()  # Raise ValueError to execute the exception path # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='test_mode', # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a'), Leaf(token.DOT, '.')] # pragma: no cover"",
            "") # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    }
]",3,7972,0.003986,5988,0.008982,0.012968
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Split according to delimiters of the highest priority.
    If the appropriate Features are given, the split will add trailing commas
    also in function signatures and calls that contain `*` and `**`.
    """"""
try: # uncovered
    last_leaf = line.leaves[-1] # uncovered
except IndexError: # uncovered
    raise CannotSplit(""Line empty"") from None # uncovered
bt = line.bracket_tracker # uncovered
try: # uncovered
    delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)}) # uncovered
except ValueError: # uncovered
    raise CannotSplit(""No delimiters found"") from None # uncovered
if delimiter_priority == DOT_PRIORITY: # uncovered
    if bt.delimiter_count_with_priority(delimiter_priority) == 1: # uncovered
        raise CannotSplit(""Splitting a single attribute from its owner looks wrong"") # uncovered
current_line = Line( # uncovered
    mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
) # uncovered
lowest_depth = sys.maxsize # uncovered
trailing_comma_safe = True # uncovered
def append_to_line(leaf: Leaf) -> Iterator[Line]: # uncovered
    """"""Append `leaf` to current line or to new line if appending impossible.""""""
    nonlocal current_line # uncovered
    try: # uncovered
        current_line.append_safe(leaf, preformatted=True) # uncovered
    except ValueError: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
        current_line.append(leaf) # uncovered
for leaf in line.leaves: # uncovered
    aux = append_to_line(leaf) # uncovered
    exit(aux) # uncovered
    for comment_after in line.comments_after(leaf): # uncovered
        aux = append_to_line(comment_after) # uncovered
        exit(aux) # uncovered
    lowest_depth = min(lowest_depth, leaf.bracket_depth) # uncovered
    if leaf.bracket_depth == lowest_depth: # uncovered
        if is_vararg(leaf, within={syms.typedargslist}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features # uncovered
            ) # uncovered
        elif is_vararg(leaf, within={syms.arglist, syms.argument}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features # uncovered
            ) # uncovered
    leaf_priority = bt.delimiters.get(id(leaf)) # uncovered
    if leaf_priority == delimiter_priority: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
if current_line: # uncovered
    if ( # uncovered
        trailing_comma_safe # uncovered
        and delimiter_priority == COMMA_PRIORITY # uncovered
        and current_line.leaves[-1].type != token.COMMA # uncovered
        and current_line.leaves[-1].type != STANDALONE_COMMENT # uncovered
    ): # uncovered
        new_comma = Leaf(token.COMMA, "","") # uncovered
        current_line.append(new_comma) # uncovered
    aux = current_line # uncovered
    exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:  # Simulates a condition that raises ValueError"",
            ""            raise ValueError('Cannot append safely')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude=set()):"",
            ""        if exclude:"",
            ""            raise ValueError('Max delimiter priority conflict')"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return list(self.delimiters.values()).count(priority)"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'a'), Leaf(token.COMMA, ',')]"",
            "")"",
            """",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""def exit(aux):"",
            ""    pass""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) > 0:"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2}"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        if exclude and exclude != {id(Leaf(token.DOT, '.'))}:"",
            ""            raise ValueError('Delimiter conflict.')"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'a')]"",
            "")"",
            """",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets, leaves):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = leaves"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.NAME, 'a')): 1}"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        if exclude:"",
            ""            raise ValueError('Delimiter conflict.')"",
            ""        return 1"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='test_mode',"",
            ""    depth=0,"",
            ""    inside_brackets=False,"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a'), Leaf(token.NAME, 'b')]"",
            "")"",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:"",
            ""            raise ValueError()  # Raise ValueError to execute the exception path"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if exclude:"",
            ""            raise ValueError('No delimiters found')"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='test_mode',"",
            ""    depth=0,"",
            ""    inside_brackets=False,"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a'), Leaf(token.DOT, '.')]"",
            "")"",
            """",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1, id(Leaf(token.DOT, '.')): 2}"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        if exclude is not None and len(exclude) > 0:"",
            ""            raise ValueError('No delimiters found')  # Trigger ValueError to execute exception path"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return sum(1 for p in self.delimiters.values() if p == priority)"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='test_mode',"",
            ""    depth=0,"",
            ""    inside_brackets=False,"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a'), Leaf(token.DOT, '.')]"",
            "")"",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) > 1:  # Trigger ValueError to explore uncovered path"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2}"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        if exclude:"",
            ""            raise ValueError('Delimiter conflict.')"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'a')]"",
            "")"",
            """",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.bracket_tracker.delimiters = {id(leaf): 2 for leaf in line.leaves}"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(line): aux.append(line)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 2:  # Raise ValueError to execute uncovered path"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1, id(Leaf(token.DOT, '.')): 2}"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if exclude:"",
            ""            raise ValueError()  # Raise ValueError to execute uncovered path"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'b')]"",
            "")"",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2}"",
            ""    def max_delimiter_priority(self, exclude=set()):"",
            ""        if exclude:"",
            ""            raise ValueError('No delimiters found')"",
            ""        return 1"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=False,"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')]"",
            "")"",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(item): aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        if exclude:"",
            ""            raise ValueError('Delimiter conflict.')"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a'), Leaf(token.DOT, '.')]"",
            "")"",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature:"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            """",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:"",
            ""            raise ValueError()  # Raise ValueError to execute the exception path"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            """",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            """",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        if exclude:"",
            ""            raise ValueError()  # Raise ValueError to execute the exception path"",
            ""        return 1"",
            """",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='test_mode',"",
            ""    depth=0,"",
            ""    inside_brackets=False,"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a'), Leaf(token.DOT, '.')]"",
            "")"",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    }
]","[
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1:  # Simulates a condition that raises ValueError # pragma: no cover"",
            ""            raise ValueError('Cannot append safely') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('Max delimiter priority conflict') # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return list(self.delimiters.values()).count(priority) # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'a'), Leaf(token.COMMA, ',')] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""    pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) > 0: # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        if exclude and exclude != {id(Leaf(token.DOT, '.'))}: # pragma: no cover"",
            ""            raise ValueError('Delimiter conflict.') # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'a')] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets, leaves): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = leaves # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.NAME, 'a')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('Delimiter conflict.') # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='test_mode', # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a'), Leaf(token.NAME, 'b')] # pragma: no cover"",
            "") # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: # pragma: no cover"",
            ""            raise ValueError()  # Raise ValueError to execute the exception path # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('No delimiters found') # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='test_mode', # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a'), Leaf(token.DOT, '.')] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1, id(Leaf(token.DOT, '.')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        if exclude is not None and len(exclude) > 0: # pragma: no cover"",
            ""            raise ValueError('No delimiters found')  # Trigger ValueError to execute exception path # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return sum(1 for p in self.delimiters.values() if p == priority) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='test_mode', # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a'), Leaf(token.DOT, '.')] # pragma: no cover"",
            "") # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) > 1:  # Trigger ValueError to explore uncovered path # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('Delimiter conflict.') # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'a')] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.bracket_tracker.delimiters = {id(leaf): 2 for leaf in line.leaves} # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 2:  # Raise ValueError to execute uncovered path # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1, id(Leaf(token.DOT, '.')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError()  # Raise ValueError to execute uncovered path # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'b')] # pragma: no cover"",
            "") # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('No delimiters found') # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')] # pragma: no cover"",
            "") # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('Delimiter conflict.') # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a'), Leaf(token.DOT, '.')] # pragma: no cover"",
            "") # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: # pragma: no cover"",
            ""            raise ValueError()  # Raise ValueError to execute the exception path # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError()  # Raise ValueError to execute the exception path # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='test_mode', # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a'), Leaf(token.DOT, '.')] # pragma: no cover"",
            "") # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    }
]",3,8069,0.0040345,5925,0.0088875,0.012922
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Split according to delimiters of the highest priority.
    If the appropriate Features are given, the split will add trailing commas
    also in function signatures and calls that contain `*` and `**`.
    """"""
try: # uncovered
    last_leaf = line.leaves[-1] # uncovered
except IndexError: # uncovered
    raise CannotSplit(""Line empty"") from None # uncovered
bt = line.bracket_tracker # uncovered
try: # uncovered
    delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)}) # uncovered
except ValueError: # uncovered
    raise CannotSplit(""No delimiters found"") from None # uncovered
if delimiter_priority == DOT_PRIORITY: # uncovered
    if bt.delimiter_count_with_priority(delimiter_priority) == 1: # uncovered
        raise CannotSplit(""Splitting a single attribute from its owner looks wrong"") # uncovered
current_line = Line( # uncovered
    mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
) # uncovered
lowest_depth = sys.maxsize # uncovered
trailing_comma_safe = True # uncovered
def append_to_line(leaf: Leaf) -> Iterator[Line]: # uncovered
    """"""Append `leaf` to current line or to new line if appending impossible.""""""
    nonlocal current_line # uncovered
    try: # uncovered
        current_line.append_safe(leaf, preformatted=True) # uncovered
    except ValueError: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
        current_line.append(leaf) # uncovered
for leaf in line.leaves: # uncovered
    aux = append_to_line(leaf) # uncovered
    exit(aux) # uncovered
    for comment_after in line.comments_after(leaf): # uncovered
        aux = append_to_line(comment_after) # uncovered
        exit(aux) # uncovered
    lowest_depth = min(lowest_depth, leaf.bracket_depth) # uncovered
    if leaf.bracket_depth == lowest_depth: # uncovered
        if is_vararg(leaf, within={syms.typedargslist}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features # uncovered
            ) # uncovered
        elif is_vararg(leaf, within={syms.arglist, syms.argument}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features # uncovered
            ) # uncovered
    leaf_priority = bt.delimiters.get(id(leaf)) # uncovered
    if leaf_priority == delimiter_priority: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
if current_line: # uncovered
    if ( # uncovered
        trailing_comma_safe # uncovered
        and delimiter_priority == COMMA_PRIORITY # uncovered
        and current_line.leaves[-1].type != token.COMMA # uncovered
        and current_line.leaves[-1].type != STANDALONE_COMMENT # uncovered
    ): # uncovered
        new_comma = Leaf(token.COMMA, "","") # uncovered
        current_line.append(new_comma) # uncovered
    aux = current_line # uncovered
    exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1, id(Leaf(token.DOT, '.')): 2}"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if exclude:"",
            ""            raise ValueError('No delimiters found')"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')]"",
            "")"",
            """",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:"",
            ""            raise ValueError('Cannot append safely')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude=set()):"",
            ""        if exclude:"",
            ""            raise ValueError('No delimiters found')"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return list(self.delimiters.values()).count(priority)"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'a')]"",
            "")"",
            """",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:"",
            ""            raise ValueError('Cannot append safely')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude=set()):"",
            ""        if exclude:"",
            ""            raise ValueError('No delimiters found')"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'a'), Leaf(token.COMMA, ',')]"",
            "")"",
            """",
            ""line.bracket_tracker = BracketTracker()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) > 1:"",
            ""            raise ValueError('Cannot append safe.')  # Raise ValueError here"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude=set()):"",
            ""        if exclude:"",
            ""            raise ValueError('No delimiters found')  # Raise ValueError here"",
            ""        return 1"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False, leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')])"",
            """",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2}"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        if exclude:"",
            ""            raise ValueError('Delimiter conflict.')"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return leaf.value == '*' or leaf.value == '**'"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'a'), Leaf(token.COMMA, ','), Leaf(token.NAME, '*args'), Leaf(token.NAME, '**kwargs')]"",
            "")"",
            """",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        if exclude is not None and len(exclude) > 0:"",
            ""            raise ValueError('Delimiter conflict.')"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return sum(1 for p in self.delimiters.values() if p == priority)"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'a'), Leaf(token.COMMA, ',')]"",
            "")"",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1, id(Leaf(token.DOT, '.')): 2}"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        if exclude:"",
            ""            return 1"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='test_mode',"",
            ""    depth=0,"",
            ""    inside_brackets=False,"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a'), Leaf(token.DOT, '.')]"",
            "")"",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude=set()):"",
            ""        if exclude:"",
            ""            raise ValueError('No delimiters found')"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')]"",
            "")"",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:"",
            ""            raise ValueError('Cannot append safely')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude=set()):"",
            ""        if exclude:"",
            ""            raise ValueError('Max delimiter priority conflict')"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return list(self.delimiters.values()).count(priority)"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.DOT, '.')]"",
            "")"",
            """",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1, id(Leaf(token.DOT, '.')): 2}"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        if exclude:"",
            ""            raise ValueError('No delimiters found')  # Raise ValueError to execute uncovered path"",
            ""        return 1"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=False,"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a'), Leaf(token.DOT, '.')]"",
            "")"",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(item): aux.append(item)""
        ]
    }
]","[
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1, id(Leaf(token.DOT, '.')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('No delimiters found') # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safely') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('No delimiters found') # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return list(self.delimiters.values()).count(priority) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'a')] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safely') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('No delimiters found') # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'a'), Leaf(token.COMMA, ',')] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) > 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.')  # Raise ValueError here # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('No delimiters found')  # Raise ValueError here # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False, leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')]) # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('Delimiter conflict.') # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return leaf.value == '*' or leaf.value == '**' # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'a'), Leaf(token.COMMA, ','), Leaf(token.NAME, '*args'), Leaf(token.NAME, '**kwargs')] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        if exclude is not None and len(exclude) > 0: # pragma: no cover"",
            ""            raise ValueError('Delimiter conflict.') # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return sum(1 for p in self.delimiters.values() if p == priority) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'a'), Leaf(token.COMMA, ',')] # pragma: no cover"",
            "") # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1, id(Leaf(token.DOT, '.')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            return 1 # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='test_mode', # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a'), Leaf(token.DOT, '.')] # pragma: no cover"",
            "") # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('No delimiters found') # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')] # pragma: no cover"",
            "") # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safely') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('Max delimiter priority conflict') # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return list(self.delimiters.values()).count(priority) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.DOT, '.')] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1, id(Leaf(token.DOT, '.')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('No delimiters found')  # Raise ValueError to execute uncovered path # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a'), Leaf(token.DOT, '.')] # pragma: no cover"",
            "") # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    }
]",3,8006,0.004003,5899,0.0088485,0.0128515
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Split according to delimiters of the highest priority.
    If the appropriate Features are given, the split will add trailing commas
    also in function signatures and calls that contain `*` and `**`.
    """"""
try: # uncovered
    last_leaf = line.leaves[-1] # uncovered
except IndexError: # uncovered
    raise CannotSplit(""Line empty"") from None # uncovered
bt = line.bracket_tracker # uncovered
try: # uncovered
    delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)}) # uncovered
except ValueError: # uncovered
    raise CannotSplit(""No delimiters found"") from None # uncovered
if delimiter_priority == DOT_PRIORITY: # uncovered
    if bt.delimiter_count_with_priority(delimiter_priority) == 1: # uncovered
        raise CannotSplit(""Splitting a single attribute from its owner looks wrong"") # uncovered
current_line = Line( # uncovered
    mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
) # uncovered
lowest_depth = sys.maxsize # uncovered
trailing_comma_safe = True # uncovered
def append_to_line(leaf: Leaf) -> Iterator[Line]: # uncovered
    """"""Append `leaf` to current line or to new line if appending impossible.""""""
    nonlocal current_line # uncovered
    try: # uncovered
        current_line.append_safe(leaf, preformatted=True) # uncovered
    except ValueError: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
        current_line.append(leaf) # uncovered
for leaf in line.leaves: # uncovered
    aux = append_to_line(leaf) # uncovered
    exit(aux) # uncovered
    for comment_after in line.comments_after(leaf): # uncovered
        aux = append_to_line(comment_after) # uncovered
        exit(aux) # uncovered
    lowest_depth = min(lowest_depth, leaf.bracket_depth) # uncovered
    if leaf.bracket_depth == lowest_depth: # uncovered
        if is_vararg(leaf, within={syms.typedargslist}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features # uncovered
            ) # uncovered
        elif is_vararg(leaf, within={syms.arglist, syms.argument}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features # uncovered
            ) # uncovered
    leaf_priority = bt.delimiters.get(id(leaf)) # uncovered
    if leaf_priority == delimiter_priority: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
if current_line: # uncovered
    if ( # uncovered
        trailing_comma_safe # uncovered
        and delimiter_priority == COMMA_PRIORITY # uncovered
        and current_line.leaves[-1].type != token.COMMA # uncovered
        and current_line.leaves[-1].type != STANDALONE_COMMENT # uncovered
    ): # uncovered
        new_comma = Leaf(token.COMMA, "","") # uncovered
        current_line.append(new_comma) # uncovered
    aux = current_line # uncovered
    exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1, id(Leaf(token.DOT, '.')): 2}"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        if exclude:"",
            ""            return 1"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=False,"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a'), Leaf(token.DOT, '.')]"",
            "")"",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(item): aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) > 1:"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1, id(Leaf(token.DOT, '.')): 2}"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        if exclude and any(id(leaf) in exclude for leaf in self.delimiters):"",
            ""            raise ValueError('No delimiters found')"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return sum(1 for p in self.delimiters.values() if p == priority)"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'a'), Leaf(token.COMMA, ',')]"",
            "")"",
            """",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        if exclude is not None:"",
            ""            raise ValueError('Delimiter conflict.')"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return sum(1 for p in self.delimiters.values() if p == priority)"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')]"",
            "")"",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        if exclude:"",
            ""            return 1"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='test_mode',"",
            ""    depth=0,"",
            ""    inside_brackets=False,"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a'), Leaf(token.DOT, '.')]"",
            "")"",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        if exclude == {id(Leaf(token.DOT, '.'))}:"",
            ""            raise ValueError('No delimiters found')"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return leaf.value in {'*', '**'}"",
            """",
            ""line = Line("",
            ""    mode='test_mode',"",
            ""    depth=0,"",
            ""    inside_brackets=False,"",
            ""    leaves=[Leaf(token.NAME, '*'), Leaf(token.COMMA, ','), Leaf(token.DOT, '.')]"",
            "")"",
            """",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) > 1:"",
            ""            raise ValueError('Cannot append safely')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude=()):"",
            ""        if exclude:"",
            ""            raise ValueError('No delimiters found')"",
            ""        return 1"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return list(self.delimiters.values()).count(priority)"",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[]"",
            "")"",
            """",
            ""line.bracket_tracker = BracketTracker()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if not preformatted and len(self.leaves) > 0:"",
            ""            raise ValueError('Cannot append safely.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        if exclude and any(id(leaf) in exclude for leaf in [Leaf(token.DOT, '.'), Leaf(token.COMMA, ',')]):"",
            ""            raise ValueError('Delimiter conflict.')"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return list(self.delimiters.values()).count(priority)"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return leaf.value in {'*', '**'}"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.NAME, 'a'), Leaf(token.NAME, '*args'), Leaf(token.NAME, '**kwargs')]"",
            "")"",
            """",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:"",
            ""            raise ValueError('Cannot append safe.')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1, id(Leaf(token.DOT, '.')): 2}"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        if exclude == {id(Leaf(token.DOT, '.'))}:"",
            ""            raise ValueError('No delimiters found')"",
            ""        return 1"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=True,"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.DOT, '.'), Leaf(token.NAME, 'a')]"",
            "")"",
            """",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:"",
            ""            raise ValueError('Cannot append safely')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude=set()):"",
            ""        if exclude:"",
            ""            raise ValueError('No delimiters found')  # Raise ValueError here"",
            ""        return 1"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return list(self.delimiters.values()).count(priority)"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='test_mode',"",
            ""    depth=0,"",
            ""    inside_brackets=False,"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.DOT, '.')]"",
            "")"",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    },
    {
        ""imports"": [
            ""import sys"",
            ""import token"",
            ""from typing import Iterator"",
            ""from dataclasses import dataclass, field"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            """",
            ""class Feature(Enum):"",
            ""    TRAILING_COMMA_IN_DEF = 1"",
            ""    TRAILING_COMMA_IN_CALL = 2"",
            """",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            """",
            ""@dataclass"",
            ""class Leaf:"",
            ""    type: int"",
            ""    value: str"",
            ""    bracket_depth: int = 0"",
            """",
            ""@dataclass"",
            ""class Line:"",
            ""    mode: str"",
            ""    depth: int"",
            ""    inside_brackets: bool"",
            ""    leaves: list = field(default_factory=list)"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        if len(self.leaves) >= 1:"",
            ""            raise ValueError('Cannot append safe')"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1, id(Leaf(token.DOT, '.')): 2}"",
            ""    def max_delimiter_priority(self, exclude=None):"",
            ""        if exclude and len(exclude) > 0:"",
            ""            raise ValueError('No delimiters found')"",
            ""# Raise ValueError to execute uncovered path"",
            ""        return 2"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            """",
            ""def is_vararg(leaf, within):"",
            ""    return False"",
            """",
            ""line = Line("",
            ""    mode='code_mode',"",
            ""    depth=1,"",
            ""    inside_brackets=False,"",
            ""    leaves=[Leaf(token.NAME, 'a')]"",
            "")"",
            """",
            ""line.bracket_tracker = BracketTracker()"",
            """",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            """",
            ""COMMA_PRIORITY = 1"",
            ""DOT_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 60"",
            """",
            ""aux = []"",
            ""def exit(item):"",
            ""    aux.append(item)""
        ]
    }
]","[
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1, id(Leaf(token.DOT, '.')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            return 1 # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a'), Leaf(token.DOT, '.')] # pragma: no cover"",
            "") # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) > 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1, id(Leaf(token.DOT, '.')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        if exclude and any(id(leaf) in exclude for leaf in self.delimiters): # pragma: no cover"",
            ""            raise ValueError('No delimiters found') # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return sum(1 for p in self.delimiters.values() if p == priority) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.DOT, '.'), Leaf(token.NAME, 'a'), Leaf(token.COMMA, ',')] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        if exclude is not None: # pragma: no cover"",
            ""            raise ValueError('Delimiter conflict.') # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return sum(1 for p in self.delimiters.values() if p == priority) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a')] # pragma: no cover"",
            "") # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            return 1 # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='test_mode', # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.NAME, 'a'), Leaf(token.DOT, '.')] # pragma: no cover"",
            "") # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        if exclude == {id(Leaf(token.DOT, '.'))}: # pragma: no cover"",
            ""            raise ValueError('No delimiters found') # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return leaf.value in {'*', '**'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='test_mode', # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    leaves=[Leaf(token.NAME, '*'), Leaf(token.COMMA, ','), Leaf(token.DOT, '.')] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) > 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safely') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=()): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('No delimiters found') # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return list(self.delimiters.values()).count(priority) # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if not preformatted and len(self.leaves) > 0: # pragma: no cover"",
            ""            raise ValueError('Cannot append safely.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        if exclude and any(id(leaf) in exclude for leaf in [Leaf(token.DOT, '.'), Leaf(token.COMMA, ',')]): # pragma: no cover"",
            ""            raise ValueError('Delimiter conflict.') # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return list(self.delimiters.values()).count(priority) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return leaf.value in {'*', '**'} # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.NAME, 'a'), Leaf(token.NAME, '*args'), Leaf(token.NAME, '**kwargs')] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safe.') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1, id(Leaf(token.DOT, '.')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        if exclude == {id(Leaf(token.DOT, '.'))}: # pragma: no cover"",
            ""            raise ValueError('No delimiters found') # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=True, # pragma: no cover"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.DOT, '.'), Leaf(token.NAME, 'a')] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safely') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.DOT, '.')): 2, id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        if exclude: # pragma: no cover"",
            ""            raise ValueError('No delimiters found')  # Raise ValueError here # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return list(self.delimiters.values()).count(priority) # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='test_mode', # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    leaves=[Leaf(token.COMMA, ','), Leaf(token.DOT, '.')] # pragma: no cover"",
            "") # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature(Enum): # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    type: int # pragma: no cover"",
            ""    value: str # pragma: no cover"",
            ""    bracket_depth: int = 0 # pragma: no cover"",
            "" # pragma: no cover"",
            ""@dataclass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    mode: str # pragma: no cover"",
            ""    depth: int # pragma: no cover"",
            ""    inside_brackets: bool # pragma: no cover"",
            ""    leaves: list = field(default_factory=list) # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: # pragma: no cover"",
            ""            raise ValueError('Cannot append safe') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            "" # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1, id(Leaf(token.DOT, '.')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=None): # pragma: no cover"",
            ""        if exclude and len(exclude) > 0: # pragma: no cover"",
            ""            raise ValueError('No delimiters found') # pragma: no cover"",
            ""# Raise ValueError to execute uncovered path # pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            "" # pragma: no cover"",
            ""line = Line( # pragma: no cover"",
            ""    mode='code_mode', # pragma: no cover"",
            ""    depth=1, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    leaves=[Leaf(token.NAME, 'a')] # pragma: no cover"",
            "") # pragma: no cover"",
            "" # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            "" # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            "" # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 60 # pragma: no cover"",
            "" # pragma: no cover"",
            ""aux = [] # pragma: no cover""
        ]
    }
]",3,7980,0.00399,6014,0.009021,0.013010999999999998
