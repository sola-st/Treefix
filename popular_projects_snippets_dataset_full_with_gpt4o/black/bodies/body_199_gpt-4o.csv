prompt,raw_predictions,predictions,prompt_type,input_size,input_price,output_size,output_price,total_price
"Provide self-contained and concrete Python values to initialize the undefined variables in the code snippet.

# begin code snippet
""""""Return a set of (relatively) new Python features used in this file.

    Currently looking for:
    - f-strings;
    - self-documenting expressions in f-strings (f""{x=}"");
    - underscores in numeric literals;
    - trailing commas after * or ** in function signatures and calls;
    - positional only arguments in function signatures and lambdas;
    - assignment expression;
    - relaxed decorator syntax;
    - usage of __future__ flags (annotations);
    - print / exec statements;
    - parenthesized context managers;
    - match statements;
    - except* clause;
    - variadic generics;
    """"""
features: Set[Feature] = set()
if future_imports:
    features |= {
        FUTURE_FLAG_TO_FEATURE[future_import]
        for future_import in future_imports
        if future_import in FUTURE_FLAG_TO_FEATURE
    }

for n in node.pre_order():
    if is_string_token(n):
        value_head = n.value[:2]
        if value_head in {'f""', 'F""', ""f'"", ""F'"", ""rf"", ""fr"", ""RF"", ""FR""}:
            features.add(Feature.F_STRINGS)
            if Feature.DEBUG_F_STRINGS not in features:
                for span_beg, span_end in iter_fexpr_spans(n.value):
                    if n.value[span_beg : span_end - 1].rstrip().endswith(""=""):
                        features.add(Feature.DEBUG_F_STRINGS)
                        break

    elif is_number_token(n):
        if ""_"" in n.value:
            features.add(Feature.NUMERIC_UNDERSCORES)

    elif n.type == token.SLASH:
        if n.parent and n.parent.type in {
            syms.typedargslist,
            syms.arglist,
            syms.varargslist,
        }:
            features.add(Feature.POS_ONLY_ARGUMENTS)

    elif n.type == token.COLONEQUAL:
        features.add(Feature.ASSIGNMENT_EXPRESSIONS)

    elif n.type == syms.decorator:
        if len(n.children) > 1 and not is_simple_decorator_expression(
            n.children[1]
        ):
            features.add(Feature.RELAXED_DECORATORS)

    elif (
        n.type in {syms.typedargslist, syms.arglist}
        and n.children
        and n.children[-1].type == token.COMMA
    ):
        if n.type == syms.typedargslist:
            feature = Feature.TRAILING_COMMA_IN_DEF
        else:
            feature = Feature.TRAILING_COMMA_IN_CALL

        for ch in n.children:
            if ch.type in STARS:
                features.add(feature)

            if ch.type == syms.argument:
                for argch in ch.children:
                    if argch.type in STARS:
                        features.add(feature)

    elif (
        n.type in {syms.return_stmt, syms.yield_expr}
        and len(n.children) >= 2
        and n.children[1].type == syms.testlist_star_expr
        and any(child.type == syms.star_expr for child in n.children[1].children)
    ):
        features.add(Feature.UNPACKING_ON_FLOW)

    elif (
        n.type == syms.annassign
        and len(n.children) >= 4
        and n.children[3].type == syms.testlist_star_expr
    ):
        features.add(Feature.ANN_ASSIGN_EXTENDED_RHS)

    elif (
        n.type == syms.with_stmt
        and len(n.children) > 2
        and n.children[1].type == syms.atom
    ):
        atom_children = n.children[1].children
        if (
            len(atom_children) == 3
            and atom_children[0].type == token.LPAR
            and atom_children[1].type == syms.testlist_gexp
            and atom_children[2].type == token.RPAR
        ):
            features.add(Feature.PARENTHESIZED_CONTEXT_MANAGERS)

    elif n.type == syms.match_stmt:
        features.add(Feature.PATTERN_MATCHING)

    elif (
        n.type == syms.except_clause
        and len(n.children) >= 2
        and n.children[1].type == token.STAR
    ):
        features.add(Feature.EXCEPT_STAR)

    elif n.type in {syms.subscriptlist, syms.trailer} and any(
        child.type == syms.star_expr for child in n.children
    ):
        features.add(Feature.VARIADIC_GENERICS)

    elif (
        n.type == syms.tname_star
        and len(n.children) == 3
        and n.children[2].type == syms.star_expr
    ):
        features.add(Feature.VARIADIC_GENERICS)

exit(features)

# end code snippet

# begin undefined variables
Set
Feature
future_imports
node
is_string_token
iter_fexpr_spans
is_number_token
token
syms
is_simple_decorator_expression
STARS
FUTURE_FLAG_TO_FEATURE
# end undefined variables

# begin undefined attributes and methods
node.pre_order
Feature.F_STRINGS
Feature.DEBUG_F_STRINGS
Feature.NUMERIC_UNDERSCORES
token.SLASH
syms.typedargslist
syms.arglist
syms.varargslist
Feature.POS_ONLY_ARGUMENTS
token.COLONEQUAL
Feature.ASSIGNMENT_EXPRESSIONS
syms.decorator
Feature.RELAXED_DECORATORS
token.COMMA
Feature.TRAILING_COMMA_IN_DEF
Feature.TRAILING_COMMA_IN_CALL
syms.argument
syms.return_stmt
syms.yield_expr
syms.testlist_star_expr
syms.star_expr
Feature.UNPACKING_ON_FLOW
syms.annassign
Feature.ANN_ASSIGN_EXTENDED_RHS
syms.with_stmt
syms.atom
token.LPAR
syms.testlist_gexp
token.RPAR
Feature.PARENTHESIZED_CONTEXT_MANAGERS
syms.match_stmt
Feature.PATTERN_MATCHING
syms.except_clause
token.STAR
Feature.EXCEPT_STAR
syms.subscriptlist
syms.trailer
Feature.VARIADIC_GENERICS
syms.tname_star
# end undefined attributes and methods

Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set, Dict, Any"",
            ""from enum import Enum"",
            ""import token"",
            ""import ast"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""node = type( 'MockNode', (object,), { 'pre_order': lambda self: [self], 'value': '', 'type': None, 'parent': None, 'children': [], } )()"",
            ""is_string_token = lambda n: isinstance(n, str)"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))]"",
            ""is_number_token = lambda n: isinstance(n, (int, float)) or (isinstance(n, str) and n.replace('_', '').isdigit())"",
            ""syms = type('MockSyms', (object,), { 'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'decorator': 4, 'argument': 5, 'return_stmt': 6, 'yield_expr': 7, 'testlist_star_expr': 8, 'star_expr': 9, 'annassign': 10, 'with_stmt': 11, 'atom': 12, 'testlist_gexp': 13, 'match_stmt': 14, 'except_clause': 15, 'subscriptlist': 16, 'trailer': 17, 'tname_star': 18})"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from collections import namedtuple"",
            ""import token"",
            ""import symtable as syms""
        ],
        ""initialization"": [
            ""Feature = namedtuple('Feature', ['F_STRINGS', 'DEBUG_F_STRINGS', 'NUMERIC_UNDERSCORES', 'POS_ONLY_ARGUMENTS', 'ASSIGNMENT_EXPRESSIONS', 'RELAXED_DECORATORS', 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL', 'UNPACKING_ON_FLOW', 'ANN_ASSIGN_EXTENDED_RHS', 'PARENTHESIZED_CONTEXT_MANAGERS', 'PATTERN_MATCHING', 'EXCEPT_STAR', 'VARIADIC_GENERICS'])(*range(14))"",
            ""future_imports = {'annotations'}"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [], 'type': None, 'value': '', 'children': [], 'parent': None})()"",
            ""is_string_token = lambda n: isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))]"",
            ""is_number_token = lambda n: n.value.isdigit()"",
            ""is_simple_decorator_expression = lambda n: False"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.PATTERN_MATCHING}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import symtable as syms""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'f-strings'"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings'"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals'"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions'"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax'"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls'"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers'"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement'"",
            ""    EXCEPT_STAR = 'except* clause'"",
            ""    VARIADIC_GENERICS = 'variadic generics'"",
            """",
            ""future_imports = ['annotations']"",
            ""node = type('Mock', (object,), {"",
            ""    'pre_order': lambda self: [],"",
            ""    'value': '',"",
            ""    'type': None,"",
            ""    'parent': None,"",
            ""    'children': []"",
            ""})()"",
            ""def is_string_token(n):"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):"",
            ""    return [(0, len(value))]"",
            ""def is_number_token(n):"",
            ""    return hasattr(n, 'value') and any(ch.isdigit() for ch in n.value)"",
            ""def is_simple_decorator_expression(n):"",
            ""    return isinstance(n, type('Mock', (object,), {}))"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS,"",
            ""}"",
            ""def set_syms_attribute(name):"",
            ""    setattr(syms, name, type('Mock', (object,), {}))"",
            ""for attribute in ['typedargslist', 'arglist', 'varargslist', 'decorator', 'argument', 'return_stmt', 'yield_expr', 'testlist_star_expr', 'star_expr', 'annassign', 'with_stmt', 'atom', 'testlist_gexp', 'match_stmt', 'except_clause', 'subscriptlist', 'trailer', 'tname_star']:"",
            ""    set_syms_attribute(attribute)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""from types import SimpleNamespace"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""future_imports = set()"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [], 'type': None, 'children': [], 'parent': None})()"",
            ""is_string_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: iter([])"",
            ""is_number_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str) and n.value.isdigit()"",
            ""syms = type('Mock', (object,), {"",
            ""    'typedargslist': auto(),"",
            ""    'arglist': auto(),"",
            ""    'varargslist': auto(),"",
            ""    'decorator': auto(),"",
            ""    'argument': auto(),"",
            ""    'return_stmt': auto(),"",
            ""    'yield_expr': auto(),"",
            ""    'testlist_star_expr': auto(),"",
            ""    'star_expr': auto(),"",
            ""    'annassign': auto(),"",
            ""    'with_stmt': auto(),"",
            ""    'atom': auto(),"",
            ""    'testlist_gexp': auto(),"",
            ""    'match_stmt': auto(),"",
            ""    'except_clause': auto(),"",
            ""    'subscriptlist': auto(),"",
            ""    'trailer': auto(),"",
            ""    'tname_star': auto()"",
            ""})"",
            ""is_simple_decorator_expression = lambda expr: True"",
            ""STARS = set([token.STAR, token.DOUBLESTAR])"",
            ""FUTURE_FLAG_TO_FEATURE = {}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""Feature = type('Feature', (), {"",
            ""    'F_STRINGS': 'F_STRINGS',"",
            ""    'DEBUG_F_STRINGS': 'DEBUG_F_STRINGS',"",
            ""    'NUMERIC_UNDERSCORES': 'NUMERIC_UNDERSCORES',"",
            ""    'POS_ONLY_ARGUMENTS': 'POS_ONLY_ARGUMENTS',"",
            ""    'ASSIGNMENT_EXPRESSIONS': 'ASSIGNMENT_EXPRESSIONS',"",
            ""    'RELAXED_DECORATORS': 'RELAXED_DECORATORS',"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF',"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL',"",
            ""    'UNPACKING_ON_FLOW': 'UNPACKING_ON_FLOW',"",
            ""    'ANN_ASSIGN_EXTENDED_RHS': 'ANN_ASSIGN_EXTENDED_RHS',"",
            ""    'PARENTHESIZED_CONTEXT_MANAGERS': 'PARENTHESIZED_CONTEXT_MANAGERS',"",
            ""    'PATTERN_MATCHING': 'PATTERN_MATCHING',"",
            ""    'EXCEPT_STAR': 'EXCEPT_STAR',"",
            ""    'VARIADIC_GENERICS': 'VARIADIC_GENERICS'"",
            ""})"",
            ""future_imports = {'annotations'}"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None)"",
            ""is_string_token = lambda n: isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(m.start(), m.end()) for m in re.finditer(r'{.*?}', s)]"",
            ""is_number_token = lambda n: n.value.replace('_', '').isdigit()"",
            ""token = type('token', (), {'SLASH': 'SLASH', 'COLONEQUAL': 'COLONEQUAL', 'COMMA': 'COMMA', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'STAR': 'STAR'})"",
            ""syms = type('syms', (), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'varargslist': 'varargslist',"",
            ""    'decorator': 'decorator',"",
            ""    'argument': 'argument',"",
            ""    'return_stmt': 'return_stmt',"",
            ""    'yield_expr': 'yield_expr',"",
            ""    'testlist_star_expr': 'testlist_star_expr',"",
            ""    'star_expr': 'star_expr',"",
            ""    'annassign': 'annassign',"",
            ""    'with_stmt': 'with_stmt',"",
            ""    'atom': 'atom',"",
            ""    'testlist_gexp': 'testlist_gexp',"",
            ""    'match_stmt': 'match_stmt',"",
            ""    'except_clause': 'except_clause',"",
            ""    'subscriptlist': 'subscriptlist',"",
            ""    'trailer': 'trailer',"",
            ""    'tname_star': 'tname_star'"",
            ""})"",
            ""is_simple_decorator_expression = lambda n: False"",
            ""STARS = {'STAR'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import enum"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""Feature = enum.Enum('Feature', 'F_STRINGS DEBUG_F_STRINGS NUMERIC_UNDERSCORES POS_ONLY_ARGUMENTS ASSIGNMENT_EXPRESSIONS RELAXED_DECORATORS TRAILING_COMMA_IN_DEF TRAILING_COMMA_IN_CALL UNPACKING_ON_FLOW ANN_ASSIGN_EXTENDED_RHS PARENTHESIZED_CONTEXT_MANAGERS PATTERN_MATCHING EXCEPT_STAR VARIADIC_GENERICS')"",
            ""future_imports = set(['annotations'])"",
            ""node = SimpleNamespace(pre_order=lambda: [])"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""token = SimpleNamespace(SLASH='/', COLONEQUAL=':=', COMMA=',', LPAR='(', RPAR=')', STAR='*')"",
            ""syms = SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', decorator='decorator', argument='argument', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', annassign='annassign', with_stmt='with_stmt', atom='atom', testlist_gexp='testlist_gexp', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star')"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {'*', '**'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from collections import namedtuple"",
            ""import token"",
            ""import ast"",
            ""syms = namedtuple('syms', 'typedargslist arglist varargslist decorator argument return_stmt yield_expr testlist_star_expr star_expr annassign with_stmt atom testlist_gexp match_stmt except_clause subscriptlist trailer tname_star')(*range(16))""
        ],
        ""initialization"": [
            ""Feature = namedtuple('Feature', 'F_STRINGS DEBUG_F_STRINGS NUMERIC_UNDERSCORES POS_ONLY_ARGUMENTS ASSIGNMENT_EXPRESSIONS RELAXED_DECORATORS TRAILING_COMMA_IN_DEF TRAILING_COMMA_IN_CALL UNPACKING_ON_FLOW ANN_ASSIGN_EXTENDED_RHS PARENTHESIZED_CONTEXT_MANAGERS PATTERN_MATCHING EXCEPT_STAR VARIADIC_GENERICS')(*range(14))"",
            ""future_imports = ['annotations']"",
            ""node = type('MockNode', (object,), {'pre_order': lambda: [], 'type': None, 'parent': None, 'value': '', 'children': []})()"",
            ""is_string_token = lambda x: isinstance(x.value, str)"",
            ""iter_fexpr_spans = lambda x: [(0, len(x))]"",
            ""is_number_token = lambda x: x.value.isdigit()"",
            ""is_simple_decorator_expression = lambda x: isinstance(x, str)"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.POS_ONLY_ARGUMENTS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token"",
            ""import ast as syms""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}"",
            ""class MockNode:\n    def pre_order(self):\n        return []\nnode = MockNode()"",
            ""def is_string_token(n):\n    return False"",
            ""def iter_fexpr_spans(value):\n    return []"",
            ""def is_number_token(n):\n    return False"",
            ""def is_simple_decorator_expression(n):\n    return False"",
            ""STARS = {token.STAR, token.DOUBLESTAR}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import symbol as syms"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: []})()"",
            ""is_string_token = lambda x: False"",
            ""iter_fexpr_spans = lambda x: iter([])"",
            ""is_number_token = lambda x: False"",
            ""is_simple_decorator_expression = lambda x: False"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.PARENTHESIZED_CONTEXT_MANAGERS}"",
            ""STARS = {token.STAR}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from unittest.mock import Mock""
        ],
        ""initialization"": [
            ""Feature = Mock()"",
            ""future_imports = set()"",
            ""node = Mock()"",
            ""node.pre_order = Mock(return_value=[])"",
            ""is_string_token = Mock(return_value=False)"",
            ""iter_fexpr_spans = Mock(return_value=[])"",
            ""is_number_token = Mock(return_value=False)"",
            ""token = Mock()"",
            ""token.SLASH = '/'"",
            ""token.COLONEQUAL = ':='"",
            ""token.COMMA = ','"",
            ""token.LPAR = '('"",
            ""token.RPAR = ')'"",
            ""token.STAR = '*'"",
            ""syms = Mock()"",
            ""syms.typedargslist = Mock()"",
            ""syms.arglist = Mock()"",
            ""syms.varargslist = Mock()"",
            ""syms.decorator = Mock()"",
            ""syms.argument = Mock()"",
            ""syms.return_stmt = Mock()"",
            ""syms.yield_expr = Mock()"",
            ""syms.testlist_star_expr = Mock()"",
            ""syms.star_expr = Mock()"",
            ""syms.annassign = Mock()"",
            ""syms.with_stmt = Mock()"",
            ""syms.atom = Mock()"",
            ""syms.testlist_gexp = Mock()"",
            ""syms.match_stmt = Mock()"",
            ""syms.except_clause = Mock()"",
            ""syms.subscriptlist = Mock()"",
            ""syms.trailer = Mock()"",
            ""syms.tname_star = Mock()"",
            ""is_simple_decorator_expression = Mock(return_value=True)"",
            ""STARS = set()"",
            ""FUTURE_FLAG_TO_FEATURE = {}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set, Dict, Any # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""node = type( 'MockNode', (object,), { 'pre_order': lambda self: [self], 'value': '', 'type': None, 'parent': None, 'children': [], } )() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float)) or (isinstance(n, str) and n.replace('_', '').isdigit()) # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { 'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'decorator': 4, 'argument': 5, 'return_stmt': 6, 'yield_expr': 7, 'testlist_star_expr': 8, 'star_expr': 9, 'annassign': 10, 'with_stmt': 11, 'atom': 12, 'testlist_gexp': 13, 'match_stmt': 14, 'except_clause': 15, 'subscriptlist': 16, 'trailer': 17, 'tname_star': 18}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import symtable as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = namedtuple('Feature', ['F_STRINGS', 'DEBUG_F_STRINGS', 'NUMERIC_UNDERSCORES', 'POS_ONLY_ARGUMENTS', 'ASSIGNMENT_EXPRESSIONS', 'RELAXED_DECORATORS', 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL', 'UNPACKING_ON_FLOW', 'ANN_ASSIGN_EXTENDED_RHS', 'PARENTHESIZED_CONTEXT_MANAGERS', 'PATTERN_MATCHING', 'EXCEPT_STAR', 'VARIADIC_GENERICS'])(*range(14)) # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [], 'type': None, 'value': '', 'children': [], 'parent': None})() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] # pragma: no cover"",
            ""is_number_token = lambda n: n.value.isdigit() # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: False # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.PATTERN_MATCHING} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import symtable as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'f-strings' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement' # pragma: no cover"",
            ""    EXCEPT_STAR = 'except* clause' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic generics' # pragma: no cover"",
            "" # pragma: no cover"",
            ""node = type('Mock', (object,), { # pragma: no cover"",
            ""    'pre_order': lambda self: [], # pragma: no cover"",
            ""    'value': '', # pragma: no cover"",
            ""    'type': None, # pragma: no cover"",
            ""    'parent': None, # pragma: no cover"",
            ""    'children': [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and any(ch.isdigit() for ch in n.value) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return isinstance(n, type('Mock', (object,), {})) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS, # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def set_syms_attribute(name): # pragma: no cover"",
            ""    setattr(syms, name, type('Mock', (object,), {})) # pragma: no cover"",
            ""for attribute in ['typedargslist', 'arglist', 'varargslist', 'decorator', 'argument', 'return_stmt', 'yield_expr', 'testlist_star_expr', 'star_expr', 'annassign', 'with_stmt', 'atom', 'testlist_gexp', 'match_stmt', 'except_clause', 'subscriptlist', 'trailer', 'tname_star']: # pragma: no cover"",
            ""    set_syms_attribute(attribute) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [], 'type': None, 'children': [], 'parent': None})() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: iter([]) # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str) and n.value.isdigit() # pragma: no cover"",
            ""syms = type('Mock', (object,), { # pragma: no cover"",
            ""    'typedargslist': auto(), # pragma: no cover"",
            ""    'arglist': auto(), # pragma: no cover"",
            ""    'varargslist': auto(), # pragma: no cover"",
            ""    'decorator': auto(), # pragma: no cover"",
            ""    'argument': auto(), # pragma: no cover"",
            ""    'return_stmt': auto(), # pragma: no cover"",
            ""    'yield_expr': auto(), # pragma: no cover"",
            ""    'testlist_star_expr': auto(), # pragma: no cover"",
            ""    'star_expr': auto(), # pragma: no cover"",
            ""    'annassign': auto(), # pragma: no cover"",
            ""    'with_stmt': auto(), # pragma: no cover"",
            ""    'atom': auto(), # pragma: no cover"",
            ""    'testlist_gexp': auto(), # pragma: no cover"",
            ""    'match_stmt': auto(), # pragma: no cover"",
            ""    'except_clause': auto(), # pragma: no cover"",
            ""    'subscriptlist': auto(), # pragma: no cover"",
            ""    'trailer': auto(), # pragma: no cover"",
            ""    'tname_star': auto() # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda expr: True # pragma: no cover"",
            ""STARS = set([token.STAR, token.DOUBLESTAR]) # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = type('Feature', (), { # pragma: no cover"",
            ""    'F_STRINGS': 'F_STRINGS', # pragma: no cover"",
            ""    'DEBUG_F_STRINGS': 'DEBUG_F_STRINGS', # pragma: no cover"",
            ""    'NUMERIC_UNDERSCORES': 'NUMERIC_UNDERSCORES', # pragma: no cover"",
            ""    'POS_ONLY_ARGUMENTS': 'POS_ONLY_ARGUMENTS', # pragma: no cover"",
            ""    'ASSIGNMENT_EXPRESSIONS': 'ASSIGNMENT_EXPRESSIONS', # pragma: no cover"",
            ""    'RELAXED_DECORATORS': 'RELAXED_DECORATORS', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL', # pragma: no cover"",
            ""    'UNPACKING_ON_FLOW': 'UNPACKING_ON_FLOW', # pragma: no cover"",
            ""    'ANN_ASSIGN_EXTENDED_RHS': 'ANN_ASSIGN_EXTENDED_RHS', # pragma: no cover"",
            ""    'PARENTHESIZED_CONTEXT_MANAGERS': 'PARENTHESIZED_CONTEXT_MANAGERS', # pragma: no cover"",
            ""    'PATTERN_MATCHING': 'PATTERN_MATCHING', # pragma: no cover"",
            ""    'EXCEPT_STAR': 'EXCEPT_STAR', # pragma: no cover"",
            ""    'VARIADIC_GENERICS': 'VARIADIC_GENERICS' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None) # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(m.start(), m.end()) for m in re.finditer(r'{.*?}', s)] # pragma: no cover"",
            ""is_number_token = lambda n: n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""token = type('token', (), {'SLASH': 'SLASH', 'COLONEQUAL': 'COLONEQUAL', 'COMMA': 'COMMA', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'STAR': 'STAR'}) # pragma: no cover"",
            ""syms = type('syms', (), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'varargslist': 'varargslist', # pragma: no cover"",
            ""    'decorator': 'decorator', # pragma: no cover"",
            ""    'argument': 'argument', # pragma: no cover"",
            ""    'return_stmt': 'return_stmt', # pragma: no cover"",
            ""    'yield_expr': 'yield_expr', # pragma: no cover"",
            ""    'testlist_star_expr': 'testlist_star_expr', # pragma: no cover"",
            ""    'star_expr': 'star_expr', # pragma: no cover"",
            ""    'annassign': 'annassign', # pragma: no cover"",
            ""    'with_stmt': 'with_stmt', # pragma: no cover"",
            ""    'atom': 'atom', # pragma: no cover"",
            ""    'testlist_gexp': 'testlist_gexp', # pragma: no cover"",
            ""    'match_stmt': 'match_stmt', # pragma: no cover"",
            ""    'except_clause': 'except_clause', # pragma: no cover"",
            ""    'subscriptlist': 'subscriptlist', # pragma: no cover"",
            ""    'trailer': 'trailer', # pragma: no cover"",
            ""    'tname_star': 'tname_star' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: False # pragma: no cover"",
            ""STARS = {'STAR'} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import enum # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = enum.Enum('Feature', 'F_STRINGS DEBUG_F_STRINGS NUMERIC_UNDERSCORES POS_ONLY_ARGUMENTS ASSIGNMENT_EXPRESSIONS RELAXED_DECORATORS TRAILING_COMMA_IN_DEF TRAILING_COMMA_IN_CALL UNPACKING_ON_FLOW ANN_ASSIGN_EXTENDED_RHS PARENTHESIZED_CONTEXT_MANAGERS PATTERN_MATCHING EXCEPT_STAR VARIADIC_GENERICS') # pragma: no cover"",
            ""node = SimpleNamespace(pre_order=lambda: []) # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""token = SimpleNamespace(SLASH='/', COLONEQUAL=':=', COMMA=',', LPAR='(', RPAR=')', STAR='*') # pragma: no cover"",
            ""syms = SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', decorator='decorator', argument='argument', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', annassign='annassign', with_stmt='with_stmt', atom='atom', testlist_gexp='testlist_gexp', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star') # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {'*', '**'} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = namedtuple('Feature', 'F_STRINGS DEBUG_F_STRINGS NUMERIC_UNDERSCORES POS_ONLY_ARGUMENTS ASSIGNMENT_EXPRESSIONS RELAXED_DECORATORS TRAILING_COMMA_IN_DEF TRAILING_COMMA_IN_CALL UNPACKING_ON_FLOW ANN_ASSIGN_EXTENDED_RHS PARENTHESIZED_CONTEXT_MANAGERS PATTERN_MATCHING EXCEPT_STAR VARIADIC_GENERICS')(*range(14)) # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda: [], 'type': None, 'parent': None, 'value': '', 'children': []})() # pragma: no cover"",
            ""is_string_token = lambda x: isinstance(x.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda x: [(0, len(x))] # pragma: no cover"",
            ""is_number_token = lambda x: x.value.isdigit() # pragma: no cover"",
            ""is_simple_decorator_expression = lambda x: isinstance(x, str) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.POS_ONLY_ARGUMENTS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""def is_simple_decorator_expression(n):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import symbol as syms # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: []})() # pragma: no cover"",
            ""is_string_token = lambda x: False # pragma: no cover"",
            ""iter_fexpr_spans = lambda x: iter([]) # pragma: no cover"",
            ""is_number_token = lambda x: False # pragma: no cover"",
            ""is_simple_decorator_expression = lambda x: False # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.PARENTHESIZED_CONTEXT_MANAGERS} # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = Mock() # pragma: no cover"",
            ""node = Mock() # pragma: no cover"",
            ""node.pre_order = Mock(return_value=[]) # pragma: no cover"",
            ""is_string_token = Mock(return_value=False) # pragma: no cover"",
            ""iter_fexpr_spans = Mock(return_value=[]) # pragma: no cover"",
            ""is_number_token = Mock(return_value=False) # pragma: no cover"",
            ""token = Mock() # pragma: no cover"",
            ""token.SLASH = '/' # pragma: no cover"",
            ""token.COLONEQUAL = ':=' # pragma: no cover"",
            ""token.COMMA = ',' # pragma: no cover"",
            ""token.LPAR = '(' # pragma: no cover"",
            ""token.RPAR = ')' # pragma: no cover"",
            ""token.STAR = '*' # pragma: no cover"",
            ""syms = Mock() # pragma: no cover"",
            ""syms.typedargslist = Mock() # pragma: no cover"",
            ""syms.arglist = Mock() # pragma: no cover"",
            ""syms.varargslist = Mock() # pragma: no cover"",
            ""syms.decorator = Mock() # pragma: no cover"",
            ""syms.argument = Mock() # pragma: no cover"",
            ""syms.return_stmt = Mock() # pragma: no cover"",
            ""syms.yield_expr = Mock() # pragma: no cover"",
            ""syms.testlist_star_expr = Mock() # pragma: no cover"",
            ""syms.star_expr = Mock() # pragma: no cover"",
            ""syms.annassign = Mock() # pragma: no cover"",
            ""syms.with_stmt = Mock() # pragma: no cover"",
            ""syms.atom = Mock() # pragma: no cover"",
            ""syms.testlist_gexp = Mock() # pragma: no cover"",
            ""syms.match_stmt = Mock() # pragma: no cover"",
            ""syms.except_clause = Mock() # pragma: no cover"",
            ""syms.subscriptlist = Mock() # pragma: no cover"",
            ""syms.trailer = Mock() # pragma: no cover"",
            ""syms.tname_star = Mock() # pragma: no cover"",
            ""is_simple_decorator_expression = Mock(return_value=True) # pragma: no cover"",
            ""STARS = set() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover""
        ]
    }
]",1,1572,0.000786,4626,0.006939,0.007725
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 50:
    if future_imports:
NameError: name 'future_imports' is not defined
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""node = type('MockNode', (object,), {\n  'pre_order': lambda self: [self],\n  'value': 'f\""example\""',\n  'type': token.STRING,\n  'parent': None,\n  'children': []\n})()"",
            ""is_string_token = lambda n: isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] if '=' in s else []"",
            ""is_number_token = lambda n: isinstance(n.value, str) and n.value.replace('_', '').isdigit()"",
            ""syms = type('MockSyms', (object,), {\n  'typedargslist': 1,\n  'arglist': 2,\n  'varargslist': 3,\n  'decorator': 4,\n  'argument': 5,\n  'return_stmt': 6,\n  'yield_expr': 7,\n  'testlist_star_expr': 8,\n  'star_expr': 9,\n  'annassign': 10,\n  'with_stmt': 11,\n  'atom': 12,\n  'testlist_gexp': 13,\n  'match_stmt': 14,\n  'except_clause': 15,\n  'subscriptlist': 16,\n  'trailer': 17,\n  'tname_star': 18\n})"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any"",
            ""from enum import Enum"",
            ""import token"",
            ""import ast"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""node = type( 'MockNode', (object,), { 'pre_order': lambda self: [self], 'value': 'f\""example={42}\""', 'type': None, 'parent': None, 'children': [], } )()"",
            ""is_string_token = lambda n: isinstance(n, type(node)) and hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))]"",
            ""is_number_token = lambda n: isinstance(n, type(node)) and hasattr(n, 'value') and (isinstance(n.value, (int, float)) or (isinstance(n.value, str) and n.value.replace('_', '').isdigit()))"",
            ""syms = type('MockSyms', (object,), { 'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'decorator': 4, 'argument': 5, 'return_stmt': 6, 'yield_expr': 7, 'testlist_star_expr': 8, 'star_expr': 9, 'annassign': 10, 'with_stmt': 11, 'atom': 12, 'testlist_gexp': 13, 'match_stmt': 14, 'except_clause': 15, 'subscriptlist': 16, 'trailer': 17, 'tname_star': 18})"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""node = type( 'MockNode', (object,), { 'pre_order': lambda self: [self], 'value': '', 'type': None, 'parent': None, 'children': [], } )()"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and (isinstance(n.value, (int, float)) or (isinstance(n.value, str) and n.value.replace('_', '').isdigit()))"",
            ""syms = type('MockSyms', (object,), { 'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'decorator': 4, 'argument': 5, 'return_stmt': 6, 'yield_expr': 7, 'testlist_star_expr': 8, 'star_expr': 9, 'annassign': 10, 'with_stmt': 11, 'atom': 12, 'testlist_gexp': 13, 'match_stmt': 14, 'except_clause': 15, 'subscriptlist': 16, 'trailer': 17, 'tname_star': 18 })"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [self], 'value': '', 'type': None, 'parent': None, 'children': []})()"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.replace('_', '').isdigit()"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'decorator': 4, 'argument': 5, 'return_stmt': 6, 'yield_expr': 7, 'testlist_star_expr': 8, 'star_expr': 9, 'annassign': 10, 'with_stmt': 11, 'atom': 12, 'testlist_gexp': 13, 'match_stmt': 14, 'except_clause': 15, 'subscriptlist': 16, 'trailer': 17, 'tname_star': 18})"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any"",
            ""from enum import Enum"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""node = type( 'MockNode', (object,), { 'pre_order': lambda self: [self], 'value': '', 'type': None, 'parent': None, 'children': [], } )()"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit()"",
            ""syms = type('MockSyms', (object,), { 'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'decorator': 4, 'argument': 5, 'return_stmt': 6, 'yield_expr': 7, 'testlist_star_expr': 8, 'star_expr': 9, 'annassign': 10, 'with_stmt': 11, 'atom': 12, 'testlist_gexp': 13, 'match_stmt': 14, 'except_clause': 15, 'subscriptlist': 16, 'trailer': 17, 'tname_star': 18 })"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, List"",
            ""from enum import Enum"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:\n    def __init__(self, value='', type=None, parent=None, children=None):\n        self.value = value\n        self.type = type\n        self.parent = parent\n        self.children = children if children is not None else []\n    def pre_order(self):\n        return [self]"",
            ""node = MockNode()"",
            ""is_string_token = lambda n: isinstance(n, MockNode) and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))]  # Dummy implementation"",
            ""is_number_token = lambda n: isinstance(n, MockNode) and (isinstance(n.value, (int, float)) or (isinstance(n.value, str) and n.value.replace('_', '').isdigit()))"",
            ""syms = type('MockSyms', (object,), { 'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'decorator': 4, 'argument': 5, 'return_stmt': 6, 'yield_expr': 7, 'testlist_star_expr': 8, 'star_expr': 9, 'annassign': 10, 'with_stmt': 11, 'atom': 12, 'testlist_gexp': 13, 'match_stmt': 14, 'except_clause': 15, 'subscriptlist': 16, 'trailer': 17, 'tname_star': 18 })"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any"",
            ""from enum import Enum"",
            ""import token"",
            ""import ast"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""node = type('MockNode', (object,), { 'pre_order': lambda self: [self], 'value': '', 'type': None, 'parent': None, 'children': [] })()"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(m.start(), m.end()) for m in re.finditer(r'\\{.*?\\}', s)]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and any(c.isdigit() for c in n.value)"",
            ""syms = type('MockSyms', (object,), { 'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'decorator': 4, 'argument': 5, 'return_stmt': 6, 'yield_expr': 7, 'testlist_star_expr': 8, 'star_expr': 9, 'annassign': 10, 'with_stmt': 11, 'atom': 12, 'testlist_gexp': 13, 'match_stmt': 14, 'except_clause': 15, 'subscriptlist': 16, 'trailer': 17, 'tname_star': 18 })"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""node = type(\n    'MockNode', (object,), {\n        'pre_order': lambda self: [self],\n        'value': '',\n        'type': None,\n        'parent': None,\n        'children': [],\n    }\n)()"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and (isinstance(n.value, (int, float)) or (isinstance(n.value, str) and n.value.replace('_', '').isdigit()))"",
            ""syms = type(\n    'MockSyms', (object,), {\n        'typedargslist': 1,\n        'arglist': 2,\n        'varargslist': 3,\n        'decorator': 4,\n        'argument': 5,\n        'return_stmt': 6,\n        'yield_expr': 7,\n        'testlist_star_expr': 8,\n        'star_expr': 9,\n        'annassign': 10,\n        'with_stmt': 11,\n        'atom': 12,\n        'testlist_gexp': 13,\n        'match_stmt': 14,\n        'except_clause': 15,\n        'subscriptlist': 16,\n        'trailer': 17,\n        'tname_star': 18\n    }\n)"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any"",
            ""from enum import Enum"",
            ""import token"",
            ""import ast"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:\n    def __init__(self, value='', type=None, parent=None, children=None):\n        self.value = value\n        self.type = type\n        self.parent = parent\n        self.children = children if children else []\n\n    def pre_order(self):\n        return [self]"",
            ""node = MockNode()"",
            ""is_string_token = lambda n: isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(m.start(), m.end()) for m in re.finditer(r'{.*?}', s)]"",
            ""is_number_token = lambda n: isinstance(n.value, str) and n.value.replace('_', '').isdigit()"",
            ""syms = type('MockSyms', (object,), { 'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'decorator': 4, 'argument': 5, 'return_stmt': 6, 'yield_expr': 7, 'testlist_star_expr': 8, 'star_expr': 9, 'annassign': 10, 'with_stmt': 11, 'atom': 12, 'testlist_gexp': 13, 'match_stmt': 14, 'except_clause': 15, 'subscriptlist': 16, 'trailer': 17, 'tname_star': 18})"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any"",
            ""from enum import Enum"",
            ""import token"",
            ""import ast"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""node = type('MockNode', (object,), { 'pre_order': lambda self: [self], 'value': '', 'type': None, 'parent': None, 'children': [], })()"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit()"",
            ""syms = type('MockSyms', (object,), { 'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'decorator': 4, 'argument': 5, 'return_stmt': 6, 'yield_expr': 7, 'testlist_star_expr': 8, 'star_expr': 9, 'annassign': 10, 'with_stmt': 11, 'atom': 12, 'testlist_gexp': 13, 'match_stmt': 14, 'except_clause': 15, 'subscriptlist': 16, 'trailer': 17, 'tname_star': 18})"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""node = type('MockNode', (object,), {# pragma: no cover"",
            ""  'pre_order': lambda self: [self],# pragma: no cover"",
            ""  'value': 'f\""example\""',# pragma: no cover"",
            ""  'type': token.STRING,# pragma: no cover"",
            ""  'parent': None,# pragma: no cover"",
            ""  'children': []# pragma: no cover"",
            ""})() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] if '=' in s else [] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n.value, str) and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {# pragma: no cover"",
            ""  'typedargslist': 1,# pragma: no cover"",
            ""  'arglist': 2,# pragma: no cover"",
            ""  'varargslist': 3,# pragma: no cover"",
            ""  'decorator': 4,# pragma: no cover"",
            ""  'argument': 5,# pragma: no cover"",
            ""  'return_stmt': 6,# pragma: no cover"",
            ""  'yield_expr': 7,# pragma: no cover"",
            ""  'testlist_star_expr': 8,# pragma: no cover"",
            ""  'star_expr': 9,# pragma: no cover"",
            ""  'annassign': 10,# pragma: no cover"",
            ""  'with_stmt': 11,# pragma: no cover"",
            ""  'atom': 12,# pragma: no cover"",
            ""  'testlist_gexp': 13,# pragma: no cover"",
            ""  'match_stmt': 14,# pragma: no cover"",
            ""  'except_clause': 15,# pragma: no cover"",
            ""  'subscriptlist': 16,# pragma: no cover"",
            ""  'trailer': 17,# pragma: no cover"",
            ""  'tname_star': 18# pragma: no cover"",
            ""}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""node = type( 'MockNode', (object,), { 'pre_order': lambda self: [self], 'value': 'f\""example={42}\""', 'type': None, 'parent': None, 'children': [], } )() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, type(node)) and hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, type(node)) and hasattr(n, 'value') and (isinstance(n.value, (int, float)) or (isinstance(n.value, str) and n.value.replace('_', '').isdigit())) # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { 'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'decorator': 4, 'argument': 5, 'return_stmt': 6, 'yield_expr': 7, 'testlist_star_expr': 8, 'star_expr': 9, 'annassign': 10, 'with_stmt': 11, 'atom': 12, 'testlist_gexp': 13, 'match_stmt': 14, 'except_clause': 15, 'subscriptlist': 16, 'trailer': 17, 'tname_star': 18}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""node = type( 'MockNode', (object,), { 'pre_order': lambda self: [self], 'value': '', 'type': None, 'parent': None, 'children': [], } )() # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and (isinstance(n.value, (int, float)) or (isinstance(n.value, str) and n.value.replace('_', '').isdigit())) # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { 'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'decorator': 4, 'argument': 5, 'return_stmt': 6, 'yield_expr': 7, 'testlist_star_expr': 8, 'star_expr': 9, 'annassign': 10, 'with_stmt': 11, 'atom': 12, 'testlist_gexp': 13, 'match_stmt': 14, 'except_clause': 15, 'subscriptlist': 16, 'trailer': 17, 'tname_star': 18 }) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [self], 'value': '', 'type': None, 'parent': None, 'children': []})() # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'decorator': 4, 'argument': 5, 'return_stmt': 6, 'yield_expr': 7, 'testlist_star_expr': 8, 'star_expr': 9, 'annassign': 10, 'with_stmt': 11, 'atom': 12, 'testlist_gexp': 13, 'match_stmt': 14, 'except_clause': 15, 'subscriptlist': 16, 'trailer': 17, 'tname_star': 18}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""node = type( 'MockNode', (object,), { 'pre_order': lambda self: [self], 'value': '', 'type': None, 'parent': None, 'children': [], } )() # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { 'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'decorator': 4, 'argument': 5, 'return_stmt': 6, 'yield_expr': 7, 'testlist_star_expr': 8, 'star_expr': 9, 'annassign': 10, 'with_stmt': 11, 'atom': 12, 'testlist_gexp': 13, 'match_stmt': 14, 'except_clause': 15, 'subscriptlist': 16, 'trailer': 17, 'tname_star': 18 }) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, List # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def __init__(self, value='', type=None, parent=None, children=None):# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.children = children if children is not None else []# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, MockNode) and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))]  # Dummy implementation # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, MockNode) and (isinstance(n.value, (int, float)) or (isinstance(n.value, str) and n.value.replace('_', '').isdigit())) # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { 'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'decorator': 4, 'argument': 5, 'return_stmt': 6, 'yield_expr': 7, 'testlist_star_expr': 8, 'star_expr': 9, 'annassign': 10, 'with_stmt': 11, 'atom': 12, 'testlist_gexp': 13, 'match_stmt': 14, 'except_clause': 15, 'subscriptlist': 16, 'trailer': 17, 'tname_star': 18 }) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""node = type('MockNode', (object,), { 'pre_order': lambda self: [self], 'value': '', 'type': None, 'parent': None, 'children': [] })() # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(m.start(), m.end()) for m in re.finditer(r'\\{.*?\\}', s)] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and any(c.isdigit() for c in n.value) # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { 'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'decorator': 4, 'argument': 5, 'return_stmt': 6, 'yield_expr': 7, 'testlist_star_expr': 8, 'star_expr': 9, 'annassign': 10, 'with_stmt': 11, 'atom': 12, 'testlist_gexp': 13, 'match_stmt': 14, 'except_clause': 15, 'subscriptlist': 16, 'trailer': 17, 'tname_star': 18 }) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""node = type(# pragma: no cover"",
            ""    'MockNode', (object,), {# pragma: no cover"",
            ""        'pre_order': lambda self: [self],# pragma: no cover"",
            ""        'value': '',# pragma: no cover"",
            ""        'type': None,# pragma: no cover"",
            ""        'parent': None,# pragma: no cover"",
            ""        'children': [],# pragma: no cover"",
            ""    }# pragma: no cover"",
            "")() # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and (isinstance(n.value, (int, float)) or (isinstance(n.value, str) and n.value.replace('_', '').isdigit())) # pragma: no cover"",
            ""syms = type(# pragma: no cover"",
            ""    'MockSyms', (object,), {# pragma: no cover"",
            ""        'typedargslist': 1,# pragma: no cover"",
            ""        'arglist': 2,# pragma: no cover"",
            ""        'varargslist': 3,# pragma: no cover"",
            ""        'decorator': 4,# pragma: no cover"",
            ""        'argument': 5,# pragma: no cover"",
            ""        'return_stmt': 6,# pragma: no cover"",
            ""        'yield_expr': 7,# pragma: no cover"",
            ""        'testlist_star_expr': 8,# pragma: no cover"",
            ""        'star_expr': 9,# pragma: no cover"",
            ""        'annassign': 10,# pragma: no cover"",
            ""        'with_stmt': 11,# pragma: no cover"",
            ""        'atom': 12,# pragma: no cover"",
            ""        'testlist_gexp': 13,# pragma: no cover"",
            ""        'match_stmt': 14,# pragma: no cover"",
            ""        'except_clause': 15,# pragma: no cover"",
            ""        'subscriptlist': 16,# pragma: no cover"",
            ""        'trailer': 17,# pragma: no cover"",
            ""        'tname_star': 18# pragma: no cover"",
            ""    }# pragma: no cover"",
            "") # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def __init__(self, value='', type=None, parent=None, children=None):# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.children = children if children else []# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(m.start(), m.end()) for m in re.finditer(r'{.*?}', s)] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n.value, str) and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { 'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'decorator': 4, 'argument': 5, 'return_stmt': 6, 'yield_expr': 7, 'testlist_star_expr': 8, 'star_expr': 9, 'annassign': 10, 'with_stmt': 11, 'atom': 12, 'testlist_gexp': 13, 'match_stmt': 14, 'except_clause': 15, 'subscriptlist': 16, 'trailer': 17, 'tname_star': 18}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""node = type('MockNode', (object,), { 'pre_order': lambda self: [self], 'value': '', 'type': None, 'parent': None, 'children': [], })() # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { 'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'decorator': 4, 'argument': 5, 'return_stmt': 6, 'yield_expr': 7, 'testlist_star_expr': 8, 'star_expr': 9, 'annassign': 10, 'with_stmt': 11, 'atom': 12, 'testlist_gexp': 13, 'match_stmt': 14, 'except_clause': 15, 'subscriptlist': 16, 'trailer': 17, 'tname_star': 18}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    }
]",2,2391,0.0011955,5522,0.008283,0.0094785
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 33:
    raise TypeError(f""{msg} Got {arg!r:.100}."")
TypeError: Parameters to generic types must be types. Got 0.
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = {'annotations'}"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [self], 'value': '', 'type': None, 'parent': None, 'children': []})()"",
            ""is_string_token = lambda n: isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))]"",
            ""is_number_token = lambda n: isinstance(n.value, str) and n.value.isdigit()"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'decorator': 4, 'argument': 5, 'return_stmt': 6, 'yield_expr': 7, 'testlist_star_expr': 8, 'star_expr': 9, 'annassign': 10, 'with_stmt': 11, 'atom': 12, 'testlist_gexp': 13, 'match_stmt': 14, 'except_clause': 15, 'subscriptlist': 16, 'trailer': 17, 'tname_star': 18})"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""Feature = type('Feature', (), {"",
            ""'F_STRINGS': 'F_STRINGS',"",
            ""'DEBUG_F_STRINGS': 'DEBUG_F_STRINGS',"",
            ""'NUMERIC_UNDERSCORES': 'NUMERIC_UNDERSCORES',"",
            ""'POS_ONLY_ARGUMENTS': 'POS_ONLY_ARGUMENTS',"",
            ""'ASSIGNMENT_EXPRESSIONS': 'ASSIGNMENT_EXPRESSIONS',"",
            ""'RELAXED_DECORATORS': 'RELAXED_DECORATORS',"",
            ""'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF',"",
            ""'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL',"",
            ""'UNPACKING_ON_FLOW': 'UNPACKING_ON_FLOW',"",
            ""'ANN_ASSIGN_EXTENDED_RHS': 'ANN_ASSIGN_EXTENDED_RHS',"",
            ""'PARENTHESIZED_CONTEXT_MANAGERS': 'PARENTHESIZED_CONTEXT_MANAGERS',"",
            ""'PATTERN_MATCHING': 'PATTERN_MATCHING',"",
            ""'EXCEPT_STAR': 'EXCEPT_STAR',"",
            ""'VARIADIC_GENERICS': 'VARIADIC_GENERICS'"",
            ""})"",
            ""future_imports = {'annotations'}"",
            ""node = type('MockNode', (object,), {"",
            ""'pre_order': lambda self: [self],"",
            ""'type': None,"",
            ""'value': '',"",
            ""'children': [],"",
            ""'parent': None"",
            ""})()"",
            ""is_string_token = lambda n: isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.isdigit()"",
            ""syms = type('syms', (), {"",
            ""'typedargslist': 1,"",
            ""'arglist': 2,"",
            ""'varargslist': 3,"",
            ""'decorator': 4,"",
            ""'argument': 5,"",
            ""'return_stmt': 6,"",
            ""'yield_expr': 7,"",
            ""'testlist_star_expr': 8,"",
            ""'star_expr': 9,"",
            ""'annassign': 10,"",
            ""'with_stmt': 11,"",
            ""'atom': 12,"",
            ""'testlist_gexp': 13,"",
            ""'match_stmt': 14,"",
            ""'except_clause': 15,"",
            ""'subscriptlist': 16,"",
            ""'trailer': 17,"",
            ""'tname_star': 18"",
            ""})"",
            ""is_simple_decorator_expression = lambda n: len(n.children) <= 1"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'F_STRINGS'\n    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'\n    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'\n    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'\n    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'\n    RELAXED_DECORATORS = 'RELAXED_DECORATORS'\n    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'\n    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'\n    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'\n    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'\n    PATTERN_MATCHING = 'PATTERN_MATCHING'\n    EXCEPT_STAR = 'EXCEPT_STAR'\n    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""node = type('MockNode', (object,), {\n    'pre_order': lambda self: [self],\n    'value': '',\n    'type': None,\n    'parent': None,\n    'children': [],\n})()"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))]"",
            ""is_number_token = lambda n: '_' in n.value or n.value.isdigit()"",
            ""syms = type('MockSyms', (object,), {\n    'typedargslist': 1,\n    'arglist': 2,\n    'varargslist': 3,\n    'decorator': 4,\n    'argument': 5,\n    'return_stmt': 6,\n    'yield_expr': 7,\n    'testlist_star_expr': 8,\n    'star_expr': 9,\n    'annassign': 10,\n    'with_stmt': 11,\n    'atom': 12,\n    'testlist_gexp': 13,\n    'match_stmt': 14,\n    'except_clause': 15,\n    'subscriptlist': 16,\n    'trailer': 17,\n    'tname_star': 18,\n})"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR}"",
            ""future_imports = {'annotations'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.PARENTHESIZED_CONTEXT_MANAGERS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""node = type( 'MockNode', (object,), { 'pre_order': lambda self: [self], 'value': '', 'type': None, 'parent': None, 'children': [], } )()"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and (n.value.isdigit() or (isinstance(n.value, str) and n.value.replace('_', '').isdigit()))"",
            ""syms = type('MockSyms', (object,), { 'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'decorator': 4, 'argument': 5, 'return_stmt': 6, 'yield_expr': 7, 'testlist_star_expr': 8, 'star_expr': 9, 'annassign': 10, 'with_stmt': 11, 'atom': 12, 'testlist_gexp': 13, 'match_stmt': 14, 'except_clause': 15, 'subscriptlist': 16, 'trailer': 17, 'tname_star': 18})"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = {'annotations'}"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [self], 'type': None, 'value': '', 'children': [], 'parent': None})()"",
            ""is_string_token = lambda n: isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))]"",
            ""is_number_token = lambda n: isinstance(n.value, str) and n.value.replace('_', '').isdigit()"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'decorator': 4, 'argument': 5, 'return_stmt': 6, 'yield_expr': 7, 'testlist_star_expr': 8, 'star_expr': 9, 'annassign': 10, 'with_stmt': 11, 'atom': 12, 'testlist_gexp': 13, 'match_stmt': 14, 'except_clause': 15, 'subscriptlist': 16, 'trailer': 17, 'tname_star': 18})"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict"",
            ""from enum import Enum"",
            ""import token"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""MockNode = type('MockNode', (object,), {'pre_order': lambda self: [self], 'value': '', 'type': None, 'parent': None, 'children': []})"",
            ""node = MockNode()"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and (isinstance(n.value, str) and n.value.replace('_', '').isdigit())"",
            ""syms = SimpleNamespace(typedargslist=1, arglist=2, varargslist=3, decorator=4, argument=5, return_stmt=6, yield_expr=7, testlist_star_expr=8, star_expr=9, annassign=10, with_stmt=11, atom=12, testlist_gexp=13, match_stmt=14, except_clause=15, subscriptlist=16, trailer=17, tname_star=18)"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import symtable as syms""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'F_STRINGS'\n    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'\n    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'\n    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'\n    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'\n    RELAXED_DECORATORS = 'RELAXED_DECORATORS'\n    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'\n    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'\n    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'\n    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'\n    PATTERN_MATCHING = 'PATTERN_MATCHING'\n    EXCEPT_STAR = 'EXCEPT_STAR'\n    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = {'annotations'}"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [], 'type': None, 'value': '', 'children': [], 'parent': None})()"",
            ""is_string_token = lambda n: isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))]"",
            ""is_number_token = lambda n: n.value.isdigit()"",
            ""is_simple_decorator_expression = lambda n: False"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.PARENTHESIZED_CONTEXT_MANAGERS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import symbol as syms""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = {'annotations'}"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [self], 'type': None, 'value': '', 'children': [], 'parent': None})()"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit()"",
            ""is_simple_decorator_expression = lambda n: False"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'F_STRINGS'\n    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'\n    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'\n    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'\n    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'\n    RELAXED_DECORATORS = 'RELAXED_DECORATORS'\n    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'\n    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'\n    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'\n    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'\n    PATTERN_MATCHING = 'PATTERN_MATCHING'\n    EXCEPT_STAR = 'EXCEPT_STAR'\n    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:\n    def __init__(self, value='', type_=None):\n        self.value = value\n        self.type = type_\n        self.children = []\n        self.parent = None\n    def pre_order(self):\n        return [self]\nnode = MockNode()"",
            ""is_string_token = lambda n: isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))]"",
            ""is_number_token = lambda n: n.value.replace('_', '').isdigit()"",
            ""class syms:\n    typedargslist = 1\n    arglist = 2\n    varargslist = 3\n    decorator = 4\n    argument = 5\n    return_stmt = 6\n    yield_expr = 7\n    testlist_star_expr = 8\n    star_expr = 9\n    annassign = 10\n    with_stmt = 11\n    atom = 12\n    testlist_gexp = 13\n    match_stmt = 14\n    except_clause = 15\n    subscriptlist = 16\n    trailer = 17\n    tname_star = 18"",
            ""is_simple_decorator_expression = lambda n: False"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.PATTERN_MATCHING}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [self], 'type': None, 'value': '', 'children': [], 'parent': None})()"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit()"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'decorator': 4, 'argument': 5, 'return_stmt': 6, 'yield_expr': 7, 'testlist_star_expr': 8, 'star_expr': 9, 'annassign': 10, 'with_stmt': 11, 'atom': 12, 'testlist_gexp': 13, 'match_stmt': 14, 'except_clause': 15, 'subscriptlist': 16, 'trailer': 17, 'tname_star': 18})"",
            ""is_simple_decorator_expression = lambda n: False"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [self], 'value': '', 'type': None, 'parent': None, 'children': []})() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n.value, str) and n.value.isdigit() # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'decorator': 4, 'argument': 5, 'return_stmt': 6, 'yield_expr': 7, 'testlist_star_expr': 8, 'star_expr': 9, 'annassign': 10, 'with_stmt': 11, 'atom': 12, 'testlist_gexp': 13, 'match_stmt': 14, 'except_clause': 15, 'subscriptlist': 16, 'trailer': 17, 'tname_star': 18}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = type('Feature', (), { # pragma: no cover"",
            ""'F_STRINGS': 'F_STRINGS', # pragma: no cover"",
            ""'DEBUG_F_STRINGS': 'DEBUG_F_STRINGS', # pragma: no cover"",
            ""'NUMERIC_UNDERSCORES': 'NUMERIC_UNDERSCORES', # pragma: no cover"",
            ""'POS_ONLY_ARGUMENTS': 'POS_ONLY_ARGUMENTS', # pragma: no cover"",
            ""'ASSIGNMENT_EXPRESSIONS': 'ASSIGNMENT_EXPRESSIONS', # pragma: no cover"",
            ""'RELAXED_DECORATORS': 'RELAXED_DECORATORS', # pragma: no cover"",
            ""'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', # pragma: no cover"",
            ""'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL', # pragma: no cover"",
            ""'UNPACKING_ON_FLOW': 'UNPACKING_ON_FLOW', # pragma: no cover"",
            ""'ANN_ASSIGN_EXTENDED_RHS': 'ANN_ASSIGN_EXTENDED_RHS', # pragma: no cover"",
            ""'PARENTHESIZED_CONTEXT_MANAGERS': 'PARENTHESIZED_CONTEXT_MANAGERS', # pragma: no cover"",
            ""'PATTERN_MATCHING': 'PATTERN_MATCHING', # pragma: no cover"",
            ""'EXCEPT_STAR': 'EXCEPT_STAR', # pragma: no cover"",
            ""'VARIADIC_GENERICS': 'VARIADIC_GENERICS' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""node = type('MockNode', (object,), { # pragma: no cover"",
            ""'pre_order': lambda self: [self], # pragma: no cover"",
            ""'type': None, # pragma: no cover"",
            ""'value': '', # pragma: no cover"",
            ""'children': [], # pragma: no cover"",
            ""'parent': None # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.isdigit() # pragma: no cover"",
            ""syms = type('syms', (), { # pragma: no cover"",
            ""'typedargslist': 1, # pragma: no cover"",
            ""'arglist': 2, # pragma: no cover"",
            ""'varargslist': 3, # pragma: no cover"",
            ""'decorator': 4, # pragma: no cover"",
            ""'argument': 5, # pragma: no cover"",
            ""'return_stmt': 6, # pragma: no cover"",
            ""'yield_expr': 7, # pragma: no cover"",
            ""'testlist_star_expr': 8, # pragma: no cover"",
            ""'star_expr': 9, # pragma: no cover"",
            ""'annassign': 10, # pragma: no cover"",
            ""'with_stmt': 11, # pragma: no cover"",
            ""'atom': 12, # pragma: no cover"",
            ""'testlist_gexp': 13, # pragma: no cover"",
            ""'match_stmt': 14, # pragma: no cover"",
            ""'except_clause': 15, # pragma: no cover"",
            ""'subscriptlist': 16, # pragma: no cover"",
            ""'trailer': 17, # pragma: no cover"",
            ""'tname_star': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: len(n.children) <= 1 # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'# pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""node = type('MockNode', (object,), {# pragma: no cover"",
            ""    'pre_order': lambda self: [self],# pragma: no cover"",
            ""    'value': '',# pragma: no cover"",
            ""    'type': None,# pragma: no cover"",
            ""    'parent': None,# pragma: no cover"",
            ""    'children': [],# pragma: no cover"",
            ""})() # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] # pragma: no cover"",
            ""is_number_token = lambda n: '_' in n.value or n.value.isdigit() # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {# pragma: no cover"",
            ""    'typedargslist': 1,# pragma: no cover"",
            ""    'arglist': 2,# pragma: no cover"",
            ""    'varargslist': 3,# pragma: no cover"",
            ""    'decorator': 4,# pragma: no cover"",
            ""    'argument': 5,# pragma: no cover"",
            ""    'return_stmt': 6,# pragma: no cover"",
            ""    'yield_expr': 7,# pragma: no cover"",
            ""    'testlist_star_expr': 8,# pragma: no cover"",
            ""    'star_expr': 9,# pragma: no cover"",
            ""    'annassign': 10,# pragma: no cover"",
            ""    'with_stmt': 11,# pragma: no cover"",
            ""    'atom': 12,# pragma: no cover"",
            ""    'testlist_gexp': 13,# pragma: no cover"",
            ""    'match_stmt': 14,# pragma: no cover"",
            ""    'except_clause': 15,# pragma: no cover"",
            ""    'subscriptlist': 16,# pragma: no cover"",
            ""    'trailer': 17,# pragma: no cover"",
            ""    'tname_star': 18,# pragma: no cover"",
            ""}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.PARENTHESIZED_CONTEXT_MANAGERS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""node = type( 'MockNode', (object,), { 'pre_order': lambda self: [self], 'value': '', 'type': None, 'parent': None, 'children': [], } )() # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and (n.value.isdigit() or (isinstance(n.value, str) and n.value.replace('_', '').isdigit())) # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { 'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'decorator': 4, 'argument': 5, 'return_stmt': 6, 'yield_expr': 7, 'testlist_star_expr': 8, 'star_expr': 9, 'annassign': 10, 'with_stmt': 11, 'atom': 12, 'testlist_gexp': 13, 'match_stmt': 14, 'except_clause': 15, 'subscriptlist': 16, 'trailer': 17, 'tname_star': 18}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [self], 'type': None, 'value': '', 'children': [], 'parent': None})() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n.value, str) and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'decorator': 4, 'argument': 5, 'return_stmt': 6, 'yield_expr': 7, 'testlist_star_expr': 8, 'star_expr': 9, 'annassign': 10, 'with_stmt': 11, 'atom': 12, 'testlist_gexp': 13, 'match_stmt': 14, 'except_clause': 15, 'subscriptlist': 16, 'trailer': 17, 'tname_star': 18}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""MockNode = type('MockNode', (object,), {'pre_order': lambda self: [self], 'value': '', 'type': None, 'parent': None, 'children': []}) # pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and (isinstance(n.value, str) and n.value.replace('_', '').isdigit()) # pragma: no cover"",
            ""syms = SimpleNamespace(typedargslist=1, arglist=2, varargslist=3, decorator=4, argument=5, return_stmt=6, yield_expr=7, testlist_star_expr=8, star_expr=9, annassign=10, with_stmt=11, atom=12, testlist_gexp=13, match_stmt=14, except_clause=15, subscriptlist=16, trailer=17, tname_star=18) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import symtable as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'# pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [], 'type': None, 'value': '', 'children': [], 'parent': None})() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] # pragma: no cover"",
            ""is_number_token = lambda n: n.value.isdigit() # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: False # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.PARENTHESIZED_CONTEXT_MANAGERS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import symbol as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [self], 'type': None, 'value': '', 'children': [], 'parent': None})() # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: False # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'# pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def __init__(self, value='', type_=None):# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.type = type_# pragma: no cover"",
            ""        self.children = []# pragma: no cover"",
            ""        self.parent = None# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [self]# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] # pragma: no cover"",
            ""is_number_token = lambda n: n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""class syms:# pragma: no cover"",
            ""    typedargslist = 1# pragma: no cover"",
            ""    arglist = 2# pragma: no cover"",
            ""    varargslist = 3# pragma: no cover"",
            ""    decorator = 4# pragma: no cover"",
            ""    argument = 5# pragma: no cover"",
            ""    return_stmt = 6# pragma: no cover"",
            ""    yield_expr = 7# pragma: no cover"",
            ""    testlist_star_expr = 8# pragma: no cover"",
            ""    star_expr = 9# pragma: no cover"",
            ""    annassign = 10# pragma: no cover"",
            ""    with_stmt = 11# pragma: no cover"",
            ""    atom = 12# pragma: no cover"",
            ""    testlist_gexp = 13# pragma: no cover"",
            ""    match_stmt = 14# pragma: no cover"",
            ""    except_clause = 15# pragma: no cover"",
            ""    subscriptlist = 16# pragma: no cover"",
            ""    trailer = 17# pragma: no cover"",
            ""    tname_star = 18 # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: False # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.PATTERN_MATCHING} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [self], 'type': None, 'value': '', 'children': [], 'parent': None})() # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'decorator': 4, 'argument': 5, 'return_stmt': 6, 'yield_expr': 7, 'testlist_star_expr': 8, 'star_expr': 9, 'annassign': 10, 'with_stmt': 11, 'atom': 12, 'testlist_gexp': 13, 'match_stmt': 14, 'except_clause': 15, 'subscriptlist': 16, 'trailer': 17, 'tname_star': 18}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: False # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    }
]",2,3008,0.001504,5386,0.008079,0.009583
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 64:
    if future_imports:
NameError: name 'future_imports' is not defined
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'f-strings'"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings'"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals'"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions'"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax'"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls'"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers'"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement'"",
            ""    EXCEPT_STAR = 'except* clause'"",
            ""    VARIADIC_GENERICS = 'variadic generics'"",
            """",
            ""future_imports = ['annotations']"",
            ""node = type('Mock', (object,), {"",
            ""    'pre_order': lambda self: [],"",
            ""    'value': '',"",
            ""    'type': None,"",
            ""    'parent': None,"",
            ""    'children': []"",
            ""})()"",
            ""def is_string_token(n):"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):"",
            ""    return [(0, len(value))]"",
            ""def is_number_token(n):"",
            ""    return hasattr(n, 'value') and any(ch.isdigit() for ch in n.value)"",
            ""def is_simple_decorator_expression(n):"",
            ""    return isinstance(n, type('Mock', (object,), {}))"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""def set_syms_attribute(name, value):"",
            ""    setattr(syms, name, value)"",
            ""syms.typedargslist = 1"",
            ""syms.arglist = 2"",
            ""syms.varargslist = 3"",
            ""syms.decorator = 4"",
            ""syms.argument = 5"",
            ""syms.return_stmt = 6"",
            ""syms.yield_expr = 7"",
            ""syms.testlist_star_expr = 8"",
            ""syms.star_expr = 9"",
            ""syms.annassign = 10"",
            ""syms.with_stmt = 11"",
            ""syms.atom = 12"",
            ""syms.testlist_gexp = 13"",
            ""syms.match_stmt = 14"",
            ""syms.except_clause = 15"",
            ""syms.subscriptlist = 16"",
            ""syms.trailer = 17"",
            ""syms.tname_star = 18""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import symtable as syms""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'f-strings'"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings'"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals'"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions'"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax'"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls'"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers'"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement'"",
            ""    EXCEPT_STAR = 'except* clause'"",
            ""    VARIADIC_GENERICS = 'variadic generics'"",
            """",
            ""future_imports = ['annotations']"",
            ""node = type('Mock', (object,), {"",
            ""    'pre_order': lambda self: [],"",
            ""    'value': '',"",
            ""    'type': None,"",
            ""    'parent': None,"",
            ""    'children': []"",
            ""})()"",
            ""def is_string_token(n):"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):"",
            ""    return [(0, len(value))]"",
            ""def is_number_token(n):"",
            ""    return hasattr(n, 'value') and any(ch.isdigit() for ch in n.value)"",
            ""def is_simple_decorator_expression(n):"",
            ""    return isinstance(n, type('Mock', (object,), {}))"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS,"",
            ""}"",
            ""def set_syms_attribute(name):"",
            ""    setattr(syms, name, type('Mock', (object,), {}))"",
            ""for attribute in ['typedargslist', 'arglist', 'varargslist', 'decorator', 'argument', 'return_stmt', 'yield_expr', 'testlist_star_expr', 'star_expr', 'annassign', 'with_stmt', 'atom', 'testlist_gexp', 'match_stmt', 'except_clause', 'subscriptlist', 'trailer', 'tname_star']:"",
            ""    set_syms_attribute(attribute)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import symtable as syms""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'f-strings'"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings'"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals'"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions'"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax'"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls'"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers'"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement'"",
            ""    EXCEPT_STAR = 'except* clause'"",
            ""    VARIADIC_GENERICS = 'variadic generics'"",
            """",
            ""future_imports = ['annotations']"",
            ""node = type('Mock', (object,), {"",
            ""    'pre_order': lambda self: [],"",
            ""    'value': '',"",
            ""    'type': None,"",
            ""    'parent': None,"",
            ""    'children': []"",
            ""})()"",
            ""def is_string_token(n):"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):"",
            ""    return [(0, len(value))]"",
            ""def is_number_token(n):"",
            ""    return hasattr(n, 'value') and any(ch.isdigit() for ch in n.value)"",
            ""def is_simple_decorator_expression(n):"",
            ""    return isinstance(n, type('Mock', (object,), {}))"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS,"",
            ""}"",
            ""def set_syms_attribute(name):"",
            ""    setattr(syms, name, type('Mock', (object,), {}))"",
            ""for attribute in ['typedargslist', 'arglist', 'varargslist', 'decorator', 'argument', 'return_stmt', 'yield_expr', 'testlist_star_expr', 'star_expr', 'annassign', 'with_stmt', 'atom', 'testlist_gexp', 'match_stmt', 'except_clause', 'subscriptlist', 'trailer', 'tname_star']:"",
            ""    set_syms_attribute(attribute)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import symtable""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'f-strings'"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings'"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals'"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions'"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax'"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls'"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers'"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement'"",
            ""    EXCEPT_STAR = 'except* clause'"",
            ""    VARIADIC_GENERICS = 'variadic generics'"",
            """",
            ""future_imports = ['annotations']"",
            ""node = type('Mock', (object,), {"",
            ""    'pre_order': lambda self: [],"",
            ""    'value': '',"",
            ""    'type': None,"",
            ""    'parent': None,"",
            ""    'children': []"",
            ""})()"",
            ""def is_string_token(n):"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):"",
            ""    return [(0, len(value))]"",
            ""def is_number_token(n):"",
            ""    return hasattr(n, 'value') and any(ch.isdigit() for ch in n.value)"",
            ""def is_simple_decorator_expression(n):"",
            ""    return isinstance(n, type('Mock', (object,), {}))"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS,"",
            ""}"",
            ""syms = type('MockSyms', (object,), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'varargslist': 'varargslist',"",
            ""    'decorator': 'decorator',"",
            ""    'argument': 'argument',"",
            ""    'return_stmt': 'return_stmt',"",
            ""    'yield_expr': 'yield_expr',"",
            ""    'testlist_star_expr': 'testlist_star_expr',"",
            ""    'star_expr': 'star_expr',"",
            ""    'annassign': 'annassign',"",
            ""    'with_stmt': 'with_stmt',"",
            ""    'atom': 'atom',"",
            ""    'testlist_gexp': 'testlist_gexp',"",
            ""    'match_stmt': 'match_stmt',"",
            ""    'except_clause': 'except_clause',"",
            ""    'subscriptlist': 'subscriptlist',"",
            ""    'trailer': 'trailer',"",
            ""    'tname_star': 'tname_star'"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import symtable as syms""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'f-strings'"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings'"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals'"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions'"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax'"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls'"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers'"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement'"",
            ""    EXCEPT_STAR = 'except* clause'"",
            ""    VARIADIC_GENERICS = 'variadic generics'"",
            """",
            ""future_imports = ['annotations']"",
            ""node = type('Mock', (object,), {"",
            ""    'pre_order': lambda self: [type('Mock', (object,), {"",
            ""        'value': '',"",
            ""        'type': token.STRING,"",
            ""        'parent': None,"",
            ""        'children': [],"",
            ""    })()]"",
            ""})()"",
            ""def is_string_token(n):"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):"",
            ""    return [(0, len(value))]"",
            ""def is_number_token(n):"",
            ""    return hasattr(n, 'value') and any(ch.isdigit() for ch in n.value)"",
            ""def is_simple_decorator_expression(n):"",
            ""    return isinstance(n, type('Mock', (object,), {}))"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS,"",
            ""}"",
            ""def set_syms_attribute(name):"",
            ""    setattr(syms, name, type('Mock', (object,), {}))"",
            ""for attribute in ['typedargslist', 'arglist', 'varargslist', 'decorator', 'argument', 'return_stmt', 'yield_expr', 'testlist_star_expr', 'star_expr', 'annassign', 'with_stmt', 'atom', 'testlist_gexp', 'match_stmt', 'except_clause', 'subscriptlist', 'trailer', 'tname_star']:"",
            ""    set_syms_attribute(attribute)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'f-strings'"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings'"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals'"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions'"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax'"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls'"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers'"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement'"",
            ""    EXCEPT_STAR = 'except* clause'"",
            ""    VARIADIC_GENERICS = 'variadic generics'"",
            """",
            ""future_imports = {'annotations'}"",
            ""node = type('Mock', (object,), {"",
            ""    'pre_order': lambda self: [],"",
            ""    'value': '',"",
            ""    'type': None,"",
            ""    'parent': None,"",
            ""    'children': []"",
            ""})()"",
            ""def is_string_token(n):"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):"",
            ""    return [(0, len(value))]"",
            ""def is_number_token(n):"",
            ""    return hasattr(n, 'value') and any(ch.isdigit() for ch in n.value)"",
            ""def is_simple_decorator_expression(n):"",
            ""    return isinstance(n, type('Mock', (object,), {}))"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS,"",
            ""}"",
            ""syms = type('MockSyms', (object,), {"",
            ""    'typedargslist': type('Mock', (object,), {}),"",
            ""    'arglist': type('Mock', (object,), {}),"",
            ""    'varargslist': type('Mock', (object,), {}),"",
            ""    'decorator': type('Mock', (object,), {}),"",
            ""    'argument': type('Mock', (object,), {}),"",
            ""    'return_stmt': type('Mock', (object,), {}),"",
            ""    'yield_expr': type('Mock', (object,), {}),"",
            ""    'testlist_star_expr': type('Mock', (object,), {}),"",
            ""    'star_expr': type('Mock', (object,), {}),"",
            ""    'annassign': type('Mock', (object,), {}),"",
            ""    'with_stmt': type('Mock', (object,), {}),"",
            ""    'atom': type('Mock', (object,), {}),"",
            ""    'testlist_gexp': type('Mock', (object,), {}),"",
            ""    'match_stmt': type('Mock', (object,), {}),"",
            ""    'except_clause': type('Mock', (object,), {}),"",
            ""    'subscriptlist': type('Mock', (object,), {}),"",
            ""    'trailer': type('Mock', (object,), {}),"",
            ""    'tname_star': type('Mock', (object,), {})"",
            ""})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import symbol as syms""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'f-strings'"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings'"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals'"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions'"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax'"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls'"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers'"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement'"",
            ""    EXCEPT_STAR = 'except* clause'"",
            ""    VARIADIC_GENERICS = 'variadic generics'"",
            ""future_imports = ['annotations']"",
            ""node = type('Mock', (object,), {"",
            ""    'pre_order': lambda self: [],"",
            ""    'value': '',"",
            ""    'type': None,"",
            ""    'parent': None,"",
            ""    'children': []"",
            ""})()"",
            ""def is_string_token(n):"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):"",
            ""    return [(0, len(value))]"",
            ""def is_number_token(n):"",
            ""    return hasattr(n, 'value') and any(ch.isdigit() for ch in n.value)"",
            ""def is_simple_decorator_expression(n):"",
            ""    return isinstance(n, type('Mock', (object,), {}))"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS,"",
            ""}"",
            ""def set_syms_attribute(name):"",
            ""    setattr(syms, name, type('Mock', (object,), {}))"",
            ""for attribute in ['typedargslist', 'arglist', 'varargslist', 'decorator', 'argument', 'return_stmt', 'yield_expr', 'testlist_star_expr', 'star_expr', 'annassign', 'with_stmt', 'atom', 'testlist_gexp', 'match_stmt', 'except_clause', 'subscriptlist', 'trailer', 'tname_star']:"",
            ""    set_syms_attribute(attribute)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'f-strings'"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings'"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals'"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions'"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax'"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls'"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers'"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement'"",
            ""    EXCEPT_STAR = 'except* clause'"",
            ""    VARIADIC_GENERICS = 'variadic generics'"",
            """",
            ""future_imports = ['annotations']"",
            ""node = type('Mock', (object,), {"",
            ""    'pre_order': lambda self: [],"",
            ""    'value': '',"",
            ""    'type': None,"",
            ""    'parent': None,"",
            ""    'children': []"",
            ""})()"",
            ""def is_string_token(n):"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):"",
            ""    return [(0, len(value))]"",
            ""def is_number_token(n):"",
            ""    return hasattr(n, 'value') and any(ch.isdigit() for ch in n.value)"",
            ""def is_simple_decorator_expression(n):"",
            ""    return isinstance(n, type('Mock', (object,), {}))"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS,"",
            ""}"",
            ""SYMS = type('SYMS', (object,), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'varargslist': 'varargslist',"",
            ""    'decorator': 'decorator',"",
            ""    'argument': 'argument',"",
            ""    'return_stmt': 'return_stmt',"",
            ""    'yield_expr': 'yield_expr',"",
            ""    'testlist_star_expr': 'testlist_star_expr',"",
            ""    'star_expr': 'star_expr',"",
            ""    'annassign': 'annassign',"",
            ""    'with_stmt': 'with_stmt',"",
            ""    'atom': 'atom',"",
            ""    'testlist_gexp': 'testlist_gexp',"",
            ""    'match_stmt': 'match_stmt',"",
            ""    'except_clause': 'except_clause',"",
            ""    'subscriptlist': 'subscriptlist',"",
            ""    'trailer': 'trailer',"",
            ""    'tname_star': 'tname_star'"",
            ""})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'f-strings'"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings'"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals'"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions'"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax'"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls'"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers'"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement'"",
            ""    EXCEPT_STAR = 'except* clause'"",
            ""    VARIADIC_GENERICS = 'variadic generics'"",
            """",
            ""future_imports = ['annotations']"",
            ""node = type('Mock', (object,), {"",
            ""    'pre_order': lambda self: [],"",
            ""    'value': '',"",
            ""    'type': None,"",
            ""    'parent': None,"",
            ""    'children': []"",
            ""})()"",
            ""def is_string_token(n):"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):"",
            ""    return [(0, len(value))]"",
            ""def is_number_token(n):"",
            ""    return hasattr(n, 'value') and any(ch.isdigit() for ch in n.value)"",
            ""def is_simple_decorator_expression(n):"",
            ""    return isinstance(n, type('Mock', (object,), {}))"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS,"",
            ""}"",
            ""syms = type('MockSyms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'argument': 5,"",
            ""    'return_stmt': 6,"",
            ""    'yield_expr': 7,"",
            ""    'testlist_star_expr': 8,"",
            ""    'star_expr': 9,"",
            ""    'annassign': 10,"",
            ""    'with_stmt': 11,"",
            ""    'atom': 12,"",
            ""    'testlist_gexp': 13,"",
            ""    'match_stmt': 14,"",
            ""    'except_clause': 15,"",
            ""    'subscriptlist': 16,"",
            ""    'trailer': 17,"",
            ""    'tname_star': 18"",
            ""})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import symtable as syms""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'f-strings'"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings'"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals'"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions'"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax'"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls'"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers'"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement'"",
            ""    EXCEPT_STAR = 'except* clause'"",
            ""    VARIADIC_GENERICS = 'variadic generics'"",
            """",
            ""future_imports = ['annotations']"",
            ""node = type('Mock', (object,), {"",
            ""    'pre_order': lambda self: [],"",
            ""    'value': '',"",
            ""    'type': None,"",
            ""    'parent': None,"",
            ""    'children': []"",
            ""})()"",
            ""def is_string_token(n):"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):"",
            ""    return [(0, len(value))]"",
            ""def is_number_token(n):"",
            ""    return hasattr(n, 'value') and any(ch.isdigit() for ch in n.value)"",
            ""def is_simple_decorator_expression(n):"",
            ""    return isinstance(n, type('Mock', (object,), {}))"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS,"",
            ""}"",
            ""def set_syms_attribute(name):"",
            ""    setattr(syms, name, type('Mock', (object,), {}))"",
            ""for attribute in ['typedargslist', 'arglist', 'varargslist', 'decorator', 'argument', 'return_stmt', 'yield_expr', 'testlist_star_expr', 'star_expr', 'annassign', 'with_stmt', 'atom', 'testlist_gexp', 'match_stmt', 'except_clause', 'subscriptlist', 'trailer', 'tname_star']:"",
            ""    set_syms_attribute(attribute)"",
            """",
            ""features: Set[str] = set()""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'f-strings' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement' # pragma: no cover"",
            ""    EXCEPT_STAR = 'except* clause' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic generics' # pragma: no cover"",
            "" # pragma: no cover"",
            ""node = type('Mock', (object,), { # pragma: no cover"",
            ""    'pre_order': lambda self: [], # pragma: no cover"",
            ""    'value': '', # pragma: no cover"",
            ""    'type': None, # pragma: no cover"",
            ""    'parent': None, # pragma: no cover"",
            ""    'children': [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and any(ch.isdigit() for ch in n.value) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return isinstance(n, type('Mock', (object,), {})) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def set_syms_attribute(name, value): # pragma: no cover"",
            ""    setattr(syms, name, value) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import symtable as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'f-strings' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement' # pragma: no cover"",
            ""    EXCEPT_STAR = 'except* clause' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic generics' # pragma: no cover"",
            "" # pragma: no cover"",
            ""node = type('Mock', (object,), { # pragma: no cover"",
            ""    'pre_order': lambda self: [], # pragma: no cover"",
            ""    'value': '', # pragma: no cover"",
            ""    'type': None, # pragma: no cover"",
            ""    'parent': None, # pragma: no cover"",
            ""    'children': [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and any(ch.isdigit() for ch in n.value) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return isinstance(n, type('Mock', (object,), {})) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS, # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def set_syms_attribute(name): # pragma: no cover"",
            ""    setattr(syms, name, type('Mock', (object,), {})) # pragma: no cover"",
            ""for attribute in ['typedargslist', 'arglist', 'varargslist', 'decorator', 'argument', 'return_stmt', 'yield_expr', 'testlist_star_expr', 'star_expr', 'annassign', 'with_stmt', 'atom', 'testlist_gexp', 'match_stmt', 'except_clause', 'subscriptlist', 'trailer', 'tname_star']: # pragma: no cover"",
            ""    set_syms_attribute(attribute) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import symtable as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'f-strings' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement' # pragma: no cover"",
            ""    EXCEPT_STAR = 'except* clause' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic generics' # pragma: no cover"",
            "" # pragma: no cover"",
            ""node = type('Mock', (object,), { # pragma: no cover"",
            ""    'pre_order': lambda self: [], # pragma: no cover"",
            ""    'value': '', # pragma: no cover"",
            ""    'type': None, # pragma: no cover"",
            ""    'parent': None, # pragma: no cover"",
            ""    'children': [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and any(ch.isdigit() for ch in n.value) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return isinstance(n, type('Mock', (object,), {})) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS, # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def set_syms_attribute(name): # pragma: no cover"",
            ""    setattr(syms, name, type('Mock', (object,), {})) # pragma: no cover"",
            ""for attribute in ['typedargslist', 'arglist', 'varargslist', 'decorator', 'argument', 'return_stmt', 'yield_expr', 'testlist_star_expr', 'star_expr', 'annassign', 'with_stmt', 'atom', 'testlist_gexp', 'match_stmt', 'except_clause', 'subscriptlist', 'trailer', 'tname_star']: # pragma: no cover"",
            ""    set_syms_attribute(attribute) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import symtable # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'f-strings' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement' # pragma: no cover"",
            ""    EXCEPT_STAR = 'except* clause' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic generics' # pragma: no cover"",
            "" # pragma: no cover"",
            ""node = type('Mock', (object,), { # pragma: no cover"",
            ""    'pre_order': lambda self: [], # pragma: no cover"",
            ""    'value': '', # pragma: no cover"",
            ""    'type': None, # pragma: no cover"",
            ""    'parent': None, # pragma: no cover"",
            ""    'children': [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and any(ch.isdigit() for ch in n.value) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return isinstance(n, type('Mock', (object,), {})) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS, # pragma: no cover"",
            ""} # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'varargslist': 'varargslist', # pragma: no cover"",
            ""    'decorator': 'decorator', # pragma: no cover"",
            ""    'argument': 'argument', # pragma: no cover"",
            ""    'return_stmt': 'return_stmt', # pragma: no cover"",
            ""    'yield_expr': 'yield_expr', # pragma: no cover"",
            ""    'testlist_star_expr': 'testlist_star_expr', # pragma: no cover"",
            ""    'star_expr': 'star_expr', # pragma: no cover"",
            ""    'annassign': 'annassign', # pragma: no cover"",
            ""    'with_stmt': 'with_stmt', # pragma: no cover"",
            ""    'atom': 'atom', # pragma: no cover"",
            ""    'testlist_gexp': 'testlist_gexp', # pragma: no cover"",
            ""    'match_stmt': 'match_stmt', # pragma: no cover"",
            ""    'except_clause': 'except_clause', # pragma: no cover"",
            ""    'subscriptlist': 'subscriptlist', # pragma: no cover"",
            ""    'trailer': 'trailer', # pragma: no cover"",
            ""    'tname_star': 'tname_star' # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import symtable as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'f-strings' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement' # pragma: no cover"",
            ""    EXCEPT_STAR = 'except* clause' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic generics' # pragma: no cover"",
            "" # pragma: no cover"",
            ""node = type('Mock', (object,), { # pragma: no cover"",
            ""    'pre_order': lambda self: [type('Mock', (object,), { # pragma: no cover"",
            ""        'value': '', # pragma: no cover"",
            ""        'type': token.STRING, # pragma: no cover"",
            ""        'parent': None, # pragma: no cover"",
            ""        'children': [], # pragma: no cover"",
            ""    })()] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and any(ch.isdigit() for ch in n.value) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return isinstance(n, type('Mock', (object,), {})) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS, # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def set_syms_attribute(name): # pragma: no cover"",
            ""    setattr(syms, name, type('Mock', (object,), {})) # pragma: no cover"",
            ""for attribute in ['typedargslist', 'arglist', 'varargslist', 'decorator', 'argument', 'return_stmt', 'yield_expr', 'testlist_star_expr', 'star_expr', 'annassign', 'with_stmt', 'atom', 'testlist_gexp', 'match_stmt', 'except_clause', 'subscriptlist', 'trailer', 'tname_star']: # pragma: no cover"",
            ""    set_syms_attribute(attribute) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'f-strings' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement' # pragma: no cover"",
            ""    EXCEPT_STAR = 'except* clause' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic generics' # pragma: no cover"",
            "" # pragma: no cover"",
            ""node = type('Mock', (object,), { # pragma: no cover"",
            ""    'pre_order': lambda self: [], # pragma: no cover"",
            ""    'value': '', # pragma: no cover"",
            ""    'type': None, # pragma: no cover"",
            ""    'parent': None, # pragma: no cover"",
            ""    'children': [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and any(ch.isdigit() for ch in n.value) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return isinstance(n, type('Mock', (object,), {})) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS, # pragma: no cover"",
            ""} # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'typedargslist': type('Mock', (object,), {}), # pragma: no cover"",
            ""    'arglist': type('Mock', (object,), {}), # pragma: no cover"",
            ""    'varargslist': type('Mock', (object,), {}), # pragma: no cover"",
            ""    'decorator': type('Mock', (object,), {}), # pragma: no cover"",
            ""    'argument': type('Mock', (object,), {}), # pragma: no cover"",
            ""    'return_stmt': type('Mock', (object,), {}), # pragma: no cover"",
            ""    'yield_expr': type('Mock', (object,), {}), # pragma: no cover"",
            ""    'testlist_star_expr': type('Mock', (object,), {}), # pragma: no cover"",
            ""    'star_expr': type('Mock', (object,), {}), # pragma: no cover"",
            ""    'annassign': type('Mock', (object,), {}), # pragma: no cover"",
            ""    'with_stmt': type('Mock', (object,), {}), # pragma: no cover"",
            ""    'atom': type('Mock', (object,), {}), # pragma: no cover"",
            ""    'testlist_gexp': type('Mock', (object,), {}), # pragma: no cover"",
            ""    'match_stmt': type('Mock', (object,), {}), # pragma: no cover"",
            ""    'except_clause': type('Mock', (object,), {}), # pragma: no cover"",
            ""    'subscriptlist': type('Mock', (object,), {}), # pragma: no cover"",
            ""    'trailer': type('Mock', (object,), {}), # pragma: no cover"",
            ""    'tname_star': type('Mock', (object,), {}) # pragma: no cover"",
            ""}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import symbol as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'f-strings' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement' # pragma: no cover"",
            ""    EXCEPT_STAR = 'except* clause' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic generics' # pragma: no cover"",
            ""node = type('Mock', (object,), { # pragma: no cover"",
            ""    'pre_order': lambda self: [], # pragma: no cover"",
            ""    'value': '', # pragma: no cover"",
            ""    'type': None, # pragma: no cover"",
            ""    'parent': None, # pragma: no cover"",
            ""    'children': [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and any(ch.isdigit() for ch in n.value) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return isinstance(n, type('Mock', (object,), {})) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS, # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def set_syms_attribute(name): # pragma: no cover"",
            ""    setattr(syms, name, type('Mock', (object,), {})) # pragma: no cover"",
            ""for attribute in ['typedargslist', 'arglist', 'varargslist', 'decorator', 'argument', 'return_stmt', 'yield_expr', 'testlist_star_expr', 'star_expr', 'annassign', 'with_stmt', 'atom', 'testlist_gexp', 'match_stmt', 'except_clause', 'subscriptlist', 'trailer', 'tname_star']: # pragma: no cover"",
            ""    set_syms_attribute(attribute) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'f-strings' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement' # pragma: no cover"",
            ""    EXCEPT_STAR = 'except* clause' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic generics' # pragma: no cover"",
            "" # pragma: no cover"",
            ""node = type('Mock', (object,), { # pragma: no cover"",
            ""    'pre_order': lambda self: [], # pragma: no cover"",
            ""    'value': '', # pragma: no cover"",
            ""    'type': None, # pragma: no cover"",
            ""    'parent': None, # pragma: no cover"",
            ""    'children': [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and any(ch.isdigit() for ch in n.value) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return isinstance(n, type('Mock', (object,), {})) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS, # pragma: no cover"",
            ""} # pragma: no cover"",
            ""SYMS = type('SYMS', (object,), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'varargslist': 'varargslist', # pragma: no cover"",
            ""    'decorator': 'decorator', # pragma: no cover"",
            ""    'argument': 'argument', # pragma: no cover"",
            ""    'return_stmt': 'return_stmt', # pragma: no cover"",
            ""    'yield_expr': 'yield_expr', # pragma: no cover"",
            ""    'testlist_star_expr': 'testlist_star_expr', # pragma: no cover"",
            ""    'star_expr': 'star_expr', # pragma: no cover"",
            ""    'annassign': 'annassign', # pragma: no cover"",
            ""    'with_stmt': 'with_stmt', # pragma: no cover"",
            ""    'atom': 'atom', # pragma: no cover"",
            ""    'testlist_gexp': 'testlist_gexp', # pragma: no cover"",
            ""    'match_stmt': 'match_stmt', # pragma: no cover"",
            ""    'except_clause': 'except_clause', # pragma: no cover"",
            ""    'subscriptlist': 'subscriptlist', # pragma: no cover"",
            ""    'trailer': 'trailer', # pragma: no cover"",
            ""    'tname_star': 'tname_star' # pragma: no cover"",
            ""}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'f-strings' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement' # pragma: no cover"",
            ""    EXCEPT_STAR = 'except* clause' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic generics' # pragma: no cover"",
            "" # pragma: no cover"",
            ""node = type('Mock', (object,), { # pragma: no cover"",
            ""    'pre_order': lambda self: [], # pragma: no cover"",
            ""    'value': '', # pragma: no cover"",
            ""    'type': None, # pragma: no cover"",
            ""    'parent': None, # pragma: no cover"",
            ""    'children': [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and any(ch.isdigit() for ch in n.value) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return isinstance(n, type('Mock', (object,), {})) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS, # pragma: no cover"",
            ""} # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'return_stmt': 6, # pragma: no cover"",
            ""    'yield_expr': 7, # pragma: no cover"",
            ""    'testlist_star_expr': 8, # pragma: no cover"",
            ""    'star_expr': 9, # pragma: no cover"",
            ""    'annassign': 10, # pragma: no cover"",
            ""    'with_stmt': 11, # pragma: no cover"",
            ""    'atom': 12, # pragma: no cover"",
            ""    'testlist_gexp': 13, # pragma: no cover"",
            ""    'match_stmt': 14, # pragma: no cover"",
            ""    'except_clause': 15, # pragma: no cover"",
            ""    'subscriptlist': 16, # pragma: no cover"",
            ""    'trailer': 17, # pragma: no cover"",
            ""    'tname_star': 18 # pragma: no cover"",
            ""}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import symtable as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'f-strings' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement' # pragma: no cover"",
            ""    EXCEPT_STAR = 'except* clause' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic generics' # pragma: no cover"",
            "" # pragma: no cover"",
            ""node = type('Mock', (object,), { # pragma: no cover"",
            ""    'pre_order': lambda self: [], # pragma: no cover"",
            ""    'value': '', # pragma: no cover"",
            ""    'type': None, # pragma: no cover"",
            ""    'parent': None, # pragma: no cover"",
            ""    'children': [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and any(ch.isdigit() for ch in n.value) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return isinstance(n, type('Mock', (object,), {})) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS, # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def set_syms_attribute(name): # pragma: no cover"",
            ""    setattr(syms, name, type('Mock', (object,), {})) # pragma: no cover"",
            ""for attribute in ['typedargslist', 'arglist', 'varargslist', 'decorator', 'argument', 'return_stmt', 'yield_expr', 'testlist_star_expr', 'star_expr', 'annassign', 'with_stmt', 'atom', 'testlist_gexp', 'match_stmt', 'except_clause', 'subscriptlist', 'trailer', 'tname_star']: # pragma: no cover"",
            ""    set_syms_attribute(attribute) # pragma: no cover"",
            "" # pragma: no cover"",
            ""features: Set[str] = set() # pragma: no cover""
        ]
    }
]",2,3920,0.00196,6837,0.0102555,0.0122155
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 69:
    if future_imports:
NameError: name 'future_imports' is not defined
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""from types import SimpleNamespace"",
            ""import token"",
            ""import symtable as syms""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""future_imports = {'annotations'}"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [], 'type': None, 'value': '', 'children': [], 'parent': None})()"",
            ""is_string_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: []"",
            ""is_number_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str) and n.value.isdigit()"",
            ""syms = type('Mock', (object,), {"",
            ""    'typedargslist': auto(),"",
            ""    'arglist': auto(),"",
            ""    'varargslist': auto(),"",
            ""    'decorator': auto(),"",
            ""    'argument': auto(),"",
            ""    'return_stmt': auto(),"",
            ""    'yield_expr': auto(),"",
            ""    'testlist_star_expr': auto(),"",
            ""    'star_expr': auto(),"",
            ""    'annassign': auto(),"",
            ""    'with_stmt': auto(),"",
            ""    'atom': auto(),"",
            ""    'testlist_gexp': auto(),"",
            ""    'match_stmt': auto(),"",
            ""    'except_clause': auto(),"",
            ""    'subscriptlist': auto(),"",
            ""    'trailer': auto(),"",
            ""    'tname_star': auto()"",
            ""})"",
            ""is_simple_decorator_expression = lambda expr: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""from types import SimpleNamespace"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""future_imports = {'annotations'}"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [], 'type': None, 'value': '', 'children': [], 'parent': None})()"",
            ""is_string_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: iter([])"",
            ""is_number_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str) and n.value.isdigit()"",
            ""syms = type('Mock', (object,), {"",
            ""    'typedargslist': auto(),"",
            ""    'arglist': auto(),"",
            ""    'varargslist': auto(),"",
            ""    'decorator': auto(),"",
            ""    'argument': auto(),"",
            ""    'return_stmt': auto(),"",
            ""    'yield_expr': auto(),"",
            ""    'testlist_star_expr': auto(),"",
            ""    'star_expr': auto(),"",
            ""    'annassign': auto(),"",
            ""    'with_stmt': auto(),"",
            ""    'atom': auto(),"",
            ""    'testlist_gexp': auto(),"",
            ""    'match_stmt': auto(),"",
            ""    'except_clause': auto(),"",
            ""    'subscriptlist': auto(),"",
            ""    'trailer': auto(),"",
            ""    'tname_star': auto()"",
            ""})"",
            ""is_simple_decorator_expression = lambda expr: True"",
            ""STARS = set([token.STAR, token.DOUBLESTAR])"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""future_imports = {'annotations'}"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [], 'value': '', 'type': None, 'children': [], 'parent': None})()"",
            ""is_string_token = lambda n: isinstance(n, type('Mock', (object,), {})) and hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: ((0, len(value)),)"",
            ""is_number_token = lambda n: isinstance(n, type('Mock', (object,), {})) and hasattr(n, 'value') and '_' in n.value"",
            ""syms = type('Mock', (object,), {"",
            ""    'typedargslist': auto(),"",
            ""    'arglist': auto(),"",
            ""    'varargslist': auto(),"",
            ""    'decorator': auto(),"",
            ""    'argument': auto(),"",
            ""    'return_stmt': auto(),"",
            ""    'yield_expr': auto(),"",
            ""    'testlist_star_expr': auto(),"",
            ""    'star_expr': auto(),"",
            ""    'annassign': auto(),"",
            ""    'with_stmt': auto(),"",
            ""    'atom': auto(),"",
            ""    'testlist_gexp': auto(),"",
            ""    'match_stmt': auto(),"",
            ""    'except_clause': auto(),"",
            ""    'subscriptlist': auto(),"",
            ""    'trailer': auto(),"",
            ""    'tname_star': auto()"",
            ""})"",
            ""is_simple_decorator_expression = lambda expr: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS"",
            ""}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""from types import SimpleNamespace"",
            ""import token"",
            ""import symtable as syms""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""future_imports = {'annotations'}"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [], 'type': None, 'children': [], 'parent': None})()"",
            ""is_string_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: iter([])"",
            ""is_number_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str) and n.value.isdigit()"",
            ""syms = type('Mock', (object,), {"",
            ""    'typedargslist': auto(),"",
            ""    'arglist': auto(),"",
            ""    'varargslist': auto(),"",
            ""    'decorator': auto(),"",
            ""    'argument': auto(),"",
            ""    'return_stmt': auto(),"",
            ""    'yield_expr': auto(),"",
            ""    'testlist_star_expr': auto(),"",
            ""    'star_expr': auto(),"",
            ""    'annassign': auto(),"",
            ""    'with_stmt': auto(),"",
            ""    'atom': auto(),"",
            ""    'testlist_gexp': auto(),"",
            ""    'match_stmt': auto(),"",
            ""    'except_clause': auto(),"",
            ""    'subscriptlist': auto(),"",
            ""    'trailer': auto(),"",
            ""    'tname_star': auto()"",
            ""})"",
            ""is_simple_decorator_expression = lambda expr: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""from types import SimpleNamespace"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""future_imports = ['annotations']"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [], 'type': None, 'children': [], 'parent': None, 'value': ''})()"",
            ""is_string_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: iter([(0, len(value))])"",
            ""is_number_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and any(ch.isdigit() for ch in n.value)"",
            ""syms = type('MockSyms', (object,), {"",
            ""    'typedargslist': auto(),"",
            ""    'arglist': auto(),"",
            ""    'varargslist': auto(),"",
            ""    'decorator': auto(),"",
            ""    'argument': auto(),"",
            ""    'return_stmt': auto(),"",
            ""    'yield_expr': auto(),"",
            ""    'testlist_star_expr': auto(),"",
            ""    'star_expr': auto(),"",
            ""    'annassign': auto(),"",
            ""    'with_stmt': auto(),"",
            ""    'atom': auto(),"",
            ""    'testlist_gexp': auto(),"",
            ""    'match_stmt': auto(),"",
            ""    'except_clause': auto(),"",
            ""    'subscriptlist': auto(),"",
            ""    'trailer': auto(),"",
            ""    'tname_star': auto()"",
            ""})"",
            ""is_simple_decorator_expression = lambda expr: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""from types import SimpleNamespace"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""future_imports = {'annotations'}"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [], 'type': None, 'children': [], 'parent': None})()"",
            ""is_string_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: iter([])"",
            ""is_number_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str) and n.value.isdigit()"",
            ""syms = type('Mock', (object,), {"",
            ""    'typedargslist': auto(),"",
            ""    'arglist': auto(),"",
            ""    'varargslist': auto(),"",
            ""    'decorator': auto(),"",
            ""    'argument': auto(),"",
            ""    'return_stmt': auto(),"",
            ""    'yield_expr': auto(),"",
            ""    'testlist_star_expr': auto(),"",
            ""    'star_expr': auto(),"",
            ""    'annassign': auto(),"",
            ""    'with_stmt': auto(),"",
            ""    'atom': auto(),"",
            ""    'testlist_gexp': auto(),"",
            ""    'match_stmt': auto(),"",
            ""    'except_clause': auto(),"",
            ""    'subscriptlist': auto(),"",
            ""    'trailer': auto(),"",
            ""    'tname_star': auto()"",
            ""})"",
            ""is_simple_decorator_expression = lambda expr: True"",
            ""STARS = set([token.STAR, token.DOUBLESTAR])"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""future_imports = {'annotations'}"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [], 'type': None, 'value': '', 'children': [], 'parent': None})()"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: iter([])"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.isdigit()"",
            ""syms = type('Mock', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'argument': 5,"",
            ""    'return_stmt': 6,"",
            ""    'yield_expr': 7,"",
            ""    'testlist_star_expr': 8,"",
            ""    'star_expr': 9,"",
            ""    'annassign': 10,"",
            ""    'with_stmt': 11,"",
            ""    'atom': 12,"",
            ""    'testlist_gexp': 13,"",
            ""    'match_stmt': 14,"",
            ""    'except_clause': 15,"",
            ""    'subscriptlist': 16,"",
            ""    'trailer': 17,"",
            ""    'tname_star': 18"",
            ""})"",
            ""is_simple_decorator_expression = lambda expr: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""future_imports = ['annotations']"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [], 'type': None, 'children': [], 'parent': None})()"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: iter([])"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and any(ch.isdigit() for ch in n.value)"",
            ""syms = type('Mock', (object,), {"",
            ""    'typedargslist': auto(),"",
            ""    'arglist': auto(),"",
            ""    'varargslist': auto(),"",
            ""    'decorator': auto(),"",
            ""    'argument': auto(),"",
            ""    'return_stmt': auto(),"",
            ""    'yield_expr': auto(),"",
            ""    'testlist_star_expr': auto(),"",
            ""    'star_expr': auto(),"",
            ""    'annassign': auto(),"",
            ""    'with_stmt': auto(),"",
            ""    'atom': auto(),"",
            ""    'testlist_gexp': auto(),"",
            ""    'match_stmt': auto(),"",
            ""    'except_clause': auto(),"",
            ""    'subscriptlist': auto(),"",
            ""    'trailer': auto(),"",
            ""    'tname_star': auto()"",
            ""})"",
            ""is_simple_decorator_expression = lambda expr: True"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""from types import SimpleNamespace"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""future_imports = {'annotations'}"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [], 'type': None, 'children': [], 'parent': None, 'value': ''})()"",
            ""is_string_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: iter([(0, len(value))])"",
            ""is_number_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit()"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': auto(),"",
            ""    'arglist': auto(),"",
            ""    'varargslist': auto(),"",
            ""    'decorator': auto(),"",
            ""    'argument': auto(),"",
            ""    'return_stmt': auto(),"",
            ""    'yield_expr': auto(),"",
            ""    'testlist_star_expr': auto(),"",
            ""    'star_expr': auto(),"",
            ""    'annassign': auto(),"",
            ""    'with_stmt': auto(),"",
            ""    'atom': auto(),"",
            ""    'testlist_gexp': auto(),"",
            ""    'match_stmt': auto(),"",
            ""    'except_clause': auto(),"",
            ""    'subscriptlist': auto(),"",
            ""    'trailer': auto(),"",
            ""    'tname_star': auto()"",
            ""})"",
            ""is_simple_decorator_expression = lambda expr: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""from types import SimpleNamespace"",
            ""import token"",
            ""import symtable as syms""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""future_imports = {'annotations'}"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [], 'type': None, 'children': [], 'parent': None})()"",
            ""is_string_token = lambda n: isinstance(n, SimpleNamespace) and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: iter([(0, len(value))])"",
            ""is_number_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str) and '_' in n.value"",
            ""syms = type('Mock', (object,), {"",
            ""    'typedargslist': auto(),"",
            ""    'arglist': auto(),"",
            ""    'varargslist': auto(),"",
            ""    'decorator': auto(),"",
            ""    'argument': auto(),"",
            ""    'return_stmt': auto(),"",
            ""    'yield_expr': auto(),"",
            ""    'testlist_star_expr': auto(),"",
            ""    'star_expr': auto(),"",
            ""    'annassign': auto(),"",
            ""    'with_stmt': auto(),"",
            ""    'atom': auto(),"",
            ""    'testlist_gexp': auto(),"",
            ""    'match_stmt': auto(),"",
            ""    'except_clause': auto(),"",
            ""    'subscriptlist': auto(),"",
            ""    'trailer': auto(),"",
            ""    'tname_star': auto()"",
            ""})"",
            ""is_simple_decorator_expression = lambda expr: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.PARENTHESIZED_CONTEXT_MANAGERS}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import symtable as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [], 'type': None, 'value': '', 'children': [], 'parent': None})() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str) and n.value.isdigit() # pragma: no cover"",
            ""syms = type('Mock', (object,), { # pragma: no cover"",
            ""    'typedargslist': auto(), # pragma: no cover"",
            ""    'arglist': auto(), # pragma: no cover"",
            ""    'varargslist': auto(), # pragma: no cover"",
            ""    'decorator': auto(), # pragma: no cover"",
            ""    'argument': auto(), # pragma: no cover"",
            ""    'return_stmt': auto(), # pragma: no cover"",
            ""    'yield_expr': auto(), # pragma: no cover"",
            ""    'testlist_star_expr': auto(), # pragma: no cover"",
            ""    'star_expr': auto(), # pragma: no cover"",
            ""    'annassign': auto(), # pragma: no cover"",
            ""    'with_stmt': auto(), # pragma: no cover"",
            ""    'atom': auto(), # pragma: no cover"",
            ""    'testlist_gexp': auto(), # pragma: no cover"",
            ""    'match_stmt': auto(), # pragma: no cover"",
            ""    'except_clause': auto(), # pragma: no cover"",
            ""    'subscriptlist': auto(), # pragma: no cover"",
            ""    'trailer': auto(), # pragma: no cover"",
            ""    'tname_star': auto() # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda expr: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [], 'type': None, 'value': '', 'children': [], 'parent': None})() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: iter([]) # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str) and n.value.isdigit() # pragma: no cover"",
            ""syms = type('Mock', (object,), { # pragma: no cover"",
            ""    'typedargslist': auto(), # pragma: no cover"",
            ""    'arglist': auto(), # pragma: no cover"",
            ""    'varargslist': auto(), # pragma: no cover"",
            ""    'decorator': auto(), # pragma: no cover"",
            ""    'argument': auto(), # pragma: no cover"",
            ""    'return_stmt': auto(), # pragma: no cover"",
            ""    'yield_expr': auto(), # pragma: no cover"",
            ""    'testlist_star_expr': auto(), # pragma: no cover"",
            ""    'star_expr': auto(), # pragma: no cover"",
            ""    'annassign': auto(), # pragma: no cover"",
            ""    'with_stmt': auto(), # pragma: no cover"",
            ""    'atom': auto(), # pragma: no cover"",
            ""    'testlist_gexp': auto(), # pragma: no cover"",
            ""    'match_stmt': auto(), # pragma: no cover"",
            ""    'except_clause': auto(), # pragma: no cover"",
            ""    'subscriptlist': auto(), # pragma: no cover"",
            ""    'trailer': auto(), # pragma: no cover"",
            ""    'tname_star': auto() # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda expr: True # pragma: no cover"",
            ""STARS = set([token.STAR, token.DOUBLESTAR]) # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [], 'value': '', 'type': None, 'children': [], 'parent': None})() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, type('Mock', (object,), {})) and hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: ((0, len(value)),) # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, type('Mock', (object,), {})) and hasattr(n, 'value') and '_' in n.value # pragma: no cover"",
            ""syms = type('Mock', (object,), { # pragma: no cover"",
            ""    'typedargslist': auto(), # pragma: no cover"",
            ""    'arglist': auto(), # pragma: no cover"",
            ""    'varargslist': auto(), # pragma: no cover"",
            ""    'decorator': auto(), # pragma: no cover"",
            ""    'argument': auto(), # pragma: no cover"",
            ""    'return_stmt': auto(), # pragma: no cover"",
            ""    'yield_expr': auto(), # pragma: no cover"",
            ""    'testlist_star_expr': auto(), # pragma: no cover"",
            ""    'star_expr': auto(), # pragma: no cover"",
            ""    'annassign': auto(), # pragma: no cover"",
            ""    'with_stmt': auto(), # pragma: no cover"",
            ""    'atom': auto(), # pragma: no cover"",
            ""    'testlist_gexp': auto(), # pragma: no cover"",
            ""    'match_stmt': auto(), # pragma: no cover"",
            ""    'except_clause': auto(), # pragma: no cover"",
            ""    'subscriptlist': auto(), # pragma: no cover"",
            ""    'trailer': auto(), # pragma: no cover"",
            ""    'tname_star': auto() # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda expr: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS # pragma: no cover"",
            ""} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import symtable as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [], 'type': None, 'children': [], 'parent': None})() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: iter([]) # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str) and n.value.isdigit() # pragma: no cover"",
            ""syms = type('Mock', (object,), { # pragma: no cover"",
            ""    'typedargslist': auto(), # pragma: no cover"",
            ""    'arglist': auto(), # pragma: no cover"",
            ""    'varargslist': auto(), # pragma: no cover"",
            ""    'decorator': auto(), # pragma: no cover"",
            ""    'argument': auto(), # pragma: no cover"",
            ""    'return_stmt': auto(), # pragma: no cover"",
            ""    'yield_expr': auto(), # pragma: no cover"",
            ""    'testlist_star_expr': auto(), # pragma: no cover"",
            ""    'star_expr': auto(), # pragma: no cover"",
            ""    'annassign': auto(), # pragma: no cover"",
            ""    'with_stmt': auto(), # pragma: no cover"",
            ""    'atom': auto(), # pragma: no cover"",
            ""    'testlist_gexp': auto(), # pragma: no cover"",
            ""    'match_stmt': auto(), # pragma: no cover"",
            ""    'except_clause': auto(), # pragma: no cover"",
            ""    'subscriptlist': auto(), # pragma: no cover"",
            ""    'trailer': auto(), # pragma: no cover"",
            ""    'tname_star': auto() # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda expr: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [], 'type': None, 'children': [], 'parent': None, 'value': ''})() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: iter([(0, len(value))]) # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and any(ch.isdigit() for ch in n.value) # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'typedargslist': auto(), # pragma: no cover"",
            ""    'arglist': auto(), # pragma: no cover"",
            ""    'varargslist': auto(), # pragma: no cover"",
            ""    'decorator': auto(), # pragma: no cover"",
            ""    'argument': auto(), # pragma: no cover"",
            ""    'return_stmt': auto(), # pragma: no cover"",
            ""    'yield_expr': auto(), # pragma: no cover"",
            ""    'testlist_star_expr': auto(), # pragma: no cover"",
            ""    'star_expr': auto(), # pragma: no cover"",
            ""    'annassign': auto(), # pragma: no cover"",
            ""    'with_stmt': auto(), # pragma: no cover"",
            ""    'atom': auto(), # pragma: no cover"",
            ""    'testlist_gexp': auto(), # pragma: no cover"",
            ""    'match_stmt': auto(), # pragma: no cover"",
            ""    'except_clause': auto(), # pragma: no cover"",
            ""    'subscriptlist': auto(), # pragma: no cover"",
            ""    'trailer': auto(), # pragma: no cover"",
            ""    'tname_star': auto() # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda expr: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [], 'type': None, 'children': [], 'parent': None})() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: iter([]) # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str) and n.value.isdigit() # pragma: no cover"",
            ""syms = type('Mock', (object,), { # pragma: no cover"",
            ""    'typedargslist': auto(), # pragma: no cover"",
            ""    'arglist': auto(), # pragma: no cover"",
            ""    'varargslist': auto(), # pragma: no cover"",
            ""    'decorator': auto(), # pragma: no cover"",
            ""    'argument': auto(), # pragma: no cover"",
            ""    'return_stmt': auto(), # pragma: no cover"",
            ""    'yield_expr': auto(), # pragma: no cover"",
            ""    'testlist_star_expr': auto(), # pragma: no cover"",
            ""    'star_expr': auto(), # pragma: no cover"",
            ""    'annassign': auto(), # pragma: no cover"",
            ""    'with_stmt': auto(), # pragma: no cover"",
            ""    'atom': auto(), # pragma: no cover"",
            ""    'testlist_gexp': auto(), # pragma: no cover"",
            ""    'match_stmt': auto(), # pragma: no cover"",
            ""    'except_clause': auto(), # pragma: no cover"",
            ""    'subscriptlist': auto(), # pragma: no cover"",
            ""    'trailer': auto(), # pragma: no cover"",
            ""    'tname_star': auto() # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda expr: True # pragma: no cover"",
            ""STARS = set([token.STAR, token.DOUBLESTAR]) # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [], 'type': None, 'value': '', 'children': [], 'parent': None})() # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: iter([]) # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.isdigit() # pragma: no cover"",
            ""syms = type('Mock', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'return_stmt': 6, # pragma: no cover"",
            ""    'yield_expr': 7, # pragma: no cover"",
            ""    'testlist_star_expr': 8, # pragma: no cover"",
            ""    'star_expr': 9, # pragma: no cover"",
            ""    'annassign': 10, # pragma: no cover"",
            ""    'with_stmt': 11, # pragma: no cover"",
            ""    'atom': 12, # pragma: no cover"",
            ""    'testlist_gexp': 13, # pragma: no cover"",
            ""    'match_stmt': 14, # pragma: no cover"",
            ""    'except_clause': 15, # pragma: no cover"",
            ""    'subscriptlist': 16, # pragma: no cover"",
            ""    'trailer': 17, # pragma: no cover"",
            ""    'tname_star': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda expr: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [], 'type': None, 'children': [], 'parent': None})() # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: iter([]) # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and any(ch.isdigit() for ch in n.value) # pragma: no cover"",
            ""syms = type('Mock', (object,), { # pragma: no cover"",
            ""    'typedargslist': auto(), # pragma: no cover"",
            ""    'arglist': auto(), # pragma: no cover"",
            ""    'varargslist': auto(), # pragma: no cover"",
            ""    'decorator': auto(), # pragma: no cover"",
            ""    'argument': auto(), # pragma: no cover"",
            ""    'return_stmt': auto(), # pragma: no cover"",
            ""    'yield_expr': auto(), # pragma: no cover"",
            ""    'testlist_star_expr': auto(), # pragma: no cover"",
            ""    'star_expr': auto(), # pragma: no cover"",
            ""    'annassign': auto(), # pragma: no cover"",
            ""    'with_stmt': auto(), # pragma: no cover"",
            ""    'atom': auto(), # pragma: no cover"",
            ""    'testlist_gexp': auto(), # pragma: no cover"",
            ""    'match_stmt': auto(), # pragma: no cover"",
            ""    'except_clause': auto(), # pragma: no cover"",
            ""    'subscriptlist': auto(), # pragma: no cover"",
            ""    'trailer': auto(), # pragma: no cover"",
            ""    'tname_star': auto() # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda expr: True # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [], 'type': None, 'children': [], 'parent': None, 'value': ''})() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: iter([(0, len(value))]) # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': auto(), # pragma: no cover"",
            ""    'arglist': auto(), # pragma: no cover"",
            ""    'varargslist': auto(), # pragma: no cover"",
            ""    'decorator': auto(), # pragma: no cover"",
            ""    'argument': auto(), # pragma: no cover"",
            ""    'return_stmt': auto(), # pragma: no cover"",
            ""    'yield_expr': auto(), # pragma: no cover"",
            ""    'testlist_star_expr': auto(), # pragma: no cover"",
            ""    'star_expr': auto(), # pragma: no cover"",
            ""    'annassign': auto(), # pragma: no cover"",
            ""    'with_stmt': auto(), # pragma: no cover"",
            ""    'atom': auto(), # pragma: no cover"",
            ""    'testlist_gexp': auto(), # pragma: no cover"",
            ""    'match_stmt': auto(), # pragma: no cover"",
            ""    'except_clause': auto(), # pragma: no cover"",
            ""    'subscriptlist': auto(), # pragma: no cover"",
            ""    'trailer': auto(), # pragma: no cover"",
            ""    'tname_star': auto() # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda expr: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import symtable as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [], 'type': None, 'children': [], 'parent': None})() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, SimpleNamespace) and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: iter([(0, len(value))]) # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""syms = type('Mock', (object,), { # pragma: no cover"",
            ""    'typedargslist': auto(), # pragma: no cover"",
            ""    'arglist': auto(), # pragma: no cover"",
            ""    'varargslist': auto(), # pragma: no cover"",
            ""    'decorator': auto(), # pragma: no cover"",
            ""    'argument': auto(), # pragma: no cover"",
            ""    'return_stmt': auto(), # pragma: no cover"",
            ""    'yield_expr': auto(), # pragma: no cover"",
            ""    'testlist_star_expr': auto(), # pragma: no cover"",
            ""    'star_expr': auto(), # pragma: no cover"",
            ""    'annassign': auto(), # pragma: no cover"",
            ""    'with_stmt': auto(), # pragma: no cover"",
            ""    'atom': auto(), # pragma: no cover"",
            ""    'testlist_gexp': auto(), # pragma: no cover"",
            ""    'match_stmt': auto(), # pragma: no cover"",
            ""    'except_clause': auto(), # pragma: no cover"",
            ""    'subscriptlist': auto(), # pragma: no cover"",
            ""    'trailer': auto(), # pragma: no cover"",
            ""    'tname_star': auto() # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda expr: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.PARENTHESIZED_CONTEXT_MANAGERS} # pragma: no cover""
        ]
    }
]",2,4816,0.002408,6155,0.0092325,0.0116405
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 68:
    if future_imports:
NameError: name 'future_imports' is not defined
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set, Any"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'F_STRINGS'"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = ['annotations']"",
            ""node = type('MockNode', (object,), {"",
            ""    'pre_order': lambda self: [SimpleNamespace(value='f\""{x=}\""', type=token.STRING)]})()"",
            ""is_string_token = lambda n: isinstance(n.value, str) if hasattr(n, 'value') else False"",
            ""iter_fexpr_spans = lambda s: [(m.start(), m.end()) for m in re.finditer(r'\\{.*?\\}', s)]"",
            ""is_number_token = lambda n: isinstance(n.value, str) and n.value.replace('_', '').isdigit()"",
            ""syms = type('syms', (), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'argument': 5,"",
            ""    'return_stmt': 6,"",
            ""    'yield_expr': 7,"",
            ""    'testlist_star_expr': 8,"",
            ""    'star_expr': 9,"",
            ""    'annassign': 10,"",
            ""    'with_stmt': 11,"",
            ""    'atom': 12,"",
            ""    'testlist_gexp': 13,"",
            ""    'match_stmt': 14,"",
            ""    'except_clause': 15,"",
            ""    'subscriptlist': 16,"",
            ""    'trailer': 17,"",
            ""    'tname_star': 18"",
            ""})"",
            ""is_simple_decorator_expression = lambda n: False"",
            ""STARS = {'STAR', 'DOUBLESTAR'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import re""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'f-strings'"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings'"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals'"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions'"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax'"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls'"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers'"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement'"",
            ""    EXCEPT_STAR = 'except* clause'"",
            ""    VARIADIC_GENERICS = 'variadic generics'"",
            """",
            ""future_imports = {'annotations'}"",
            ""node = type('MockNode', (object,), {"",
            ""    'pre_order': lambda self: [],"",
            ""    'type': None,"",
            ""    'value': '',"",
            ""    'children': [],"",
            ""    'parent': None"",
            ""})()"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):"",
            ""    return [(m.start(), m.end()) for m in re.finditer(r'{.*?}', value)]"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and any(char.isdigit() for char in n.value)"",
            ""syms = type('MockSyms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'argument': 5,"",
            ""    'return_stmt': 6,"",
            ""    'yield_expr': 7,"",
            ""    'testlist_star_expr': 8,"",
            ""    'star_expr': 9,"",
            ""    'annassign': 10,"",
            ""    'with_stmt': 11,"",
            ""    'atom': 12,"",
            ""    'testlist_gexp': 13,"",
            ""    'match_stmt': 14,"",
            ""    'except_clause': 15,"",
            ""    'subscriptlist': 16,"",
            ""    'trailer': 17,"",
            ""    'tname_star': 18"",
            ""})"",
            ""def is_simple_decorator_expression(n):"",
            ""    return isinstance(n, type('Mock', (object,), {}))"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from types import SimpleNamespace"",
            ""import token""
        ],
        ""initialization"": [
            ""Feature = type('Feature', (object,), {"",
            ""    'F_STRINGS': 1,"",
            ""    'DEBUG_F_STRINGS': 2,"",
            ""    'NUMERIC_UNDERSCORES': 3,"",
            ""    'POS_ONLY_ARGUMENTS': 4,"",
            ""    'ASSIGNMENT_EXPRESSIONS': 5,"",
            ""    'RELAXED_DECORATORS': 6,"",
            ""    'TRAILING_COMMA_IN_DEF': 7,"",
            ""    'TRAILING_COMMA_IN_CALL': 8,"",
            ""    'UNPACKING_ON_FLOW': 9,"",
            ""    'ANN_ASSIGN_EXTENDED_RHS': 10,"",
            ""    'PARENTHESIZED_CONTEXT_MANAGERS': 11,"",
            ""    'PATTERN_MATCHING': 12,"",
            ""    'EXCEPT_STAR': 13,"",
            ""    'VARIADIC_GENERICS': 14"",
            ""})"",
            ""future_imports = {'annotations'}"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, value='', children=[], parent=None)"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(m.start(), m.end()) for m in re.finditer(r'{.*?}', s)]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit()"",
            ""syms = SimpleNamespace(typedargslist=1, arglist=2, varargslist=3, decorator=4, argument=5, return_stmt=6, yield_expr=7, testlist_star_expr=8, star_expr=9, annassign=10, with_stmt=11, atom=12, testlist_gexp=13, match_stmt=14, except_clause=15, subscriptlist=16, trailer=17, tname_star=18)"",
            ""is_simple_decorator_expression = lambda n: False"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import re""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'f-strings'"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings'"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals'"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions'"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax'"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls'"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers'"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement'"",
            ""    EXCEPT_STAR = 'except* clause'"",
            ""    VARIADIC_GENERICS = 'variadic generics'"",
            ""future_imports = {'annotations'}"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [], 'value': '', 'type': None, 'children': [], 'parent': None})()"",
            ""is_string_token = lambda n: isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(m.start(), m.end()) for m in re.finditer(r'{.*?}', s)]"",
            ""is_number_token = lambda n: n.value.replace('_', '').isdigit()"",
            ""syms = type('syms', (), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'varargslist': 'varargslist',"",
            ""    'decorator': 'decorator',"",
            ""    'argument': 'argument',"",
            ""    'return_stmt': 'return_stmt',"",
            ""    'yield_expr': 'yield_expr',"",
            ""    'testlist_star_expr': 'testlist_star_expr',"",
            ""    'star_expr': 'star_expr',"",
            ""    'annassign': 'annassign',"",
            ""    'with_stmt': 'with_stmt',"",
            ""    'atom': 'atom',"",
            ""    'testlist_gexp': 'testlist_gexp',"",
            ""    'match_stmt': 'match_stmt',"",
            ""    'except_clause': 'except_clause',"",
            ""    'subscriptlist': 'subscriptlist',"",
            ""    'trailer': 'trailer',"",
            ""    'tname_star': 'tname_star'"",
            ""})"",
            ""is_simple_decorator_expression = lambda n: False"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import re""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'F_STRINGS'"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = {'annotations'}"",
            ""node = type('MockNode', (object,), {"",
            ""    'pre_order': lambda self: [],"",
            ""    'value': '',"",
            ""    'type': None,"",
            ""    'parent': None,"",
            ""    'children': [],"",
            ""})()"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):"",
            ""    return [(m.start(), m.end()) for m in re.finditer(r'{.*?}', value)]"",
            ""def is_number_token(n):"",
            ""    return n.value.replace('_', '').isdigit()"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'varargslist': 'varargslist',"",
            ""    'decorator': 'decorator',"",
            ""    'argument': 'argument',"",
            ""    'return_stmt': 'return_stmt',"",
            ""    'yield_expr': 'yield_expr',"",
            ""    'testlist_star_expr': 'testlist_star_expr',"",
            ""    'star_expr': 'star_expr',"",
            ""    'annassign': 'annassign',"",
            ""    'with_stmt': 'with_stmt',"",
            ""    'atom': 'atom',"",
            ""    'testlist_gexp': 'testlist_gexp',"",
            ""    'match_stmt': 'match_stmt',"",
            ""    'except_clause': 'except_clause',"",
            ""    'subscriptlist': 'subscriptlist',"",
            ""    'trailer': 'trailer',"",
            ""    'tname_star': 'tname_star'"",
            ""})"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from types import SimpleNamespace"",
            ""import token"",
            ""import re""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'f-strings'"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings'"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals'"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions'"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax'"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls'"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers'"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement'"",
            ""    EXCEPT_STAR = 'except* clause'"",
            ""    VARIADIC_GENERICS = 'variadic generics'"",
            """",
            ""future_imports = {'annotations'}"",
            ""node = SimpleNamespace(pre_order=lambda: [], value='', type=None, children=[], parent=None)"",
            ""def is_string_token(n):"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(s):"",
            ""    return [(m.start(), m.end()) for m in re.finditer(r'{.*?}', s)]"",
            ""def is_number_token(n):"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit()"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}"",
            ""syms = type('MockSyms', (object,), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'varargslist': 'varargslist',"",
            ""    'decorator': 'decorator',"",
            ""    'argument': 'argument',"",
            ""    'return_stmt': 'return_stmt',"",
            ""    'yield_expr': 'yield_expr',"",
            ""    'testlist_star_expr': 'testlist_star_expr',"",
            ""    'star_expr': 'star_expr',"",
            ""    'annassign': 'annassign',"",
            ""    'with_stmt': 'with_stmt',"",
            ""    'atom': 'atom',"",
            ""    'testlist_gexp': 'testlist_gexp',"",
            ""    'match_stmt': 'match_stmt',"",
            ""    'except_clause': 'except_clause',"",
            ""    'subscriptlist': 'subscriptlist',"",
            ""    'trailer': 'trailer',"",
            ""    'tname_star': 'tname_star'"",
            ""})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from types import SimpleNamespace"",
            ""import re"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'f-strings'"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings'"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals'"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expression'"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax'"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls'"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers'"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement'"",
            ""    EXCEPT_STAR = 'except* clause'"",
            ""    VARIADIC_GENERICS = 'variadic generics'"",
            """",
            ""future_imports = {'annotations'}"",
            ""node = SimpleNamespace(pre_order=lambda: [], value='', type=None, children=[], parent=None)"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(m.start(), m.end()) for m in re.finditer(r'{.*?}', s)]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit()"",
            ""syms = SimpleNamespace("",
            ""    typedargslist='typedargslist',"",
            ""    arglist='arglist',"",
            ""    varargslist='varargslist',"",
            ""    decorator='decorator',"",
            ""    argument='argument',"",
            ""    return_stmt='return_stmt',"",
            ""    yield_expr='yield_expr',"",
            ""    testlist_star_expr='testlist_star_expr',"",
            ""    star_expr='star_expr',"",
            ""    annassign='annassign',"",
            ""    with_stmt='with_stmt',"",
            ""    atom='atom',"",
            ""    testlist_gexp='testlist_gexp',"",
            ""    match_stmt='match_stmt',"",
            ""    except_clause='except_clause',"",
            ""    subscriptlist='subscriptlist',"",
            ""    trailer='trailer',"",
            ""    tname_star='tname_star')"",
            ""is_simple_decorator_expression = lambda n: False"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import re""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'f-strings'"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings'"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals'"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions'"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax'"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls'"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers'"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement'"",
            ""    EXCEPT_STAR = 'except* clause'"",
            ""    VARIADIC_GENERICS = 'variadic generics'"",
            ""future_imports = {'annotations'}"",
            ""class Node:"",
            ""    def __init__(self):"",
            ""        self.type = None"",
            ""        self.value = None"",
            ""        self.children = []"",
            ""        self.parent = None"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""node = Node()"",
            ""is_string_token = lambda n: isinstance(n.value, str) if hasattr(n, 'value') else False"",
            ""iter_fexpr_spans = lambda s: [(m.start(), m.end()) for m in re.finditer(r'{.*?}', s)]"",
            ""is_number_token = lambda n: isinstance(n.value, str) and n.value.replace('_', '').isdigit() if hasattr(n, 'value') else False"",
            ""class Syms:"",
            ""    typedargslist = 'typedargslist'"",
            ""    arglist = 'arglist'"",
            ""    varargslist = 'varargslist'"",
            ""    decorator = 'decorator'"",
            ""    argument = 'argument'"",
            ""    return_stmt = 'return_stmt'"",
            ""    yield_expr = 'yield_expr'"",
            ""    testlist_star_expr = 'testlist_star_expr'"",
            ""    star_expr = 'star_expr'"",
            ""    annassign = 'annassign'"",
            ""    with_stmt = 'with_stmt'"",
            ""    atom = 'atom'"",
            ""    testlist_gexp = 'testlist_gexp'"",
            ""    match_stmt = 'match_stmt'"",
            ""    except_clause = 'except_clause'"",
            ""    subscriptlist = 'subscriptlist'"",
            ""    trailer = 'trailer'"",
            ""    tname_star = 'tname_star'"",
            ""syms = Syms()"",
            ""is_simple_decorator_expression = lambda expr: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'F_STRINGS'"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = {'annotations'}"",
            ""node = type('MockNode', (object,), {"",
            ""    'pre_order': lambda self: [],"",
            ""    'value': '',"",
            ""    'type': None,"",
            ""    'parent': None,"",
            ""    'children': []"",
            ""})()"",
            ""is_string_token = lambda n: isinstance(n, type('MockNode', (object,), {}))"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))]"",
            ""is_number_token = lambda n: isinstance(n, type('MockNode', (object,), {})) and n.value.isdigit()"",
            ""syms = type('MockSyms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'argument': 5,"",
            ""    'return_stmt': 6,"",
            ""    'yield_expr': 7,"",
            ""    'testlist_star_expr': 8,"",
            ""    'star_expr': 9,"",
            ""    'annassign': 10,"",
            ""    'with_stmt': 11,"",
            ""    'atom': 12,"",
            ""    'testlist_gexp': 13,"",
            ""    'match_stmt': 14,"",
            ""    'except_clause': 15,"",
            ""    'subscriptlist': 16,"",
            ""    'trailer': 17,"",
            ""    'tname_star': 18"",
            ""})"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from types import SimpleNamespace"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'F_STRINGS'"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = {'annotations'}"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, value='', children=[], parent=None)"",
            ""is_string_token = lambda n: isinstance(n, SimpleNamespace) and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))]"",
            ""is_number_token = lambda n: isinstance(n, SimpleNamespace) and isinstance(n.value, str) and n.value.replace('_', '').isdigit()"",
            ""syms = SimpleNamespace("",
            ""    typedargslist=1, arglist=2, varargslist=3, decorator=4, argument=5, return_stmt=6,"",
            ""    yield_expr=7, testlist_star_expr=8, star_expr=9, annassign=10,"",
            ""    with_stmt=11, atom=12, testlist_gexp=13, match_stmt=14, except_clause=15,"",
            ""    subscriptlist=16, trailer=17, tname_star=18"",
            "")"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set, Any # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING' # pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""node = type('MockNode', (object,), { # pragma: no cover"",
            ""    'pre_order': lambda self: [SimpleNamespace(value='f\""{x=}\""', type=token.STRING)]})() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n.value, str) if hasattr(n, 'value') else False # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(m.start(), m.end()) for m in re.finditer(r'\\{.*?\\}', s)] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n.value, str) and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""syms = type('syms', (), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'return_stmt': 6, # pragma: no cover"",
            ""    'yield_expr': 7, # pragma: no cover"",
            ""    'testlist_star_expr': 8, # pragma: no cover"",
            ""    'star_expr': 9, # pragma: no cover"",
            ""    'annassign': 10, # pragma: no cover"",
            ""    'with_stmt': 11, # pragma: no cover"",
            ""    'atom': 12, # pragma: no cover"",
            ""    'testlist_gexp': 13, # pragma: no cover"",
            ""    'match_stmt': 14, # pragma: no cover"",
            ""    'except_clause': 15, # pragma: no cover"",
            ""    'subscriptlist': 16, # pragma: no cover"",
            ""    'trailer': 17, # pragma: no cover"",
            ""    'tname_star': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: False # pragma: no cover"",
            ""STARS = {'STAR', 'DOUBLESTAR'} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'f-strings' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement' # pragma: no cover"",
            ""    EXCEPT_STAR = 'except* clause' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic generics' # pragma: no cover"",
            "" # pragma: no cover"",
            ""node = type('MockNode', (object,), { # pragma: no cover"",
            ""    'pre_order': lambda self: [], # pragma: no cover"",
            ""    'type': None, # pragma: no cover"",
            ""    'value': '', # pragma: no cover"",
            ""    'children': [], # pragma: no cover"",
            ""    'parent': None # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return [(m.start(), m.end()) for m in re.finditer(r'{.*?}', value)] # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and any(char.isdigit() for char in n.value) # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'return_stmt': 6, # pragma: no cover"",
            ""    'yield_expr': 7, # pragma: no cover"",
            ""    'testlist_star_expr': 8, # pragma: no cover"",
            ""    'star_expr': 9, # pragma: no cover"",
            ""    'annassign': 10, # pragma: no cover"",
            ""    'with_stmt': 11, # pragma: no cover"",
            ""    'atom': 12, # pragma: no cover"",
            ""    'testlist_gexp': 13, # pragma: no cover"",
            ""    'match_stmt': 14, # pragma: no cover"",
            ""    'except_clause': 15, # pragma: no cover"",
            ""    'subscriptlist': 16, # pragma: no cover"",
            ""    'trailer': 17, # pragma: no cover"",
            ""    'tname_star': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return isinstance(n, type('Mock', (object,), {})) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = type('Feature', (object,), { # pragma: no cover"",
            ""    'F_STRINGS': 1, # pragma: no cover"",
            ""    'DEBUG_F_STRINGS': 2, # pragma: no cover"",
            ""    'NUMERIC_UNDERSCORES': 3, # pragma: no cover"",
            ""    'POS_ONLY_ARGUMENTS': 4, # pragma: no cover"",
            ""    'ASSIGNMENT_EXPRESSIONS': 5, # pragma: no cover"",
            ""    'RELAXED_DECORATORS': 6, # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 7, # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 8, # pragma: no cover"",
            ""    'UNPACKING_ON_FLOW': 9, # pragma: no cover"",
            ""    'ANN_ASSIGN_EXTENDED_RHS': 10, # pragma: no cover"",
            ""    'PARENTHESIZED_CONTEXT_MANAGERS': 11, # pragma: no cover"",
            ""    'PATTERN_MATCHING': 12, # pragma: no cover"",
            ""    'EXCEPT_STAR': 13, # pragma: no cover"",
            ""    'VARIADIC_GENERICS': 14 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, value='', children=[], parent=None) # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(m.start(), m.end()) for m in re.finditer(r'{.*?}', s)] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""syms = SimpleNamespace(typedargslist=1, arglist=2, varargslist=3, decorator=4, argument=5, return_stmt=6, yield_expr=7, testlist_star_expr=8, star_expr=9, annassign=10, with_stmt=11, atom=12, testlist_gexp=13, match_stmt=14, except_clause=15, subscriptlist=16, trailer=17, tname_star=18) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: False # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'f-strings' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement' # pragma: no cover"",
            ""    EXCEPT_STAR = 'except* clause' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic generics' # pragma: no cover"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [], 'value': '', 'type': None, 'children': [], 'parent': None})() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(m.start(), m.end()) for m in re.finditer(r'{.*?}', s)] # pragma: no cover"",
            ""is_number_token = lambda n: n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""syms = type('syms', (), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'varargslist': 'varargslist', # pragma: no cover"",
            ""    'decorator': 'decorator', # pragma: no cover"",
            ""    'argument': 'argument', # pragma: no cover"",
            ""    'return_stmt': 'return_stmt', # pragma: no cover"",
            ""    'yield_expr': 'yield_expr', # pragma: no cover"",
            ""    'testlist_star_expr': 'testlist_star_expr', # pragma: no cover"",
            ""    'star_expr': 'star_expr', # pragma: no cover"",
            ""    'annassign': 'annassign', # pragma: no cover"",
            ""    'with_stmt': 'with_stmt', # pragma: no cover"",
            ""    'atom': 'atom', # pragma: no cover"",
            ""    'testlist_gexp': 'testlist_gexp', # pragma: no cover"",
            ""    'match_stmt': 'match_stmt', # pragma: no cover"",
            ""    'except_clause': 'except_clause', # pragma: no cover"",
            ""    'subscriptlist': 'subscriptlist', # pragma: no cover"",
            ""    'trailer': 'trailer', # pragma: no cover"",
            ""    'tname_star': 'tname_star' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: False # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING' # pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""node = type('MockNode', (object,), { # pragma: no cover"",
            ""    'pre_order': lambda self: [], # pragma: no cover"",
            ""    'value': '', # pragma: no cover"",
            ""    'type': None, # pragma: no cover"",
            ""    'parent': None, # pragma: no cover"",
            ""    'children': [], # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return [(m.start(), m.end()) for m in re.finditer(r'{.*?}', value)] # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'varargslist': 'varargslist', # pragma: no cover"",
            ""    'decorator': 'decorator', # pragma: no cover"",
            ""    'argument': 'argument', # pragma: no cover"",
            ""    'return_stmt': 'return_stmt', # pragma: no cover"",
            ""    'yield_expr': 'yield_expr', # pragma: no cover"",
            ""    'testlist_star_expr': 'testlist_star_expr', # pragma: no cover"",
            ""    'star_expr': 'star_expr', # pragma: no cover"",
            ""    'annassign': 'annassign', # pragma: no cover"",
            ""    'with_stmt': 'with_stmt', # pragma: no cover"",
            ""    'atom': 'atom', # pragma: no cover"",
            ""    'testlist_gexp': 'testlist_gexp', # pragma: no cover"",
            ""    'match_stmt': 'match_stmt', # pragma: no cover"",
            ""    'except_clause': 'except_clause', # pragma: no cover"",
            ""    'subscriptlist': 'subscriptlist', # pragma: no cover"",
            ""    'trailer': 'trailer', # pragma: no cover"",
            ""    'tname_star': 'tname_star' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'f-strings' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement' # pragma: no cover"",
            ""    EXCEPT_STAR = 'except* clause' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic generics' # pragma: no cover"",
            "" # pragma: no cover"",
            ""node = SimpleNamespace(pre_order=lambda: [], value='', type=None, children=[], parent=None) # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(s): # pragma: no cover"",
            ""    return [(m.start(), m.end()) for m in re.finditer(r'{.*?}', s)] # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'varargslist': 'varargslist', # pragma: no cover"",
            ""    'decorator': 'decorator', # pragma: no cover"",
            ""    'argument': 'argument', # pragma: no cover"",
            ""    'return_stmt': 'return_stmt', # pragma: no cover"",
            ""    'yield_expr': 'yield_expr', # pragma: no cover"",
            ""    'testlist_star_expr': 'testlist_star_expr', # pragma: no cover"",
            ""    'star_expr': 'star_expr', # pragma: no cover"",
            ""    'annassign': 'annassign', # pragma: no cover"",
            ""    'with_stmt': 'with_stmt', # pragma: no cover"",
            ""    'atom': 'atom', # pragma: no cover"",
            ""    'testlist_gexp': 'testlist_gexp', # pragma: no cover"",
            ""    'match_stmt': 'match_stmt', # pragma: no cover"",
            ""    'except_clause': 'except_clause', # pragma: no cover"",
            ""    'subscriptlist': 'subscriptlist', # pragma: no cover"",
            ""    'trailer': 'trailer', # pragma: no cover"",
            ""    'tname_star': 'tname_star' # pragma: no cover"",
            ""}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover"",
            ""import re # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'f-strings' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expression' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement' # pragma: no cover"",
            ""    EXCEPT_STAR = 'except* clause' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic generics' # pragma: no cover"",
            "" # pragma: no cover"",
            ""node = SimpleNamespace(pre_order=lambda: [], value='', type=None, children=[], parent=None) # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(m.start(), m.end()) for m in re.finditer(r'{.*?}', s)] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""syms = SimpleNamespace( # pragma: no cover"",
            ""    typedargslist='typedargslist', # pragma: no cover"",
            ""    arglist='arglist', # pragma: no cover"",
            ""    varargslist='varargslist', # pragma: no cover"",
            ""    decorator='decorator', # pragma: no cover"",
            ""    argument='argument', # pragma: no cover"",
            ""    return_stmt='return_stmt', # pragma: no cover"",
            ""    yield_expr='yield_expr', # pragma: no cover"",
            ""    testlist_star_expr='testlist_star_expr', # pragma: no cover"",
            ""    star_expr='star_expr', # pragma: no cover"",
            ""    annassign='annassign', # pragma: no cover"",
            ""    with_stmt='with_stmt', # pragma: no cover"",
            ""    atom='atom', # pragma: no cover"",
            ""    testlist_gexp='testlist_gexp', # pragma: no cover"",
            ""    match_stmt='match_stmt', # pragma: no cover"",
            ""    except_clause='except_clause', # pragma: no cover"",
            ""    subscriptlist='subscriptlist', # pragma: no cover"",
            ""    trailer='trailer', # pragma: no cover"",
            ""    tname_star='tname_star') # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: False # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'f-strings' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement' # pragma: no cover"",
            ""    EXCEPT_STAR = 'except* clause' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic generics' # pragma: no cover"",
            ""class Node: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.type = None # pragma: no cover"",
            ""        self.value = None # pragma: no cover"",
            ""        self.children = [] # pragma: no cover"",
            ""        self.parent = None # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""node = Node() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n.value, str) if hasattr(n, 'value') else False # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(m.start(), m.end()) for m in re.finditer(r'{.*?}', s)] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n.value, str) and n.value.replace('_', '').isdigit() if hasattr(n, 'value') else False # pragma: no cover"",
            ""class Syms: # pragma: no cover"",
            ""    typedargslist = 'typedargslist' # pragma: no cover"",
            ""    arglist = 'arglist' # pragma: no cover"",
            ""    varargslist = 'varargslist' # pragma: no cover"",
            ""    decorator = 'decorator' # pragma: no cover"",
            ""    argument = 'argument' # pragma: no cover"",
            ""    return_stmt = 'return_stmt' # pragma: no cover"",
            ""    yield_expr = 'yield_expr' # pragma: no cover"",
            ""    testlist_star_expr = 'testlist_star_expr' # pragma: no cover"",
            ""    star_expr = 'star_expr' # pragma: no cover"",
            ""    annassign = 'annassign' # pragma: no cover"",
            ""    with_stmt = 'with_stmt' # pragma: no cover"",
            ""    atom = 'atom' # pragma: no cover"",
            ""    testlist_gexp = 'testlist_gexp' # pragma: no cover"",
            ""    match_stmt = 'match_stmt' # pragma: no cover"",
            ""    except_clause = 'except_clause' # pragma: no cover"",
            ""    subscriptlist = 'subscriptlist' # pragma: no cover"",
            ""    trailer = 'trailer' # pragma: no cover"",
            ""    tname_star = 'tname_star' # pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""is_simple_decorator_expression = lambda expr: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING' # pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""node = type('MockNode', (object,), { # pragma: no cover"",
            ""    'pre_order': lambda self: [], # pragma: no cover"",
            ""    'value': '', # pragma: no cover"",
            ""    'type': None, # pragma: no cover"",
            ""    'parent': None, # pragma: no cover"",
            ""    'children': [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, type('MockNode', (object,), {})) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, type('MockNode', (object,), {})) and n.value.isdigit() # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'return_stmt': 6, # pragma: no cover"",
            ""    'yield_expr': 7, # pragma: no cover"",
            ""    'testlist_star_expr': 8, # pragma: no cover"",
            ""    'star_expr': 9, # pragma: no cover"",
            ""    'annassign': 10, # pragma: no cover"",
            ""    'with_stmt': 11, # pragma: no cover"",
            ""    'atom': 12, # pragma: no cover"",
            ""    'testlist_gexp': 13, # pragma: no cover"",
            ""    'match_stmt': 14, # pragma: no cover"",
            ""    'except_clause': 15, # pragma: no cover"",
            ""    'subscriptlist': 16, # pragma: no cover"",
            ""    'trailer': 17, # pragma: no cover"",
            ""    'tname_star': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING' # pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, value='', children=[], parent=None) # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, SimpleNamespace) and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, SimpleNamespace) and isinstance(n.value, str) and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""syms = SimpleNamespace( # pragma: no cover"",
            ""    typedargslist=1, arglist=2, varargslist=3, decorator=4, argument=5, return_stmt=6, # pragma: no cover"",
            ""    yield_expr=7, testlist_star_expr=8, star_expr=9, annassign=10, # pragma: no cover"",
            ""    with_stmt=11, atom=12, testlist_gexp=13, match_stmt=14, except_clause=15, # pragma: no cover"",
            ""    subscriptlist=16, trailer=17, tname_star=18 # pragma: no cover"",
            "") # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover""
        ]
    }
]",2,5859,0.0029295,6616,0.009924,0.0128535
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 35:
    if future_imports:
NameError: name 'future_imports' is not defined
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""import enum"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""Feature = enum.Enum('Feature', 'F_STRINGS DEBUG_F_STRINGS NUMERIC_UNDERSCORES POS_ONLY_ARGUMENTS ASSIGNMENT_EXPRESSIONS RELAXED_DECORATORS TRAILING_COMMA_IN_DEF TRAILING_COMMA_IN_CALL UNPACKING_ON_FLOW ANN_ASSIGN_EXTENDED_RHS PARENTHESIZED_CONTEXT_MANAGERS PATTERN_MATCHING EXCEPT_STAR VARIADIC_GENERICS')"",
            ""future_imports = {'annotations'}"",
            ""node = SimpleNamespace(pre_order=lambda: [], value='', type=None, parent=None, children=[])"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit()"",
            ""token = SimpleNamespace(SLASH='/', COLONEQUAL=':=', COMMA=',', LPAR='(', RPAR=')', STAR='*')"",
            ""syms = SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', decorator='decorator', argument='argument', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', annassign='annassign', with_stmt='with_stmt', atom='atom', testlist_gexp='testlist_gexp', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star')"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {'*', '**'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import enum"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""Feature = enum.Enum('Feature', 'F_STRINGS DEBUG_F_STRINGS NUMERIC_UNDERSCORES POS_ONLY_ARGUMENTS ASSIGNMENT_EXPRESSIONS RELAXED_DECORATORS TRAILING_COMMA_IN_DEF TRAILING_COMMA_IN_CALL UNPACKING_ON_FLOW ANN_ASSIGN_EXTENDED_RHS PARENTHESIZED_CONTEXT_MANAGERS PATTERN_MATCHING EXCEPT_STAR VARIADIC_GENERICS')"",
            ""future_imports = set(['annotations'])"",
            ""node = SimpleNamespace(pre_order=lambda: [], value='', type=None, children=[], parent=None)"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and any(c.isdigit() for c in n.value)"",
            ""token = SimpleNamespace(SLASH='/', COLONEQUAL=':=', COMMA=',', LPAR='(', RPAR=')', STAR='*', DOUBLESTAR='**')"",
            ""syms = SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', decorator='decorator', argument='argument', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', annassign='annassign', with_stmt='with_stmt', atom='atom', testlist_gexp='testlist_gexp', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star')"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {'*', '**'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import enum"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""Feature = enum.Enum('Feature', 'F_STRINGS DEBUG_F_STRINGS NUMERIC_UNDERSCORES POS_ONLY_ARGUMENTS ASSIGNMENT_EXPRESSIONS RELAXED_DECORATORS TRAILING_COMMA_IN_DEF TRAILING_COMMA_IN_CALL UNPACKING_ON_FLOW ANN_ASSIGN_EXTENDED_RHS PARENTHESIZED_CONTEXT_MANAGERS PATTERN_MATCHING EXCEPT_STAR VARIADIC_GENERICS')"",
            ""future_imports = {'annotations'}"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, value='', children=[], parent=None)"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""token = SimpleNamespace(SLASH='/', COLONEQUAL=':=', COMMA=',', LPAR='(', RPAR=')', STAR='*', DOUBLESTAR='**')"",
            ""syms = SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', decorator='decorator', argument='argument', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', annassign='annassign', with_stmt='with_stmt', atom='atom', testlist_gexp='testlist_gexp', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star')"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {'*', '**'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import enum"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""Feature = enum.Enum('Feature', 'F_STRINGS DEBUG_F_STRINGS NUMERIC_UNDERSCORES POS_ONLY_ARGUMENTS ASSIGNMENT_EXPRESSIONS RELAXED_DECORATORS TRAILING_COMMA_IN_DEF TRAILING_COMMA_IN_CALL UNPACKING_ON_FLOW ANN_ASSIGN_EXTENDED_RHS PARENTHESIZED_CONTEXT_MANAGERS PATTERN_MATCHING EXCEPT_STAR VARIADIC_GENERICS')"",
            ""future_imports = set(['annotations'])"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, value='', parent=None, children=[])"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""token = SimpleNamespace(SLASH='/', COLONEQUAL=':=', COMMA=',', LPAR='(', RPAR=')', STAR='*', DOUBLESTAR='**')"",
            ""syms = SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', decorator='decorator', argument='argument', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', annassign='annassign', with_stmt='with_stmt', atom='atom', testlist_gexp='testlist_gexp', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star')"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {'*', '**'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import enum"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(enum.Enum):"",
            ""    F_STRINGS = enum.auto()"",
            ""    DEBUG_F_STRINGS = enum.auto()"",
            ""    NUMERIC_UNDERSCORES = enum.auto()"",
            ""    POS_ONLY_ARGUMENTS = enum.auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = enum.auto()"",
            ""    RELAXED_DECORATORS = enum.auto()"",
            ""    TRAILING_COMMA_IN_DEF = enum.auto()"",
            ""    TRAILING_COMMA_IN_CALL = enum.auto()"",
            ""    UNPACKING_ON_FLOW = enum.auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = enum.auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = enum.auto()"",
            ""    PATTERN_MATCHING = enum.auto()"",
            ""    EXCEPT_STAR = enum.auto()"",
            ""    VARIADIC_GENERICS = enum.auto()"",
            ""future_imports = {'annotations'}"",
            ""class Node:"",
            ""    def pre_order(self):"",
            ""        return []"",
            ""    value = ''"",
            ""    type = None"",
            ""    children = []"",
            ""    parent = None"",
            ""node = Node()"",
            ""is_string_token = lambda n: isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: n.value.isdigit()"",
            ""class Syms:"",
            ""    typedargslist = token.SEMI"",
            ""    arglist = token.RPAR"",
            ""    varargslist = token.STAR"",
            ""    decorator = token.AT"",
            ""    argument = token.NAME"",
            ""    return_stmt = token.NEWLINE"",
            ""    yield_expr = token.COLON"",
            ""    testlist_star_expr = token.STAR"",
            ""    star_expr = token.STAR"",
            ""    annassign = token.COLON"",
            ""    with_stmt = token.NAME"",
            ""    atom = token.NAME"",
            ""    testlist_gexp = token.NAME"",
            ""    match_stmt = token.NAME"",
            ""    except_clause = token.NAME"",
            ""    subscriptlist = token.NAME"",
            ""    trailer = token.NAME"",
            ""    tname_star = token.NAME"",
            ""syms = Syms()"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import enum"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""Feature = enum.Enum('Feature', 'F_STRINGS DEBUG_F_STRINGS NUMERIC_UNDERSCORES POS_ONLY_ARGUMENTS ASSIGNMENT_EXPRESSIONS RELAXED_DECORATORS TRAILING_COMMA_IN_DEF TRAILING_COMMA_IN_CALL UNPACKING_ON_FLOW ANN_ASSIGN_EXTENDED_RHS PARENTHESIZED_CONTEXT_MANAGERS PATTERN_MATCHING EXCEPT_STAR VARIADIC_GENERICS')"",
            ""future_imports = {'annotations'}"",
            ""node = SimpleNamespace(pre_order=lambda: [], value='', type=None, children=[], parent=None)"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit()"",
            ""token = SimpleNamespace(SLASH='SLASH', COLONEQUAL='COLONEQUAL', COMMA='COMMA', LPAR='LPAR', RPAR='RPAR', STAR='STAR', DOUBLESTAR='DOUBLESTAR')"",
            ""syms = SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', decorator='decorator', argument='argument', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', annassign='annassign', with_stmt='with_stmt', atom='atom', testlist_gexp='testlist_gexp', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star')"",
            ""is_simple_decorator_expression = lambda n: False"",
            ""STARS = {'STAR', 'DOUBLESTAR'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import enum"",
            ""import ast"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""Feature = enum.Enum('Feature', {"",
            ""    'F_STRINGS': 'F_STRINGS',"",
            ""    'DEBUG_F_STRINGS': 'DEBUG_F_STRINGS',"",
            ""    'NUMERIC_UNDERSCORES': 'NUMERIC_UNDERSCORES',"",
            ""    'POS_ONLY_ARGUMENTS': 'POS_ONLY_ARGUMENTS',"",
            ""    'ASSIGNMENT_EXPRESSIONS': 'ASSIGNMENT_EXPRESSIONS',"",
            ""    'RELAXED_DECORATORS': 'RELAXED_DECORATORS',"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF',"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL',"",
            ""    'UNPACKING_ON_FLOW': 'UNPACKING_ON_FLOW',"",
            ""    'ANN_ASSIGN_EXTENDED_RHS': 'ANN_ASSIGN_EXTENDED_RHS',"",
            ""    'PARENTHESIZED_CONTEXT_MANAGERS': 'PARENTHESIZED_CONTEXT_MANAGERS',"",
            ""    'PATTERN_MATCHING': 'PATTERN_MATCHING',"",
            ""    'EXCEPT_STAR': 'EXCEPT_STAR',"",
            ""    'VARIADIC_GENERICS': 'VARIADIC_GENERICS'"",
            ""})"",
            ""future_imports = ['annotations']"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, children=[], value='')"",
            ""is_string_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and n.value.isdigit()"",
            ""token = SimpleNamespace(SLASH='/', COLONEQUAL=':=', COMMA=',', LPAR='(', RPAR=')', STAR='*')"",
            ""syms = SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', decorator='decorator', argument='argument', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', annassign='annassign', with_stmt='with_stmt', atom='atom', testlist_gexp='testlist_gexp', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star')"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {'*', '**'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import enum"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""Feature = enum.Enum('Feature', 'F_STRINGS DEBUG_F_STRINGS NUMERIC_UNDERSCORES POS_ONLY_ARGUMENTS ASSIGNMENT_EXPRESSIONS RELAXED_DECORATORS TRAILING_COMMA_IN_DEF TRAILING_COMMA_IN_CALL UNPACKING_ON_FLOW ANN_ASSIGN_EXTENDED_RHS PARENTHESIZED_CONTEXT_MANAGERS PATTERN_MATCHING EXCEPT_STAR VARIADIC_GENERICS')"",
            ""future_imports = set(['annotations'])"",
            ""node = SimpleNamespace(pre_order=lambda: [], value='', type=None, children=[], parent=None)"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] if 'f' in value or 'F' in value else []"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and any(char.isdigit() for char in n.value)"",
            ""token = SimpleNamespace(SLASH='/', COLONEQUAL=':=', COMMA=',', LPAR='(', RPAR=')', STAR='*', DOUBLESTAR='**')"",
            ""syms = SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', decorator='decorator', argument='argument', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', annassign='annassign', with_stmt='with_stmt', atom='atom', testlist_gexp='testlist_gexp', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star')"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {'*', '**'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import enum"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""Feature = enum.Enum('Feature', 'F_STRINGS DEBUG_F_STRINGS NUMERIC_UNDERSCORES POS_ONLY_ARGUMENTS ASSIGNMENT_EXPRESSIONS RELAXED_DECORATORS TRAILING_COMMA_IN_DEF TRAILING_COMMA_IN_CALL UNPACKING_ON_FLOW ANN_ASSIGN_EXTENDED_RHS PARENTHESIZED_CONTEXT_MANAGERS PATTERN_MATCHING EXCEPT_STAR VARIADIC_GENERICS')"",
            ""future_imports = ['annotations']"",
            ""node = SimpleNamespace(pre_order=lambda: [])"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""token = SimpleNamespace(SLASH='/', COLONEQUAL=':=', COMMA=',', LPAR='(', RPAR=')', STAR='*', DOUBLESTAR='**')"",
            ""syms = SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', decorator='decorator', argument='argument', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', annassign='annassign', with_stmt='with_stmt', atom='atom', testlist_gexp='testlist_gexp', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star')"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {'*', '**'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import enum"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""Feature = enum.Enum('Feature', 'F_STRINGS DEBUG_F_STRINGS NUMERIC_UNDERSCORES POS_ONLY_ARGUMENTS ASSIGNMENT_EXPRESSIONS RELAXED_DECORATORS TRAILING_COMMA_IN_DEF TRAILING_COMMA_IN_CALL UNPACKING_ON_FLOW ANN_ASSIGN_EXTENDED_RHS PARENTHESIZED_CONTEXT_MANAGERS PATTERN_MATCHING EXCEPT_STAR VARIADIC_GENERICS')"",
            ""future_imports = {'annotations'}"",
            ""node = SimpleNamespace(pre_order=lambda: [SimpleNamespace(value='', type=None, children=[], parent=None)])"",
            ""is_string_token = lambda n: isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: n.value.replace('_', '').isdigit()"",
            ""token = SimpleNamespace(SLASH='/', COLONEQUAL=':=', COMMA=',', LPAR='(', RPAR=')', STAR='*')"",
            ""syms = SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', decorator='decorator', argument='argument', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', annassign='annassign', with_stmt='with_stmt', atom='atom', testlist_gexp='testlist_gexp', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star')"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {'*', '**'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import enum # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = enum.Enum('Feature', 'F_STRINGS DEBUG_F_STRINGS NUMERIC_UNDERSCORES POS_ONLY_ARGUMENTS ASSIGNMENT_EXPRESSIONS RELAXED_DECORATORS TRAILING_COMMA_IN_DEF TRAILING_COMMA_IN_CALL UNPACKING_ON_FLOW ANN_ASSIGN_EXTENDED_RHS PARENTHESIZED_CONTEXT_MANAGERS PATTERN_MATCHING EXCEPT_STAR VARIADIC_GENERICS') # pragma: no cover"",
            ""node = SimpleNamespace(pre_order=lambda: [], value='', type=None, parent=None, children=[]) # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""token = SimpleNamespace(SLASH='/', COLONEQUAL=':=', COMMA=',', LPAR='(', RPAR=')', STAR='*') # pragma: no cover"",
            ""syms = SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', decorator='decorator', argument='argument', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', annassign='annassign', with_stmt='with_stmt', atom='atom', testlist_gexp='testlist_gexp', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star') # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {'*', '**'} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import enum # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = enum.Enum('Feature', 'F_STRINGS DEBUG_F_STRINGS NUMERIC_UNDERSCORES POS_ONLY_ARGUMENTS ASSIGNMENT_EXPRESSIONS RELAXED_DECORATORS TRAILING_COMMA_IN_DEF TRAILING_COMMA_IN_CALL UNPACKING_ON_FLOW ANN_ASSIGN_EXTENDED_RHS PARENTHESIZED_CONTEXT_MANAGERS PATTERN_MATCHING EXCEPT_STAR VARIADIC_GENERICS') # pragma: no cover"",
            ""node = SimpleNamespace(pre_order=lambda: [], value='', type=None, children=[], parent=None) # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and any(c.isdigit() for c in n.value) # pragma: no cover"",
            ""token = SimpleNamespace(SLASH='/', COLONEQUAL=':=', COMMA=',', LPAR='(', RPAR=')', STAR='*', DOUBLESTAR='**') # pragma: no cover"",
            ""syms = SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', decorator='decorator', argument='argument', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', annassign='annassign', with_stmt='with_stmt', atom='atom', testlist_gexp='testlist_gexp', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star') # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {'*', '**'} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import enum # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = enum.Enum('Feature', 'F_STRINGS DEBUG_F_STRINGS NUMERIC_UNDERSCORES POS_ONLY_ARGUMENTS ASSIGNMENT_EXPRESSIONS RELAXED_DECORATORS TRAILING_COMMA_IN_DEF TRAILING_COMMA_IN_CALL UNPACKING_ON_FLOW ANN_ASSIGN_EXTENDED_RHS PARENTHESIZED_CONTEXT_MANAGERS PATTERN_MATCHING EXCEPT_STAR VARIADIC_GENERICS') # pragma: no cover"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, value='', children=[], parent=None) # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""token = SimpleNamespace(SLASH='/', COLONEQUAL=':=', COMMA=',', LPAR='(', RPAR=')', STAR='*', DOUBLESTAR='**') # pragma: no cover"",
            ""syms = SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', decorator='decorator', argument='argument', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', annassign='annassign', with_stmt='with_stmt', atom='atom', testlist_gexp='testlist_gexp', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star') # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {'*', '**'} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import enum # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = enum.Enum('Feature', 'F_STRINGS DEBUG_F_STRINGS NUMERIC_UNDERSCORES POS_ONLY_ARGUMENTS ASSIGNMENT_EXPRESSIONS RELAXED_DECORATORS TRAILING_COMMA_IN_DEF TRAILING_COMMA_IN_CALL UNPACKING_ON_FLOW ANN_ASSIGN_EXTENDED_RHS PARENTHESIZED_CONTEXT_MANAGERS PATTERN_MATCHING EXCEPT_STAR VARIADIC_GENERICS') # pragma: no cover"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, value='', parent=None, children=[]) # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""token = SimpleNamespace(SLASH='/', COLONEQUAL=':=', COMMA=',', LPAR='(', RPAR=')', STAR='*', DOUBLESTAR='**') # pragma: no cover"",
            ""syms = SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', decorator='decorator', argument='argument', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', annassign='annassign', with_stmt='with_stmt', atom='atom', testlist_gexp='testlist_gexp', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star') # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {'*', '**'} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(enum.Enum): # pragma: no cover"",
            ""    F_STRINGS = enum.auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = enum.auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = enum.auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = enum.auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = enum.auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = enum.auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = enum.auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = enum.auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = enum.auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = enum.auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = enum.auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = enum.auto() # pragma: no cover"",
            ""    EXCEPT_STAR = enum.auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = enum.auto() # pragma: no cover"",
            ""class Node: # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""    value = '' # pragma: no cover"",
            ""    type = None # pragma: no cover"",
            ""    children = [] # pragma: no cover"",
            ""    parent = None # pragma: no cover"",
            ""node = Node() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: n.value.isdigit() # pragma: no cover"",
            ""class Syms: # pragma: no cover"",
            ""    typedargslist = token.SEMI # pragma: no cover"",
            ""    arglist = token.RPAR # pragma: no cover"",
            ""    varargslist = token.STAR # pragma: no cover"",
            ""    decorator = token.AT # pragma: no cover"",
            ""    argument = token.NAME # pragma: no cover"",
            ""    return_stmt = token.NEWLINE # pragma: no cover"",
            ""    yield_expr = token.COLON # pragma: no cover"",
            ""    testlist_star_expr = token.STAR # pragma: no cover"",
            ""    star_expr = token.STAR # pragma: no cover"",
            ""    annassign = token.COLON # pragma: no cover"",
            ""    with_stmt = token.NAME # pragma: no cover"",
            ""    atom = token.NAME # pragma: no cover"",
            ""    testlist_gexp = token.NAME # pragma: no cover"",
            ""    match_stmt = token.NAME # pragma: no cover"",
            ""    except_clause = token.NAME # pragma: no cover"",
            ""    subscriptlist = token.NAME # pragma: no cover"",
            ""    trailer = token.NAME # pragma: no cover"",
            ""    tname_star = token.NAME # pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import enum # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = enum.Enum('Feature', 'F_STRINGS DEBUG_F_STRINGS NUMERIC_UNDERSCORES POS_ONLY_ARGUMENTS ASSIGNMENT_EXPRESSIONS RELAXED_DECORATORS TRAILING_COMMA_IN_DEF TRAILING_COMMA_IN_CALL UNPACKING_ON_FLOW ANN_ASSIGN_EXTENDED_RHS PARENTHESIZED_CONTEXT_MANAGERS PATTERN_MATCHING EXCEPT_STAR VARIADIC_GENERICS') # pragma: no cover"",
            ""node = SimpleNamespace(pre_order=lambda: [], value='', type=None, children=[], parent=None) # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""token = SimpleNamespace(SLASH='SLASH', COLONEQUAL='COLONEQUAL', COMMA='COMMA', LPAR='LPAR', RPAR='RPAR', STAR='STAR', DOUBLESTAR='DOUBLESTAR') # pragma: no cover"",
            ""syms = SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', decorator='decorator', argument='argument', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', annassign='annassign', with_stmt='with_stmt', atom='atom', testlist_gexp='testlist_gexp', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star') # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: False # pragma: no cover"",
            ""STARS = {'STAR', 'DOUBLESTAR'} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import enum # pragma: no cover"",
            ""import ast # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = enum.Enum('Feature', { # pragma: no cover"",
            ""    'F_STRINGS': 'F_STRINGS', # pragma: no cover"",
            ""    'DEBUG_F_STRINGS': 'DEBUG_F_STRINGS', # pragma: no cover"",
            ""    'NUMERIC_UNDERSCORES': 'NUMERIC_UNDERSCORES', # pragma: no cover"",
            ""    'POS_ONLY_ARGUMENTS': 'POS_ONLY_ARGUMENTS', # pragma: no cover"",
            ""    'ASSIGNMENT_EXPRESSIONS': 'ASSIGNMENT_EXPRESSIONS', # pragma: no cover"",
            ""    'RELAXED_DECORATORS': 'RELAXED_DECORATORS', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL', # pragma: no cover"",
            ""    'UNPACKING_ON_FLOW': 'UNPACKING_ON_FLOW', # pragma: no cover"",
            ""    'ANN_ASSIGN_EXTENDED_RHS': 'ANN_ASSIGN_EXTENDED_RHS', # pragma: no cover"",
            ""    'PARENTHESIZED_CONTEXT_MANAGERS': 'PARENTHESIZED_CONTEXT_MANAGERS', # pragma: no cover"",
            ""    'PATTERN_MATCHING': 'PATTERN_MATCHING', # pragma: no cover"",
            ""    'EXCEPT_STAR': 'EXCEPT_STAR', # pragma: no cover"",
            ""    'VARIADIC_GENERICS': 'VARIADIC_GENERICS' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, children=[], value='') # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, SimpleNamespace) and hasattr(n, 'value') and n.value.isdigit() # pragma: no cover"",
            ""token = SimpleNamespace(SLASH='/', COLONEQUAL=':=', COMMA=',', LPAR='(', RPAR=')', STAR='*') # pragma: no cover"",
            ""syms = SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', decorator='decorator', argument='argument', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', annassign='annassign', with_stmt='with_stmt', atom='atom', testlist_gexp='testlist_gexp', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star') # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {'*', '**'} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import enum # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = enum.Enum('Feature', 'F_STRINGS DEBUG_F_STRINGS NUMERIC_UNDERSCORES POS_ONLY_ARGUMENTS ASSIGNMENT_EXPRESSIONS RELAXED_DECORATORS TRAILING_COMMA_IN_DEF TRAILING_COMMA_IN_CALL UNPACKING_ON_FLOW ANN_ASSIGN_EXTENDED_RHS PARENTHESIZED_CONTEXT_MANAGERS PATTERN_MATCHING EXCEPT_STAR VARIADIC_GENERICS') # pragma: no cover"",
            ""node = SimpleNamespace(pre_order=lambda: [], value='', type=None, children=[], parent=None) # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] if 'f' in value or 'F' in value else [] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and any(char.isdigit() for char in n.value) # pragma: no cover"",
            ""token = SimpleNamespace(SLASH='/', COLONEQUAL=':=', COMMA=',', LPAR='(', RPAR=')', STAR='*', DOUBLESTAR='**') # pragma: no cover"",
            ""syms = SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', decorator='decorator', argument='argument', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', annassign='annassign', with_stmt='with_stmt', atom='atom', testlist_gexp='testlist_gexp', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star') # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {'*', '**'} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import enum # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = enum.Enum('Feature', 'F_STRINGS DEBUG_F_STRINGS NUMERIC_UNDERSCORES POS_ONLY_ARGUMENTS ASSIGNMENT_EXPRESSIONS RELAXED_DECORATORS TRAILING_COMMA_IN_DEF TRAILING_COMMA_IN_CALL UNPACKING_ON_FLOW ANN_ASSIGN_EXTENDED_RHS PARENTHESIZED_CONTEXT_MANAGERS PATTERN_MATCHING EXCEPT_STAR VARIADIC_GENERICS') # pragma: no cover"",
            ""node = SimpleNamespace(pre_order=lambda: []) # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""token = SimpleNamespace(SLASH='/', COLONEQUAL=':=', COMMA=',', LPAR='(', RPAR=')', STAR='*', DOUBLESTAR='**') # pragma: no cover"",
            ""syms = SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', decorator='decorator', argument='argument', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', annassign='annassign', with_stmt='with_stmt', atom='atom', testlist_gexp='testlist_gexp', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star') # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {'*', '**'} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import enum # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = enum.Enum('Feature', 'F_STRINGS DEBUG_F_STRINGS NUMERIC_UNDERSCORES POS_ONLY_ARGUMENTS ASSIGNMENT_EXPRESSIONS RELAXED_DECORATORS TRAILING_COMMA_IN_DEF TRAILING_COMMA_IN_CALL UNPACKING_ON_FLOW ANN_ASSIGN_EXTENDED_RHS PARENTHESIZED_CONTEXT_MANAGERS PATTERN_MATCHING EXCEPT_STAR VARIADIC_GENERICS') # pragma: no cover"",
            ""node = SimpleNamespace(pre_order=lambda: [SimpleNamespace(value='', type=None, children=[], parent=None)]) # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""token = SimpleNamespace(SLASH='/', COLONEQUAL=':=', COMMA=',', LPAR='(', RPAR=')', STAR='*') # pragma: no cover"",
            ""syms = SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', decorator='decorator', argument='argument', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', annassign='annassign', with_stmt='with_stmt', atom='atom', testlist_gexp='testlist_gexp', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star') # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {'*', '**'} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    }
]",2,6572,0.003286,4750,0.007125,0.010411
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 33:
    raise TypeError(f""{msg} Got {arg!r:.100}."")
TypeError: Parameters to generic types must be types. Got 0.
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""import enum"",
            ""from types import SimpleNamespace"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(enum.Enum):"",
            ""    F_STRINGS = enum.auto()"",
            ""    DEBUG_F_STRINGS = enum.auto()"",
            ""    NUMERIC_UNDERSCORES = enum.auto()"",
            ""    POS_ONLY_ARGUMENTS = enum.auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = enum.auto()"",
            ""    RELAXED_DECORATORS = enum.auto()"",
            ""    TRAILING_COMMA_IN_DEF = enum.auto()"",
            ""    TRAILING_COMMA_IN_CALL = enum.auto()"",
            ""    UNPACKING_ON_FLOW = enum.auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = enum.auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = enum.auto()"",
            ""    PATTERN_MATCHING = enum.auto()"",
            ""    EXCEPT_STAR = enum.auto()"",
            ""    VARIADIC_GENERICS = enum.auto()"",
            ""future_imports = {'annotations'}"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, value='', children=[], parent=None)"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit()"",
            ""token = SimpleNamespace(SLASH=token.SLASH, COLONEQUAL=token.COLONEQUAL, COMMA=token.COMMA, LPAR=token.LPAR, RPAR=token.RPAR, STAR=token.STAR)"",
            ""syms = SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', decorator='decorator', argument='argument', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', annassign='annassign', with_stmt='with_stmt', atom='atom', testlist_gexp='testlist_gexp', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star')"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'F_STRINGS'"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = ['annotations']"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [], 'type': None, 'value': '', 'children': [], 'parent': None})()"",
            ""def is_string_token(n): return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""def is_number_token(n): return hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit()"",
            ""token = type('MockToken', (object,), {'SLASH': 'SLASH', 'COLONEQUAL': 'COLONEQUAL', 'COMMA': 'COMMA', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'STAR': 'STAR', 'DOUBLESTAR': 'DOUBLESTAR'})"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'varargslist': 'varargslist', 'decorator': 'decorator', 'argument': 'argument', 'return_stmt': 'return_stmt', 'yield_expr': 'yield_expr', 'testlist_star_expr': 'testlist_star_expr', 'star_expr': 'star_expr', 'annassign': 'annassign', 'with_stmt': 'with_stmt', 'atom': 'atom', 'testlist_gexp': 'testlist_gexp', 'match_stmt': 'match_stmt', 'except_clause': 'except_clause', 'subscriptlist': 'subscriptlist', 'trailer': 'trailer', 'tname_star': 'tname_star'})"",
            ""def is_simple_decorator_expression(n): return True"",
            ""STARS = {'STAR', 'DOUBLESTAR'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'F_STRINGS'"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = {'annotations'}"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [], 'type': None, 'children': [], 'parent': None, 'value': ''})()"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.replace('_', '').isdigit()"",
            ""syms = type('syms', (), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'argument': 5,"",
            ""    'return_stmt': 6,"",
            ""    'yield_expr': 7,"",
            ""    'testlist_star_expr': 8,"",
            ""    'star_expr': 9,"",
            ""    'annassign': 10,"",
            ""    'with_stmt': 11,"",
            ""    'atom': 12,"",
            ""    'testlist_gexp': 13,"",
            ""    'match_stmt': 14,"",
            ""    'except_clause': 15,"",
            ""    'subscriptlist': 16,"",
            ""    'trailer': 17,"",
            ""    'tname_star': 18"",
            ""})"",
            ""is_simple_decorator_expression = lambda n: isinstance(n, str)"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from types import SimpleNamespace"",
            ""import token"",
            ""import re""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'F_STRINGS'"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = {'annotations'}"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, value='')"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: [(m.start(), m.end()) for m in re.finditer(r'{.*?}', value)]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and re.match(r'^[_\\d]+$', n.value)"",
            ""syms = SimpleNamespace(typedargslist=1, arglist=2, varargslist=3, decorator=4, argument=5, return_stmt=6, yield_expr=7, testlist_star_expr=8, star_expr=9, annassign=10, with_stmt=11, atom=12, testlist_gexp=13, match_stmt=14, except_clause=15, subscriptlist=16, trailer=17, tname_star=18)"",
            ""is_simple_decorator_expression = lambda expr: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from types import SimpleNamespace"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(SimpleNamespace):"",
            ""    F_STRINGS = 'F_STRINGS'"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            """",
            ""future_imports = {'annotations'}"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, value='', parent=None, children=[])"",
            ""is_string_token = lambda n: isinstance(n, SimpleNamespace) and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))]"",
            ""is_number_token = lambda n: isinstance(n, SimpleNamespace) and isinstance(n.value, str) and n.value.replace('_', '').isdigit()"",
            ""syms = SimpleNamespace(typedargslist=1, arglist=2, varargslist=3, decorator=4, argument=5, return_stmt=6, yield_expr=7, testlist_star_expr=8, star_expr=9, annassign=10, with_stmt=11, atom=12, testlist_gexp=13, match_stmt=14, except_clause=15, subscriptlist=16, trailer=17, tname_star=18)"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'f-strings'"",
            ""    DEBUG_F_STRINGS = 'debug f-strings'"",
            ""    NUMERIC_UNDERSCORES = 'numeric underscores'"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions'"",
            ""    RELAXED_DECORATORS = 'relaxed decorators'"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls'"",
            ""    UNPACKING_ON_FLOW = 'unpacking in flow statements'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignment'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers'"",
            ""    PATTERN_MATCHING = 'pattern matching'"",
            ""    EXCEPT_STAR = 'except* clause'"",
            ""    VARIADIC_GENERICS = 'variadic generics'"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def pre_order(self): return []"",
            ""node = MockNode()"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(i, len(s)) for i in range(0, len(s), 2)]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and any(c.isdigit() for c in n.value)"",
            ""token = type('MockToken', (object,), {"",
            ""    'SLASH': '/',"",
            ""    'COLONEQUAL': ':=',"",
            ""    'COMMA': ',',"",
            ""    'LPAR': '(',"",
            ""    'RPAR': ')',"",
            ""    'STAR': '*'})"",
            ""syms = type('MockSyms', (object,), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'varargslist': 'varargslist',"",
            ""    'decorator': 'decorator',"",
            ""    'argument': 'argument',"",
            ""    'return_stmt': 'return_stmt',"",
            ""    'yield_expr': 'yield_expr',"",
            ""    'testlist_star_expr': 'testlist_star_expr',"",
            ""    'star_expr': 'star_expr',"",
            ""    'annassign': 'annassign',"",
            ""    'with_stmt': 'with_stmt',"",
            ""    'atom': 'atom',"",
            ""    'testlist_gexp': 'testlist_gexp',"",
            ""    'match_stmt': 'match_stmt',"",
            ""    'except_clause': 'except_clause',"",
            ""    'subscriptlist': 'subscriptlist',"",
            ""    'trailer': 'trailer',"",
            ""    'tname_star': 'tname_star'})"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {'*', '**'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'F_STRINGS'"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            """",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def pre_order(self):"",
            ""        return []"",
            ""node = MockNode()"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.isdigit()"",
            ""class syms:"",
            ""    typedargslist = 1"",
            ""    arglist = 2"",
            ""    varargslist = 3"",
            ""    decorator = 4"",
            ""    argument = 5"",
            ""    return_stmt = 6"",
            ""    yield_expr = 7"",
            ""    testlist_star_expr = 8"",
            ""    star_expr = 9"",
            ""    annassign = 10"",
            ""    with_stmt = 11"",
            ""    atom = 12"",
            ""    testlist_gexp = 13"",
            ""    match_stmt = 14"",
            ""    except_clause = 15"",
            ""    subscriptlist = 16"",
            ""    trailer = 17"",
            ""    tname_star = 18"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""from types import SimpleNamespace"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""future_imports = {'annotations'}"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, value='', children=[], parent=None)"",
            ""is_string_token = lambda n: isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: iter([(0, len(value))])"",
            ""is_number_token = lambda n: n.value.isdigit()"",
            ""syms = SimpleNamespace(typedargslist=1, arglist=2, varargslist=3, decorator=4, argument=5, return_stmt=6, yield_expr=7, testlist_star_expr=8, star_expr=9, annassign=10, with_stmt=11, atom=12, testlist_gexp=13, match_stmt=14, except_clause=15, subscriptlist=16, trailer=17, tname_star=18)"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, '**'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'f-strings'"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings'"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals'"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions'"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax'"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls'"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers'"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement'"",
            ""    EXCEPT_STAR = 'except* clause'"",
            ""    VARIADIC_GENERICS = 'variadic generics'"",
            """",
            ""future_imports = ['annotations']"",
            ""node = type('MockNode', (object,), {"",
            ""    'pre_order': lambda self: [],"",
            ""    'value': '',"",
            ""    'type': None,"",
            ""    'parent': None,"",
            ""    'children': []"",
            ""})()"",
            ""def is_string_token(n):"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):"",
            ""    return [(0, len(value))]"",
            ""def is_number_token(n):"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) and n.value.isdigit()"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS,"",
            ""}"",
            ""class syms:"",
            ""    typedargslist = 'typedargslist'"",
            ""    arglist = 'arglist'"",
            ""    varargslist = 'varargslist'"",
            ""    decorator = 'decorator'"",
            ""    argument = 'argument'"",
            ""    return_stmt = 'return_stmt'"",
            ""    yield_expr = 'yield_expr'"",
            ""    testlist_star_expr = 'testlist_star_expr'"",
            ""    star_expr = 'star_expr'"",
            ""    annassign = 'annassign'"",
            ""    with_stmt = 'with_stmt'"",
            ""    atom = 'atom'"",
            ""    testlist_gexp = 'testlist_gexp'"",
            ""    match_stmt = 'match_stmt'"",
            ""    except_clause = 'except_clause'"",
            ""    subscriptlist = 'subscriptlist'"",
            ""    trailer = 'trailer'"",
            ""    tname_star = 'tname_star'""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""from types import SimpleNamespace"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""future_imports = None"",
            ""def node_pre_order():"",
            ""    return []"",
            ""node = SimpleNamespace(pre_order=node_pre_order, type=None, value='', children=[], parent=None)"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""token = SimpleNamespace(SLASH=token.SLASH, COLONEQUAL=token.COLONEQUAL, COMMA=token.COMMA, LPAR=token.LPAR, RPAR=token.RPAR, STAR=token.STAR, DOUBLESTAR=token.DOUBLESTAR)"",
            ""syms = SimpleNamespace(typedargslist=1, arglist=2, varargslist=3, decorator=4, argument=5, return_stmt=6, yield_expr=7, testlist_star_expr=8, star_expr=9, annassign=10, with_stmt=11, atom=12, testlist_gexp=13, match_stmt=14, except_clause=15, subscriptlist=16, trailer=17, tname_star=18)"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import enum # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(enum.Enum): # pragma: no cover"",
            ""    F_STRINGS = enum.auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = enum.auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = enum.auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = enum.auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = enum.auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = enum.auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = enum.auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = enum.auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = enum.auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = enum.auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = enum.auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = enum.auto() # pragma: no cover"",
            ""    EXCEPT_STAR = enum.auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = enum.auto() # pragma: no cover"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, value='', children=[], parent=None) # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""token = SimpleNamespace(SLASH=token.SLASH, COLONEQUAL=token.COLONEQUAL, COMMA=token.COMMA, LPAR=token.LPAR, RPAR=token.RPAR, STAR=token.STAR) # pragma: no cover"",
            ""syms = SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', decorator='decorator', argument='argument', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', annassign='annassign', with_stmt='with_stmt', atom='atom', testlist_gexp='testlist_gexp', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star') # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING' # pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [], 'type': None, 'value': '', 'children': [], 'parent': None})() # pragma: no cover"",
            ""def is_string_token(n): return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n): return hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""token = type('MockToken', (object,), {'SLASH': 'SLASH', 'COLONEQUAL': 'COLONEQUAL', 'COMMA': 'COMMA', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'STAR': 'STAR', 'DOUBLESTAR': 'DOUBLESTAR'}) # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'varargslist': 'varargslist', 'decorator': 'decorator', 'argument': 'argument', 'return_stmt': 'return_stmt', 'yield_expr': 'yield_expr', 'testlist_star_expr': 'testlist_star_expr', 'star_expr': 'star_expr', 'annassign': 'annassign', 'with_stmt': 'with_stmt', 'atom': 'atom', 'testlist_gexp': 'testlist_gexp', 'match_stmt': 'match_stmt', 'except_clause': 'except_clause', 'subscriptlist': 'subscriptlist', 'trailer': 'trailer', 'tname_star': 'tname_star'}) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): return True # pragma: no cover"",
            ""STARS = {'STAR', 'DOUBLESTAR'} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING' # pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [], 'type': None, 'children': [], 'parent': None, 'value': ''})() # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""syms = type('syms', (), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'return_stmt': 6, # pragma: no cover"",
            ""    'yield_expr': 7, # pragma: no cover"",
            ""    'testlist_star_expr': 8, # pragma: no cover"",
            ""    'star_expr': 9, # pragma: no cover"",
            ""    'annassign': 10, # pragma: no cover"",
            ""    'with_stmt': 11, # pragma: no cover"",
            ""    'atom': 12, # pragma: no cover"",
            ""    'testlist_gexp': 13, # pragma: no cover"",
            ""    'match_stmt': 14, # pragma: no cover"",
            ""    'except_clause': 15, # pragma: no cover"",
            ""    'subscriptlist': 16, # pragma: no cover"",
            ""    'trailer': 17, # pragma: no cover"",
            ""    'tname_star': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: isinstance(n, str) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import re # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING' # pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, value='') # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(m.start(), m.end()) for m in re.finditer(r'{.*?}', value)] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and re.match(r'^[_\\d]+$', n.value) # pragma: no cover"",
            ""syms = SimpleNamespace(typedargslist=1, arglist=2, varargslist=3, decorator=4, argument=5, return_stmt=6, yield_expr=7, testlist_star_expr=8, star_expr=9, annassign=10, with_stmt=11, atom=12, testlist_gexp=13, match_stmt=14, except_clause=15, subscriptlist=16, trailer=17, tname_star=18) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda expr: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(SimpleNamespace): # pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING' # pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            "" # pragma: no cover"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, value='', parent=None, children=[]) # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, SimpleNamespace) and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, SimpleNamespace) and isinstance(n.value, str) and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""syms = SimpleNamespace(typedargslist=1, arglist=2, varargslist=3, decorator=4, argument=5, return_stmt=6, yield_expr=7, testlist_star_expr=8, star_expr=9, annassign=10, with_stmt=11, atom=12, testlist_gexp=13, match_stmt=14, except_clause=15, subscriptlist=16, trailer=17, tname_star=18) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'f-strings' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug f-strings' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric underscores' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed decorators' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking in flow statements' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignment' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern matching' # pragma: no cover"",
            ""    EXCEPT_STAR = 'except* clause' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic generics' # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def pre_order(self): return [] # pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(i, len(s)) for i in range(0, len(s), 2)] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and any(c.isdigit() for c in n.value) # pragma: no cover"",
            ""token = type('MockToken', (object,), { # pragma: no cover"",
            ""    'SLASH': '/', # pragma: no cover"",
            ""    'COLONEQUAL': ':=', # pragma: no cover"",
            ""    'COMMA': ',', # pragma: no cover"",
            ""    'LPAR': '(', # pragma: no cover"",
            ""    'RPAR': ')', # pragma: no cover"",
            ""    'STAR': '*'}) # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'varargslist': 'varargslist', # pragma: no cover"",
            ""    'decorator': 'decorator', # pragma: no cover"",
            ""    'argument': 'argument', # pragma: no cover"",
            ""    'return_stmt': 'return_stmt', # pragma: no cover"",
            ""    'yield_expr': 'yield_expr', # pragma: no cover"",
            ""    'testlist_star_expr': 'testlist_star_expr', # pragma: no cover"",
            ""    'star_expr': 'star_expr', # pragma: no cover"",
            ""    'annassign': 'annassign', # pragma: no cover"",
            ""    'with_stmt': 'with_stmt', # pragma: no cover"",
            ""    'atom': 'atom', # pragma: no cover"",
            ""    'testlist_gexp': 'testlist_gexp', # pragma: no cover"",
            ""    'match_stmt': 'match_stmt', # pragma: no cover"",
            ""    'except_clause': 'except_clause', # pragma: no cover"",
            ""    'subscriptlist': 'subscriptlist', # pragma: no cover"",
            ""    'trailer': 'trailer', # pragma: no cover"",
            ""    'tname_star': 'tname_star'}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {'*', '**'} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING' # pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.isdigit() # pragma: no cover"",
            ""class syms: # pragma: no cover"",
            ""    typedargslist = 1 # pragma: no cover"",
            ""    arglist = 2 # pragma: no cover"",
            ""    varargslist = 3 # pragma: no cover"",
            ""    decorator = 4 # pragma: no cover"",
            ""    argument = 5 # pragma: no cover"",
            ""    return_stmt = 6 # pragma: no cover"",
            ""    yield_expr = 7 # pragma: no cover"",
            ""    testlist_star_expr = 8 # pragma: no cover"",
            ""    star_expr = 9 # pragma: no cover"",
            ""    annassign = 10 # pragma: no cover"",
            ""    with_stmt = 11 # pragma: no cover"",
            ""    atom = 12 # pragma: no cover"",
            ""    testlist_gexp = 13 # pragma: no cover"",
            ""    match_stmt = 14 # pragma: no cover"",
            ""    except_clause = 15 # pragma: no cover"",
            ""    subscriptlist = 16 # pragma: no cover"",
            ""    trailer = 17 # pragma: no cover"",
            ""    tname_star = 18 # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, value='', children=[], parent=None) # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: iter([(0, len(value))]) # pragma: no cover"",
            ""is_number_token = lambda n: n.value.isdigit() # pragma: no cover"",
            ""syms = SimpleNamespace(typedargslist=1, arglist=2, varargslist=3, decorator=4, argument=5, return_stmt=6, yield_expr=7, testlist_star_expr=8, star_expr=9, annassign=10, with_stmt=11, atom=12, testlist_gexp=13, match_stmt=14, except_clause=15, subscriptlist=16, trailer=17, tname_star=18) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, '**'} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'f-strings' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern matching with match statement' # pragma: no cover"",
            ""    EXCEPT_STAR = 'except* clause' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic generics' # pragma: no cover"",
            "" # pragma: no cover"",
            ""node = type('MockNode', (object,), { # pragma: no cover"",
            ""    'pre_order': lambda self: [], # pragma: no cover"",
            ""    'value': '', # pragma: no cover"",
            ""    'type': None, # pragma: no cover"",
            ""    'parent': None, # pragma: no cover"",
            ""    'children': [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) and n.value.isdigit() # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS, # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class syms: # pragma: no cover"",
            ""    typedargslist = 'typedargslist' # pragma: no cover"",
            ""    arglist = 'arglist' # pragma: no cover"",
            ""    varargslist = 'varargslist' # pragma: no cover"",
            ""    decorator = 'decorator' # pragma: no cover"",
            ""    argument = 'argument' # pragma: no cover"",
            ""    return_stmt = 'return_stmt' # pragma: no cover"",
            ""    yield_expr = 'yield_expr' # pragma: no cover"",
            ""    testlist_star_expr = 'testlist_star_expr' # pragma: no cover"",
            ""    star_expr = 'star_expr' # pragma: no cover"",
            ""    annassign = 'annassign' # pragma: no cover"",
            ""    with_stmt = 'with_stmt' # pragma: no cover"",
            ""    atom = 'atom' # pragma: no cover"",
            ""    testlist_gexp = 'testlist_gexp' # pragma: no cover"",
            ""    match_stmt = 'match_stmt' # pragma: no cover"",
            ""    except_clause = 'except_clause' # pragma: no cover"",
            ""    subscriptlist = 'subscriptlist' # pragma: no cover"",
            ""    trailer = 'trailer' # pragma: no cover"",
            ""    tname_star = 'tname_star' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""def node_pre_order(): # pragma: no cover"",
            ""    return [] # pragma: no cover"",
            ""node = SimpleNamespace(pre_order=node_pre_order, type=None, value='', children=[], parent=None) # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""token = SimpleNamespace(SLASH=token.SLASH, COLONEQUAL=token.COLONEQUAL, COMMA=token.COMMA, LPAR=token.LPAR, RPAR=token.RPAR, STAR=token.STAR, DOUBLESTAR=token.DOUBLESTAR) # pragma: no cover"",
            ""syms = SimpleNamespace(typedargslist=1, arglist=2, varargslist=3, decorator=4, argument=5, return_stmt=6, yield_expr=7, testlist_star_expr=8, star_expr=9, annassign=10, with_stmt=11, atom=12, testlist_gexp=13, match_stmt=14, except_clause=15, subscriptlist=16, trailer=17, tname_star=18) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    }
]",2,7222,0.003611,6062,0.009093,0.012704
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 55:
    if future_imports:
NameError: name 'future_imports' is not defined
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""future_imports = {'annotations'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}"",
            ""class MockNode:"",
            ""    def __init__(self, value='', type=None, parent=None, children=None):"",
            ""        self.value = value"",
            ""        self.type = type"",
            ""        self.parent = parent"",
            ""        self.children = children if children is not None else []"",
            ""    def pre_order(self):"",
            ""        return [self] + [child for ch in self.children for child in ch.pre_order()]"",
            ""node = MockNode()"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):"",
            ""    return [(i, i+len(value)) for i in range(len(value)) if value[i] in {'{', '}'}]"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and n.value.replace('_', '').isdigit()"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'varargslist': 'varargslist',"",
            ""    'decorator': 'decorator',"",
            ""    'argument': 'argument',"",
            ""    'return_stmt': 'return_stmt',"",
            ""    'yield_expr': 'yield_expr',"",
            ""    'testlist_star_expr': 'testlist_star_expr',"",
            ""    'star_expr': 'star_expr',"",
            ""    'annassign': 'annassign',"",
            ""    'with_stmt': 'with_stmt',"",
            ""    'atom': 'atom',"",
            ""    'testlist_gexp': 'testlist_gexp',"",
            ""    'match_stmt': 'match_stmt',"",
            ""    'except_clause': 'except_clause',"",
            ""    'subscriptlist': 'subscriptlist',"",
            ""    'trailer': 'trailer',"",
            ""    'tname_star': 'tname_star'"",
            ""})"",
            ""def is_simple_decorator_expression(n):"",
            ""    return True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token"",
            ""import ast as syms""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [], 'type': None, 'value': '', 'children': [], 'parent': None})()"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""token = type('token', (), {'SLASH': 'SLASH', 'COLONEQUAL': 'COLONEQUAL', 'COMMA': 'COMMA', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'STAR': 'STAR'})"",
            ""syms = type('syms', (), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'varargslist': 'varargslist', 'decorator': 'decorator', 'argument': 'argument', 'return_stmt': 'return_stmt', 'yield_expr': 'yield_expr', 'testlist_star_expr': 'testlist_star_expr', 'star_expr': 'star_expr', 'annassign': 'annassign', 'with_stmt': 'with_stmt', 'atom': 'atom', 'testlist_gexp': 'testlist_gexp', 'match_stmt': 'match_stmt', 'except_clause': 'except_clause', 'subscriptlist': 'subscriptlist', 'trailer': 'trailer', 'tname_star': 'tname_star'})"",
            ""is_simple_decorator_expression = lambda n: False"",
            ""STARS = {'*', '**'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""future_imports = {'annotations'}"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [], 'type': None, 'children': [], 'parent': None, 'value': ''})()"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value)) for _ in range(1)]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit()"",
            ""syms = type('syms', (), {'typedargslist': 257, 'arglist': 258, 'varargslist': 259, 'decorator': 260, 'argument': 261, 'return_stmt': 262, 'yield_expr': 263, 'testlist_star_expr': 264, 'star_expr': 265, 'annassign': 266, 'with_stmt': 267, 'atom': 268, 'testlist_gexp': 269, 'match_stmt': 270, 'except_clause': 271, 'subscriptlist': 272, 'trailer': 273, 'tname_star': 274})"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""from types import SimpleNamespace"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""future_imports = {'annotations'}"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, value='', children=[], parent=None)"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):"",
            ""    return [(0, len(value))]"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and n.value.replace('_', '').isdigit()"",
            ""syms = SimpleNamespace("",
            ""    typedargslist=1,"",
            ""    arglist=2,"",
            ""    varargslist=3,"",
            ""    decorator=4,"",
            ""    argument=5,"",
            ""    return_stmt=6,"",
            ""    yield_expr=7,"",
            ""    testlist_star_expr=8,"",
            ""    star_expr=9,"",
            ""    annassign=10,"",
            ""    with_stmt=11,"",
            ""    atom=12,"",
            ""    testlist_gexp=13,"",
            ""    match_stmt=14,"",
            ""    except_clause=15,"",
            ""    subscriptlist=16,"",
            ""    trailer=17,"",
            ""    tname_star=18"",
            "")"",
            ""def is_simple_decorator_expression(n):"",
            ""    return True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token"",
            ""import ast as syms""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}"",
            ""class MockNode:\n    def pre_order(self):\n        return []\nnode = MockNode()"",
            ""def is_string_token(n):\n    return False"",
            ""def iter_fexpr_spans(value):\n    return []"",
            ""def is_number_token(n):\n    return False"",
            ""def is_simple_decorator_expression(n):\n    return False"",
            ""STARS = {token.STAR, token.DOUBLESTAR}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""from types import SimpleNamespace"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""future_imports = {'annotations'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}"",
            ""node = SimpleNamespace(pre_order=lambda: [SimpleNamespace(value='f\""example\""', type=None, parent=None, children=[])])"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: [(m.start(), m.end()) for m in re.finditer(r'{.*?}', value)]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.replace('_', '').isdigit()"",
            ""token = SimpleNamespace(SLASH='SLASH', COLONEQUAL=':=', COMMA=',', LPAR='(', RPAR=')', STAR='*', DOUBLESTAR='**')"",
            ""syms = SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', decorator='decorator', argument='argument', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', annassign='annassign', with_stmt='with_stmt', atom='atom', testlist_gexp='testlist_gexp', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star')"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""from types import SimpleNamespace"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = 'f-strings'"",
            ""    DEBUG_F_STRINGS = 'debug f-strings'"",
            ""    NUMERIC_UNDERSCORES = 'numeric underscores'"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions'"",
            ""    RELAXED_DECORATORS = 'relaxed decorators'"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls'"",
            ""    UNPACKING_ON_FLOW = 'unpacking on flow statements'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers'"",
            ""    PATTERN_MATCHING = 'pattern matching'"",
            ""    EXCEPT_STAR = 'except* clause'"",
            ""    VARIADIC_GENERICS = 'variadic generics'"",
            ""future_imports = {'annotations'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, value='', parent=None, children=[])"",
            ""def is_string_token(token):"",
            ""    return hasattr(token, 'value') and isinstance(token.value, str)"",
            ""def iter_fexpr_spans(value):"",
            ""    return [(m.start(), m.end()) for m in re.finditer(r'{.*?}', value)]"",
            ""def is_number_token(token):"",
            ""    return hasattr(token, 'value') and isinstance(token.value, str) and token.value.isdigit()"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = SimpleNamespace("",
            ""    typedargslist='typedargslist',"",
            ""    arglist='arglist',"",
            ""    varargslist='varargslist',"",
            ""    decorator='decorator',"",
            ""    argument='argument',"",
            ""    return_stmt='return_stmt',"",
            ""    yield_expr='yield_expr',"",
            ""    testlist_star_expr='testlist_star_expr',"",
            ""    star_expr='star_expr',"",
            ""    annassign='annassign',"",
            ""    with_stmt='with_stmt',"",
            ""    atom='atom',"",
            ""    testlist_gexp='testlist_gexp',"",
            ""    match_stmt='match_stmt',"",
            ""    except_clause='except_clause',"",
            ""    subscriptlist='subscriptlist',"",
            ""    trailer='trailer',"",
            ""    tname_star='tname_star'""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = 1"",
            ""    DEBUG_F_STRINGS = 2"",
            ""    NUMERIC_UNDERSCORES = 3"",
            ""    POS_ONLY_ARGUMENTS = 4"",
            ""    ASSIGNMENT_EXPRESSIONS = 5"",
            ""    RELAXED_DECORATORS = 6"",
            ""    TRAILING_COMMA_IN_DEF = 7"",
            ""    TRAILING_COMMA_IN_CALL = 8"",
            ""    UNPACKING_ON_FLOW = 9"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11"",
            ""    PATTERN_MATCHING = 12"",
            ""    EXCEPT_STAR = 13"",
            ""    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""node = type('Mock', (object,), {"",
            ""    'pre_order': lambda self: [],"",
            ""    'type': None,"",
            ""    'value': '',"",
            ""    'children': [],"",
            ""    'parent': None"",
            ""})()"",
            ""def is_string_token(n):"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):"",
            ""    return [(m.start(), m.end()) for m in re.finditer(r'{.*?}', value)]"",
            ""def is_number_token(n):"",
            ""    return hasattr(n, 'value') and n.value.replace('_', '').isdigit()"",
            ""token = type('token', (), {"",
            ""    'SLASH': 'SLASH',"",
            ""    'COLONEQUAL': 'COLONEQUAL',"",
            ""    'COMMA': 'COMMA',"",
            ""    'LPAR': 'LPAR',"",
            ""    'RPAR': 'RPAR',"",
            ""    'STAR': 'STAR'"",
            ""})"",
            ""syms = type('syms', (), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'varargslist': 'varargslist',"",
            ""    'decorator': 'decorator',"",
            ""    'argument': 'argument',"",
            ""    'return_stmt': 'return_stmt',"",
            ""    'yield_expr': 'yield_expr',"",
            ""    'testlist_star_expr': 'testlist_star_expr',"",
            ""    'star_expr': 'star_expr',"",
            ""    'annassign': 'annassign',"",
            ""    'with_stmt': 'with_stmt',"",
            ""    'atom': 'atom',"",
            ""    'testlist_gexp': 'testlist_gexp',"",
            ""    'match_stmt': 'match_stmt',"",
            ""    'except_clause': 'except_clause',"",
            ""    'subscriptlist': 'subscriptlist',"",
            ""    'trailer': 'trailer',"",
            ""    'tname_star': 'tname_star'"",
            ""})"",
            ""def is_simple_decorator_expression(n):"",
            ""    return True"",
            ""STARS = {'*', '**'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""from types import SimpleNamespace"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""future_imports = {'annotations'}"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, value='', parent=None, children=[])"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.replace('_', '').isdigit()"",
            ""token = SimpleNamespace(SLASH=1, COLONEQUAL=2, COMMA=3, LPAR=4, RPAR=5, STAR=6, DOUBLESTAR=7)"",
            ""syms = SimpleNamespace(typedargslist=8, arglist=9, varargslist=10, decorator=11, argument=12, return_stmt=13, yield_expr=14, testlist_star_expr=15, star_expr=16, annassign=17, with_stmt=18, atom=19, testlist_gexp=20, match_stmt=21, except_clause=22, subscriptlist=23, trailer=24, tname_star=25)"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}"",
            ""class MockNode:\n    def pre_order(self):\n        return []\nnode = MockNode()"",
            ""def is_string_token(n):\n    return False"",
            ""def iter_fexpr_spans(value):\n    return []"",
            ""def is_number_token(n):\n    return False"",
            ""def is_simple_decorator_expression(n):\n    return False"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = ast\n    \n    \n""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, value='', type=None, parent=None, children=None): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.children = children if children is not None else [] # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] + [child for ch in self.children for child in ch.pre_order()] # pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return [(i, i+len(value)) for i in range(len(value)) if value[i] in {'{', '}'}] # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'varargslist': 'varargslist', # pragma: no cover"",
            ""    'decorator': 'decorator', # pragma: no cover"",
            ""    'argument': 'argument', # pragma: no cover"",
            ""    'return_stmt': 'return_stmt', # pragma: no cover"",
            ""    'yield_expr': 'yield_expr', # pragma: no cover"",
            ""    'testlist_star_expr': 'testlist_star_expr', # pragma: no cover"",
            ""    'star_expr': 'star_expr', # pragma: no cover"",
            ""    'annassign': 'annassign', # pragma: no cover"",
            ""    'with_stmt': 'with_stmt', # pragma: no cover"",
            ""    'atom': 'atom', # pragma: no cover"",
            ""    'testlist_gexp': 'testlist_gexp', # pragma: no cover"",
            ""    'match_stmt': 'match_stmt', # pragma: no cover"",
            ""    'except_clause': 'except_clause', # pragma: no cover"",
            ""    'subscriptlist': 'subscriptlist', # pragma: no cover"",
            ""    'trailer': 'trailer', # pragma: no cover"",
            ""    'tname_star': 'tname_star' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [], 'type': None, 'value': '', 'children': [], 'parent': None})() # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""token = type('token', (), {'SLASH': 'SLASH', 'COLONEQUAL': 'COLONEQUAL', 'COMMA': 'COMMA', 'LPAR': 'LPAR', 'RPAR': 'RPAR', 'STAR': 'STAR'}) # pragma: no cover"",
            ""syms = type('syms', (), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'varargslist': 'varargslist', 'decorator': 'decorator', 'argument': 'argument', 'return_stmt': 'return_stmt', 'yield_expr': 'yield_expr', 'testlist_star_expr': 'testlist_star_expr', 'star_expr': 'star_expr', 'annassign': 'annassign', 'with_stmt': 'with_stmt', 'atom': 'atom', 'testlist_gexp': 'testlist_gexp', 'match_stmt': 'match_stmt', 'except_clause': 'except_clause', 'subscriptlist': 'subscriptlist', 'trailer': 'trailer', 'tname_star': 'tname_star'}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: False # pragma: no cover"",
            ""STARS = {'*', '**'} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [], 'type': None, 'children': [], 'parent': None, 'value': ''})() # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value)) for _ in range(1)] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""syms = type('syms', (), {'typedargslist': 257, 'arglist': 258, 'varargslist': 259, 'decorator': 260, 'argument': 261, 'return_stmt': 262, 'yield_expr': 263, 'testlist_star_expr': 264, 'star_expr': 265, 'annassign': 266, 'with_stmt': 267, 'atom': 268, 'testlist_gexp': 269, 'match_stmt': 270, 'except_clause': 271, 'subscriptlist': 272, 'trailer': 273, 'tname_star': 274}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, value='', children=[], parent=None) # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""syms = SimpleNamespace( # pragma: no cover"",
            ""    typedargslist=1, # pragma: no cover"",
            ""    arglist=2, # pragma: no cover"",
            ""    varargslist=3, # pragma: no cover"",
            ""    decorator=4, # pragma: no cover"",
            ""    argument=5, # pragma: no cover"",
            ""    return_stmt=6, # pragma: no cover"",
            ""    yield_expr=7, # pragma: no cover"",
            ""    testlist_star_expr=8, # pragma: no cover"",
            ""    star_expr=9, # pragma: no cover"",
            ""    annassign=10, # pragma: no cover"",
            ""    with_stmt=11, # pragma: no cover"",
            ""    atom=12, # pragma: no cover"",
            ""    testlist_gexp=13, # pragma: no cover"",
            ""    match_stmt=14, # pragma: no cover"",
            ""    except_clause=15, # pragma: no cover"",
            ""    subscriptlist=16, # pragma: no cover"",
            ""    trailer=17, # pragma: no cover"",
            ""    tname_star=18 # pragma: no cover"",
            "") # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""def is_simple_decorator_expression(n):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover"",
            ""node = SimpleNamespace(pre_order=lambda: [SimpleNamespace(value='f\""example\""', type=None, parent=None, children=[])]) # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(m.start(), m.end()) for m in re.finditer(r'{.*?}', value)] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""token = SimpleNamespace(SLASH='SLASH', COLONEQUAL=':=', COMMA=',', LPAR='(', RPAR=')', STAR='*', DOUBLESTAR='**') # pragma: no cover"",
            ""syms = SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', decorator='decorator', argument='argument', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', annassign='annassign', with_stmt='with_stmt', atom='atom', testlist_gexp='testlist_gexp', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star') # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = 'f-strings' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug f-strings' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric underscores' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed decorators' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking on flow statements' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern matching' # pragma: no cover"",
            ""    EXCEPT_STAR = 'except* clause' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic generics' # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, value='', parent=None, children=[]) # pragma: no cover"",
            ""def is_string_token(token): # pragma: no cover"",
            ""    return hasattr(token, 'value') and isinstance(token.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return [(m.start(), m.end()) for m in re.finditer(r'{.*?}', value)] # pragma: no cover"",
            ""def is_number_token(token): # pragma: no cover"",
            ""    return hasattr(token, 'value') and isinstance(token.value, str) and token.value.isdigit() # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = 1 # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2 # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3 # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4 # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5 # pragma: no cover"",
            ""    RELAXED_DECORATORS = 6 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8 # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9 # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10 # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11 # pragma: no cover"",
            ""    PATTERN_MATCHING = 12 # pragma: no cover"",
            ""    EXCEPT_STAR = 13 # pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""node = type('Mock', (object,), { # pragma: no cover"",
            ""    'pre_order': lambda self: [], # pragma: no cover"",
            ""    'type': None, # pragma: no cover"",
            ""    'value': '', # pragma: no cover"",
            ""    'children': [], # pragma: no cover"",
            ""    'parent': None # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return [(m.start(), m.end()) for m in re.finditer(r'{.*?}', value)] # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""token = type('token', (), { # pragma: no cover"",
            ""    'SLASH': 'SLASH', # pragma: no cover"",
            ""    'COLONEQUAL': 'COLONEQUAL', # pragma: no cover"",
            ""    'COMMA': 'COMMA', # pragma: no cover"",
            ""    'LPAR': 'LPAR', # pragma: no cover"",
            ""    'RPAR': 'RPAR', # pragma: no cover"",
            ""    'STAR': 'STAR' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""syms = type('syms', (), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'varargslist': 'varargslist', # pragma: no cover"",
            ""    'decorator': 'decorator', # pragma: no cover"",
            ""    'argument': 'argument', # pragma: no cover"",
            ""    'return_stmt': 'return_stmt', # pragma: no cover"",
            ""    'yield_expr': 'yield_expr', # pragma: no cover"",
            ""    'testlist_star_expr': 'testlist_star_expr', # pragma: no cover"",
            ""    'star_expr': 'star_expr', # pragma: no cover"",
            ""    'annassign': 'annassign', # pragma: no cover"",
            ""    'with_stmt': 'with_stmt', # pragma: no cover"",
            ""    'atom': 'atom', # pragma: no cover"",
            ""    'testlist_gexp': 'testlist_gexp', # pragma: no cover"",
            ""    'match_stmt': 'match_stmt', # pragma: no cover"",
            ""    'except_clause': 'except_clause', # pragma: no cover"",
            ""    'subscriptlist': 'subscriptlist', # pragma: no cover"",
            ""    'trailer': 'trailer', # pragma: no cover"",
            ""    'tname_star': 'tname_star' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            ""STARS = {'*', '**'} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, value='', parent=None, children=[]) # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""token = SimpleNamespace(SLASH=1, COLONEQUAL=2, COMMA=3, LPAR=4, RPAR=5, STAR=6, DOUBLESTAR=7) # pragma: no cover"",
            ""syms = SimpleNamespace(typedargslist=8, arglist=9, varargslist=10, decorator=11, argument=12, return_stmt=13, yield_expr=14, testlist_star_expr=15, star_expr=16, annassign=17, with_stmt=18, atom=19, testlist_gexp=20, match_stmt=21, except_clause=22, subscriptlist=23, trailer=24, tname_star=25) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""def is_simple_decorator_expression(n):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""syms = ast# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    # pragma: no cover"",
            "" # pragma: no cover""
        ]
    }
]",2,7848,0.003924,5617,0.0084255,0.0123495
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 48:
    if future_imports:
NameError: name 'future_imports' is not defined
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token"",
            ""import ast as syms""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}"",
            ""class MockNode:\n    def pre_order(self):\n        return []\nnode = MockNode()"",
            ""def is_string_token(n):\n    return False"",
            ""def iter_fexpr_spans(value):\n    return []"",
            ""def is_number_token(n):\n    return False"",
            ""def is_simple_decorator_expression(n):\n    return False"",
            ""STARS = {token.STAR, token.DOUBLESTAR}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token"",
            ""import symbol as syms""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}"",
            ""class MockNode:\n    def pre_order(self):\n        return []\nnode = MockNode()"",
            ""def is_string_token(n):\n    return False"",
            ""def iter_fexpr_spans(value):\n    return []"",
            ""def is_number_token(n):\n    return False"",
            ""def is_simple_decorator_expression(n):\n    return False"",
            ""STARS = {token.STAR, token.DOUBLESTAR}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import symbol as syms"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [], 'type': None, 'children': [], 'parent': None })()"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: []"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.isdigit()"",
            ""is_simple_decorator_expression = lambda n: isinstance(n, str)"",
            ""STARS = {token.STAR, token.DOUBLESTAR}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, value='', children=[], parent=None)"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.replace('_', '').isdigit()"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}"",
            ""syms = SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', decorator='decorator', argument='argument', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', annassign='annassign', with_stmt='with_stmt', atom='atom', testlist_gexp='testlist_gexp', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star')""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [], 'type': 0, 'value': '', 'children': [], 'parent': None})()"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] if 'f' in s else []"",
            ""is_number_token = lambda n: hasattr(n, 'value') and any(c.isdigit() for c in n.value)"",
            ""token = type('Token', (), {'SLASH': 0, 'COLONEQUAL': 1, 'COMMA': 2, 'LPAR': 3, 'RPAR': 4, 'STAR': 5})"",
            ""syms = type('Syms', (), {'typedargslist': 0, 'arglist': 1, 'varargslist': 2, 'decorator': 3, 'argument': 4, 'return_stmt': 5, 'yield_expr': 6, 'testlist_star_expr': 7, 'star_expr': 8, 'annassign': 9, 'with_stmt': 10, 'atom': 11, 'testlist_gexp': 12, 'match_stmt': 13, 'except_clause': 14, 'subscriptlist': 15, 'trailer': 16, 'tname_star': 17})"",
            ""is_simple_decorator_expression = lambda n: False"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import symbol as syms"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [], 'type': None, 'children': [], 'parent': None, 'value': ''})()"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and '_' in n.value"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import symbol as syms"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: []})()"",
            ""is_string_token = lambda x: False"",
            ""iter_fexpr_spans = lambda x: iter([])"",
            ""is_number_token = lambda x: False"",
            ""is_simple_decorator_expression = lambda x: False"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.PARENTHESIZED_CONTEXT_MANAGERS}"",
            ""STARS = {token.STAR}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token"",
            ""import ast as syms""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [], 'type': None, 'children': [], 'parent': None, 'value': ''})()"",
            ""def is_string_token(n):\n    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):\n    yield (0, len(value))"",
            ""def is_number_token(n):\n    return hasattr(n, 'value') and isinstance(n.value, str) and any(ch.isdigit() for ch in n.value)"",
            ""def is_simple_decorator_expression(n):\n    return True"",
            ""STARS = {token.STAR}"",
            ""syms.typedargslist = 1"",
            ""syms.arglist = 2"",
            ""syms.varargslist = 3"",
            ""syms.decorator = 4"",
            ""syms.argument = 5"",
            ""syms.return_stmt = 6"",
            ""syms.yield_expr = 7"",
            ""syms.testlist_star_expr = 8"",
            ""syms.star_expr = 9"",
            ""syms.annassign = 10"",
            ""syms.with_stmt = 11"",
            ""syms.atom = 12"",
            ""syms.testlist_gexp = 13"",
            ""syms.match_stmt = 14"",
            ""syms.except_clause = 15"",
            ""syms.subscriptlist = 16"",
            ""syms.trailer = 17"",
            ""syms.tname_star = 18""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""from types import SimpleNamespace"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = 1"",
            ""    DEBUG_F_STRINGS = 2"",
            ""    NUMERIC_UNDERSCORES = 3"",
            ""    POS_ONLY_ARGUMENTS = 4"",
            ""    ASSIGNMENT_EXPRESSIONS = 5"",
            ""    RELAXED_DECORATORS = 6"",
            ""    TRAILING_COMMA_IN_DEF = 7"",
            ""    TRAILING_COMMA_IN_CALL = 8"",
            ""    UNPACKING_ON_FLOW = 9"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11"",
            ""    PATTERN_MATCHING = 12"",
            ""    EXCEPT_STAR = 13"",
            ""    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, value='', children=[], parent=None)"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit()"",
            ""syms = SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', decorator='decorator', argument='argument', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', annassign='annassign', with_stmt='with_stmt', atom='atom', testlist_gexp='testlist_gexp', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star')"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import symbol as syms"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [], 'value': '', 'type': None, 'parent': None, 'children': []})()"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit()"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""def is_simple_decorator_expression(n):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import symbol as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""def is_simple_decorator_expression(n):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import symbol as syms # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [], 'type': None, 'children': [], 'parent': None })() # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.isdigit() # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: isinstance(n, str) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, value='', children=[], parent=None) # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover"",
            ""syms = SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', decorator='decorator', argument='argument', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', annassign='annassign', with_stmt='with_stmt', atom='atom', testlist_gexp='testlist_gexp', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star') # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [], 'type': 0, 'value': '', 'children': [], 'parent': None})() # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] if 'f' in s else [] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and any(c.isdigit() for c in n.value) # pragma: no cover"",
            ""token = type('Token', (), {'SLASH': 0, 'COLONEQUAL': 1, 'COMMA': 2, 'LPAR': 3, 'RPAR': 4, 'STAR': 5}) # pragma: no cover"",
            ""syms = type('Syms', (), {'typedargslist': 0, 'arglist': 1, 'varargslist': 2, 'decorator': 3, 'argument': 4, 'return_stmt': 5, 'yield_expr': 6, 'testlist_star_expr': 7, 'star_expr': 8, 'annassign': 9, 'with_stmt': 10, 'atom': 11, 'testlist_gexp': 12, 'match_stmt': 13, 'except_clause': 14, 'subscriptlist': 15, 'trailer': 16, 'tname_star': 17}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: False # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import symbol as syms # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [], 'type': None, 'children': [], 'parent': None, 'value': ''})() # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and '_' in n.value # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import symbol as syms # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: []})() # pragma: no cover"",
            ""is_string_token = lambda x: False # pragma: no cover"",
            ""iter_fexpr_spans = lambda x: iter([]) # pragma: no cover"",
            ""is_number_token = lambda x: False # pragma: no cover"",
            ""is_simple_decorator_expression = lambda x: False # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.PARENTHESIZED_CONTEXT_MANAGERS} # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [], 'type': None, 'children': [], 'parent': None, 'value': ''})() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) and any(ch.isdigit() for ch in n.value) # pragma: no cover"",
            ""def is_simple_decorator_expression(n):# pragma: no cover"",
            ""    return True # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""syms.typedargslist = 1 # pragma: no cover"",
            ""syms.arglist = 2 # pragma: no cover"",
            ""syms.varargslist = 3 # pragma: no cover"",
            ""syms.decorator = 4 # pragma: no cover"",
            ""syms.argument = 5 # pragma: no cover"",
            ""syms.return_stmt = 6 # pragma: no cover"",
            ""syms.yield_expr = 7 # pragma: no cover"",
            ""syms.testlist_star_expr = 8 # pragma: no cover"",
            ""syms.star_expr = 9 # pragma: no cover"",
            ""syms.annassign = 10 # pragma: no cover"",
            ""syms.with_stmt = 11 # pragma: no cover"",
            ""syms.atom = 12 # pragma: no cover"",
            ""syms.testlist_gexp = 13 # pragma: no cover"",
            ""syms.match_stmt = 14 # pragma: no cover"",
            ""syms.except_clause = 15 # pragma: no cover"",
            ""syms.subscriptlist = 16 # pragma: no cover"",
            ""syms.trailer = 17 # pragma: no cover"",
            ""syms.tname_star = 18 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = 1 # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2 # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3 # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4 # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5 # pragma: no cover"",
            ""    RELAXED_DECORATORS = 6 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8 # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9 # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10 # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11 # pragma: no cover"",
            ""    PATTERN_MATCHING = 12 # pragma: no cover"",
            ""    EXCEPT_STAR = 13 # pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, value='', children=[], parent=None) # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""syms = SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', decorator='decorator', argument='argument', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', annassign='annassign', with_stmt='with_stmt', atom='atom', testlist_gexp='testlist_gexp', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star') # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import symbol as syms # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [], 'value': '', 'type': None, 'parent': None, 'children': []})() # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover""
        ]
    }
]",2,8456,0.004228,4198,0.006297,0.010525
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 59:
    if future_imports:
NameError: name 'future_imports' is not defined
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import ast as syms"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}"",
            ""class MockNode:\n    def pre_order(self):\n        return []\nnode = MockNode()"",
            ""def is_string_token(n):\n    return False"",
            ""def iter_fexpr_spans(value):\n    return []"",
            ""def is_number_token(n):\n    return False"",
            ""def is_simple_decorator_expression(n):\n    return False"",
            ""STARS = {token.STAR, token.DOUBLESTAR}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""future_imports = {'annotations'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [], 'value': '', 'type': None, 'parent': None, 'children': []})()"",
            ""def is_string_token(n):"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):"",
            ""    return [(0, len(value))] if value else []"",
            ""def is_number_token(n):"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) and n.value.isdigit()"",
            ""def is_simple_decorator_expression(n):"",
            ""    return isinstance(n, str)"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'argument': 5,"",
            ""    'return_stmt': 6,"",
            ""    'yield_expr': 7,"",
            ""    'testlist_star_expr': 8,"",
            ""    'star_expr': 9,"",
            ""    'annassign': 10,"",
            ""    'with_stmt': 11,"",
            ""    'atom': 12,"",
            ""    'testlist_gexp': 13,"",
            ""    'match_stmt': 14,"",
            ""    'except_clause': 15,"",
            ""    'subscriptlist': 16,"",
            ""    'trailer': 17,"",
            ""    'tname_star': 18"",
            ""})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import symbol as syms"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = set()"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [], 'value': '', 'type': None, 'parent': None, 'children': []})()"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: [(m.start(), m.end()) for m in re.finditer(r'{.*?}', value)]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.replace('_', '').isdigit()"",
            ""is_simple_decorator_expression = lambda expr: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import ast as syms"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            """",
            ""future_imports = {'annotations'}"",
            ""node = type('Node', (object,), {'pre_order': lambda self: [], 'type': None, 'value': '', 'children': [], 'parent': None})()"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: iter([])"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.replace('_', '').isdigit()"",
            ""token.SLASH = 1"",
            ""token.COLONEQUAL = 2"",
            ""token.COMMA = 3"",
            ""token.STAR = 4"",
            ""token.DOUBLESTAR = 5"",
            ""syms.typedargslist = 6"",
            ""syms.arglist = 7"",
            ""syms.varargslist = 8"",
            ""syms.decorator = 9"",
            ""syms.argument = 10"",
            ""syms.return_stmt = 11"",
            ""syms.yield_expr = 12"",
            ""syms.testlist_star_expr = 13"",
            ""syms.star_expr = 14"",
            ""syms.annassign = 15"",
            ""syms.with_stmt = 16"",
            ""syms.atom = 17"",
            ""syms.testlist_gexp = 18"",
            ""syms.match_stmt = 19"",
            ""syms.except_clause = 20"",
            ""syms.subscriptlist = 21"",
            ""syms.trailer = 22"",
            ""syms.tname_star = 23"",
            ""is_simple_decorator_expression = lambda n: False"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from types import SimpleNamespace"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'F_STRINGS'"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = {'annotations'}"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, children=[])"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""token = SimpleNamespace(SLASH=token.SLASH, COLONEQUAL=token.COLONEQUAL, COMMA=token.COMMA, LPAR=token.LPAR, RPAR=token.RPAR, STAR=token.STAR)"",
            ""syms = SimpleNamespace(typedargslist=ast.arguments, arglist=ast.arguments, varargslist=ast.arguments, decorator=ast.FunctionDef, argument=ast.arg, return_stmt=ast.Return, yield_expr=ast.Yield, testlist_star_expr=ast.Tuple, star_expr=ast.Starred, annassign=ast.AnnAssign, with_stmt=ast.With, atom=ast.Name, testlist_gexp=ast.GeneratorExp, match_stmt=ast.Match, except_clause=ast.ExceptHandler, subscriptlist=ast.Subscript, trailer=ast.Call, tname_star=ast.Starred)"",
            ""is_simple_decorator_expression = lambda expr: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from types import SimpleNamespace"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f-strings'\n    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings'\n    NUMERIC_UNDERSCORES = 'underscores in numeric literals'\n    POS_ONLY_ARGUMENTS = 'positional only arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment expressions'\n    RELAXED_DECORATORS = 'relaxed decorator syntax'\n    TRAILING_COMMA_IN_DEF = 'trailing commas after * or ** in function definitions'\n    TRAILING_COMMA_IN_CALL = 'trailing commas after * or ** in function calls'\n    UNPACKING_ON_FLOW = 'unpacking expressions in flow statements'\n    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs annotation assignments'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers'\n    PATTERN_MATCHING = 'pattern matching statements'\n    EXCEPT_STAR = 'except* clause'\n    VARIADIC_GENERICS = 'variadic generics'"",
            ""future_imports = {'annotations'}"",
            ""node = SimpleNamespace(pre_order=lambda: [], value='')"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda s: [(m.start(), m.end()) for m in re.finditer(r'{.*?}', s)]"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.replace('_', '').isdigit()"",
            ""token = SimpleNamespace(SLASH='/', COLONEQUAL=':=', COMMA=',', LPAR='(', RPAR=')', STAR='*')"",
            ""syms = SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', decorator='decorator', argument='argument', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', annassign='annassign', with_stmt='with_stmt', atom='atom', testlist_gexp='testlist_gexp', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star')"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {'*', '**'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = auto()\n    DEBUG_F_STRINGS = auto()\n    NUMERIC_UNDERSCORES = auto()\n    POS_ONLY_ARGUMENTS = auto()\n    ASSIGNMENT_EXPRESSIONS = auto()\n    RELAXED_DECORATORS = auto()\n    TRAILING_COMMA_IN_DEF = auto()\n    TRAILING_COMMA_IN_CALL = auto()\n    UNPACKING_ON_FLOW = auto()\n    ANN_ASSIGN_EXTENDED_RHS = auto()\n    PARENTHESIZED_CONTEXT_MANAGERS = auto()\n    PATTERN_MATCHING = auto()\n    EXCEPT_STAR = auto()\n    VARIADIC_GENERICS = auto()"",
            ""future_imports = {'annotations'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, value='', parent=None, children=[])"",
            ""def is_string_token(n):\n    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):\n    return []"",
            ""def is_number_token(n):\n    return hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit()"",
            ""token = SimpleNamespace(SLASH=1, COLONEQUAL=2, COMMA=3, LPAR=4, RPAR=5, STAR=6, DOUBLESTAR=7)"",
            ""syms = SimpleNamespace(typedargslist=1, arglist=2, varargslist=3, decorator=4, argument=5, return_stmt=6, yield_expr=7, testlist_star_expr=8, star_expr=9, annassign=10, with_stmt=11, atom=12, testlist_gexp=13, match_stmt=14, except_clause=15, subscriptlist=16, trailer=17, tname_star=18)"",
            ""def is_simple_decorator_expression(n):\n    return True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'f-strings'"",
            ""    DEBUG_F_STRINGS = 'debug f-strings'"",
            ""    NUMERIC_UNDERSCORES = 'numeric underscores'"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions'"",
            ""    RELAXED_DECORATORS = 'relaxed decorators'"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls'"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers'"",
            ""    PATTERN_MATCHING = 'pattern matching'"",
            ""    EXCEPT_STAR = 'except* clause'"",
            ""    VARIADIC_GENERICS = 'variadic generics'"",
            ""future_imports = {'annotations', 'another_future_import'}"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS"",
            ""}"",
            ""node = type('MockNode', (object,), {"",
            ""    'pre_order': lambda self: [],"",
            ""    'type': None,"",
            ""    'value': '',"",
            ""    'parent': None,"",
            ""    'children': []"",
            ""})()"",
            ""def is_string_token(n):"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):"",
            ""    return iter([])"",
            ""def is_number_token(n):"",
            ""    return hasattr(n, 'value') and n.value.replace('_', '').isdigit()"",
            ""syms = type('MockSyms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'argument': 5,"",
            ""    'return_stmt': 6,"",
            ""    'yield_expr': 7,"",
            ""    'testlist_star_expr': 8,"",
            ""    'star_expr': 9,"",
            ""    'annassign': 10,"",
            ""    'with_stmt': 11,"",
            ""    'atom': 12,"",
            ""    'testlist_gexp': 13,"",
            ""    'match_stmt': 14,"",
            ""    'except_clause': 15,"",
            ""    'subscriptlist': 16,"",
            ""    'trailer': 17,"",
            ""    'tname_star': 18"",
            ""})"",
            ""def is_simple_decorator_expression(expr):"",
            ""    return True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'F_STRINGS'"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = {'annotations'}"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [], 'type': None, 'value': '', 'children': [], 'parent': None})()"",
            ""def is_string_token(n):"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):"",
            ""    return [(0, len(value))] if 'f' in value else []"",
            ""def is_number_token(n):"",
            ""    return hasattr(n, 'value') and any(ch.isdigit() for ch in n.value)"",
            ""class mock_token:"",
            ""    SLASH = token.SLASH"",
            ""    COLONEQUAL = token.COLONEQUAL"",
            ""    COMMA = token.COMMA"",
            ""    LPAR = token.LPAR"",
            ""    RPAR = token.RPAR"",
            ""    STAR = token.STAR"",
            ""class mock_syms:"",
            ""    typedargslist = 1"",
            ""    arglist = 2"",
            ""    varargslist = 3"",
            ""    decorator = 4"",
            ""    argument = 5"",
            ""    return_stmt = 6"",
            ""    yield_expr = 7"",
            ""    testlist_star_expr = 8"",
            ""    star_expr = 9"",
            ""    annassign = 10"",
            ""    with_stmt = 11"",
            ""    atom = 12"",
            ""    testlist_gexp = 13"",
            ""    match_stmt = 14"",
            ""    except_clause = 15"",
            ""    subscriptlist = 16"",
            ""    trailer = 17"",
            ""    tname_star = 18"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {mock_token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = {'annotations'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}"",
            ""class MockNode:\n    def __init__(self):\n        self.type = None\n        self.value = ''\n        self.children = []\n        self.parent = None\n    def pre_order(self):\n        return [self]\nnode = MockNode()"",
            ""def is_string_token(n):\n    return isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""def is_number_token(n):\n    return isinstance(n.value, str) and n.value.isdigit()"",
            ""syms = type('syms', (object,), {\n    'typedargslist': 1,\n    'arglist': 2,\n    'varargslist': 3,\n    'decorator': 4,\n    'argument': 5,\n    'return_stmt': 6,\n    'yield_expr': 7,\n    'testlist_star_expr': 8,\n    'star_expr': 9,\n    'annassign': 10,\n    'with_stmt': 11,\n    'atom': 12,\n    'testlist_gexp': 13,\n    'match_stmt': 14,\n    'except_clause': 15,\n    'subscriptlist': 16,\n    'trailer': 17,\n    'tname_star': 18\n})"",
            ""def is_simple_decorator_expression(n):\n    return True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast as syms # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""def is_simple_decorator_expression(n):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [], 'value': '', 'type': None, 'parent': None, 'children': []})() # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return [(0, len(value))] if value else [] # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) and n.value.isdigit() # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return isinstance(n, str) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'return_stmt': 6, # pragma: no cover"",
            ""    'yield_expr': 7, # pragma: no cover"",
            ""    'testlist_star_expr': 8, # pragma: no cover"",
            ""    'star_expr': 9, # pragma: no cover"",
            ""    'annassign': 10, # pragma: no cover"",
            ""    'with_stmt': 11, # pragma: no cover"",
            ""    'atom': 12, # pragma: no cover"",
            ""    'testlist_gexp': 13, # pragma: no cover"",
            ""    'match_stmt': 14, # pragma: no cover"",
            ""    'except_clause': 15, # pragma: no cover"",
            ""    'subscriptlist': 16, # pragma: no cover"",
            ""    'trailer': 17, # pragma: no cover"",
            ""    'tname_star': 18 # pragma: no cover"",
            ""}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import symbol as syms # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [], 'value': '', 'type': None, 'parent': None, 'children': []})() # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(m.start(), m.end()) for m in re.finditer(r'{.*?}', value)] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""is_simple_decorator_expression = lambda expr: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast as syms # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            "" # pragma: no cover"",
            ""node = type('Node', (object,), {'pre_order': lambda self: [], 'type': None, 'value': '', 'children': [], 'parent': None})() # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: iter([]) # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""token.SLASH = 1 # pragma: no cover"",
            ""token.COLONEQUAL = 2 # pragma: no cover"",
            ""token.COMMA = 3 # pragma: no cover"",
            ""token.STAR = 4 # pragma: no cover"",
            ""token.DOUBLESTAR = 5 # pragma: no cover"",
            ""syms.typedargslist = 6 # pragma: no cover"",
            ""syms.arglist = 7 # pragma: no cover"",
            ""syms.varargslist = 8 # pragma: no cover"",
            ""syms.decorator = 9 # pragma: no cover"",
            ""syms.argument = 10 # pragma: no cover"",
            ""syms.return_stmt = 11 # pragma: no cover"",
            ""syms.yield_expr = 12 # pragma: no cover"",
            ""syms.testlist_star_expr = 13 # pragma: no cover"",
            ""syms.star_expr = 14 # pragma: no cover"",
            ""syms.annassign = 15 # pragma: no cover"",
            ""syms.with_stmt = 16 # pragma: no cover"",
            ""syms.atom = 17 # pragma: no cover"",
            ""syms.testlist_gexp = 18 # pragma: no cover"",
            ""syms.match_stmt = 19 # pragma: no cover"",
            ""syms.except_clause = 20 # pragma: no cover"",
            ""syms.subscriptlist = 21 # pragma: no cover"",
            ""syms.trailer = 22 # pragma: no cover"",
            ""syms.tname_star = 23 # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: False # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING' # pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, children=[]) # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""token = SimpleNamespace(SLASH=token.SLASH, COLONEQUAL=token.COLONEQUAL, COMMA=token.COMMA, LPAR=token.LPAR, RPAR=token.RPAR, STAR=token.STAR) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda expr: True # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f-strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'self-documenting expressions in f-strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'underscores in numeric literals'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed decorator syntax'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing commas after * or ** in function definitions'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing commas after * or ** in function calls'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow statements'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs annotation assignments'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern matching statements'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except* clause'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic generics' # pragma: no cover"",
            ""node = SimpleNamespace(pre_order=lambda: [], value='') # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(m.start(), m.end()) for m in re.finditer(r'{.*?}', s)] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""token = SimpleNamespace(SLASH='/', COLONEQUAL=':=', COMMA=',', LPAR='(', RPAR=')', STAR='*') # pragma: no cover"",
            ""syms = SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', decorator='decorator', argument='argument', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', annassign='annassign', with_stmt='with_stmt', atom='atom', testlist_gexp='testlist_gexp', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star') # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {'*', '**'} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = auto()# pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto()# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto()# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto()# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()# pragma: no cover"",
            ""    RELAXED_DECORATORS = auto()# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto()# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto()# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto()# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()# pragma: no cover"",
            ""    PATTERN_MATCHING = auto()# pragma: no cover"",
            ""    EXCEPT_STAR = auto()# pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover"",
            ""node = SimpleNamespace(pre_order=lambda: [], type=None, value='', parent=None, children=[]) # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""token = SimpleNamespace(SLASH=1, COLONEQUAL=2, COMMA=3, LPAR=4, RPAR=5, STAR=6, DOUBLESTAR=7) # pragma: no cover"",
            ""syms = SimpleNamespace(typedargslist=1, arglist=2, varargslist=3, decorator=4, argument=5, return_stmt=6, yield_expr=7, testlist_star_expr=8, star_expr=9, annassign=10, with_stmt=11, atom=12, testlist_gexp=13, match_stmt=14, except_clause=15, subscriptlist=16, trailer=17, tname_star=18) # pragma: no cover"",
            ""def is_simple_decorator_expression(n):# pragma: no cover"",
            ""    return True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'f-strings' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug f-strings' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric underscores' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'positional only arguments' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment expressions' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed decorators' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing comma in function definitions' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing comma in function calls' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking expressions in flow control statements' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'extended rhs in annotated assignments' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern matching' # pragma: no cover"",
            ""    EXCEPT_STAR = 'except* clause' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic generics' # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""node = type('MockNode', (object,), { # pragma: no cover"",
            ""    'pre_order': lambda self: [], # pragma: no cover"",
            ""    'type': None, # pragma: no cover"",
            ""    'value': '', # pragma: no cover"",
            ""    'parent': None, # pragma: no cover"",
            ""    'children': [] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return iter([]) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and n.value.replace('_', '').isdigit() # pragma: no cover"",
            ""syms = type('MockSyms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'argument': 5, # pragma: no cover"",
            ""    'return_stmt': 6, # pragma: no cover"",
            ""    'yield_expr': 7, # pragma: no cover"",
            ""    'testlist_star_expr': 8, # pragma: no cover"",
            ""    'star_expr': 9, # pragma: no cover"",
            ""    'annassign': 10, # pragma: no cover"",
            ""    'with_stmt': 11, # pragma: no cover"",
            ""    'atom': 12, # pragma: no cover"",
            ""    'testlist_gexp': 13, # pragma: no cover"",
            ""    'match_stmt': 14, # pragma: no cover"",
            ""    'except_clause': 15, # pragma: no cover"",
            ""    'subscriptlist': 16, # pragma: no cover"",
            ""    'trailer': 17, # pragma: no cover"",
            ""    'tname_star': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""def is_simple_decorator_expression(expr): # pragma: no cover"",
            ""    return True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING' # pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [], 'type': None, 'value': '', 'children': [], 'parent': None})() # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return [(0, len(value))] if 'f' in value else [] # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'value') and any(ch.isdigit() for ch in n.value) # pragma: no cover"",
            ""class mock_token: # pragma: no cover"",
            ""    SLASH = token.SLASH # pragma: no cover"",
            ""    COLONEQUAL = token.COLONEQUAL # pragma: no cover"",
            ""    COMMA = token.COMMA # pragma: no cover"",
            ""    LPAR = token.LPAR # pragma: no cover"",
            ""    RPAR = token.RPAR # pragma: no cover"",
            ""    STAR = token.STAR # pragma: no cover"",
            ""class mock_syms: # pragma: no cover"",
            ""    typedargslist = 1 # pragma: no cover"",
            ""    arglist = 2 # pragma: no cover"",
            ""    varargslist = 3 # pragma: no cover"",
            ""    decorator = 4 # pragma: no cover"",
            ""    argument = 5 # pragma: no cover"",
            ""    return_stmt = 6 # pragma: no cover"",
            ""    yield_expr = 7 # pragma: no cover"",
            ""    testlist_star_expr = 8 # pragma: no cover"",
            ""    star_expr = 9 # pragma: no cover"",
            ""    annassign = 10 # pragma: no cover"",
            ""    with_stmt = 11 # pragma: no cover"",
            ""    atom = 12 # pragma: no cover"",
            ""    testlist_gexp = 13 # pragma: no cover"",
            ""    match_stmt = 14 # pragma: no cover"",
            ""    except_clause = 15 # pragma: no cover"",
            ""    subscriptlist = 16 # pragma: no cover"",
            ""    trailer = 17 # pragma: no cover"",
            ""    tname_star = 18 # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {mock_token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.type = None# pragma: no cover"",
            ""        self.value = ''# pragma: no cover"",
            ""        self.children = []# pragma: no cover"",
            ""        self.parent = None# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [self]# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.isdigit() # pragma: no cover"",
            ""syms = type('syms', (object,), {# pragma: no cover"",
            ""    'typedargslist': 1,# pragma: no cover"",
            ""    'arglist': 2,# pragma: no cover"",
            ""    'varargslist': 3,# pragma: no cover"",
            ""    'decorator': 4,# pragma: no cover"",
            ""    'argument': 5,# pragma: no cover"",
            ""    'return_stmt': 6,# pragma: no cover"",
            ""    'yield_expr': 7,# pragma: no cover"",
            ""    'testlist_star_expr': 8,# pragma: no cover"",
            ""    'star_expr': 9,# pragma: no cover"",
            ""    'annassign': 10,# pragma: no cover"",
            ""    'with_stmt': 11,# pragma: no cover"",
            ""    'atom': 12,# pragma: no cover"",
            ""    'testlist_gexp': 13,# pragma: no cover"",
            ""    'match_stmt': 14,# pragma: no cover"",
            ""    'except_clause': 15,# pragma: no cover"",
            ""    'subscriptlist': 16,# pragma: no cover"",
            ""    'trailer': 17,# pragma: no cover"",
            ""    'tname_star': 18# pragma: no cover"",
            ""}) # pragma: no cover"",
            ""def is_simple_decorator_expression(n):# pragma: no cover"",
            ""    return True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover""
        ]
    }
]",2,9144,0.004572,5656,0.008484,0.013056
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return a set of (relatively) new Python features used in this file.
    Currently looking for:
    - f-strings;
    - self-documenting expressions in f-strings (f""{x=}"");
    - underscores in numeric literals;
    - trailing commas after * or ** in function signatures and calls;
    - positional only arguments in function signatures and lambdas;
    - assignment expression;
    - relaxed decorator syntax;
    - usage of __future__ flags (annotations);
    - print / exec statements;
    - parenthesized context managers;
    - match statements;
    - except* clause;
    - variadic generics;
    """"""
features: Set[Feature] = set()
if future_imports: # uncovered
    features |= { # uncovered
        FUTURE_FLAG_TO_FEATURE[future_import] # uncovered
        for future_import in future_imports # uncovered
        if future_import in FUTURE_FLAG_TO_FEATURE # uncovered
    } # uncovered
for n in node.pre_order(): # uncovered
    if is_string_token(n): # uncovered
        value_head = n.value[:2] # uncovered
        if value_head in {'f""', 'F""', ""f'"", ""F'"", ""rf"", ""fr"", ""RF"", ""FR""}: # uncovered
            features.add(Feature.F_STRINGS) # uncovered
            if Feature.DEBUG_F_STRINGS not in features: # uncovered
                for span_beg, span_end in iter_fexpr_spans(n.value): # uncovered
                    if n.value[span_beg : span_end - 1].rstrip().endswith(""=""): # uncovered
                        features.add(Feature.DEBUG_F_STRINGS) # uncovered
                        break # uncovered
    elif is_number_token(n): # uncovered
        if ""_"" in n.value: # uncovered
            features.add(Feature.NUMERIC_UNDERSCORES) # uncovered
    elif n.type == token.SLASH: # uncovered
        if n.parent and n.parent.type in { # uncovered
            syms.typedargslist, # uncovered
            syms.arglist, # uncovered
            syms.varargslist, # uncovered
        }: # uncovered
            features.add(Feature.POS_ONLY_ARGUMENTS) # uncovered
    elif n.type == token.COLONEQUAL: # uncovered
        features.add(Feature.ASSIGNMENT_EXPRESSIONS) # uncovered
    elif n.type == syms.decorator: # uncovered
        if len(n.children) > 1 and not is_simple_decorator_expression( # uncovered
            n.children[1] # uncovered
        ): # uncovered
            features.add(Feature.RELAXED_DECORATORS) # uncovered
    elif ( # uncovered
        n.type in {syms.typedargslist, syms.arglist} # uncovered
        and n.children # uncovered
        and n.children[-1].type == token.COMMA # uncovered
    ): # uncovered
        if n.type == syms.typedargslist: # uncovered
            feature = Feature.TRAILING_COMMA_IN_DEF # uncovered
        else: # uncovered
            feature = Feature.TRAILING_COMMA_IN_CALL # uncovered
        for ch in n.children: # uncovered
            if ch.type in STARS: # uncovered
                features.add(feature) # uncovered
            if ch.type == syms.argument: # uncovered
                for argch in ch.children: # uncovered
                    if argch.type in STARS: # uncovered
                        features.add(feature) # uncovered
    elif ( # uncovered
        n.type in {syms.return_stmt, syms.yield_expr} # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == syms.testlist_star_expr # uncovered
        and any(child.type == syms.star_expr for child in n.children[1].children) # uncovered
    ): # uncovered
        features.add(Feature.UNPACKING_ON_FLOW) # uncovered
    elif ( # uncovered
        n.type == syms.annassign # uncovered
        and len(n.children) >= 4 # uncovered
        and n.children[3].type == syms.testlist_star_expr # uncovered
    ): # uncovered
        features.add(Feature.ANN_ASSIGN_EXTENDED_RHS) # uncovered
    elif ( # uncovered
        n.type == syms.with_stmt # uncovered
        and len(n.children) > 2 # uncovered
        and n.children[1].type == syms.atom # uncovered
    ): # uncovered
        atom_children = n.children[1].children # uncovered
        if ( # uncovered
            len(atom_children) == 3 # uncovered
            and atom_children[0].type == token.LPAR # uncovered
            and atom_children[1].type == syms.testlist_gexp # uncovered
            and atom_children[2].type == token.RPAR # uncovered
        ): # uncovered
            features.add(Feature.PARENTHESIZED_CONTEXT_MANAGERS) # uncovered
    elif n.type == syms.match_stmt: # uncovered
        features.add(Feature.PATTERN_MATCHING) # uncovered
    elif ( # uncovered
        n.type == syms.except_clause # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == token.STAR # uncovered
    ): # uncovered
        features.add(Feature.EXCEPT_STAR) # uncovered
    elif n.type in {syms.subscriptlist, syms.trailer} and any( # uncovered
        child.type == syms.star_expr for child in n.children # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
    elif ( # uncovered
        n.type == syms.tname_star # uncovered
        and len(n.children) == 3 # uncovered
        and n.children[2].type == syms.star_expr # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
aux = features # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import ast"",
            ""syms = ast"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = ['annotations']"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}"",
            ""class NodeMock:\n    def __init__(self, type, value, children=[]):\n        self.type = type\n        self.value = value\n        self.children = children\n    def pre_order(self):\n        return [self]\n    def __repr__(self):\n        return f'NodeMock(type={self.type}, value={self.value}, children={self.children})'"",
            ""def is_string_token(n):\n    return isinstance(n.value, str) and (n.value.startswith(('f', 'F')))"",
            ""def is_number_token(n):\n    return n.value.isdigit()"",
            ""def iter_fexpr_spans(value):\n    return [(3, 5)]"",
            ""def is_simple_decorator_expression(n):\n    return True"",
            ""node = NodeMock(token.STRING, 'f\""example\""')""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token"",
            ""import ast"",
            ""from __future__ import annotations""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = 1"",
            ""    DEBUG_F_STRINGS = 2"",
            ""    NUMERIC_UNDERSCORES = 3"",
            ""    POS_ONLY_ARGUMENTS = 4"",
            ""    ASSIGNMENT_EXPRESSIONS = 5"",
            ""    RELAXED_DECORATORS = 6"",
            ""    TRAILING_COMMA_IN_DEF = 7"",
            ""    TRAILING_COMMA_IN_CALL = 8"",
            ""    UNPACKING_ON_FLOW = 9"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11"",
            ""    PATTERN_MATCHING = 12"",
            ""    EXCEPT_STAR = 13"",
            ""    VARIADIC_GENERICS = 14"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    # Mock implementation"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def is_number_token(n):"",
            ""    # Mock implementation"",
            ""    return hasattr(n, 'value') and isinstance(n.value, (int, float))"",
            ""def iter_fexpr_spans(value):"",
            ""    # Mock implementation"",
            ""    yield 0, len(value)"",
            ""def is_simple_decorator_expression(child):"",
            ""    # Mock implementation"",
            ""    return False"",
            ""syms = type('Mock', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'return_stmt': 4,"",
            ""    'yield_expr': 5,"",
            ""    'testlist_star_expr': 6,"",
            ""    'annassign': 7,"",
            ""    'with_stmt': 8,"",
            ""    'atom': 9,"",
            ""    'testlist_gexp': 10,"",
            ""    'match_stmt': 11,"",
            ""    'except_clause': 12,"",
            ""    'subscriptlist': 13,"",
            ""    'trailer': 14,"",
            ""    'tname_star': 15,"",
            ""    'star_expr': 16"",
            ""})"",
            ""STARS = {16}"",
            ""node = type('Mock', (object,), {"",
            ""    'pre_order': lambda self: ["",
            ""        type('Mock', (object,), {"",
            ""            'value': 'f\""example\""',"",
            ""            'type': token.STRING,"",
            ""            'parent': None"",
            ""        })"",
            ""    ]"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""class Feature:"",
            ""    F_STRINGS = 'f-strings'"",
            ""    DEBUG_F_STRINGS = 'debug-f-strings'"",
            ""    NUMERIC_UNDERSCORES = 'numeric-literals'"",
            ""    POS_ONLY_ARGUMENTS = 'positional-only-arguments'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment-expressions'"",
            ""    RELAXED_DECORATORS = 'relaxed-decorators'"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing-comma-in-def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing-comma-in-call'"",
            ""    UNPACKING_ON_FLOW = 'unpacking-on-flow'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann-assign-extended-rhs'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized-context-managers'"",
            ""    PATTERN_MATCHING = 'pattern-matching'"",
            ""    EXCEPT_STAR = 'except*-clause'"",
            ""    VARIADIC_GENERICS = 'variadic-generics'"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'varargslist': 'varargslist',"",
            ""    'return_stmt': 'return_stmt',"",
            ""    'yield_expr': 'yield_expr',"",
            ""    'testlist_star_expr': 'testlist_star_expr',"",
            ""    'star_expr': 'star_expr',"",
            ""    'annassign': 'annassign',"",
            ""    'with_stmt': 'with_stmt',"",
            ""    'atom': 'atom',"",
            ""    'testlist_gexp': 'testlist_gexp',"",
            ""    'match_stmt': 'match_stmt',"",
            ""    'except_clause': 'except_clause',"",
            ""    'subscriptlist': 'subscriptlist',"",
            ""    'trailer': 'trailer',"",
            ""    'tname_star': 'tname_star',"",
            ""    'argument': 'argument'"",
            ""})"",
            ""STARS = {token.STAR, token.DOUBLESTAR}""
        ],
        ""initialization"": [
            ""future_imports = ['annotations']"",
            ""node = type('NodeMock', (object,), {"",
            ""    'pre_order': lambda self: ["",
            ""        type('Node', (object,), {'value': 'f\""{x}\""', 'type': token.STRING}),"",
            ""        type('Node', (object,), {'value': '100_000', 'type': token.NUMBER}),"",
            ""        type('Node', (object,), {'type': token.SLASH, 'parent': type('Parent', (object,), {'type': 'typedargslist'})}),"",
            ""        type('Node', (object,), {'type': token.COLONEQUAL}),"",
            ""        type('Node', (object,), {'type': 'decorator', 'children': [None, object()]}),"",
            ""        type('Node', (object,), {'type': 'arglist', 'children': [type('Child', (object,), {'type': token.COMMA, 'value': '*args'})]}),"",
            ""        type('Node', (object,), {'type': 'return_stmt', 'children': [None, type('Child', (object,), {'type': 'testlist_star_expr', 'children': [type('GrandChild', (object,), {'type': 'star_expr'})]})]}),"",
            ""        type('Node', (object,), {'type': 'annassign', 'children': [None, None, None, type('Child', (object,), {'type': 'testlist_star_expr'})]}),"",
            ""        type('Node', (object,), {'type': 'with_stmt', 'children': [None, type('Atom', (object,), {'type': 'atom', 'children': [token.LPAR, type('Child', (object,), {'type': 'testlist_gexp'}), token.RPAR]})]}),"",
            ""        type('Node', (object,), {'type': 'match_stmt'}),"",
            ""        type('Node', (object,), {'type': 'except_clause', 'children': [None, token.STAR]}),"",
            ""        type('Node', (object,), {'type': 'subscriptlist', 'children': [type('Child', (object,), {'type': 'star_expr'})]}),"",
            ""        type('Node', (object,), {'type': 'tname_star', 'children': [None, None, type('Child', (object,), {'type': 'star_expr'})]})"",
            ""    ]"",
            ""})()"",
            ""is_string_token = lambda n: n.type == token.STRING"",
            ""is_number_token = lambda n: n.type == token.NUMBER"",
            ""is_simple_decorator_expression = lambda x: False"",
            ""iter_fexpr_spans = lambda value: [(3, 6)]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import sys"",
            ""from typing import Any"",
            ""import symbol as syms""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'f_strings'"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'"",
            ""    PATTERN_MATCHING = 'pattern_matching'"",
            ""    EXCEPT_STAR = 'except_star'"",
            ""    VARIADIC_GENERICS = 'variadic_generics'"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'annotations'}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n: Any) -> bool:"",
            ""    return isinstance(n, type('Mock', (object,), {'value': 'f\""example\""'}))"",
            ""def iter_fexpr_spans(value: str):"",
            ""    return [(0, len(value))]"",
            ""def is_number_token(n: Any) -> bool:"",
            ""    return isinstance(n, type('Mock', (object,), {'value': '1_000'}))"",
            ""def is_simple_decorator_expression(n: Any) -> bool:"",
            ""    return False"",
            ""node = type('Mock', (object,), {'pre_order': lambda: ["",
            ""    type('Mock', (object,), {'value': 'f\""example\""', 'type': token.NAME, 'children': []})"",
            ""]})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from token import token"",
            ""from symtable import SymbolTable"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""Feature = type('Feature', (), {feature: feature for feature in ["",
            ""  'F_STRINGS',"",
            ""  'DEBUG_F_STRINGS',"",
            ""  'NUMERIC_UNDERSCORES',"",
            ""  'POS_ONLY_ARGUMENTS',"",
            ""  'ASSIGNMENT_EXPRESSIONS',"",
            ""  'RELAXED_DECORATORS',"",
            ""  'TRAILING_COMMA_IN_DEF',"",
            ""  'TRAILING_COMMA_IN_CALL',"",
            ""  'UNPACKING_ON_FLOW',"",
            ""  'ANN_ASSIGN_EXTENDED_RHS',"",
            ""  'PARENTHESIZED_CONTEXT_MANAGERS',"",
            ""  'PATTERN_MATCHING',"",
            ""  'EXCEPT_STAR',"",
            ""  'VARIADIC_GENERICS'"",
            ""]})"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature}"",
            ""future_imports = ['annotations']"",
            ""node = SimpleNamespace("",
            ""  pre_order=lambda: ["",
            ""    SimpleNamespace(type=token.COLONEQUAL, value='=')"",
            ""  ]"",
            "")"",
            ""is_string_token = lambda n: n.type == token.COLONEQUAL"",
            ""is_number_token = lambda n: False"",
            ""iter_fexpr_spans = lambda x: [(0, len(x))]"",
            ""is_simple_decorator_expression = lambda x: False"",
            ""STARS = {token.STAR}"",
            ""syms = SimpleNamespace("",
            ""  typedargslist=1,"",
            ""  arglist=2,"",
            ""  varargslist=3,"",
            ""  argument=4,"",
            ""  return_stmt=5,"",
            ""  yield_expr=6,"",
            ""  testlist_star_expr=7,"",
            ""  star_expr=8,"",
            ""  annassign=9,"",
            ""  with_stmt=10,"",
            ""  atom=11,"",
            ""  testlist_gexp=12,"",
            ""  match_stmt=13,"",
            ""  except_clause=14,"",
            ""  subscriptlist=15,"",
            ""  trailer=16,"",
            ""  tname_star=17"",
            "")""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Union"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""Feature = type('Feature', (object,), {name: name for name in ['F_STRINGS', 'DEBUG_F_STRINGS', 'NUMERIC_UNDERSCORES', 'POS_ONLY_ARGUMENTS', 'ASSIGNMENT_EXPRESSIONS', 'RELAXED_DECORATORS', 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL', 'UNPACKING_ON_FLOW', 'ANN_ASSIGN_EXTENDED_RHS', 'PARENTHESIZED_CONTEXT_MANAGERS', 'PATTERN_MATCHING', 'EXCEPT_STAR', 'VARIADIC_GENERICS']})"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""future_imports = {'annotations'}"",
            ""syms = type('syms', (object,), {name: index for index, name in enumerate(['typedargslist', 'arglist', 'varargslist', 'decorator', 'return_stmt', 'yield_expr', 'testlist_star_expr', 'star_expr', 'annassign', 'with_stmt', 'atom', 'testlist_gexp', 'match_stmt', 'except_clause', 'subscriptlist', 'trailer', 'tname_star'])})"",
            ""STARS = {token.STAR}"",
            ""def is_string_token(n): return isinstance(n, ast.Str)"",
            ""def is_number_token(n): return isinstance(n, ast.Num)"",
            ""def is_simple_decorator_expression(n): return isinstance(n, ast.expr)"",
            ""def iter_fexpr_spans(value): return iter([(0, len(value))])"",
            ""node = type('Node', (object,), {'pre_order': lambda self: [ast.Str(s='f\""example\""')], 'type': None, 'value': 'f\""example\""'})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""def is_string_token(n):"",
            ""    return isinstance(n, ast.Str)"",
            ""def is_number_token(n):"",
            ""    return isinstance(n, ast.Num)"",
            ""def iter_fexpr_spans(s):"",
            ""    yield (1, len(s))  # Mock implementation"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False  # Mock implementation"",
            ""syms = type('Mock', (object,), {})"",
            ""syms.typedargslist = auto()"",
            ""syms.arglist = auto()"",
            ""syms.varargslist = auto()"",
            ""syms.testlist_star_expr = auto()"",
            ""syms.star_expr = auto()"",
            ""syms.with_stmt = auto()"",
            ""syms.atom = auto()"",
            ""syms.match_stmt = auto()"",
            ""syms.except_clause = auto()"",
            ""syms.subscriptlist = auto()"",
            ""syms.trailer = auto()"",
            ""syms.tname_star = auto()"",
            ""syms.return_stmt = auto()"",
            ""syms.yield_expr = auto()"",
            ""syms.annassign = auto()"",
            ""STARS = {token.STAR}  # Mock implementation"",
            ""node = type('Mock', (object,), {'pre_order': lambda: [type('Mock', (object,), {'value': 'f\""example\""', 'type': token.STRING, 'children': [], 'parent': None})]})"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""future_imports = []""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""Feature = Enum('Feature', 'F_STRINGS DEBUG_F_STRINGS NUMERIC_UNDERSCORES POS_ONLY_ARGUMENTS ASSIGNMENT_EXPRESSIONS RELAXED_DECORATORS TRAILING_COMMA_IN_DEF TRAILING_COMMA_IN_CALL UNPACKING_ON_FLOW ANN_ASSIGN_EXTENDED_RHS PARENTHESIZED_CONTEXT_MANAGERS PATTERN_MATCHING EXCEPT_STAR VARIADIC_GENERICS')"",
            ""def is_string_token(n): return isinstance(n, type('Mock', (object,), {'value': 'f\""example\""'}))"",
            ""def is_number_token(n): return isinstance(n, type('Mock', (object,), {'value': '1_000'}))"",
            ""def iter_fexpr_spans(value): yield (0, len(value))"",
            ""def is_simple_decorator_expression(n): return False"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""future_imports = ['annotations']"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [type('Mock', (object,), {'type': token.STRING, 'value': 'f\""example\""', 'parent': self})]})()""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum, auto"",
            ""from typing import Set"",
            ""import token"",
            ""import ast"",
            ""from typed_ast import ast3, parse"",
            ""from typed_ast.ast3 import *""
        ],
        ""initialization"": [
            ""Feature = Enum('Feature', 'F_STRINGS DEBUG_F_STRINGS NUMERIC_UNDERSCORES POS_ONLY_ARGUMENTS ASSIGNMENT_EXPRESSIONS RELAXED_DECORATORS TRAILING_COMMA_IN_DEF TRAILING_COMMA_IN_CALL UNPACKING_ON_FLOW ANN_ASSIGN_EXTENDED_RHS PARENTHESIZED_CONTEXT_MANAGERS PATTERN_MATCHING EXCEPT_STAR VARIADIC_GENERICS')"",
            ""class Node:"",
            ""    def __init__(self, value, type, children=[]):"",
            ""        self.value = value"",
            ""        self.type = type"",
            ""        self.children = children"",
            ""        self.parent = None"",
            ""    def pre_order(self):"",
            ""        yield self"",
            ""        for child in self.children:"",
            ""            yield from child.pre_order()"",
            ""def is_string_token(node):"",
            ""    return node.type == token.STRING"",
            ""def is_number_token(node):"",
            ""    return node.type == token.NUMBER"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (3, len(value))"",
            ""def is_simple_decorator_expression(node):"",
            ""    return False"",
            ""future_imports = []"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = ast3"",
            ""node = type('MockNode', (object,), {})"",
            ""node = Node('', token.STRING, [Node(f'f\""example={1}\""', token.STRING)])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from some_module import Feature, FUTURE_FLAG_TO_FEATURE, syms, token, STARS, iter_fexpr_spans"",
            ""from other_module import is_string_token, is_number_token, is_simple_decorator_expression""
        ],
        ""initialization"": [
            ""future_imports = ['annotations']"",
            ""class MockNode(type('MockNodeBase', (object,), dict())):\n    def pre_order(self):\n        return [MockNode()]"",
            ""node = MockNode()"",
            ""node.value = 'f\""{x=}\""'"",
            ""node.children = [MockNode(), MockNode(), MockNode()]"",
            ""node.type = token.STRING"",
            ""node.parent = MockNode()"",
            ""node.parent.type = syms.typedargslist"",
            ""node.children[1].type = syms.atom"",
            ""node.children[1].children = [MockNode(), MockNode(), MockNode()]"",
            ""node.children[1].children[0].type = token.LPAR"",
            ""node.children[1].children[1].type = syms.testlist_gexp"",
            ""node.children[1].children[2].type = token.RPAR""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover"",
            ""syms = ast # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover"",
            ""class NodeMock:# pragma: no cover"",
            ""    def __init__(self, type, value, children=[]):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.children = children# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [self]# pragma: no cover"",
            ""    def __repr__(self):# pragma: no cover"",
            ""        return f'NodeMock(type={self.type}, value={self.value}, children={self.children})' # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return isinstance(n.value, str) and (n.value.startswith(('f', 'F'))) # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return n.value.isdigit() # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(3, 5)] # pragma: no cover"",
            ""def is_simple_decorator_expression(n):# pragma: no cover"",
            ""    return True # pragma: no cover"",
            ""node = NodeMock(token.STRING, 'f\""example\""') # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = 1 # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2 # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3 # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4 # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5 # pragma: no cover"",
            ""    RELAXED_DECORATORS = 6 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8 # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9 # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10 # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11 # pragma: no cover"",
            ""    PATTERN_MATCHING = 12 # pragma: no cover"",
            ""    EXCEPT_STAR = 13 # pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    # Mock implementation # pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    # Mock implementation # pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, (int, float)) # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    # Mock implementation # pragma: no cover"",
            ""    yield 0, len(value) # pragma: no cover"",
            ""def is_simple_decorator_expression(child): # pragma: no cover"",
            ""    # Mock implementation # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('Mock', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'return_stmt': 4, # pragma: no cover"",
            ""    'yield_expr': 5, # pragma: no cover"",
            ""    'testlist_star_expr': 6, # pragma: no cover"",
            ""    'annassign': 7, # pragma: no cover"",
            ""    'with_stmt': 8, # pragma: no cover"",
            ""    'atom': 9, # pragma: no cover"",
            ""    'testlist_gexp': 10, # pragma: no cover"",
            ""    'match_stmt': 11, # pragma: no cover"",
            ""    'except_clause': 12, # pragma: no cover"",
            ""    'subscriptlist': 13, # pragma: no cover"",
            ""    'trailer': 14, # pragma: no cover"",
            ""    'tname_star': 15, # pragma: no cover"",
            ""    'star_expr': 16 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {16} # pragma: no cover"",
            ""node = type('Mock', (object,), { # pragma: no cover"",
            ""    'pre_order': lambda self: [ # pragma: no cover"",
            ""        type('Mock', (object,), { # pragma: no cover"",
            ""            'value': 'f\""example\""', # pragma: no cover"",
            ""            'type': token.STRING, # pragma: no cover"",
            ""            'parent': None # pragma: no cover"",
            ""        }) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'f-strings' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug-f-strings' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric-literals' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'positional-only-arguments' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment-expressions' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed-decorators' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing-comma-in-def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing-comma-in-call' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking-on-flow' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann-assign-extended-rhs' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized-context-managers' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern-matching' # pragma: no cover"",
            ""    EXCEPT_STAR = 'except*-clause' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic-generics' # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'varargslist': 'varargslist', # pragma: no cover"",
            ""    'return_stmt': 'return_stmt', # pragma: no cover"",
            ""    'yield_expr': 'yield_expr', # pragma: no cover"",
            ""    'testlist_star_expr': 'testlist_star_expr', # pragma: no cover"",
            ""    'star_expr': 'star_expr', # pragma: no cover"",
            ""    'annassign': 'annassign', # pragma: no cover"",
            ""    'with_stmt': 'with_stmt', # pragma: no cover"",
            ""    'atom': 'atom', # pragma: no cover"",
            ""    'testlist_gexp': 'testlist_gexp', # pragma: no cover"",
            ""    'match_stmt': 'match_stmt', # pragma: no cover"",
            ""    'except_clause': 'except_clause', # pragma: no cover"",
            ""    'subscriptlist': 'subscriptlist', # pragma: no cover"",
            ""    'trailer': 'trailer', # pragma: no cover"",
            ""    'tname_star': 'tname_star', # pragma: no cover"",
            ""    'argument': 'argument' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover""
        ],
        ""initialization"": [
            ""node = type('NodeMock', (object,), { # pragma: no cover"",
            ""    'pre_order': lambda self: [ # pragma: no cover"",
            ""        type('Node', (object,), {'value': 'f\""{x}\""', 'type': token.STRING}), # pragma: no cover"",
            ""        type('Node', (object,), {'value': '100_000', 'type': token.NUMBER}), # pragma: no cover"",
            ""        type('Node', (object,), {'type': token.SLASH, 'parent': type('Parent', (object,), {'type': 'typedargslist'})}), # pragma: no cover"",
            ""        type('Node', (object,), {'type': token.COLONEQUAL}), # pragma: no cover"",
            ""        type('Node', (object,), {'type': 'decorator', 'children': [None, object()]}), # pragma: no cover"",
            ""        type('Node', (object,), {'type': 'arglist', 'children': [type('Child', (object,), {'type': token.COMMA, 'value': '*args'})]}), # pragma: no cover"",
            ""        type('Node', (object,), {'type': 'return_stmt', 'children': [None, type('Child', (object,), {'type': 'testlist_star_expr', 'children': [type('GrandChild', (object,), {'type': 'star_expr'})]})]}), # pragma: no cover"",
            ""        type('Node', (object,), {'type': 'annassign', 'children': [None, None, None, type('Child', (object,), {'type': 'testlist_star_expr'})]}), # pragma: no cover"",
            ""        type('Node', (object,), {'type': 'with_stmt', 'children': [None, type('Atom', (object,), {'type': 'atom', 'children': [token.LPAR, type('Child', (object,), {'type': 'testlist_gexp'}), token.RPAR]})]}), # pragma: no cover"",
            ""        type('Node', (object,), {'type': 'match_stmt'}), # pragma: no cover"",
            ""        type('Node', (object,), {'type': 'except_clause', 'children': [None, token.STAR]}), # pragma: no cover"",
            ""        type('Node', (object,), {'type': 'subscriptlist', 'children': [type('Child', (object,), {'type': 'star_expr'})]}), # pragma: no cover"",
            ""        type('Node', (object,), {'type': 'tname_star', 'children': [None, None, type('Child', (object,), {'type': 'star_expr'})]}) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""is_string_token = lambda n: n.type == token.STRING # pragma: no cover"",
            ""is_number_token = lambda n: n.type == token.NUMBER # pragma: no cover"",
            ""is_simple_decorator_expression = lambda x: False # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(3, 6)] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from typing import Any # pragma: no cover"",
            ""import symbol as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'f_strings' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching' # pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'annotations'} # pragma: no cover"",
            ""def is_string_token(n: Any) -> bool: # pragma: no cover"",
            ""    return isinstance(n, type('Mock', (object,), {'value': 'f\""example\""'})) # pragma: no cover"",
            ""def iter_fexpr_spans(value: str): # pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n: Any) -> bool: # pragma: no cover"",
            ""    return isinstance(n, type('Mock', (object,), {'value': '1_000'})) # pragma: no cover"",
            ""def is_simple_decorator_expression(n: Any) -> bool: # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""node = type('Mock', (object,), {'pre_order': lambda: [ # pragma: no cover"",
            ""    type('Mock', (object,), {'value': 'f\""example\""', 'type': token.NAME, 'children': []}) # pragma: no cover"",
            ""]})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from symtable import SymbolTable # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = type('Feature', (), {feature: feature for feature in [ # pragma: no cover"",
            ""  'F_STRINGS', # pragma: no cover"",
            ""  'DEBUG_F_STRINGS', # pragma: no cover"",
            ""  'NUMERIC_UNDERSCORES', # pragma: no cover"",
            ""  'POS_ONLY_ARGUMENTS', # pragma: no cover"",
            ""  'ASSIGNMENT_EXPRESSIONS', # pragma: no cover"",
            ""  'RELAXED_DECORATORS', # pragma: no cover"",
            ""  'TRAILING_COMMA_IN_DEF', # pragma: no cover"",
            ""  'TRAILING_COMMA_IN_CALL', # pragma: no cover"",
            ""  'UNPACKING_ON_FLOW', # pragma: no cover"",
            ""  'ANN_ASSIGN_EXTENDED_RHS', # pragma: no cover"",
            ""  'PARENTHESIZED_CONTEXT_MANAGERS', # pragma: no cover"",
            ""  'PATTERN_MATCHING', # pragma: no cover"",
            ""  'EXCEPT_STAR', # pragma: no cover"",
            ""  'VARIADIC_GENERICS' # pragma: no cover"",
            ""]}) # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature} # pragma: no cover"",
            ""node = SimpleNamespace( # pragma: no cover"",
            ""  pre_order=lambda: [ # pragma: no cover"",
            ""    SimpleNamespace(type=token.COLONEQUAL, value='=') # pragma: no cover"",
            ""  ] # pragma: no cover"",
            "") # pragma: no cover"",
            ""is_string_token = lambda n: n.type == token.COLONEQUAL # pragma: no cover"",
            ""is_number_token = lambda n: False # pragma: no cover"",
            ""iter_fexpr_spans = lambda x: [(0, len(x))] # pragma: no cover"",
            ""is_simple_decorator_expression = lambda x: False # pragma: no cover"",
            ""syms = SimpleNamespace( # pragma: no cover"",
            ""  typedargslist=1, # pragma: no cover"",
            ""  arglist=2, # pragma: no cover"",
            ""  varargslist=3, # pragma: no cover"",
            ""  argument=4, # pragma: no cover"",
            ""  return_stmt=5, # pragma: no cover"",
            ""  yield_expr=6, # pragma: no cover"",
            ""  testlist_star_expr=7, # pragma: no cover"",
            ""  star_expr=8, # pragma: no cover"",
            ""  annassign=9, # pragma: no cover"",
            ""  with_stmt=10, # pragma: no cover"",
            ""  atom=11, # pragma: no cover"",
            ""  testlist_gexp=12, # pragma: no cover"",
            ""  match_stmt=13, # pragma: no cover"",
            ""  except_clause=14, # pragma: no cover"",
            ""  subscriptlist=15, # pragma: no cover"",
            ""  trailer=16, # pragma: no cover"",
            ""  tname_star=17 # pragma: no cover"",
            "") # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Union # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = type('Feature', (object,), {name: name for name in ['F_STRINGS', 'DEBUG_F_STRINGS', 'NUMERIC_UNDERSCORES', 'POS_ONLY_ARGUMENTS', 'ASSIGNMENT_EXPRESSIONS', 'RELAXED_DECORATORS', 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL', 'UNPACKING_ON_FLOW', 'ANN_ASSIGN_EXTENDED_RHS', 'PARENTHESIZED_CONTEXT_MANAGERS', 'PATTERN_MATCHING', 'EXCEPT_STAR', 'VARIADIC_GENERICS']}) # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""syms = type('syms', (object,), {name: index for index, name in enumerate(['typedargslist', 'arglist', 'varargslist', 'decorator', 'return_stmt', 'yield_expr', 'testlist_star_expr', 'star_expr', 'annassign', 'with_stmt', 'atom', 'testlist_gexp', 'match_stmt', 'except_clause', 'subscriptlist', 'trailer', 'tname_star'])}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, ast.Str) # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, ast.Num) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): return isinstance(n, ast.expr) # pragma: no cover"",
            ""def iter_fexpr_spans(value): return iter([(0, len(value))]) # pragma: no cover"",
            ""node = type('Node', (object,), {'pre_order': lambda self: [ast.Str(s='f\""example\""')], 'type': None, 'value': 'f\""example\""'})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n, ast.Str) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n, ast.Num) # pragma: no cover"",
            ""def iter_fexpr_spans(s): # pragma: no cover"",
            ""    yield (1, len(s))  # Mock implementation # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False  # Mock implementation # pragma: no cover"",
            ""syms = type('Mock', (object,), {}) # pragma: no cover"",
            ""syms.typedargslist = auto() # pragma: no cover"",
            ""syms.arglist = auto() # pragma: no cover"",
            ""syms.varargslist = auto() # pragma: no cover"",
            ""syms.testlist_star_expr = auto() # pragma: no cover"",
            ""syms.star_expr = auto() # pragma: no cover"",
            ""syms.with_stmt = auto() # pragma: no cover"",
            ""syms.atom = auto() # pragma: no cover"",
            ""syms.match_stmt = auto() # pragma: no cover"",
            ""syms.except_clause = auto() # pragma: no cover"",
            ""syms.subscriptlist = auto() # pragma: no cover"",
            ""syms.trailer = auto() # pragma: no cover"",
            ""syms.tname_star = auto() # pragma: no cover"",
            ""syms.return_stmt = auto() # pragma: no cover"",
            ""syms.yield_expr = auto() # pragma: no cover"",
            ""syms.annassign = auto() # pragma: no cover"",
            ""STARS = {token.STAR}  # Mock implementation # pragma: no cover"",
            ""node = type('Mock', (object,), {'pre_order': lambda: [type('Mock', (object,), {'value': 'f\""example\""', 'type': token.STRING, 'children': [], 'parent': None})]}) # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = Enum('Feature', 'F_STRINGS DEBUG_F_STRINGS NUMERIC_UNDERSCORES POS_ONLY_ARGUMENTS ASSIGNMENT_EXPRESSIONS RELAXED_DECORATORS TRAILING_COMMA_IN_DEF TRAILING_COMMA_IN_CALL UNPACKING_ON_FLOW ANN_ASSIGN_EXTENDED_RHS PARENTHESIZED_CONTEXT_MANAGERS PATTERN_MATCHING EXCEPT_STAR VARIADIC_GENERICS') # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, type('Mock', (object,), {'value': 'f\""example\""'})) # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, type('Mock', (object,), {'value': '1_000'})) # pragma: no cover"",
            ""def iter_fexpr_spans(value): yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): return False # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [type('Mock', (object,), {'type': token.STRING, 'value': 'f\""example\""', 'parent': self})]})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum, auto # pragma: no cover"",
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover"",
            ""from typed_ast.ast3 import * # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = Enum('Feature', 'F_STRINGS DEBUG_F_STRINGS NUMERIC_UNDERSCORES POS_ONLY_ARGUMENTS ASSIGNMENT_EXPRESSIONS RELAXED_DECORATORS TRAILING_COMMA_IN_DEF TRAILING_COMMA_IN_CALL UNPACKING_ON_FLOW ANN_ASSIGN_EXTENDED_RHS PARENTHESIZED_CONTEXT_MANAGERS PATTERN_MATCHING EXCEPT_STAR VARIADIC_GENERICS') # pragma: no cover"",
            ""class Node: # pragma: no cover"",
            ""    def __init__(self, value, type, children=[]): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.children = children # pragma: no cover"",
            ""        self.parent = None # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        yield self # pragma: no cover"",
            ""        for child in self.children: # pragma: no cover"",
            ""            yield from child.pre_order() # pragma: no cover"",
            ""def is_string_token(node): # pragma: no cover"",
            ""    return node.type == token.STRING # pragma: no cover"",
            ""def is_number_token(node): # pragma: no cover"",
            ""    return node.type == token.NUMBER # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (3, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(node): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""node = type('MockNode', (object,), {}) # pragma: no cover"",
            ""node = Node('', token.STRING, [Node(f'f\""example={1}\""', token.STRING)]) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockNode(type('MockNodeBase', (object,), dict())):# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [MockNode()] # pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""node.value = 'f\""{x=}\""' # pragma: no cover"",
            ""node.children = [MockNode(), MockNode(), MockNode()] # pragma: no cover"",
            ""node.parent = MockNode() # pragma: no cover"",
            ""node.children[1].children = [MockNode(), MockNode(), MockNode()] # pragma: no cover""
        ]
    }
]",3,1561,0.0007805,5250,0.007875,0.0086555
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return a set of (relatively) new Python features used in this file.
    Currently looking for:
    - f-strings;
    - self-documenting expressions in f-strings (f""{x=}"");
    - underscores in numeric literals;
    - trailing commas after * or ** in function signatures and calls;
    - positional only arguments in function signatures and lambdas;
    - assignment expression;
    - relaxed decorator syntax;
    - usage of __future__ flags (annotations);
    - print / exec statements;
    - parenthesized context managers;
    - match statements;
    - except* clause;
    - variadic generics;
    """"""
features: Set[Feature] = set()
if future_imports: # uncovered
    features |= { # uncovered
        FUTURE_FLAG_TO_FEATURE[future_import] # uncovered
        for future_import in future_imports # uncovered
        if future_import in FUTURE_FLAG_TO_FEATURE # uncovered
    } # uncovered
for n in node.pre_order(): # uncovered
    if is_string_token(n): # uncovered
        value_head = n.value[:2] # uncovered
        if value_head in {'f""', 'F""', ""f'"", ""F'"", ""rf"", ""fr"", ""RF"", ""FR""}: # uncovered
            features.add(Feature.F_STRINGS) # uncovered
            if Feature.DEBUG_F_STRINGS not in features: # uncovered
                for span_beg, span_end in iter_fexpr_spans(n.value): # uncovered
                    if n.value[span_beg : span_end - 1].rstrip().endswith(""=""): # uncovered
                        features.add(Feature.DEBUG_F_STRINGS) # uncovered
                        break # uncovered
    elif is_number_token(n): # uncovered
        if ""_"" in n.value: # uncovered
            features.add(Feature.NUMERIC_UNDERSCORES) # uncovered
    elif n.type == token.SLASH: # uncovered
        if n.parent and n.parent.type in { # uncovered
            syms.typedargslist, # uncovered
            syms.arglist, # uncovered
            syms.varargslist, # uncovered
        }: # uncovered
            features.add(Feature.POS_ONLY_ARGUMENTS) # uncovered
    elif n.type == token.COLONEQUAL: # uncovered
        features.add(Feature.ASSIGNMENT_EXPRESSIONS) # uncovered
    elif n.type == syms.decorator: # uncovered
        if len(n.children) > 1 and not is_simple_decorator_expression( # uncovered
            n.children[1] # uncovered
        ): # uncovered
            features.add(Feature.RELAXED_DECORATORS) # uncovered
    elif ( # uncovered
        n.type in {syms.typedargslist, syms.arglist} # uncovered
        and n.children # uncovered
        and n.children[-1].type == token.COMMA # uncovered
    ): # uncovered
        if n.type == syms.typedargslist: # uncovered
            feature = Feature.TRAILING_COMMA_IN_DEF # uncovered
        else: # uncovered
            feature = Feature.TRAILING_COMMA_IN_CALL # uncovered
        for ch in n.children: # uncovered
            if ch.type in STARS: # uncovered
                features.add(feature) # uncovered
            if ch.type == syms.argument: # uncovered
                for argch in ch.children: # uncovered
                    if argch.type in STARS: # uncovered
                        features.add(feature) # uncovered
    elif ( # uncovered
        n.type in {syms.return_stmt, syms.yield_expr} # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == syms.testlist_star_expr # uncovered
        and any(child.type == syms.star_expr for child in n.children[1].children) # uncovered
    ): # uncovered
        features.add(Feature.UNPACKING_ON_FLOW) # uncovered
    elif ( # uncovered
        n.type == syms.annassign # uncovered
        and len(n.children) >= 4 # uncovered
        and n.children[3].type == syms.testlist_star_expr # uncovered
    ): # uncovered
        features.add(Feature.ANN_ASSIGN_EXTENDED_RHS) # uncovered
    elif ( # uncovered
        n.type == syms.with_stmt # uncovered
        and len(n.children) > 2 # uncovered
        and n.children[1].type == syms.atom # uncovered
    ): # uncovered
        atom_children = n.children[1].children # uncovered
        if ( # uncovered
            len(atom_children) == 3 # uncovered
            and atom_children[0].type == token.LPAR # uncovered
            and atom_children[1].type == syms.testlist_gexp # uncovered
            and atom_children[2].type == token.RPAR # uncovered
        ): # uncovered
            features.add(Feature.PARENTHESIZED_CONTEXT_MANAGERS) # uncovered
    elif n.type == syms.match_stmt: # uncovered
        features.add(Feature.PATTERN_MATCHING) # uncovered
    elif ( # uncovered
        n.type == syms.except_clause # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == token.STAR # uncovered
    ): # uncovered
        features.add(Feature.EXCEPT_STAR) # uncovered
    elif n.type in {syms.subscriptlist, syms.trailer} and any( # uncovered
        child.type == syms.star_expr for child in n.children # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
    elif ( # uncovered
        n.type == syms.tname_star # uncovered
        and len(n.children) == 3 # uncovered
        and n.children[2].type == syms.star_expr # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
aux = features # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import ast"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}"",
            ""future_imports = ['annotations']"",
            ""def is_string_token(n):"",
            ""    return isinstance(n, type('Mock', (object,), {'value': 'f\""example=\""'}))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n, (int, float))"",
            ""def iter_fexpr_spans(value):"",
            ""    return iter([(0, len(value))])"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 'typedargslist',"",
            ""    'arglist': 'arglist',"",
            ""    'varargslist': 'varargslist',"",
            ""    'return_stmt': 'return_stmt',"",
            ""    'yield_expr': 'yield_expr',"",
            ""    'testlist_star_expr': 'testlist_star_expr',"",
            ""    'star_expr': 'star_expr',"",
            ""    'annassign': 'annassign',"",
            ""    'with_stmt': 'with_stmt',"",
            ""    'atom': 'atom',"",
            ""    'testlist_gexp': 'testlist_gexp',"",
            ""    'match_stmt': 'match_stmt',"",
            ""    'except_clause': 'except_clause',"",
            ""    'subscriptlist': 'subscriptlist',"",
            ""    'trailer': 'trailer',"",
            ""    'tname_star': 'tname_star'"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = type('MockNode', (object,), {"",
            ""    'pre_order': lambda self: ["",
            ""        type('Mock', (object,), {'type': token.STRING, 'value': 'f\""example\""', 'children': []})"",
            ""    ]"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import ast"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = 'f_strings'"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'"",
            ""    PATTERN_MATCHING = 'pattern_matching'"",
            ""    EXCEPT_STAR = 'except_star'"",
            ""    VARIADIC_GENERICS = 'variadic_generics'"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.PATTERN_MATCHING}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n): return isinstance(n, ast.Str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n): return isinstance(n, ast.Constant) and isinstance(n.value, (int, float))"",
            ""def iter_fexpr_spans(value): return [(3, len(value))]"",
            ""def is_simple_decorator_expression(n): return False"",
            ""syms = type('MockSyms', (object,), dict("",
            ""    typedargslist=1,"",
            ""    arglist=2,"",
            ""    varargslist=3,"",
            ""    return_stmt=4,"",
            ""    yield_expr=5,"",
            ""    testlist_star_expr=6,"",
            ""    star_expr=7,"",
            ""    annassign=8,"",
            ""    with_stmt=9,"",
            ""    atom=10,"",
            ""    testlist_gexp=11,"",
            ""    match_stmt=12,"",
            ""    except_clause=13,"",
            ""    subscriptlist=14,"",
            ""    trailer=15,"",
            ""    tname_star=16,"",
            ""    argument=17"",
            ""))"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""node = type('MockNode', (object,), dict(pre_order=lambda self: ["",
            ""    type('Mock', (object,), dict("",
            ""        value='f\""example={1}\""',"",
            ""        type=token.STRING,"",
            ""        children=[],"",
            ""        parent=None"",
            ""    ))"",
            ""]))()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""class Mock: pass  # Create necessary mock classes and enums"",
            ""syms = Mock()"",
            ""syms.typedargslist = 1"",
            ""syms.arglist = 2"",
            ""syms.varargslist = 3"",
            ""syms.decorator = 4"",
            ""syms.return_stmt = 5"",
            ""syms.yield_expr = 6"",
            ""syms.testlist_star_expr = 7"",
            ""syms.star_expr = 8"",
            ""syms.annassign = 9"",
            ""syms.with_stmt = 10"",
            ""syms.atom = 11"",
            ""syms.testlist_gexp = 12"",
            ""syms.match_stmt = 13"",
            ""syms.except_clause = 14"",
            ""syms.subscriptlist = 15"",
            ""syms.trailer = 16"",
            ""syms.tname_star = 17"",
            ""class Feature(Enum):"",
            ""    F_STRINGS = 'F_STRINGS'"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}""
        ],
        ""initialization"": [
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return '_' in n.value if isinstance(n.value, str) else False"",
            ""def iter_fexpr_spans(value):"",
            ""    return [(3, len(value) - 1)] if value.startswith('f\""') or value.startswith('F\""') else []"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""node = Mock()"",
            ""node.type = token.STRING"",
            ""node.value = 'f\""example\""'"",
            ""node.children = []"",
            ""node.parent = None"",
            ""node.pre_order = lambda: [node]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return isinstance(n, type('Mock', (object,), {'value': 'f\""example\""'}))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n, type('Mock', (object,), {'value': '1_000'}))"",
            ""def iter_fexpr_spans(value):"",
            ""    return [(0, len(value))]"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': auto(),"",
            ""    'arglist': auto(),"",
            ""    'varargslist': auto(),"",
            ""    'return_stmt': auto(),"",
            ""    'yield_expr': auto(),"",
            ""    'testlist_star_expr': auto(),"",
            ""    'star_expr': auto(),"",
            ""    'annassign': auto(),"",
            ""    'with_stmt': auto(),"",
            ""    'atom': auto(),"",
            ""    'testlist_gexp': auto(),"",
            ""    'match_stmt': auto(),"",
            ""    'except_clause': auto(),"",
            ""    'subscriptlist': auto(),"",
            ""    'trailer': auto(),"",
            ""    'tname_star': auto(),"",
            ""    'argument': auto()"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('Mock', (object,), {'value': 'f\""{x=}\""', 'type': token.STRING, 'children': [], 'parent': None}), type('Mock', (object,), {'value': '1_000', 'type': token.NUMBER, 'children': [], 'parent': None}), type('Mock', (object,), {'type': token.SLASH, 'parent': type('Parent', (object,), {'type': syms.typedargslist})}), type('Mock', (object,), {'type': token.COLONEQUAL}), type('Mock', (object,), {'type': syms.decorator, 'children': [None, object()]}), type('Mock', (object,), {'type': syms.arglist, 'children': [type('Child', (object,), {'type': token.COMMA, 'value': '*args'})]}), type('Mock', (object,), {'type': syms.return_stmt, 'children': [None, type('Child', (object,), {'type': syms.testlist_star_expr, 'children': [type('GrandChild', (object,), {'type': syms.star_expr})]})]}), type('Mock', (object,), {'type': syms.annassign, 'children': [None, None, None, type('Child', (object,), {'type': syms.testlist_star_expr})]}), type('Mock', (object,), {'type': syms.with_stmt, 'children': [None, type('Atom', (object,), {'type': syms.atom, 'children': [token.LPAR, type('Child', (object,), {'type': syms.testlist_gexp}), token.RPAR]})]}), type('Mock', (object,), {'type': syms.match_stmt}), type('Mock', (object,), {'type': syms.except_clause, 'children': [None, token.STAR]}), type('Mock', (object,), {'type': syms.subscriptlist, 'children': [type('Child', (object,), {'type': syms.star_expr})]}), type('Mock', (object,), {'type': syms.tname_star, 'children': [None, None, type('Child', (object,), {'type': syms.star_expr})]})]})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 'f-strings'\n    DEBUG_F_STRINGS = 'debug-f-strings'\n    NUMERIC_UNDERSCORES = 'numeric-underscores'\n    POS_ONLY_ARGUMENTS = 'positional-only-arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment-expressions'\n    RELAXED_DECORATORS = 'relaxed-decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing-comma-in-def'\n    TRAILING_COMMA_IN_CALL = 'trailing-comma-in-call'\n    UNPACKING_ON_FLOW = 'unpacking-on-flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann-assign-extended-rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized-context-managers'\n    PATTERN_MATCHING = 'pattern-matching'\n    EXCEPT_STAR = 'except*-clause'\n    VARIADIC_GENERICS = 'variadic-generics'"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}"",
            ""future_imports = ['annotations']"",
            ""class NodeMock:\n    def __init__(self, type, value, children=[]):\n        self.type = type\n        self.value = value\n        self.children = children\n    def pre_order(self):\n        return [self]"",
            ""def is_string_token(n):\n    return isinstance(n, NodeMock) and isinstance(n.value, str)"",
            ""def is_number_token(n):\n    return isinstance(n, NodeMock) and n.value.isdigit()"",
            ""def iter_fexpr_spans(value):\n    yield (3, 5)"",
            ""def is_simple_decorator_expression(n):\n    return False"",
            ""syms = type('syms', (object,), {\n    'typedargslist': 1,\n    'arglist': 2,\n    'varargslist': 3,\n    'return_stmt': 4,\n    'yield_expr': 5,\n    'testlist_star_expr': 6,\n    'annassign': 7,\n    'with_stmt': 8,\n    'atom': 9,\n    'testlist_gexp': 10,\n    'match_stmt': 11,\n    'except_clause': 12,\n    'subscriptlist': 13,\n    'trailer': 14,\n    'tname_star': 15,\n    'argument': 16,\n    'star_expr': 17})"",
            ""STARS = {token.STAR}"",
            ""node = NodeMock(syms.annassign, 'example', [None, None, None, NodeMock(syms.testlist_star_expr, 'test')])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import ast"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n): return isinstance(n, ast.Str)"",
            ""def is_number_token(n): return '_' in n.value"",
            ""def iter_fexpr_spans(value): yield (0, len(value))"",
            ""def is_simple_decorator_expression(n): return False"",
            ""syms = type('syms', (object,), {\n    'typedargslist': 1,\n    'arglist': 2,\n    'varargslist': 3,\n    'decorator': 4,\n    'return_stmt': 5,    \n    'yield_expr': 6,\n    'testlist_star_expr': 7,\n    'star_expr': 8,\n    'annassign': 9,\n    'with_stmt': 10,\n    'atom': 11,\n    'testlist_gexp': 12,\n    'match_stmt': 13,\n    'except_clause': 14,\n    'subscriptlist': 15,\n    'trailer': 16,\n    'tname_star': 17,\n    'argument': 18\n})"",
            ""STARS = {token.STAR}"",
            ""node = type('NodeMock', (object,), {\n    'children': [type('Child', (object,), {'type': token.NAME, 'value': '1_000'})],\n    'pre_order': lambda self: self.children\n})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature:"",
            ""    F_STRINGS = 'f_strings'"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'"",
            ""    PATTERN_MATCHING = 'pattern_matching'"",
            ""    EXCEPT_STAR = 'except_star'"",
            ""    VARIADIC_GENERICS = 'variadic_generics'"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.PARENTHESIZED_CONTEXT_MANAGERS}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n): return '\""' in n.value or \""'\"" in n.value"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value): yield (0, 1)"",
            ""def is_simple_decorator_expression(n): return False"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'testlist_star_expr': 6, 'annassign': 7, 'with_stmt': 8, 'atom': 9, 'testlist_gexp': 10, 'match_stmt': 11, 'except_clause': 12, 'subscriptlist': 13, 'trailer': 14, 'tname_star': 15, 'argument': 16})"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""node = type('Node', (object,), {'pre_order': lambda self: [type('Mock', (object,), {'type': syms.with_stmt, 'children': [None, type('Mock', (object,), {'type': syms.atom}, {'children': [token.LPAR, type('Mock', (object,), {'type': syms.testlist_gexp}), token.RPAR]})]}), type('Mock', (object,), {'type': token.STRING, 'value': 'f\""example\""'})]})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return isinstance(n, ast.Str)"",
            ""def is_number_token(n):"",
            ""    return isinstance(n, ast.Num)"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {k: k for k in ['typedargslist', 'arglist', 'varargslist', 'decorator', 'return_stmt', 'yield_expr', 'testlist_star_expr', 'annassign', 'with_stmt', 'atom', 'testlist_gexp', 'match_stmt', 'except_clause', 'subscriptlist', 'trailer', 'tname_star']})"",
            ""STARS = {token.STAR}"",
            ""node = type('NodeMock', (object,), {'pre_order': lambda self: [type('Node', (object,), {'type': token.STRING, 'value': 'f\""example={1}\""', 'children': []})]})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token"",
            ""import builtins""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = 'f_strings'"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'"",
            ""    PATTERN_MATCHING = 'pattern_matching'"",
            ""    EXCEPT_STAR = 'except_star'"",
            ""    VARIADIC_GENERICS = 'variadic_generics'"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}"",
            ""future_imports = {'annotations'}"",
            ""class NodeMock:"",
            ""    def __init__(self, type, value, children=None, parent=None):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.children = children if children is not None else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""    def __repr__(self):"",
            ""        return f'NodeMock(type={self.type}, value={self.value}, children={self.children})'"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (3, len(value))"",
            ""def is_number_token(n):"",
            ""    return str(n.value).isdigit()"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'argument': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'annassign': 8,"",
            ""    'with_stmt': 9,"",
            ""    'atom': 10,"",
            ""    'testlist_gexp': 11,"",
            ""    'match_stmt': 12,"",
            ""    'except_clause': 13,"",
            ""    'subscriptlist': 14,"",
            ""    'trailer': 15,"",
            ""    'tname_star': 16,"",
            ""} )"",
            ""STARS = {token.STAR, token.DOUBLESTAR, 16}"",
            ""node = NodeMock(token.STRING, 'f\""example\""')""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import ast"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}"",
            ""future_imports = {'annotations'}"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'return_stmt': 4,"",
            ""    'yield_expr': 5,"",
            ""    'testlist_star_expr': 6,"",
            ""    'annassign': 7,"",
            ""    'with_stmt': 8,"",
            ""    'atom': 9,"",
            ""    'testlist_gexp': 10,"",
            ""    'match_stmt': 11,"",
            ""    'except_clause': 12,"",
            ""    'subscriptlist': 13,"",
            ""    'trailer': 14,"",
            ""    'tname_star': 15"",
            ""})"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_string_token(n):"",
            ""    return isinstance(n, ast.Str) or (isinstance(n, type('Mock', (object,), {})) and hasattr(n, 'value') and (n.value.startswith('f') or n.value.startswith('F')))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n, ast.Num) or (isinstance(n, type('Mock', (object,), {})) and hasattr(n, 'value') and '_' in n.value and n.value.replace('_', '').isdigit())"",
            ""def iter_fexpr_spans(value):"",
            ""    yield 2, len(value)"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [type('Mock', (object,), {'value': 'f\""{x}\""', 'type': token.STRING, 'children': [], 'parent': None})]})()""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n, type('Mock', (object,), {'value': 'f\""example=\""'})) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n, (int, float)) # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return iter([(0, len(value))]) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 'typedargslist', # pragma: no cover"",
            ""    'arglist': 'arglist', # pragma: no cover"",
            ""    'varargslist': 'varargslist', # pragma: no cover"",
            ""    'return_stmt': 'return_stmt', # pragma: no cover"",
            ""    'yield_expr': 'yield_expr', # pragma: no cover"",
            ""    'testlist_star_expr': 'testlist_star_expr', # pragma: no cover"",
            ""    'star_expr': 'star_expr', # pragma: no cover"",
            ""    'annassign': 'annassign', # pragma: no cover"",
            ""    'with_stmt': 'with_stmt', # pragma: no cover"",
            ""    'atom': 'atom', # pragma: no cover"",
            ""    'testlist_gexp': 'testlist_gexp', # pragma: no cover"",
            ""    'match_stmt': 'match_stmt', # pragma: no cover"",
            ""    'except_clause': 'except_clause', # pragma: no cover"",
            ""    'subscriptlist': 'subscriptlist', # pragma: no cover"",
            ""    'trailer': 'trailer', # pragma: no cover"",
            ""    'tname_star': 'tname_star' # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""node = type('MockNode', (object,), { # pragma: no cover"",
            ""    'pre_order': lambda self: [ # pragma: no cover"",
            ""        type('Mock', (object,), {'type': token.STRING, 'value': 'f\""example\""', 'children': []}) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = 'f_strings' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching' # pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.PATTERN_MATCHING} # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, ast.Str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, ast.Constant) and isinstance(n.value, (int, float)) # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(3, len(value))] # pragma: no cover"",
            ""def is_simple_decorator_expression(n): return False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), dict( # pragma: no cover"",
            ""    typedargslist=1, # pragma: no cover"",
            ""    arglist=2, # pragma: no cover"",
            ""    varargslist=3, # pragma: no cover"",
            ""    return_stmt=4, # pragma: no cover"",
            ""    yield_expr=5, # pragma: no cover"",
            ""    testlist_star_expr=6, # pragma: no cover"",
            ""    star_expr=7, # pragma: no cover"",
            ""    annassign=8, # pragma: no cover"",
            ""    with_stmt=9, # pragma: no cover"",
            ""    atom=10, # pragma: no cover"",
            ""    testlist_gexp=11, # pragma: no cover"",
            ""    match_stmt=12, # pragma: no cover"",
            ""    except_clause=13, # pragma: no cover"",
            ""    subscriptlist=14, # pragma: no cover"",
            ""    trailer=15, # pragma: no cover"",
            ""    tname_star=16, # pragma: no cover"",
            ""    argument=17 # pragma: no cover"",
            "")) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""node = type('MockNode', (object,), dict(pre_order=lambda self: [ # pragma: no cover"",
            ""    type('Mock', (object,), dict( # pragma: no cover"",
            ""        value='f\""example={1}\""', # pragma: no cover"",
            ""        type=token.STRING, # pragma: no cover"",
            ""        children=[], # pragma: no cover"",
            ""        parent=None # pragma: no cover"",
            ""    )) # pragma: no cover"",
            ""]))() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""class Mock: pass  # Create necessary mock classes and enums # pragma: no cover"",
            ""syms = Mock() # pragma: no cover"",
            ""syms.typedargslist = 1 # pragma: no cover"",
            ""syms.arglist = 2 # pragma: no cover"",
            ""syms.varargslist = 3 # pragma: no cover"",
            ""syms.decorator = 4 # pragma: no cover"",
            ""syms.return_stmt = 5 # pragma: no cover"",
            ""syms.yield_expr = 6 # pragma: no cover"",
            ""syms.testlist_star_expr = 7 # pragma: no cover"",
            ""syms.star_expr = 8 # pragma: no cover"",
            ""syms.annassign = 9 # pragma: no cover"",
            ""syms.with_stmt = 10 # pragma: no cover"",
            ""syms.atom = 11 # pragma: no cover"",
            ""syms.testlist_gexp = 12 # pragma: no cover"",
            ""syms.match_stmt = 13 # pragma: no cover"",
            ""syms.except_clause = 14 # pragma: no cover"",
            ""syms.subscriptlist = 15 # pragma: no cover"",
            ""syms.trailer = 16 # pragma: no cover"",
            ""syms.tname_star = 17 # pragma: no cover""
        ],
        ""initialization"": [
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return '_' in n.value if isinstance(n.value, str) else False # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return [(3, len(value) - 1)] if value.startswith('f\""') or value.startswith('F\""') else [] # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""node = Mock() # pragma: no cover"",
            ""node.type = token.STRING # pragma: no cover"",
            ""node.value = 'f\""example\""' # pragma: no cover"",
            ""node.children = [] # pragma: no cover"",
            ""node.parent = None # pragma: no cover"",
            ""node.pre_order = lambda: [node] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n, type('Mock', (object,), {'value': 'f\""example\""'})) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n, type('Mock', (object,), {'value': '1_000'})) # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': auto(), # pragma: no cover"",
            ""    'arglist': auto(), # pragma: no cover"",
            ""    'varargslist': auto(), # pragma: no cover"",
            ""    'return_stmt': auto(), # pragma: no cover"",
            ""    'yield_expr': auto(), # pragma: no cover"",
            ""    'testlist_star_expr': auto(), # pragma: no cover"",
            ""    'star_expr': auto(), # pragma: no cover"",
            ""    'annassign': auto(), # pragma: no cover"",
            ""    'with_stmt': auto(), # pragma: no cover"",
            ""    'atom': auto(), # pragma: no cover"",
            ""    'testlist_gexp': auto(), # pragma: no cover"",
            ""    'match_stmt': auto(), # pragma: no cover"",
            ""    'except_clause': auto(), # pragma: no cover"",
            ""    'subscriptlist': auto(), # pragma: no cover"",
            ""    'trailer': auto(), # pragma: no cover"",
            ""    'tname_star': auto(), # pragma: no cover"",
            ""    'argument': auto() # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('Mock', (object,), {'value': 'f\""{x=}\""', 'type': token.STRING, 'children': [], 'parent': None}), type('Mock', (object,), {'value': '1_000', 'type': token.NUMBER, 'children': [], 'parent': None}), type('Mock', (object,), {'type': token.SLASH, 'parent': type('Parent', (object,), {'type': syms.typedargslist})}), type('Mock', (object,), {'type': token.COLONEQUAL}), type('Mock', (object,), {'type': syms.decorator, 'children': [None, object()]}), type('Mock', (object,), {'type': syms.arglist, 'children': [type('Child', (object,), {'type': token.COMMA, 'value': '*args'})]}), type('Mock', (object,), {'type': syms.return_stmt, 'children': [None, type('Child', (object,), {'type': syms.testlist_star_expr, 'children': [type('GrandChild', (object,), {'type': syms.star_expr})]})]}), type('Mock', (object,), {'type': syms.annassign, 'children': [None, None, None, type('Child', (object,), {'type': syms.testlist_star_expr})]}), type('Mock', (object,), {'type': syms.with_stmt, 'children': [None, type('Atom', (object,), {'type': syms.atom, 'children': [token.LPAR, type('Child', (object,), {'type': syms.testlist_gexp}), token.RPAR]})]}), type('Mock', (object,), {'type': syms.match_stmt}), type('Mock', (object,), {'type': syms.except_clause, 'children': [None, token.STAR]}), type('Mock', (object,), {'type': syms.subscriptlist, 'children': [type('Child', (object,), {'type': syms.star_expr})]}), type('Mock', (object,), {'type': syms.tname_star, 'children': [None, None, type('Child', (object,), {'type': syms.star_expr})]})]})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 'f-strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug-f-strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric-underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'positional-only-arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment-expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed-decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing-comma-in-def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing-comma-in-call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking-on-flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann-assign-extended-rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized-context-managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern-matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except*-clause'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic-generics' # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover"",
            ""class NodeMock:# pragma: no cover"",
            ""    def __init__(self, type, value, children=[]):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.children = children# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return isinstance(n, NodeMock) and isinstance(n.value, str) # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return isinstance(n, NodeMock) and n.value.isdigit() # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    yield (3, 5) # pragma: no cover"",
            ""def is_simple_decorator_expression(n):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), {# pragma: no cover"",
            ""    'typedargslist': 1,# pragma: no cover"",
            ""    'arglist': 2,# pragma: no cover"",
            ""    'varargslist': 3,# pragma: no cover"",
            ""    'return_stmt': 4,# pragma: no cover"",
            ""    'yield_expr': 5,# pragma: no cover"",
            ""    'testlist_star_expr': 6,# pragma: no cover"",
            ""    'annassign': 7,# pragma: no cover"",
            ""    'with_stmt': 8,# pragma: no cover"",
            ""    'atom': 9,# pragma: no cover"",
            ""    'testlist_gexp': 10,# pragma: no cover"",
            ""    'match_stmt': 11,# pragma: no cover"",
            ""    'except_clause': 12,# pragma: no cover"",
            ""    'subscriptlist': 13,# pragma: no cover"",
            ""    'trailer': 14,# pragma: no cover"",
            ""    'tname_star': 15,# pragma: no cover"",
            ""    'argument': 16,# pragma: no cover"",
            ""    'star_expr': 17}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""node = NodeMock(syms.annassign, 'example', [None, None, None, NodeMock(syms.testlist_star_expr, 'test')]) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, ast.Str) # pragma: no cover"",
            ""def is_number_token(n): return '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): return False # pragma: no cover"",
            ""syms = type('syms', (object,), {# pragma: no cover"",
            ""    'typedargslist': 1,# pragma: no cover"",
            ""    'arglist': 2,# pragma: no cover"",
            ""    'varargslist': 3,# pragma: no cover"",
            ""    'decorator': 4,# pragma: no cover"",
            ""    'return_stmt': 5,    # pragma: no cover"",
            ""    'yield_expr': 6,# pragma: no cover"",
            ""    'testlist_star_expr': 7,# pragma: no cover"",
            ""    'star_expr': 8,# pragma: no cover"",
            ""    'annassign': 9,# pragma: no cover"",
            ""    'with_stmt': 10,# pragma: no cover"",
            ""    'atom': 11,# pragma: no cover"",
            ""    'testlist_gexp': 12,# pragma: no cover"",
            ""    'match_stmt': 13,# pragma: no cover"",
            ""    'except_clause': 14,# pragma: no cover"",
            ""    'subscriptlist': 15,# pragma: no cover"",
            ""    'trailer': 16,# pragma: no cover"",
            ""    'tname_star': 17,# pragma: no cover"",
            ""    'argument': 18# pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""node = type('NodeMock', (object,), {# pragma: no cover"",
            ""    'children': [type('Child', (object,), {'type': token.NAME, 'value': '1_000'})],# pragma: no cover"",
            ""    'pre_order': lambda self: self.children# pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'f_strings' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching' # pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.PARENTHESIZED_CONTEXT_MANAGERS} # pragma: no cover"",
            ""def is_string_token(n): return '\""' in n.value or \""'\"" in n.value # pragma: no cover"",
            ""def is_number_token(n): return n.type == token.NUMBER # pragma: no cover"",
            ""def iter_fexpr_spans(value): yield (0, 1) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): return False # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'testlist_star_expr': 6, 'annassign': 7, 'with_stmt': 8, 'atom': 9, 'testlist_gexp': 10, 'match_stmt': 11, 'except_clause': 12, 'subscriptlist': 13, 'trailer': 14, 'tname_star': 15, 'argument': 16}) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""node = type('Node', (object,), {'pre_order': lambda self: [type('Mock', (object,), {'type': syms.with_stmt, 'children': [None, type('Mock', (object,), {'type': syms.atom}, {'children': [token.LPAR, type('Mock', (object,), {'type': syms.testlist_gexp}), token.RPAR]})]}), type('Mock', (object,), {'type': token.STRING, 'value': 'f\""example\""'})]})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n, ast.Str) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n, ast.Num) # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), {k: k for k in ['typedargslist', 'arglist', 'varargslist', 'decorator', 'return_stmt', 'yield_expr', 'testlist_star_expr', 'annassign', 'with_stmt', 'atom', 'testlist_gexp', 'match_stmt', 'except_clause', 'subscriptlist', 'trailer', 'tname_star']}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""node = type('NodeMock', (object,), {'pre_order': lambda self: [type('Node', (object,), {'type': token.STRING, 'value': 'f\""example={1}\""', 'children': []})]})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import builtins # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = 'f_strings' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching' # pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover"",
            ""class NodeMock: # pragma: no cover"",
            ""    def __init__(self, type, value, children=None, parent=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children is not None else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""    def __repr__(self): # pragma: no cover"",
            ""        return f'NodeMock(type={self.type}, value={self.value}, children={self.children})' # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (3, len(value)) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return str(n.value).isdigit() # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'argument': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'annassign': 8, # pragma: no cover"",
            ""    'with_stmt': 9, # pragma: no cover"",
            ""    'atom': 10, # pragma: no cover"",
            ""    'testlist_gexp': 11, # pragma: no cover"",
            ""    'match_stmt': 12, # pragma: no cover"",
            ""    'except_clause': 13, # pragma: no cover"",
            ""    'subscriptlist': 14, # pragma: no cover"",
            ""    'trailer': 15, # pragma: no cover"",
            ""    'tname_star': 16, # pragma: no cover"",
            ""} ) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR, 16} # pragma: no cover"",
            ""node = NodeMock(token.STRING, 'f\""example\""') # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'return_stmt': 4, # pragma: no cover"",
            ""    'yield_expr': 5, # pragma: no cover"",
            ""    'testlist_star_expr': 6, # pragma: no cover"",
            ""    'annassign': 7, # pragma: no cover"",
            ""    'with_stmt': 8, # pragma: no cover"",
            ""    'atom': 9, # pragma: no cover"",
            ""    'testlist_gexp': 10, # pragma: no cover"",
            ""    'match_stmt': 11, # pragma: no cover"",
            ""    'except_clause': 12, # pragma: no cover"",
            ""    'subscriptlist': 13, # pragma: no cover"",
            ""    'trailer': 14, # pragma: no cover"",
            ""    'tname_star': 15 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n, ast.Str) or (isinstance(n, type('Mock', (object,), {})) and hasattr(n, 'value') and (n.value.startswith('f') or n.value.startswith('F'))) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n, ast.Num) or (isinstance(n, type('Mock', (object,), {})) and hasattr(n, 'value') and '_' in n.value and n.value.replace('_', '').isdigit()) # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield 2, len(value) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""node = type('Mock', (object,), {'pre_order': lambda self: [type('Mock', (object,), {'value': 'f\""{x}\""', 'type': token.STRING, 'children': [], 'parent': None})]})() # pragma: no cover""
        ]
    }
]",3,8349,0.0041745,6810,0.010215,0.0143895
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return a set of (relatively) new Python features used in this file.
    Currently looking for:
    - f-strings;
    - self-documenting expressions in f-strings (f""{x=}"");
    - underscores in numeric literals;
    - trailing commas after * or ** in function signatures and calls;
    - positional only arguments in function signatures and lambdas;
    - assignment expression;
    - relaxed decorator syntax;
    - usage of __future__ flags (annotations);
    - print / exec statements;
    - parenthesized context managers;
    - match statements;
    - except* clause;
    - variadic generics;
    """"""
features: Set[Feature] = set()
if future_imports: # uncovered
    features |= { # uncovered
        FUTURE_FLAG_TO_FEATURE[future_import] # uncovered
        for future_import in future_imports # uncovered
        if future_import in FUTURE_FLAG_TO_FEATURE # uncovered
    } # uncovered
for n in node.pre_order(): # uncovered
    if is_string_token(n): # uncovered
        value_head = n.value[:2] # uncovered
        if value_head in {'f""', 'F""', ""f'"", ""F'"", ""rf"", ""fr"", ""RF"", ""FR""}: # uncovered
            features.add(Feature.F_STRINGS) # uncovered
            if Feature.DEBUG_F_STRINGS not in features: # uncovered
                for span_beg, span_end in iter_fexpr_spans(n.value): # uncovered
                    if n.value[span_beg : span_end - 1].rstrip().endswith(""=""): # uncovered
                        features.add(Feature.DEBUG_F_STRINGS) # uncovered
                        break # uncovered
    elif is_number_token(n): # uncovered
        if ""_"" in n.value: # uncovered
            features.add(Feature.NUMERIC_UNDERSCORES) # uncovered
    elif n.type == token.SLASH: # uncovered
        if n.parent and n.parent.type in { # uncovered
            syms.typedargslist, # uncovered
            syms.arglist, # uncovered
            syms.varargslist, # uncovered
        }: # uncovered
            features.add(Feature.POS_ONLY_ARGUMENTS) # uncovered
    elif n.type == token.COLONEQUAL: # uncovered
        features.add(Feature.ASSIGNMENT_EXPRESSIONS) # uncovered
    elif n.type == syms.decorator: # uncovered
        if len(n.children) > 1 and not is_simple_decorator_expression( # uncovered
            n.children[1] # uncovered
        ): # uncovered
            features.add(Feature.RELAXED_DECORATORS) # uncovered
    elif ( # uncovered
        n.type in {syms.typedargslist, syms.arglist} # uncovered
        and n.children # uncovered
        and n.children[-1].type == token.COMMA # uncovered
    ): # uncovered
        if n.type == syms.typedargslist: # uncovered
            feature = Feature.TRAILING_COMMA_IN_DEF # uncovered
        else: # uncovered
            feature = Feature.TRAILING_COMMA_IN_CALL # uncovered
        for ch in n.children: # uncovered
            if ch.type in STARS: # uncovered
                features.add(feature) # uncovered
            if ch.type == syms.argument: # uncovered
                for argch in ch.children: # uncovered
                    if argch.type in STARS: # uncovered
                        features.add(feature) # uncovered
    elif ( # uncovered
        n.type in {syms.return_stmt, syms.yield_expr} # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == syms.testlist_star_expr # uncovered
        and any(child.type == syms.star_expr for child in n.children[1].children) # uncovered
    ): # uncovered
        features.add(Feature.UNPACKING_ON_FLOW) # uncovered
    elif ( # uncovered
        n.type == syms.annassign # uncovered
        and len(n.children) >= 4 # uncovered
        and n.children[3].type == syms.testlist_star_expr # uncovered
    ): # uncovered
        features.add(Feature.ANN_ASSIGN_EXTENDED_RHS) # uncovered
    elif ( # uncovered
        n.type == syms.with_stmt # uncovered
        and len(n.children) > 2 # uncovered
        and n.children[1].type == syms.atom # uncovered
    ): # uncovered
        atom_children = n.children[1].children # uncovered
        if ( # uncovered
            len(atom_children) == 3 # uncovered
            and atom_children[0].type == token.LPAR # uncovered
            and atom_children[1].type == syms.testlist_gexp # uncovered
            and atom_children[2].type == token.RPAR # uncovered
        ): # uncovered
            features.add(Feature.PARENTHESIZED_CONTEXT_MANAGERS) # uncovered
    elif n.type == syms.match_stmt: # uncovered
        features.add(Feature.PATTERN_MATCHING) # uncovered
    elif ( # uncovered
        n.type == syms.except_clause # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == token.STAR # uncovered
    ): # uncovered
        features.add(Feature.EXCEPT_STAR) # uncovered
    elif n.type in {syms.subscriptlist, syms.trailer} and any( # uncovered
        child.type == syms.star_expr for child in n.children # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
    elif ( # uncovered
        n.type == syms.tname_star # uncovered
        and len(n.children) == 3 # uncovered
        and n.children[2].type == syms.star_expr # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
aux = features # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from enum import Enum, auto"",
            ""from typing import Set"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.PATTERN_MATCHING}"",
            ""future_imports = {'annotations'}"",
            ""syms = type('syms', (object,), {k: k for k in ['typedargslist', 'arglist', 'varargslist', 'decorator', 'return_stmt', 'yield_expr', 'testlist_star_expr', 'annassign', 'with_stmt', 'atom', 'testlist_gexp', 'match_stmt', 'except_clause', 'subscriptlist', 'trailer', 'tname_star']})"",
            ""STARS = {token.STAR}"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and ('f' in n.value or 'F' in n.value)"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    return [(2, len(value) - 1)]"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""node = type('NodeMock', (object,), {'pre_order': lambda self: [type('MockNode', (object,), {'type': token.STRING, 'value': 'f\""{x=}\""'})]})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}"",
            ""future_imports = {'annotations'}"",
            ""class NodeMock:\n    def __init__(self, type, value, children=None, parent=None):\n        self.type = type\n        self.value = value\n        self.children = children if children is not None else []\n        self.parent = parent\n    def pre_order(self):\n        return [self]"",
            ""def is_string_token(n):\n    return isinstance(n, NodeMock) and isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):\n    return isinstance(n, NodeMock) and isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):\n    yield (2, len(value))"",
            ""def is_simple_decorator_expression(n):\n    return False"",
            ""syms = type('syms', (object,), {\n    'typedargslist': 1,\n    'arglist': 2,\n    'varargslist': 3,\n    'decorator': 4,\n    'return_stmt': 5,\n    'yield_expr': 6,\n    'testlist_star_expr': 7,\n    'star_expr': 8,\n    'annassign': 9,\n    'with_stmt': 10,\n    'atom': 11,\n    'testlist_gexp': 12,\n    'match_stmt': 13,\n    'except_clause': 14,\n    'subscriptlist': 15,\n    'trailer': 16,\n    'tname_star': 17,\n    'argument': 18})"",
            ""STARS = {token.STAR, token.DOUBLESTAR, 17}"",
            ""node = NodeMock(token.STRING, 'f\""example\""', children=[NodeMock(syms.decorator, '@decorator', children=[None, NodeMock(token.NAME, 'value')])])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return isinstance(n, type('Mock', (object,), {'value': 'f\""example=\""'}))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n, type('Mock', (object,), {'value': '1_000'}))"",
            ""def iter_fexpr_spans(value):"",
            ""    return [(3, len(value))]"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': auto(),"",
            ""    'arglist': auto(),"",
            ""    'varargslist': auto(),"",
            ""    'decorator': auto(),"",
            ""    'return_stmt': auto(),"",
            ""    'yield_expr': auto(),"",
            ""    'testlist_star_expr': auto(),"",
            ""    'star_expr': auto(),"",
            ""    'annassign': auto(),"",
            ""    'with_stmt': auto(),"",
            ""    'atom': auto(),"",
            ""    'testlist_gexp': auto(),"",
            ""    'match_stmt': auto(),"",
            ""    'except_clause': auto(),"",
            ""    'subscriptlist': auto(),"",
            ""    'trailer': auto(),"",
            ""    'tname_star': auto(),"",
            ""    'argument': auto()"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('Mock', (object,), {'value': 'f\""example\""', 'type': token.STRING, 'children': []})]})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, value, type, children=None, parent=None):"",
            ""        self.value = value"",
            ""        self.type = type"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and (n.value.startswith('f') or n.value.startswith('F'))"",
            ""def is_number_token(n):"",
            ""    return '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17"",
            ""})"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""node = MockNode('f\""example\""', token.STRING)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str)"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    return [(0, len(value))]"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'return_stmt': 4,"",
            ""    'yield_expr': 5,"",
            ""    'testlist_star_expr': 6,"",
            ""    'star_expr': 7,"",
            ""    'annassign': 8,"",
            ""    'with_stmt': 9,"",
            ""    'atom': 10,"",
            ""    'testlist_gexp': 11,"",
            ""    'match_stmt': 12,"",
            ""    'except_clause': 13,"",
            ""    'subscriptlist': 14,"",
            ""    'trailer': 15,"",
            ""    'tname_star': 16,"",
            ""    'argument': 17"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = type('Mock', (object,), {"",
            ""    'value': '1_000',"",
            ""    'type': token.NUMBER,"",
            ""    'children': [],"",
            ""    'parent': None,"",
            ""    'pre_order': lambda self: [self]"",
            ""})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = auto()\n    DEBUG_F_STRINGS = auto()\n    NUMERIC_UNDERSCORES = auto()\n    POS_ONLY_ARGUMENTS = auto()\n    ASSIGNMENT_EXPRESSIONS = auto()\n    RELAXED_DECORATORS = auto()\n    TRAILING_COMMA_IN_DEF = auto()\n    TRAILING_COMMA_IN_CALL = auto()\n    UNPACKING_ON_FLOW = auto()\n    ANN_ASSIGN_EXTENDED_RHS = auto()\n    PARENTHESIZED_CONTEXT_MANAGERS = auto()\n    PATTERN_MATCHING = auto()\n    EXCEPT_STAR = auto()\n    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}"",
            ""future_imports = ['annotations']"",
            ""def is_string_token(n):\n    return isinstance(n, type('Mock', (object,), {'value': 'f\""example\""'}))"",
            ""def is_number_token(n):\n    return isinstance(n, type('Mock', (object,), {'value': '1_000'}))"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""def is_simple_decorator_expression(n):\n    return False"",
            ""syms = type('syms', (object,), {\n    'typedargslist': 1,\n    'arglist': 2,\n    'varargslist': 3,\n    'return_stmt': 4,\n    'yield_expr': 5,\n    'testlist_star_expr': 6,\n    'annassign': 7,\n    'with_stmt': 8,\n    'atom': 9,\n    'testlist_gexp': 10,\n    'match_stmt': 11,\n    'except_clause': 12,\n    'subscriptlist': 13,\n    'trailer': 14,\n    'tname_star': 15,\n    'argument': 16\n})"",
            ""STARS = {token.STAR}"",
            ""node = type('MockNode', (object,), {\n    'pre_order': lambda self: [\n        type('Mock', (object,), {'value': 'f\""example=\""', 'type': token.STRING, 'children': [], 'parent': None}),\n        type('Mock', (object,), {'value': '1_000', 'type': token.NUMBER, 'children': [], 'parent': None}),\n        type('Mock', (object,), {'type': token.SLASH, 'parent': type('Parent', (object,), {'type': syms.typedargslist})}),\n        type('Mock', (object,), {'type': token.COLONEQUAL}),\n        type('Mock', (object,), {'type': syms.decorator, 'children': [None, object()]}),\n        type('Mock', (object,), {'type': syms.arglist, 'children': [type('Child', (object,), {'type': token.COMMA, 'value': '*args'})]}),\n        type('Mock', (object,), {'type': syms.return_stmt, 'children': [None, type('Child', (object,), {'type': syms.testlist_star_expr, 'children': [type('GrandChild', (object,), {'type': syms.star_expr})]})]}),\n        type('Mock', (object,), {'type': syms.annassign, 'children': [None, None, None, type('Child', (object,), {'type': syms.testlist_star_expr})]}),\n        type('Mock', (object,), {'type': syms.with_stmt, 'children': [None, type('Atom', (object,), {'type': syms.atom, 'children': [token.LPAR, type('Child', (object,), {'type': syms.testlist_gexp}), token.RPAR]})]}),\n        type('Mock', (object,), {'type': syms.match_stmt}),\n        type('Mock', (object,), {'type': syms.except_clause, 'children': [None, token.STAR]}),\n        type('Mock', (object,), {'type': syms.subscriptlist, 'children': [type('Child', (object,), {'type': syms.star_expr})]}),\n        type('Mock', (object,), {'type': syms.tname_star, 'children': [None, None, type('Child', (object,), {'type': syms.star_expr})]})\n    ]\n})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = auto()\n    DEBUG_F_STRINGS = auto()\n    NUMERIC_UNDERSCORES = auto()\n    POS_ONLY_ARGUMENTS = auto()\n    ASSIGNMENT_EXPRESSIONS = auto()\n    RELAXED_DECORATORS = auto()\n    TRAILING_COMMA_IN_DEF = auto()\n    TRAILING_COMMA_IN_CALL = auto()\n    UNPACKING_ON_FLOW = auto()\n    ANN_ASSIGN_EXTENDED_RHS = auto()\n    PARENTHESIZED_CONTEXT_MANAGERS = auto()\n    PATTERN_MATCHING = auto()\n    EXCEPT_STAR = auto()\n    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):\n    return n.type == token.STRING"",
            ""def is_number_token(n):\n    return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value):\n    yield (3, 5)"",
            ""def is_simple_decorator_expression(n):\n    return False"",
            ""syms = type('syms', (object,), {\n    'typedargslist': 1,\n    'arglist': 2,\n    'varargslist': 3,\n    'return_stmt': 4,\n    'yield_expr': 5,\n    'testlist_star_expr': 6,\n    'star_expr': 7,\n    'annassign': 8,\n    'with_stmt': 9,\n    'atom': 10,\n    'testlist_gexp': 11,\n    'match_stmt': 12,\n    'except_clause': 13,\n    'subscriptlist': 14,\n    'trailer': 15,\n    'tname_star': 16,\n    'argument': 17})"",
            ""STARS = {token.STAR}"",
            ""node = type('Node', (object,), dict(pre_order=lambda self: [type('NodeMock', (object,), dict(type=token.STRING, value='f\""example=\""', children=[], parent=None))])())""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import ast"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.PARENTHESIZED_CONTEXT_MANAGERS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str)"",
            ""def is_number_token(n):"",
            ""    return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'return_stmt': 4,"",
            ""    'yield_expr': 5,"",
            ""    'testlist_star_expr': 6,"",
            ""    'star_expr': 7,"",
            ""    'annassign': 8,"",
            ""    'with_stmt': 9,"",
            ""    'atom': 10,"",
            ""    'testlist_gexp': 11,"",
            ""    'match_stmt': 12,"",
            ""    'except_clause': 13,"",
            ""    'subscriptlist': 14,"",
            ""    'trailer': 15,"",
            ""    'tname_star': 16"",
            ""})"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('Mock', (object,), {'type': syms.with_stmt, 'children': [None, type('Mock', (object,), {'type': syms.atom, 'children': [token.LPAR, type('Mock', (object,), {'type': syms.testlist_gexp}), token.RPAR]})]})]()})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = 'f_strings'"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'"",
            ""    PATTERN_MATCHING = 'pattern_matching'"",
            ""    EXCEPT_STAR = 'except_star'"",
            ""    VARIADIC_GENERICS = 'variadic_generics'"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n): return isinstance(n, type('Mock', (object,), {'value': 'f\""example\""'}))"",
            ""def is_number_token(n): return isinstance(n, type('Mock', (object,), {'value': '1_000'}))"",
            ""def iter_fexpr_spans(value): yield (2, len(value))"",
            ""def is_simple_decorator_expression(n): return False"",
            ""syms = type('syms', (object,), {'typedargslist': auto(), 'arglist': auto(), 'varargslist': auto(), 'return_stmt': auto(), 'yield_expr': auto(), 'testlist_star_expr': auto(), 'star_expr': auto(), 'annassign': auto(), 'with_stmt': auto(), 'atom': auto(), 'testlist_gexp': auto(), 'match_stmt': auto(), 'except_clause': auto(), 'subscriptlist': auto(), 'trailer': auto(), 'tname_star': auto(), 'argument': auto()})"",
            ""STARS = {token.STAR}"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('Mock', (object,), {'type': token.STRING, 'value': 'f\""example={1}\""', 'children': [], 'parent': None})]})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return isinstance(n, type('Mock', (object,), {'value': 'f\""example\""'}))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n, type('Mock', (object,), {'value': '1_000'}))"",
            ""def iter_fexpr_spans(value):"",
            ""    return [(2, len(value))]"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': auto(),"",
            ""    'arglist': auto(),"",
            ""    'varargslist': auto(),"",
            ""    'return_stmt': auto(),"",
            ""    'yield_expr': auto(),"",
            ""    'testlist_star_expr': auto(),"",
            ""    'star_expr': auto(),"",
            ""    'annassign': auto(),"",
            ""    'with_stmt': auto(),"",
            ""    'atom': auto(),"",
            ""    'testlist_gexp': auto(),"",
            ""    'match_stmt': auto(),"",
            ""    'except_clause': auto(),"",
            ""    'subscriptlist': auto(),"",
            ""    'trailer': auto(),"",
            ""    'tname_star': auto(),"",
            ""    'argument': auto()"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = type('Mock', (object,), {"",
            ""    'pre_order': lambda self: ["",
            ""        type('MockNode', (object,), {"",
            ""            'value': '1_000',"",
            ""            'type': token.NUMBER,"",
            ""            'children': [],"",
            ""            'parent': None"",
            ""        })"",
            ""    ]"",
            ""})()""
        ]
    }
]","[
    {
        ""imports"": [
            ""from enum import Enum, auto # pragma: no cover"",
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.PATTERN_MATCHING} # pragma: no cover"",
            ""syms = type('syms', (object,), {k: k for k in ['typedargslist', 'arglist', 'varargslist', 'decorator', 'return_stmt', 'yield_expr', 'testlist_star_expr', 'annassign', 'with_stmt', 'atom', 'testlist_gexp', 'match_stmt', 'except_clause', 'subscriptlist', 'trailer', 'tname_star']}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and ('f' in n.value or 'F' in n.value) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return [(2, len(value) - 1)] # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""node = type('NodeMock', (object,), {'pre_order': lambda self: [type('MockNode', (object,), {'type': token.STRING, 'value': 'f\""{x=}\""'})]})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover"",
            ""class NodeMock:# pragma: no cover"",
            ""    def __init__(self, type, value, children=None, parent=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.children = children if children is not None else []# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return isinstance(n, NodeMock) and isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return isinstance(n, NodeMock) and isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    yield (2, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), {# pragma: no cover"",
            ""    'typedargslist': 1,# pragma: no cover"",
            ""    'arglist': 2,# pragma: no cover"",
            ""    'varargslist': 3,# pragma: no cover"",
            ""    'decorator': 4,# pragma: no cover"",
            ""    'return_stmt': 5,# pragma: no cover"",
            ""    'yield_expr': 6,# pragma: no cover"",
            ""    'testlist_star_expr': 7,# pragma: no cover"",
            ""    'star_expr': 8,# pragma: no cover"",
            ""    'annassign': 9,# pragma: no cover"",
            ""    'with_stmt': 10,# pragma: no cover"",
            ""    'atom': 11,# pragma: no cover"",
            ""    'testlist_gexp': 12,# pragma: no cover"",
            ""    'match_stmt': 13,# pragma: no cover"",
            ""    'except_clause': 14,# pragma: no cover"",
            ""    'subscriptlist': 15,# pragma: no cover"",
            ""    'trailer': 16,# pragma: no cover"",
            ""    'tname_star': 17,# pragma: no cover"",
            ""    'argument': 18}) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR, 17} # pragma: no cover"",
            ""node = NodeMock(token.STRING, 'f\""example\""', children=[NodeMock(syms.decorator, '@decorator', children=[None, NodeMock(token.NAME, 'value')])]) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n, type('Mock', (object,), {'value': 'f\""example=\""'})) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n, type('Mock', (object,), {'value': '1_000'})) # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return [(3, len(value))] # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': auto(), # pragma: no cover"",
            ""    'arglist': auto(), # pragma: no cover"",
            ""    'varargslist': auto(), # pragma: no cover"",
            ""    'decorator': auto(), # pragma: no cover"",
            ""    'return_stmt': auto(), # pragma: no cover"",
            ""    'yield_expr': auto(), # pragma: no cover"",
            ""    'testlist_star_expr': auto(), # pragma: no cover"",
            ""    'star_expr': auto(), # pragma: no cover"",
            ""    'annassign': auto(), # pragma: no cover"",
            ""    'with_stmt': auto(), # pragma: no cover"",
            ""    'atom': auto(), # pragma: no cover"",
            ""    'testlist_gexp': auto(), # pragma: no cover"",
            ""    'match_stmt': auto(), # pragma: no cover"",
            ""    'except_clause': auto(), # pragma: no cover"",
            ""    'subscriptlist': auto(), # pragma: no cover"",
            ""    'trailer': auto(), # pragma: no cover"",
            ""    'tname_star': auto(), # pragma: no cover"",
            ""    'argument': auto() # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('Mock', (object,), {'value': 'f\""example\""', 'type': token.STRING, 'children': []})]})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, value, type, children=None, parent=None): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and (n.value.startswith('f') or n.value.startswith('F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""node = MockNode('f\""example\""', token.STRING) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'return_stmt': 4, # pragma: no cover"",
            ""    'yield_expr': 5, # pragma: no cover"",
            ""    'testlist_star_expr': 6, # pragma: no cover"",
            ""    'star_expr': 7, # pragma: no cover"",
            ""    'annassign': 8, # pragma: no cover"",
            ""    'with_stmt': 9, # pragma: no cover"",
            ""    'atom': 10, # pragma: no cover"",
            ""    'testlist_gexp': 11, # pragma: no cover"",
            ""    'match_stmt': 12, # pragma: no cover"",
            ""    'except_clause': 13, # pragma: no cover"",
            ""    'subscriptlist': 14, # pragma: no cover"",
            ""    'trailer': 15, # pragma: no cover"",
            ""    'tname_star': 16, # pragma: no cover"",
            ""    'argument': 17 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""node = type('Mock', (object,), { # pragma: no cover"",
            ""    'value': '1_000', # pragma: no cover"",
            ""    'type': token.NUMBER, # pragma: no cover"",
            ""    'children': [], # pragma: no cover"",
            ""    'parent': None, # pragma: no cover"",
            ""    'pre_order': lambda self: [self] # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = auto()# pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto()# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto()# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto()# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()# pragma: no cover"",
            ""    RELAXED_DECORATORS = auto()# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto()# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto()# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto()# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()# pragma: no cover"",
            ""    PATTERN_MATCHING = auto()# pragma: no cover"",
            ""    EXCEPT_STAR = auto()# pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return isinstance(n, type('Mock', (object,), {'value': 'f\""example\""'})) # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return isinstance(n, type('Mock', (object,), {'value': '1_000'})) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_simple_decorator_expression(n):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), {# pragma: no cover"",
            ""    'typedargslist': 1,# pragma: no cover"",
            ""    'arglist': 2,# pragma: no cover"",
            ""    'varargslist': 3,# pragma: no cover"",
            ""    'return_stmt': 4,# pragma: no cover"",
            ""    'yield_expr': 5,# pragma: no cover"",
            ""    'testlist_star_expr': 6,# pragma: no cover"",
            ""    'annassign': 7,# pragma: no cover"",
            ""    'with_stmt': 8,# pragma: no cover"",
            ""    'atom': 9,# pragma: no cover"",
            ""    'testlist_gexp': 10,# pragma: no cover"",
            ""    'match_stmt': 11,# pragma: no cover"",
            ""    'except_clause': 12,# pragma: no cover"",
            ""    'subscriptlist': 13,# pragma: no cover"",
            ""    'trailer': 14,# pragma: no cover"",
            ""    'tname_star': 15,# pragma: no cover"",
            ""    'argument': 16# pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""node = type('MockNode', (object,), {# pragma: no cover"",
            ""    'pre_order': lambda self: [# pragma: no cover"",
            ""        type('Mock', (object,), {'value': 'f\""example=\""', 'type': token.STRING, 'children': [], 'parent': None}),# pragma: no cover"",
            ""        type('Mock', (object,), {'value': '1_000', 'type': token.NUMBER, 'children': [], 'parent': None}),# pragma: no cover"",
            ""        type('Mock', (object,), {'type': token.SLASH, 'parent': type('Parent', (object,), {'type': syms.typedargslist})}),# pragma: no cover"",
            ""        type('Mock', (object,), {'type': token.COLONEQUAL}),# pragma: no cover"",
            ""        type('Mock', (object,), {'type': syms.decorator, 'children': [None, object()]}),# pragma: no cover"",
            ""        type('Mock', (object,), {'type': syms.arglist, 'children': [type('Child', (object,), {'type': token.COMMA, 'value': '*args'})]}),# pragma: no cover"",
            ""        type('Mock', (object,), {'type': syms.return_stmt, 'children': [None, type('Child', (object,), {'type': syms.testlist_star_expr, 'children': [type('GrandChild', (object,), {'type': syms.star_expr})]})]}),# pragma: no cover"",
            ""        type('Mock', (object,), {'type': syms.annassign, 'children': [None, None, None, type('Child', (object,), {'type': syms.testlist_star_expr})]}),# pragma: no cover"",
            ""        type('Mock', (object,), {'type': syms.with_stmt, 'children': [None, type('Atom', (object,), {'type': syms.atom, 'children': [token.LPAR, type('Child', (object,), {'type': syms.testlist_gexp}), token.RPAR]})]}),# pragma: no cover"",
            ""        type('Mock', (object,), {'type': syms.match_stmt}),# pragma: no cover"",
            ""        type('Mock', (object,), {'type': syms.except_clause, 'children': [None, token.STAR]}),# pragma: no cover"",
            ""        type('Mock', (object,), {'type': syms.subscriptlist, 'children': [type('Child', (object,), {'type': syms.star_expr})]}),# pragma: no cover"",
            ""        type('Mock', (object,), {'type': syms.tname_star, 'children': [None, None, type('Child', (object,), {'type': syms.star_expr})]})# pragma: no cover"",
            ""    ]# pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = auto()# pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto()# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto()# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto()# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()# pragma: no cover"",
            ""    RELAXED_DECORATORS = auto()# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto()# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto()# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto()# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()# pragma: no cover"",
            ""    PATTERN_MATCHING = auto()# pragma: no cover"",
            ""    EXCEPT_STAR = auto()# pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return n.type == token.STRING # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return n.type == token.NUMBER # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    yield (3, 5) # pragma: no cover"",
            ""def is_simple_decorator_expression(n):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), {# pragma: no cover"",
            ""    'typedargslist': 1,# pragma: no cover"",
            ""    'arglist': 2,# pragma: no cover"",
            ""    'varargslist': 3,# pragma: no cover"",
            ""    'return_stmt': 4,# pragma: no cover"",
            ""    'yield_expr': 5,# pragma: no cover"",
            ""    'testlist_star_expr': 6,# pragma: no cover"",
            ""    'star_expr': 7,# pragma: no cover"",
            ""    'annassign': 8,# pragma: no cover"",
            ""    'with_stmt': 9,# pragma: no cover"",
            ""    'atom': 10,# pragma: no cover"",
            ""    'testlist_gexp': 11,# pragma: no cover"",
            ""    'match_stmt': 12,# pragma: no cover"",
            ""    'except_clause': 13,# pragma: no cover"",
            ""    'subscriptlist': 14,# pragma: no cover"",
            ""    'trailer': 15,# pragma: no cover"",
            ""    'tname_star': 16,# pragma: no cover"",
            ""    'argument': 17}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.PARENTHESIZED_CONTEXT_MANAGERS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return n.type == token.NUMBER # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'return_stmt': 4, # pragma: no cover"",
            ""    'yield_expr': 5, # pragma: no cover"",
            ""    'testlist_star_expr': 6, # pragma: no cover"",
            ""    'star_expr': 7, # pragma: no cover"",
            ""    'annassign': 8, # pragma: no cover"",
            ""    'with_stmt': 9, # pragma: no cover"",
            ""    'atom': 10, # pragma: no cover"",
            ""    'testlist_gexp': 11, # pragma: no cover"",
            ""    'match_stmt': 12, # pragma: no cover"",
            ""    'except_clause': 13, # pragma: no cover"",
            ""    'subscriptlist': 14, # pragma: no cover"",
            ""    'trailer': 15, # pragma: no cover"",
            ""    'tname_star': 16 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('Mock', (object,), {'type': syms.with_stmt, 'children': [None, type('Mock', (object,), {'type': syms.atom, 'children': [token.LPAR, type('Mock', (object,), {'type': syms.testlist_gexp}), token.RPAR]})]})]()})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = 'f_strings' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching' # pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, type('Mock', (object,), {'value': 'f\""example\""'})) # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, type('Mock', (object,), {'value': '1_000'})) # pragma: no cover"",
            ""def iter_fexpr_spans(value): yield (2, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): return False # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('Mock', (object,), {'type': token.STRING, 'value': 'f\""example={1}\""', 'children': [], 'parent': None})]})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n, type('Mock', (object,), {'value': 'f\""example\""'})) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n, type('Mock', (object,), {'value': '1_000'})) # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return [(2, len(value))] # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': auto(), # pragma: no cover"",
            ""    'arglist': auto(), # pragma: no cover"",
            ""    'varargslist': auto(), # pragma: no cover"",
            ""    'return_stmt': auto(), # pragma: no cover"",
            ""    'yield_expr': auto(), # pragma: no cover"",
            ""    'testlist_star_expr': auto(), # pragma: no cover"",
            ""    'star_expr': auto(), # pragma: no cover"",
            ""    'annassign': auto(), # pragma: no cover"",
            ""    'with_stmt': auto(), # pragma: no cover"",
            ""    'atom': auto(), # pragma: no cover"",
            ""    'testlist_gexp': auto(), # pragma: no cover"",
            ""    'match_stmt': auto(), # pragma: no cover"",
            ""    'except_clause': auto(), # pragma: no cover"",
            ""    'subscriptlist': auto(), # pragma: no cover"",
            ""    'trailer': auto(), # pragma: no cover"",
            ""    'tname_star': auto(), # pragma: no cover"",
            ""    'argument': auto() # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""node = type('Mock', (object,), { # pragma: no cover"",
            ""    'pre_order': lambda self: [ # pragma: no cover"",
            ""        type('MockNode', (object,), { # pragma: no cover"",
            ""            'value': '1_000', # pragma: no cover"",
            ""            'type': token.NUMBER, # pragma: no cover"",
            ""            'children': [], # pragma: no cover"",
            ""            'parent': None # pragma: no cover"",
            ""        }) # pragma: no cover"",
            ""    ] # pragma: no cover"",
            ""})() # pragma: no cover""
        ]
    }
]",3,9909,0.0049545,6588,0.009882,0.0148364999999999
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return a set of (relatively) new Python features used in this file.
    Currently looking for:
    - f-strings;
    - self-documenting expressions in f-strings (f""{x=}"");
    - underscores in numeric literals;
    - trailing commas after * or ** in function signatures and calls;
    - positional only arguments in function signatures and lambdas;
    - assignment expression;
    - relaxed decorator syntax;
    - usage of __future__ flags (annotations);
    - print / exec statements;
    - parenthesized context managers;
    - match statements;
    - except* clause;
    - variadic generics;
    """"""
features: Set[Feature] = set()
if future_imports: # uncovered
    features |= { # uncovered
        FUTURE_FLAG_TO_FEATURE[future_import] # uncovered
        for future_import in future_imports # uncovered
        if future_import in FUTURE_FLAG_TO_FEATURE # uncovered
    } # uncovered
for n in node.pre_order(): # uncovered
    if is_string_token(n): # uncovered
        value_head = n.value[:2] # uncovered
        if value_head in {'f""', 'F""', ""f'"", ""F'"", ""rf"", ""fr"", ""RF"", ""FR""}: # uncovered
            features.add(Feature.F_STRINGS) # uncovered
            if Feature.DEBUG_F_STRINGS not in features: # uncovered
                for span_beg, span_end in iter_fexpr_spans(n.value): # uncovered
                    if n.value[span_beg : span_end - 1].rstrip().endswith(""=""): # uncovered
                        features.add(Feature.DEBUG_F_STRINGS) # uncovered
                        break # uncovered
    elif is_number_token(n): # uncovered
        if ""_"" in n.value: # uncovered
            features.add(Feature.NUMERIC_UNDERSCORES) # uncovered
    elif n.type == token.SLASH: # uncovered
        if n.parent and n.parent.type in { # uncovered
            syms.typedargslist, # uncovered
            syms.arglist, # uncovered
            syms.varargslist, # uncovered
        }: # uncovered
            features.add(Feature.POS_ONLY_ARGUMENTS) # uncovered
    elif n.type == token.COLONEQUAL: # uncovered
        features.add(Feature.ASSIGNMENT_EXPRESSIONS) # uncovered
    elif n.type == syms.decorator: # uncovered
        if len(n.children) > 1 and not is_simple_decorator_expression( # uncovered
            n.children[1] # uncovered
        ): # uncovered
            features.add(Feature.RELAXED_DECORATORS) # uncovered
    elif ( # uncovered
        n.type in {syms.typedargslist, syms.arglist} # uncovered
        and n.children # uncovered
        and n.children[-1].type == token.COMMA # uncovered
    ): # uncovered
        if n.type == syms.typedargslist: # uncovered
            feature = Feature.TRAILING_COMMA_IN_DEF # uncovered
        else: # uncovered
            feature = Feature.TRAILING_COMMA_IN_CALL # uncovered
        for ch in n.children: # uncovered
            if ch.type in STARS: # uncovered
                features.add(feature) # uncovered
            if ch.type == syms.argument: # uncovered
                for argch in ch.children: # uncovered
                    if argch.type in STARS: # uncovered
                        features.add(feature) # uncovered
    elif ( # uncovered
        n.type in {syms.return_stmt, syms.yield_expr} # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == syms.testlist_star_expr # uncovered
        and any(child.type == syms.star_expr for child in n.children[1].children) # uncovered
    ): # uncovered
        features.add(Feature.UNPACKING_ON_FLOW) # uncovered
    elif ( # uncovered
        n.type == syms.annassign # uncovered
        and len(n.children) >= 4 # uncovered
        and n.children[3].type == syms.testlist_star_expr # uncovered
    ): # uncovered
        features.add(Feature.ANN_ASSIGN_EXTENDED_RHS) # uncovered
    elif ( # uncovered
        n.type == syms.with_stmt # uncovered
        and len(n.children) > 2 # uncovered
        and n.children[1].type == syms.atom # uncovered
    ): # uncovered
        atom_children = n.children[1].children # uncovered
        if ( # uncovered
            len(atom_children) == 3 # uncovered
            and atom_children[0].type == token.LPAR # uncovered
            and atom_children[1].type == syms.testlist_gexp # uncovered
            and atom_children[2].type == token.RPAR # uncovered
        ): # uncovered
            features.add(Feature.PARENTHESIZED_CONTEXT_MANAGERS) # uncovered
    elif n.type == syms.match_stmt: # uncovered
        features.add(Feature.PATTERN_MATCHING) # uncovered
    elif ( # uncovered
        n.type == syms.except_clause # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == token.STAR # uncovered
    ): # uncovered
        features.add(Feature.EXCEPT_STAR) # uncovered
    elif n.type in {syms.subscriptlist, syms.trailer} and any( # uncovered
        child.type == syms.star_expr for child in n.children # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
    elif ( # uncovered
        n.type == syms.tname_star # uncovered
        and len(n.children) == 3 # uncovered
        and n.children[2].type == syms.star_expr # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
aux = features # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = auto()\n    DEBUG_F_STRINGS = auto()\n    NUMERIC_UNDERSCORES = auto()\n    POS_ONLY_ARGUMENTS = auto()\n    ASSIGNMENT_EXPRESSIONS = auto()\n    RELAXED_DECORATORS = auto()\n    TRAILING_COMMA_IN_DEF = auto()\n    TRAILING_COMMA_IN_CALL = auto()\n    UNPACKING_ON_FLOW = auto()\n    ANN_ASSIGN_EXTENDED_RHS = auto()\n    PARENTHESIZED_CONTEXT_MANAGERS = auto()\n    PATTERN_MATCHING = auto()\n    EXCEPT_STAR = auto()\n    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, value, type, children=None, parent=None):"",
            ""        self.value = value"",
            ""        self.type = type"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'return_stmt': 4,"",
            ""    'yield_expr': 5,"",
            ""    'testlist_star_expr': 6,"",
            ""    'star_expr': 7,"",
            ""    'annassign': 8,"",
            ""    'with_stmt': 9,"",
            ""    'atom': 10,"",
            ""    'testlist_gexp': 11,"",
            ""    'match_stmt': 12,"",
            ""    'except_clause': 13,"",
            ""    'subscriptlist': 14,"",
            ""    'trailer': 15,"",
            ""    'tname_star': 16"",
            ""})"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""node = MockNode(value='@decorator', type=syms.decorator, children=[None, MockNode(value='value', type=token.NAME)])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.POS_ONLY_ARGUMENTS}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return n.type == token.STRING"",
            ""def is_number_token(n):"",
            ""    return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'return_stmt': 4,"",
            ""    'yield_expr': 5,"",
            ""    'testlist_star_expr': 6,"",
            ""    'star_expr': 7,"",
            ""    'annassign': 8,"",
            ""    'with_stmt': 9,"",
            ""    'atom': 10,"",
            ""    'testlist_gexp': 11,"",
            ""    'match_stmt': 12,"",
            ""    'except_clause': 13,"",
            ""    'subscriptlist': 14,"",
            ""    'trailer': 15,"",
            ""    'tname_star': 16,"",
            ""    'argument': 17"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('Mock', (object,), {'type': token.SLASH, 'parent': type('Parent', (object,), {'type': 1})})]})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = auto()\n    DEBUG_F_STRINGS = auto()\n    NUMERIC_UNDERSCORES = auto()\n    POS_ONLY_ARGUMENTS = auto()\n    ASSIGNMENT_EXPRESSIONS = auto()\n    RELAXED_DECORATORS = auto()\n    TRAILING_COMMA_IN_DEF = auto()\n    TRAILING_COMMA_IN_CALL = auto()\n    UNPACKING_ON_FLOW = auto()\n    ANN_ASSIGN_EXTENDED_RHS = auto()\n    PARENTHESIZED_CONTEXT_MANAGERS = auto()\n    PATTERN_MATCHING = auto()\n    EXCEPT_STAR = auto()\n    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):\n    return isinstance(n, type('Mock', (object,), {'value': 'f\""example\""'}))"",
            ""def is_number_token(n):\n    return isinstance(n, type('Mock', (object,), {'value': '1_000'}))"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""def is_simple_decorator_expression(n):\n    return False"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'testlist_star_expr': 6, 'annassign': 7, 'with_stmt': 8, 'atom': 9, 'testlist_gexp': 10, 'match_stmt': 11, 'except_clause': 12, 'subscriptlist': 13, 'trailer': 14, 'tname_star': 15, 'argument': 16})"",
            ""STARS = {token.STAR}"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('Mock', (object,), {'type': syms.annassign, 'children': [None, None, None, type('Child', (object,), {'type': syms.testlist_star_expr})]})]})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n): return isinstance(n.value, str)"",
            ""def is_number_token(n): return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value): return [(2, len(value))]"",
            ""def is_simple_decorator_expression(n): return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'return_stmt': 4,"",
            ""    'yield_expr': 5,"",
            ""    'star_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'annassign': 8,"",
            ""    'with_stmt': 9,"",
            ""    'atom': 10,"",
            ""    'testlist_gexp': 11,"",
            ""    'match_stmt': 12,"",
            ""    'except_clause': 13,"",
            ""    'subscriptlist': 14,"",
            ""    'trailer': 15,"",
            ""    'tname_star': 16,"",
            ""    'argument': 17"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: ["",
            ""    type('Mock', (object,), {'type': token.COLONEQUAL, 'value': ':=', 'children': []}),"",
            ""    type('Mock', (object,), {'value': 'f\""example={1}\""', 'type': token.STRING, 'children': []}),"",
            ""    type('Mock', (object,), {'value': '1_000', 'type': token.NUMBER, 'children': []}),"",
            ""    type('Mock', (object,), {'type': token.SLASH, 'parent': type('Parent', (object,), {'type': syms.typedargslist})}),"",
            ""    type('Mock', (object,), {'type': syms.decorator, 'children': [None, object()]}),"",
            ""    type('Mock', (object,), {'type': syms.arglist, 'children': [type('Child', (object,), {'type': token.COMMA, 'value': '*args'})]}),"",
            ""    type('Mock', (object,), {'type': syms.return_stmt, 'children': [None, type('Child', (object,), {'type': syms.testlist_star_expr, 'children': [type('GrandChild', (object,), {'type': syms.star_expr})]})]}),"",
            ""    type('Mock', (object,), {'type': syms.annassign, 'children': [None, None, None, type('Child', (object,), {'type': syms.testlist_star_expr})]}),"",
            ""    type('Mock', (object,), {'type': syms.with_stmt, 'children': [None, type('Atom', (object,), {'type': syms.atom, 'children': [token.LPAR, type('Child', (object,), {'type': syms.testlist_gexp}), token.RPAR]})]}),"",
            ""    type('Mock', (object,), {'type': syms.match_stmt}),"",
            ""    type('Mock', (object,), {'type': syms.except_clause, 'children': [None, token.STAR]}),"",
            ""    type('Mock', (object,), {'type': syms.subscriptlist, 'children': [type('Child', (object,), {'type': syms.star_expr})]}),"",
            ""    type('Mock', (object,), {'type': syms.tname_star, 'children': [None, None, type('Child', (object,), {'type': syms.star_expr})]})"",
            ""]})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, value, typ, children=None, parent=None):"",
            ""        self.value = value"",
            ""        self.type = typ"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and (n.value.startswith('f') or n.value.startswith('F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'return_stmt': 4,"",
            ""    'yield_expr': 5,"",
            ""    'testlist_star_expr': 6,"",
            ""    'star_expr': 7,"",
            ""    'annassign': 8,"",
            ""    'with_stmt': 9,"",
            ""    'atom': 10,"",
            ""    'testlist_gexp': 11,"",
            ""    'match_stmt': 12,"",
            ""    'except_clause': 13,"",
            ""    'subscriptlist': 14,"",
            ""    'trailer': 15,"",
            ""    'tname_star': 16,"",
            ""    'argument': 17"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = MockNode('f\""example=\""', token.STRING)""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum, auto"",
            ""from typing import Set"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, value, type, children=None, parent=None):"",
            ""        self.value = value"",
            ""        self.type = type"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17"",
            ""})"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""node = MockNode('f\""example=\""', token.STRING)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str)"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    return [(0, len(value))]"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = type('MockNode', (object,), dict(pre_order=lambda self: [type('NodeMock', (object,), dict(value='1_000', type=token.NUMBER, children=[]))]))()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return isinstance(n, MockNode) and isinstance(n.value, str)"",
            ""def is_number_token(n):"",
            ""    return isinstance(n, MockNode) and isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""class MockNode:"",
            ""    def __init__(self, type, value, children=None, parent=None):"",
            ""        self.type = type;"",
            ""        self.value = value;"",
            ""        self.children = children if children is not None else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""node = MockNode(token.STRING, 'f\""example={1}\""')""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):\n    return n.type == token.STRING"",
            ""def is_number_token(n):\n    return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value):\n    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):\n    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'return_stmt': 4,"",
            ""    'yield_expr': 5,"",
            ""    'testlist_star_expr': 6,"",
            ""    'star_expr': 7,"",
            ""    'annassign': 8,"",
            ""    'with_stmt': 9,"",
            ""    'atom': 10,"",
            ""    'testlist_gexp': 11,"",
            ""    'match_stmt': 12,"",
            ""    'except_clause': 13,"",
            ""    'subscriptlist': 14,"",
            ""    'trailer': 15,"",
            ""    'tname_star': 16,"",
            ""    'argument': 17"",
            ""})"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('Mock', (object,), {'type': token.NUMBER, 'value': '1_000', 'children': [], 'parent': None})]})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.PARENTHESIZED_CONTEXT_MANAGERS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return n.type == token.STRING"",
            ""def is_number_token(n):"",
            ""    return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (3, 5)"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = type('MockNode', (object,), dict(pre_order=lambda self: [type('Mock', (object,), dict(type=syms.with_stmt, children=[None, type('Mock', (object,), dict(type=syms.atom, children=[token.LPAR, type('Mock', (object,), dict(type=syms.testlist_gexp)), token.RPAR]))]))]))()""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = auto()# pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto()# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto()# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto()# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()# pragma: no cover"",
            ""    RELAXED_DECORATORS = auto()# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto()# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto()# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto()# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()# pragma: no cover"",
            ""    PATTERN_MATCHING = auto()# pragma: no cover"",
            ""    EXCEPT_STAR = auto()# pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, value, type, children=None, parent=None): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'return_stmt': 4, # pragma: no cover"",
            ""    'yield_expr': 5, # pragma: no cover"",
            ""    'testlist_star_expr': 6, # pragma: no cover"",
            ""    'star_expr': 7, # pragma: no cover"",
            ""    'annassign': 8, # pragma: no cover"",
            ""    'with_stmt': 9, # pragma: no cover"",
            ""    'atom': 10, # pragma: no cover"",
            ""    'testlist_gexp': 11, # pragma: no cover"",
            ""    'match_stmt': 12, # pragma: no cover"",
            ""    'except_clause': 13, # pragma: no cover"",
            ""    'subscriptlist': 14, # pragma: no cover"",
            ""    'trailer': 15, # pragma: no cover"",
            ""    'tname_star': 16 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.POS_ONLY_ARGUMENTS} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return n.type == token.STRING # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return n.type == token.NUMBER # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'return_stmt': 4, # pragma: no cover"",
            ""    'yield_expr': 5, # pragma: no cover"",
            ""    'testlist_star_expr': 6, # pragma: no cover"",
            ""    'star_expr': 7, # pragma: no cover"",
            ""    'annassign': 8, # pragma: no cover"",
            ""    'with_stmt': 9, # pragma: no cover"",
            ""    'atom': 10, # pragma: no cover"",
            ""    'testlist_gexp': 11, # pragma: no cover"",
            ""    'match_stmt': 12, # pragma: no cover"",
            ""    'except_clause': 13, # pragma: no cover"",
            ""    'subscriptlist': 14, # pragma: no cover"",
            ""    'trailer': 15, # pragma: no cover"",
            ""    'tname_star': 16, # pragma: no cover"",
            ""    'argument': 17 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('Mock', (object,), {'type': token.SLASH, 'parent': type('Parent', (object,), {'type': 1})})]})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = auto()# pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto()# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto()# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto()# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()# pragma: no cover"",
            ""    RELAXED_DECORATORS = auto()# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto()# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto()# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto()# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()# pragma: no cover"",
            ""    PATTERN_MATCHING = auto()# pragma: no cover"",
            ""    EXCEPT_STAR = auto()# pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return isinstance(n, type('Mock', (object,), {'value': 'f\""example\""'})) # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return isinstance(n, type('Mock', (object,), {'value': '1_000'})) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_simple_decorator_expression(n):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'testlist_star_expr': 6, 'annassign': 7, 'with_stmt': 8, 'atom': 9, 'testlist_gexp': 10, 'match_stmt': 11, 'except_clause': 12, 'subscriptlist': 13, 'trailer': 14, 'tname_star': 15, 'argument': 16}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('Mock', (object,), {'type': syms.annassign, 'children': [None, None, None, type('Child', (object,), {'type': syms.testlist_star_expr})]})]})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n.value, str) # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(2, len(value))] # pragma: no cover"",
            ""def is_simple_decorator_expression(n): return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'return_stmt': 4, # pragma: no cover"",
            ""    'yield_expr': 5, # pragma: no cover"",
            ""    'star_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'annassign': 8, # pragma: no cover"",
            ""    'with_stmt': 9, # pragma: no cover"",
            ""    'atom': 10, # pragma: no cover"",
            ""    'testlist_gexp': 11, # pragma: no cover"",
            ""    'match_stmt': 12, # pragma: no cover"",
            ""    'except_clause': 13, # pragma: no cover"",
            ""    'subscriptlist': 14, # pragma: no cover"",
            ""    'trailer': 15, # pragma: no cover"",
            ""    'tname_star': 16, # pragma: no cover"",
            ""    'argument': 17 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [ # pragma: no cover"",
            ""    type('Mock', (object,), {'type': token.COLONEQUAL, 'value': ':=', 'children': []}), # pragma: no cover"",
            ""    type('Mock', (object,), {'value': 'f\""example={1}\""', 'type': token.STRING, 'children': []}), # pragma: no cover"",
            ""    type('Mock', (object,), {'value': '1_000', 'type': token.NUMBER, 'children': []}), # pragma: no cover"",
            ""    type('Mock', (object,), {'type': token.SLASH, 'parent': type('Parent', (object,), {'type': syms.typedargslist})}), # pragma: no cover"",
            ""    type('Mock', (object,), {'type': syms.decorator, 'children': [None, object()]}), # pragma: no cover"",
            ""    type('Mock', (object,), {'type': syms.arglist, 'children': [type('Child', (object,), {'type': token.COMMA, 'value': '*args'})]}), # pragma: no cover"",
            ""    type('Mock', (object,), {'type': syms.return_stmt, 'children': [None, type('Child', (object,), {'type': syms.testlist_star_expr, 'children': [type('GrandChild', (object,), {'type': syms.star_expr})]})]}), # pragma: no cover"",
            ""    type('Mock', (object,), {'type': syms.annassign, 'children': [None, None, None, type('Child', (object,), {'type': syms.testlist_star_expr})]}), # pragma: no cover"",
            ""    type('Mock', (object,), {'type': syms.with_stmt, 'children': [None, type('Atom', (object,), {'type': syms.atom, 'children': [token.LPAR, type('Child', (object,), {'type': syms.testlist_gexp}), token.RPAR]})]}), # pragma: no cover"",
            ""    type('Mock', (object,), {'type': syms.match_stmt}), # pragma: no cover"",
            ""    type('Mock', (object,), {'type': syms.except_clause, 'children': [None, token.STAR]}), # pragma: no cover"",
            ""    type('Mock', (object,), {'type': syms.subscriptlist, 'children': [type('Child', (object,), {'type': syms.star_expr})]}), # pragma: no cover"",
            ""    type('Mock', (object,), {'type': syms.tname_star, 'children': [None, None, type('Child', (object,), {'type': syms.star_expr})]}) # pragma: no cover"",
            ""]})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, value, typ, children=None, parent=None): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and (n.value.startswith('f') or n.value.startswith('F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'return_stmt': 4, # pragma: no cover"",
            ""    'yield_expr': 5, # pragma: no cover"",
            ""    'testlist_star_expr': 6, # pragma: no cover"",
            ""    'star_expr': 7, # pragma: no cover"",
            ""    'annassign': 8, # pragma: no cover"",
            ""    'with_stmt': 9, # pragma: no cover"",
            ""    'atom': 10, # pragma: no cover"",
            ""    'testlist_gexp': 11, # pragma: no cover"",
            ""    'match_stmt': 12, # pragma: no cover"",
            ""    'except_clause': 13, # pragma: no cover"",
            ""    'subscriptlist': 14, # pragma: no cover"",
            ""    'trailer': 15, # pragma: no cover"",
            ""    'tname_star': 16, # pragma: no cover"",
            ""    'argument': 17 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""node = MockNode('f\""example=\""', token.STRING) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from enum import Enum, auto # pragma: no cover"",
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, value, type, children=None, parent=None): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""node = MockNode('f\""example=\""', token.STRING) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""node = type('MockNode', (object,), dict(pre_order=lambda self: [type('NodeMock', (object,), dict(value='1_000', type=token.NUMBER, children=[]))]))() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n, MockNode) and isinstance(n.value, str) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n, MockNode) and isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, type, value, children=None, parent=None): # pragma: no cover"",
            ""        self.type = type; # pragma: no cover"",
            ""        self.value = value; # pragma: no cover"",
            ""        self.children = children if children is not None else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""node = MockNode(token.STRING, 'f\""example={1}\""') # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return n.type == token.STRING # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return n.type == token.NUMBER # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'return_stmt': 4, # pragma: no cover"",
            ""    'yield_expr': 5, # pragma: no cover"",
            ""    'testlist_star_expr': 6, # pragma: no cover"",
            ""    'star_expr': 7, # pragma: no cover"",
            ""    'annassign': 8, # pragma: no cover"",
            ""    'with_stmt': 9, # pragma: no cover"",
            ""    'atom': 10, # pragma: no cover"",
            ""    'testlist_gexp': 11, # pragma: no cover"",
            ""    'match_stmt': 12, # pragma: no cover"",
            ""    'except_clause': 13, # pragma: no cover"",
            ""    'subscriptlist': 14, # pragma: no cover"",
            ""    'trailer': 15, # pragma: no cover"",
            ""    'tname_star': 16, # pragma: no cover"",
            ""    'argument': 17 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('Mock', (object,), {'type': token.NUMBER, 'value': '1_000', 'children': [], 'parent': None})]})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.PARENTHESIZED_CONTEXT_MANAGERS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return n.type == token.STRING # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return n.type == token.NUMBER # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (3, 5) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""node = type('MockNode', (object,), dict(pre_order=lambda self: [type('Mock', (object,), dict(type=syms.with_stmt, children=[None, type('Mock', (object,), dict(type=syms.atom, children=[token.LPAR, type('Mock', (object,), dict(type=syms.testlist_gexp)), token.RPAR]))]))]))() # pragma: no cover""
        ]
    }
]",3,9687,0.0048435,6791,0.0101865,0.0150299999999999
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return a set of (relatively) new Python features used in this file.
    Currently looking for:
    - f-strings;
    - self-documenting expressions in f-strings (f""{x=}"");
    - underscores in numeric literals;
    - trailing commas after * or ** in function signatures and calls;
    - positional only arguments in function signatures and lambdas;
    - assignment expression;
    - relaxed decorator syntax;
    - usage of __future__ flags (annotations);
    - print / exec statements;
    - parenthesized context managers;
    - match statements;
    - except* clause;
    - variadic generics;
    """"""
features: Set[Feature] = set()
if future_imports: # uncovered
    features |= { # uncovered
        FUTURE_FLAG_TO_FEATURE[future_import] # uncovered
        for future_import in future_imports # uncovered
        if future_import in FUTURE_FLAG_TO_FEATURE # uncovered
    } # uncovered
for n in node.pre_order(): # uncovered
    if is_string_token(n): # uncovered
        value_head = n.value[:2] # uncovered
        if value_head in {'f""', 'F""', ""f'"", ""F'"", ""rf"", ""fr"", ""RF"", ""FR""}: # uncovered
            features.add(Feature.F_STRINGS) # uncovered
            if Feature.DEBUG_F_STRINGS not in features: # uncovered
                for span_beg, span_end in iter_fexpr_spans(n.value): # uncovered
                    if n.value[span_beg : span_end - 1].rstrip().endswith(""=""): # uncovered
                        features.add(Feature.DEBUG_F_STRINGS) # uncovered
                        break # uncovered
    elif is_number_token(n): # uncovered
        if ""_"" in n.value: # uncovered
            features.add(Feature.NUMERIC_UNDERSCORES) # uncovered
    elif n.type == token.SLASH: # uncovered
        if n.parent and n.parent.type in { # uncovered
            syms.typedargslist, # uncovered
            syms.arglist, # uncovered
            syms.varargslist, # uncovered
        }: # uncovered
            features.add(Feature.POS_ONLY_ARGUMENTS) # uncovered
    elif n.type == token.COLONEQUAL: # uncovered
        features.add(Feature.ASSIGNMENT_EXPRESSIONS) # uncovered
    elif n.type == syms.decorator: # uncovered
        if len(n.children) > 1 and not is_simple_decorator_expression( # uncovered
            n.children[1] # uncovered
        ): # uncovered
            features.add(Feature.RELAXED_DECORATORS) # uncovered
    elif ( # uncovered
        n.type in {syms.typedargslist, syms.arglist} # uncovered
        and n.children # uncovered
        and n.children[-1].type == token.COMMA # uncovered
    ): # uncovered
        if n.type == syms.typedargslist: # uncovered
            feature = Feature.TRAILING_COMMA_IN_DEF # uncovered
        else: # uncovered
            feature = Feature.TRAILING_COMMA_IN_CALL # uncovered
        for ch in n.children: # uncovered
            if ch.type in STARS: # uncovered
                features.add(feature) # uncovered
            if ch.type == syms.argument: # uncovered
                for argch in ch.children: # uncovered
                    if argch.type in STARS: # uncovered
                        features.add(feature) # uncovered
    elif ( # uncovered
        n.type in {syms.return_stmt, syms.yield_expr} # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == syms.testlist_star_expr # uncovered
        and any(child.type == syms.star_expr for child in n.children[1].children) # uncovered
    ): # uncovered
        features.add(Feature.UNPACKING_ON_FLOW) # uncovered
    elif ( # uncovered
        n.type == syms.annassign # uncovered
        and len(n.children) >= 4 # uncovered
        and n.children[3].type == syms.testlist_star_expr # uncovered
    ): # uncovered
        features.add(Feature.ANN_ASSIGN_EXTENDED_RHS) # uncovered
    elif ( # uncovered
        n.type == syms.with_stmt # uncovered
        and len(n.children) > 2 # uncovered
        and n.children[1].type == syms.atom # uncovered
    ): # uncovered
        atom_children = n.children[1].children # uncovered
        if ( # uncovered
            len(atom_children) == 3 # uncovered
            and atom_children[0].type == token.LPAR # uncovered
            and atom_children[1].type == syms.testlist_gexp # uncovered
            and atom_children[2].type == token.RPAR # uncovered
        ): # uncovered
            features.add(Feature.PARENTHESIZED_CONTEXT_MANAGERS) # uncovered
    elif n.type == syms.match_stmt: # uncovered
        features.add(Feature.PATTERN_MATCHING) # uncovered
    elif ( # uncovered
        n.type == syms.except_clause # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == token.STAR # uncovered
    ): # uncovered
        features.add(Feature.EXCEPT_STAR) # uncovered
    elif n.type in {syms.subscriptlist, syms.trailer} and any( # uncovered
        child.type == syms.star_expr for child in n.children # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
    elif ( # uncovered
        n.type == syms.tname_star # uncovered
        and len(n.children) == 3 # uncovered
        and n.children[2].type == syms.star_expr # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
aux = features # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, type, value, children=None, parent=None):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return n.type == token.STRING"",
            ""def is_number_token(n):"",
            ""    return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value):"",
            ""    return [(0, len(value))]"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = MockNode(token.STRING, 'f\""example={1}\""')""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str)"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    return [(0, len(value))]"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""node = type('MockNode', (object,), dict(pre_order=lambda self: [type('Mock', (object,), dict(type=token.SLASH, parent=type('Parent', (object,), dict(type=1))))]))()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.POS_ONLY_ARGUMENTS}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n): return isinstance(n.value, str) and n.value.startswith('f')"",
            ""def is_number_token(n): return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""def is_simple_decorator_expression(n): return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""class MockNode:"",
            ""    def __init__(self, value='', type=None, children=None, parent=None):"",
            ""        self.value = value"",
            ""        self.type = type"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""node = MockNode(value='arg', type=token.SLASH, parent=MockNode(type=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and 'f' in n.value or 'F' in n.value"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (2, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = type('MockNode', (object,), dict(pre_order=lambda self: [type('Mock', (object,), dict(value='1_000', type=token.NUMBER, children=[]))]))()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.PARENTHESIZED_CONTEXT_MANAGERS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = type('MockNode', (object,), dict(pre_order=lambda self: [type('Mock', (object,), dict(type=syms.with_stmt, children=[None, type('Mock', (object,), dict(type=syms.atom, children=[token.LPAR, type('Mock', (object,), dict(type=syms.testlist_gexp)), token.RPAR]))]))]))()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n): return isinstance(n.value, str) and (n.value.startswith(('f', 'F')))"",
            ""def is_number_token(n): return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value): yield (0, len(value))"",
            ""def is_simple_decorator_expression(n): return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""class MockNode:"",
            ""    def __init__(self, type_, value, children=None, parent=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self): return [self]"",
            ""node = MockNode(token.STRING, 'f\""example={x}\""')""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.POS_ONLY_ARGUMENTS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return hasattr(n, 'type') and n.type == token.STRING"",
            ""def is_number_token(n):"",
            ""    return hasattr(n, 'type') and n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'return_stmt': 4,"",
            ""    'yield_expr': 5,"",
            ""    'testlist_star_expr': 6,"",
            ""    'star_expr': 7,"",
            ""    'annassign': 8,"",
            ""    'with_stmt': 9,"",
            ""    'atom': 10,"",
            ""    'testlist_gexp': 11,"",
            ""    'match_stmt': 12,"",
            ""    'except_clause': 13,"",
            ""    'subscriptlist': 14,"",
            ""    'trailer': 15,"",
            ""    'tname_star': 16,"",
            ""    'argument': 17"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('Mock', (object,), {'type': token.SLASH, 'parent': type('Mock', (object,), {'type': 1})})]})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and (n.value.startswith('f') or n.value.startswith('F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""class MockNode:"",
            ""    def __init__(self, value, typ, children=None, parent=None):"",
            ""        self.value = value"",
            ""        self.type = typ"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""node = MockNode('f\""example={1}\""', token.STRING)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith('f')"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""class MockNode:"",
            ""    def __init__(self, type, value=None, children=None, parent=None):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.children = children if children is not None else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""node = MockNode(token.STRING, value='f\""example=\""')""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, value, typ, children=None, parent=None):"",
            ""        self.value = value"",
            ""        self.type = typ"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = MockNode('f\""example\""', token.STRING)""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, type, value, children=None, parent=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return n.type == token.STRING # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return n.type == token.NUMBER # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""node = MockNode(token.STRING, 'f\""example={1}\""') # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""node = type('MockNode', (object,), dict(pre_order=lambda self: [type('Mock', (object,), dict(type=token.SLASH, parent=type('Parent', (object,), dict(type=1))))]))() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.POS_ONLY_ARGUMENTS} # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n.value, str) and n.value.startswith('f') # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(0, len(value))] # pragma: no cover"",
            ""def is_simple_decorator_expression(n): return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, value='', type=None, children=None, parent=None): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""node = MockNode(value='arg', type=token.SLASH, parent=MockNode(type=syms.typedargslist)) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and 'f' in n.value or 'F' in n.value # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (2, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""node = type('MockNode', (object,), dict(pre_order=lambda self: [type('Mock', (object,), dict(value='1_000', type=token.NUMBER, children=[]))]))() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.PARENTHESIZED_CONTEXT_MANAGERS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""node = type('MockNode', (object,), dict(pre_order=lambda self: [type('Mock', (object,), dict(type=syms.with_stmt, children=[None, type('Mock', (object,), dict(type=syms.atom, children=[token.LPAR, type('Mock', (object,), dict(type=syms.testlist_gexp)), token.RPAR]))]))]))() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n.value, str) and (n.value.startswith(('f', 'F'))) # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, type_, value, children=None, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): return [self] # pragma: no cover"",
            ""node = MockNode(token.STRING, 'f\""example={x}\""') # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.POS_ONLY_ARGUMENTS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'type') and n.type == token.STRING # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'type') and n.type == token.NUMBER # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'return_stmt': 4, # pragma: no cover"",
            ""    'yield_expr': 5, # pragma: no cover"",
            ""    'testlist_star_expr': 6, # pragma: no cover"",
            ""    'star_expr': 7, # pragma: no cover"",
            ""    'annassign': 8, # pragma: no cover"",
            ""    'with_stmt': 9, # pragma: no cover"",
            ""    'atom': 10, # pragma: no cover"",
            ""    'testlist_gexp': 11, # pragma: no cover"",
            ""    'match_stmt': 12, # pragma: no cover"",
            ""    'except_clause': 13, # pragma: no cover"",
            ""    'subscriptlist': 14, # pragma: no cover"",
            ""    'trailer': 15, # pragma: no cover"",
            ""    'tname_star': 16, # pragma: no cover"",
            ""    'argument': 17 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('Mock', (object,), {'type': token.SLASH, 'parent': type('Mock', (object,), {'type': 1})})]})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and (n.value.startswith('f') or n.value.startswith('F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, value, typ, children=None, parent=None): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""node = MockNode('f\""example={1}\""', token.STRING) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith('f') # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, type, value=None, children=None, parent=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children is not None else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""node = MockNode(token.STRING, value='f\""example=\""') # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, value, typ, children=None, parent=None): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""node = MockNode('f\""example\""', token.STRING) # pragma: no cover""
        ]
    }
]",3,9890,0.004945,6599,0.0098985,0.0148434999999999
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return a set of (relatively) new Python features used in this file.
    Currently looking for:
    - f-strings;
    - self-documenting expressions in f-strings (f""{x=}"");
    - underscores in numeric literals;
    - trailing commas after * or ** in function signatures and calls;
    - positional only arguments in function signatures and lambdas;
    - assignment expression;
    - relaxed decorator syntax;
    - usage of __future__ flags (annotations);
    - print / exec statements;
    - parenthesized context managers;
    - match statements;
    - except* clause;
    - variadic generics;
    """"""
features: Set[Feature] = set()
if future_imports: # uncovered
    features |= { # uncovered
        FUTURE_FLAG_TO_FEATURE[future_import] # uncovered
        for future_import in future_imports # uncovered
        if future_import in FUTURE_FLAG_TO_FEATURE # uncovered
    } # uncovered
for n in node.pre_order(): # uncovered
    if is_string_token(n): # uncovered
        value_head = n.value[:2] # uncovered
        if value_head in {'f""', 'F""', ""f'"", ""F'"", ""rf"", ""fr"", ""RF"", ""FR""}: # uncovered
            features.add(Feature.F_STRINGS) # uncovered
            if Feature.DEBUG_F_STRINGS not in features: # uncovered
                for span_beg, span_end in iter_fexpr_spans(n.value): # uncovered
                    if n.value[span_beg : span_end - 1].rstrip().endswith(""=""): # uncovered
                        features.add(Feature.DEBUG_F_STRINGS) # uncovered
                        break # uncovered
    elif is_number_token(n): # uncovered
        if ""_"" in n.value: # uncovered
            features.add(Feature.NUMERIC_UNDERSCORES) # uncovered
    elif n.type == token.SLASH: # uncovered
        if n.parent and n.parent.type in { # uncovered
            syms.typedargslist, # uncovered
            syms.arglist, # uncovered
            syms.varargslist, # uncovered
        }: # uncovered
            features.add(Feature.POS_ONLY_ARGUMENTS) # uncovered
    elif n.type == token.COLONEQUAL: # uncovered
        features.add(Feature.ASSIGNMENT_EXPRESSIONS) # uncovered
    elif n.type == syms.decorator: # uncovered
        if len(n.children) > 1 and not is_simple_decorator_expression( # uncovered
            n.children[1] # uncovered
        ): # uncovered
            features.add(Feature.RELAXED_DECORATORS) # uncovered
    elif ( # uncovered
        n.type in {syms.typedargslist, syms.arglist} # uncovered
        and n.children # uncovered
        and n.children[-1].type == token.COMMA # uncovered
    ): # uncovered
        if n.type == syms.typedargslist: # uncovered
            feature = Feature.TRAILING_COMMA_IN_DEF # uncovered
        else: # uncovered
            feature = Feature.TRAILING_COMMA_IN_CALL # uncovered
        for ch in n.children: # uncovered
            if ch.type in STARS: # uncovered
                features.add(feature) # uncovered
            if ch.type == syms.argument: # uncovered
                for argch in ch.children: # uncovered
                    if argch.type in STARS: # uncovered
                        features.add(feature) # uncovered
    elif ( # uncovered
        n.type in {syms.return_stmt, syms.yield_expr} # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == syms.testlist_star_expr # uncovered
        and any(child.type == syms.star_expr for child in n.children[1].children) # uncovered
    ): # uncovered
        features.add(Feature.UNPACKING_ON_FLOW) # uncovered
    elif ( # uncovered
        n.type == syms.annassign # uncovered
        and len(n.children) >= 4 # uncovered
        and n.children[3].type == syms.testlist_star_expr # uncovered
    ): # uncovered
        features.add(Feature.ANN_ASSIGN_EXTENDED_RHS) # uncovered
    elif ( # uncovered
        n.type == syms.with_stmt # uncovered
        and len(n.children) > 2 # uncovered
        and n.children[1].type == syms.atom # uncovered
    ): # uncovered
        atom_children = n.children[1].children # uncovered
        if ( # uncovered
            len(atom_children) == 3 # uncovered
            and atom_children[0].type == token.LPAR # uncovered
            and atom_children[1].type == syms.testlist_gexp # uncovered
            and atom_children[2].type == token.RPAR # uncovered
        ): # uncovered
            features.add(Feature.PARENTHESIZED_CONTEXT_MANAGERS) # uncovered
    elif n.type == syms.match_stmt: # uncovered
        features.add(Feature.PATTERN_MATCHING) # uncovered
    elif ( # uncovered
        n.type == syms.except_clause # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == token.STAR # uncovered
    ): # uncovered
        features.add(Feature.EXCEPT_STAR) # uncovered
    elif n.type in {syms.subscriptlist, syms.trailer} and any( # uncovered
        child.type == syms.star_expr for child in n.children # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
    elif ( # uncovered
        n.type == syms.tname_star # uncovered
        and len(n.children) == 3 # uncovered
        and n.children[2].type == syms.star_expr # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
aux = features # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and (n.value.startswith('f') or n.value.startswith('F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""class MockNode:"",
            ""    def __init__(self, type_, value, children=None, parent=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self): return [self]"",
            ""node = MockNode(token.SLASH, '/', parent=MockNode(syms.typedargslist, 'args'))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return n and hasattr(n, 'value') and isinstance(n.value, str) and len(n.value) > 0"",
            ""def is_number_token(n):"",
            ""    return n and hasattr(n, 'value') and isinstance(n.value, str) and n.value.isnumeric()"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""class MockNode:"",
            ""    def __init__(self, type, value='', children=None, parent=None):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""node = MockNode(token.SLASH, parent=MockNode(syms.typedargslist, children=[MockNode(token.STAR)]))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS,"",
            ""    'other_feature': Feature.PREFERRED_FEATURE"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, type_, value='', children=None, parent=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = MockNode(token.SLASH, parent=MockNode(syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith('f')"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""class MockNode:"",
            ""    def __init__(self, value, typ, children=None, parent=None):"",
            ""        self.value = value"",
            ""        self.type = typ"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""node = MockNode('f\""example={1}\""', token.STRING)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return hasattr(n, 'type') and n.type == token.STRING"",
            ""def is_number_token(n):"",
            ""    return hasattr(n, 'type') and n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""class MockNode:"",
            ""    def __init__(self, value='', typ=None, children=None, parent=None):"",
            ""        self.value = value"",
            ""        self.type = typ"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""node = MockNode(value='arg', typ=token.SLASH, parent=MockNode(typ=1))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, value, typ, children=None, parent=None):"",
            ""        self.value = value"",
            ""        self.type = typ"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = MockNode(type=token.SLASH, value='/', parent=MockNode(type=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""class MockNode:"",
            ""    def __init__(self, value, typ, children=None, parent=None):"",
            ""        self.value = value"",
            ""        self.type = typ"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""node = MockNode('f\""example={x}\""', token.STRING)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""class MockNode:"",
            ""    def __init__(self, value, typ=None, children=None, parent=None):"",
            ""        self.value = value"",
            ""        self.type = typ"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""node = MockNode('example', token.SLASH, parent=MockNode('', 1))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, value=None, typ=None, children=None, parent=None):"",
            ""        self.value = value"",
            ""        self.type = typ"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = MockNode(type=token.SLASH, parent=MockNode(type=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.NUMERIC_UNDERSCORES}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""class MockNode:"",
            ""    def __init__(self, type_=None, value='', children=None, parent=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""node = MockNode(type_=token.NUMBER, value='1_000')""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and (n.value.startswith('f') or n.value.startswith('F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, type_, value, children=None, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): return [self] # pragma: no cover"",
            ""node = MockNode(token.SLASH, '/', parent=MockNode(syms.typedargslist, 'args')) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return n and hasattr(n, 'value') and isinstance(n.value, str) and len(n.value) > 0 # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return n and hasattr(n, 'value') and isinstance(n.value, str) and n.value.isnumeric() # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, type, value='', children=None, parent=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""node = MockNode(token.SLASH, parent=MockNode(syms.typedargslist, children=[MockNode(token.STAR)])) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith('f') # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, value, typ, children=None, parent=None): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""node = MockNode('f\""example={1}\""', token.STRING) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'type') and n.type == token.STRING # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'type') and n.type == token.NUMBER # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, value='', typ=None, children=None, parent=None): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""node = MockNode(value='arg', typ=token.SLASH, parent=MockNode(typ=1)) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, value, typ, children=None, parent=None): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, value, typ, children=None, parent=None): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""node = MockNode('f\""example={x}\""', token.STRING) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, value, typ=None, children=None, parent=None): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""node = MockNode('example', token.SLASH, parent=MockNode('', 1)) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, value=None, typ=None, children=None, parent=None): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.NUMERIC_UNDERSCORES} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, type_=None, value='', children=None, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""node = MockNode(type_=token.NUMBER, value='1_000') # pragma: no cover""
        ]
    }
]",3,9698,0.004849,6937,0.0104055,0.0152545
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return a set of (relatively) new Python features used in this file.
    Currently looking for:
    - f-strings;
    - self-documenting expressions in f-strings (f""{x=}"");
    - underscores in numeric literals;
    - trailing commas after * or ** in function signatures and calls;
    - positional only arguments in function signatures and lambdas;
    - assignment expression;
    - relaxed decorator syntax;
    - usage of __future__ flags (annotations);
    - print / exec statements;
    - parenthesized context managers;
    - match statements;
    - except* clause;
    - variadic generics;
    """"""
features: Set[Feature] = set()
if future_imports: # uncovered
    features |= { # uncovered
        FUTURE_FLAG_TO_FEATURE[future_import] # uncovered
        for future_import in future_imports # uncovered
        if future_import in FUTURE_FLAG_TO_FEATURE # uncovered
    } # uncovered
for n in node.pre_order(): # uncovered
    if is_string_token(n): # uncovered
        value_head = n.value[:2] # uncovered
        if value_head in {'f""', 'F""', ""f'"", ""F'"", ""rf"", ""fr"", ""RF"", ""FR""}: # uncovered
            features.add(Feature.F_STRINGS) # uncovered
            if Feature.DEBUG_F_STRINGS not in features: # uncovered
                for span_beg, span_end in iter_fexpr_spans(n.value): # uncovered
                    if n.value[span_beg : span_end - 1].rstrip().endswith(""=""): # uncovered
                        features.add(Feature.DEBUG_F_STRINGS) # uncovered
                        break # uncovered
    elif is_number_token(n): # uncovered
        if ""_"" in n.value: # uncovered
            features.add(Feature.NUMERIC_UNDERSCORES) # uncovered
    elif n.type == token.SLASH: # uncovered
        if n.parent and n.parent.type in { # uncovered
            syms.typedargslist, # uncovered
            syms.arglist, # uncovered
            syms.varargslist, # uncovered
        }: # uncovered
            features.add(Feature.POS_ONLY_ARGUMENTS) # uncovered
    elif n.type == token.COLONEQUAL: # uncovered
        features.add(Feature.ASSIGNMENT_EXPRESSIONS) # uncovered
    elif n.type == syms.decorator: # uncovered
        if len(n.children) > 1 and not is_simple_decorator_expression( # uncovered
            n.children[1] # uncovered
        ): # uncovered
            features.add(Feature.RELAXED_DECORATORS) # uncovered
    elif ( # uncovered
        n.type in {syms.typedargslist, syms.arglist} # uncovered
        and n.children # uncovered
        and n.children[-1].type == token.COMMA # uncovered
    ): # uncovered
        if n.type == syms.typedargslist: # uncovered
            feature = Feature.TRAILING_COMMA_IN_DEF # uncovered
        else: # uncovered
            feature = Feature.TRAILING_COMMA_IN_CALL # uncovered
        for ch in n.children: # uncovered
            if ch.type in STARS: # uncovered
                features.add(feature) # uncovered
            if ch.type == syms.argument: # uncovered
                for argch in ch.children: # uncovered
                    if argch.type in STARS: # uncovered
                        features.add(feature) # uncovered
    elif ( # uncovered
        n.type in {syms.return_stmt, syms.yield_expr} # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == syms.testlist_star_expr # uncovered
        and any(child.type == syms.star_expr for child in n.children[1].children) # uncovered
    ): # uncovered
        features.add(Feature.UNPACKING_ON_FLOW) # uncovered
    elif ( # uncovered
        n.type == syms.annassign # uncovered
        and len(n.children) >= 4 # uncovered
        and n.children[3].type == syms.testlist_star_expr # uncovered
    ): # uncovered
        features.add(Feature.ANN_ASSIGN_EXTENDED_RHS) # uncovered
    elif ( # uncovered
        n.type == syms.with_stmt # uncovered
        and len(n.children) > 2 # uncovered
        and n.children[1].type == syms.atom # uncovered
    ): # uncovered
        atom_children = n.children[1].children # uncovered
        if ( # uncovered
            len(atom_children) == 3 # uncovered
            and atom_children[0].type == token.LPAR # uncovered
            and atom_children[1].type == syms.testlist_gexp # uncovered
            and atom_children[2].type == token.RPAR # uncovered
        ): # uncovered
            features.add(Feature.PARENTHESIZED_CONTEXT_MANAGERS) # uncovered
    elif n.type == syms.match_stmt: # uncovered
        features.add(Feature.PATTERN_MATCHING) # uncovered
    elif ( # uncovered
        n.type == syms.except_clause # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == token.STAR # uncovered
    ): # uncovered
        features.add(Feature.EXCEPT_STAR) # uncovered
    elif n.type in {syms.subscriptlist, syms.trailer} and any( # uncovered
        child.type == syms.star_expr for child in n.children # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
    elif ( # uncovered
        n.type == syms.tname_star # uncovered
        and len(n.children) == 3 # uncovered
        and n.children[2].type == syms.star_expr # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
aux = features # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and len(n.value) > 0"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and n.value.isnumeric()"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = MockNode(type=token.SLASH, parent=MockNode(type=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, typ=None, value=None, children=None, parent=None):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return n.type == token.STRING"",
            ""def is_number_token(n):"",
            ""    return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""node = MockNode(typ=syms.decorator, children=[MockNode(), MockNode(typ=token.NAME)])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith('f')"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""class MockNode:"",
            ""    def __init__(self, value='', typ=None, children=None, parent=None):"",
            ""        self.value = value"",
            ""        self.type = typ"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""node = MockNode(value='/', typ=token.SLASH, parent=MockNode(typ=1))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, value='', typ=None, children=None, parent=None):"",
            ""        self.value = value"",
            ""        self.type = typ"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self] if not self.children else [self] + [node for child in self.children for node in child.pre_order()]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and (n.value.startswith('f') or n.value.startswith('F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = MockNode(type=token.SLASH, parent=MockNode(type=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return hasattr(n, 'type') and hasattr(n, 'value') and n.type == token.STRING"",
            ""def is_number_token(n):"",
            ""    return hasattr(n, 'type') and hasattr(n, 'value') and n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""class MockNode:"",
            ""    def __init__(self, type=None, value='', children=None, parent=None):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""node = MockNode(type=token.SLASH, parent=MockNode(type=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, value=None, typ=None, children=None, parent=None):"",
            ""        self.value = value"",
            ""        self.type = typ"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and len(n.value) > 0"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and len(n.value) > 0"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = MockNode('/', typ=token.SLASH, parent=MockNode(typ=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = MockNode(typ=token.SLASH, parent=MockNode(typ=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, value=None, typ=None, children=None, parent=None):"",
            ""        self.value = value"",
            ""        self.type = typ"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = MockNode(type=token.SLASH, parent=MockNode(type=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return hasattr(n, 'type') and n.type == token.STRING"",
            ""def is_number_token(n):"",
            ""    return hasattr(n, 'type') and n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""class MockNode:"",
            ""    def __init__(self, value=None, typ=None, children=None, parent=None):"",
            ""        self.value = value"",
            ""        self.type = typ"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""node = MockNode(type=token.SLASH, parent=MockNode(type=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""class MockNode:"",
            ""    def __init__(self, type_, value=None, children=None, parent=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""node = MockNode(type=token.SLASH, parent=MockNode(type=1))""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and len(n.value) > 0 # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.isnumeric() # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, typ=None, value=None, children=None, parent=None): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return n.type == token.STRING # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return n.type == token.NUMBER # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""node = MockNode(typ=syms.decorator, children=[MockNode(), MockNode(typ=token.NAME)]) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith('f') # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, value='', typ=None, children=None, parent=None): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""node = MockNode(value='/', typ=token.SLASH, parent=MockNode(typ=1)) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, value='', typ=None, children=None, parent=None): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] if not self.children else [self] + [node for child in self.children for node in child.pre_order()] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and (n.value.startswith('f') or n.value.startswith('F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'type') and hasattr(n, 'value') and n.type == token.STRING # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'type') and hasattr(n, 'value') and n.type == token.NUMBER # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, type=None, value='', children=None, parent=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""node = MockNode(type=token.SLASH, parent=MockNode(type=syms.typedargslist)) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, value=None, typ=None, children=None, parent=None): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and len(n.value) > 0 # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and len(n.value) > 0 # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""node = MockNode('/', typ=token.SLASH, parent=MockNode(typ=syms.typedargslist)) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""node = MockNode(typ=token.SLASH, parent=MockNode(typ=syms.typedargslist)) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, value=None, typ=None, children=None, parent=None): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'type') and n.type == token.STRING # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'type') and n.type == token.NUMBER # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, value=None, typ=None, children=None, parent=None): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, type_, value=None, children=None, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover""
        ]
    }
]",3,10036,0.005018,6966,0.010449,0.015467
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return a set of (relatively) new Python features used in this file.
    Currently looking for:
    - f-strings;
    - self-documenting expressions in f-strings (f""{x=}"");
    - underscores in numeric literals;
    - trailing commas after * or ** in function signatures and calls;
    - positional only arguments in function signatures and lambdas;
    - assignment expression;
    - relaxed decorator syntax;
    - usage of __future__ flags (annotations);
    - print / exec statements;
    - parenthesized context managers;
    - match statements;
    - except* clause;
    - variadic generics;
    """"""
features: Set[Feature] = set()
if future_imports: # uncovered
    features |= { # uncovered
        FUTURE_FLAG_TO_FEATURE[future_import] # uncovered
        for future_import in future_imports # uncovered
        if future_import in FUTURE_FLAG_TO_FEATURE # uncovered
    } # uncovered
for n in node.pre_order(): # uncovered
    if is_string_token(n): # uncovered
        value_head = n.value[:2] # uncovered
        if value_head in {'f""', 'F""', ""f'"", ""F'"", ""rf"", ""fr"", ""RF"", ""FR""}: # uncovered
            features.add(Feature.F_STRINGS) # uncovered
            if Feature.DEBUG_F_STRINGS not in features: # uncovered
                for span_beg, span_end in iter_fexpr_spans(n.value): # uncovered
                    if n.value[span_beg : span_end - 1].rstrip().endswith(""=""): # uncovered
                        features.add(Feature.DEBUG_F_STRINGS) # uncovered
                        break # uncovered
    elif is_number_token(n): # uncovered
        if ""_"" in n.value: # uncovered
            features.add(Feature.NUMERIC_UNDERSCORES) # uncovered
    elif n.type == token.SLASH: # uncovered
        if n.parent and n.parent.type in { # uncovered
            syms.typedargslist, # uncovered
            syms.arglist, # uncovered
            syms.varargslist, # uncovered
        }: # uncovered
            features.add(Feature.POS_ONLY_ARGUMENTS) # uncovered
    elif n.type == token.COLONEQUAL: # uncovered
        features.add(Feature.ASSIGNMENT_EXPRESSIONS) # uncovered
    elif n.type == syms.decorator: # uncovered
        if len(n.children) > 1 and not is_simple_decorator_expression( # uncovered
            n.children[1] # uncovered
        ): # uncovered
            features.add(Feature.RELAXED_DECORATORS) # uncovered
    elif ( # uncovered
        n.type in {syms.typedargslist, syms.arglist} # uncovered
        and n.children # uncovered
        and n.children[-1].type == token.COMMA # uncovered
    ): # uncovered
        if n.type == syms.typedargslist: # uncovered
            feature = Feature.TRAILING_COMMA_IN_DEF # uncovered
        else: # uncovered
            feature = Feature.TRAILING_COMMA_IN_CALL # uncovered
        for ch in n.children: # uncovered
            if ch.type in STARS: # uncovered
                features.add(feature) # uncovered
            if ch.type == syms.argument: # uncovered
                for argch in ch.children: # uncovered
                    if argch.type in STARS: # uncovered
                        features.add(feature) # uncovered
    elif ( # uncovered
        n.type in {syms.return_stmt, syms.yield_expr} # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == syms.testlist_star_expr # uncovered
        and any(child.type == syms.star_expr for child in n.children[1].children) # uncovered
    ): # uncovered
        features.add(Feature.UNPACKING_ON_FLOW) # uncovered
    elif ( # uncovered
        n.type == syms.annassign # uncovered
        and len(n.children) >= 4 # uncovered
        and n.children[3].type == syms.testlist_star_expr # uncovered
    ): # uncovered
        features.add(Feature.ANN_ASSIGN_EXTENDED_RHS) # uncovered
    elif ( # uncovered
        n.type == syms.with_stmt # uncovered
        and len(n.children) > 2 # uncovered
        and n.children[1].type == syms.atom # uncovered
    ): # uncovered
        atom_children = n.children[1].children # uncovered
        if ( # uncovered
            len(atom_children) == 3 # uncovered
            and atom_children[0].type == token.LPAR # uncovered
            and atom_children[1].type == syms.testlist_gexp # uncovered
            and atom_children[2].type == token.RPAR # uncovered
        ): # uncovered
            features.add(Feature.PARENTHESIZED_CONTEXT_MANAGERS) # uncovered
    elif n.type == syms.match_stmt: # uncovered
        features.add(Feature.PATTERN_MATCHING) # uncovered
    elif ( # uncovered
        n.type == syms.except_clause # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == token.STAR # uncovered
    ): # uncovered
        features.add(Feature.EXCEPT_STAR) # uncovered
    elif n.type in {syms.subscriptlist, syms.trailer} and any( # uncovered
        child.type == syms.star_expr for child in n.children # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
    elif ( # uncovered
        n.type == syms.tname_star # uncovered
        and len(n.children) == 3 # uncovered
        and n.children[2].type == syms.star_expr # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
aux = features # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}"",
            ""future_imports = ['annotations']"",
            ""class MockNode:"",
            ""    def __init__(self, value='', typ=None, children=None, parent=None):"",
            ""        self.value = value"",
            ""        self.type = typ"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return len(n.children) == 1"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""node = MockNode(typ=token.SLASH, parent=MockNode(typ=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""class MockNode:"",
            ""    def __init__(self, type=None, value='', children=None, parent=None):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""node = MockNode(type=token.SLASH, parent=MockNode(type=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, value=None, typ=None, children=None, parent=None):"",
            ""        self.value = value"",
            ""        self.type = typ"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and len(n.value) > 0"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and len(n.value) > 0"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = MockNode(value='/', typ=token.SLASH, parent=MockNode(typ=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return n.type == token.STRING"",
            ""def is_number_token(n):"",
            ""    return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""class MockNode:"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""node = MockNode(type=token.COLONEQUAL, value='x := 10', parent=None)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, type=None, value='', children=None, parent=None):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = MockNode(typ=token.SLASH, parent=MockNode(typ=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""class MockNode:"",
            ""    def __init__(self, type_=None, value=None, children=None, parent=None):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""node = MockNode(type=token.SLASH, parent=MockNode(type=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, type=None, value=None, children=None, parent=None):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return hasattr(n, 'type') and hasattr(n, 'value') and n.type == token.STRING"",
            ""def is_number_token(n):"",
            ""    return hasattr(n, 'type') and hasattr(n, 'value') and n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""node = MockNode(type=token.SLASH, parent=MockNode(type=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, value='', typ=None, children=None, parent=None):"",
            ""        self.value = value"",
            ""        self.type = typ"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith('f')"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""node = MockNode(value='f\""value\""', typ=token.STRING)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = MockNode(type=token.STRING, value='f\""example\""')""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = MockNode(type=token.STRING, value='f\""example\""')""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, value='', typ=None, children=None, parent=None): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return len(n.children) == 1 # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""node = MockNode(typ=token.SLASH, parent=MockNode(typ=syms.typedargslist)) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, type=None, value='', children=None, parent=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""node = MockNode(type=token.SLASH, parent=MockNode(type=syms.typedargslist)) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, value=None, typ=None, children=None, parent=None): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and len(n.value) > 0 # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and len(n.value) > 0 # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""node = MockNode(value='/', typ=token.SLASH, parent=MockNode(typ=syms.typedargslist)) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return n.type == token.STRING # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return n.type == token.NUMBER # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, type=None, value='', children=None, parent=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, type_=None, value=None, children=None, parent=None): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, type=None, value=None, children=None, parent=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'type') and hasattr(n, 'value') and n.type == token.STRING # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return hasattr(n, 'type') and hasattr(n, 'value') and n.type == token.NUMBER # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""node = MockNode(type=token.SLASH, parent=MockNode(type=syms.typedargslist)) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, value='', typ=None, children=None, parent=None): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith('f') # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""node = MockNode(value='f\""value\""', typ=token.STRING) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover""
        ]
    }
]",3,10065,0.0050325,6920,0.01038,0.0154124999999999
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return a set of (relatively) new Python features used in this file.
    Currently looking for:
    - f-strings;
    - self-documenting expressions in f-strings (f""{x=}"");
    - underscores in numeric literals;
    - trailing commas after * or ** in function signatures and calls;
    - positional only arguments in function signatures and lambdas;
    - assignment expression;
    - relaxed decorator syntax;
    - usage of __future__ flags (annotations);
    - print / exec statements;
    - parenthesized context managers;
    - match statements;
    - except* clause;
    - variadic generics;
    """"""
features: Set[Feature] = set()
if future_imports: # uncovered
    features |= { # uncovered
        FUTURE_FLAG_TO_FEATURE[future_import] # uncovered
        for future_import in future_imports # uncovered
        if future_import in FUTURE_FLAG_TO_FEATURE # uncovered
    } # uncovered
for n in node.pre_order(): # uncovered
    if is_string_token(n): # uncovered
        value_head = n.value[:2] # uncovered
        if value_head in {'f""', 'F""', ""f'"", ""F'"", ""rf"", ""fr"", ""RF"", ""FR""}: # uncovered
            features.add(Feature.F_STRINGS) # uncovered
            if Feature.DEBUG_F_STRINGS not in features: # uncovered
                for span_beg, span_end in iter_fexpr_spans(n.value): # uncovered
                    if n.value[span_beg : span_end - 1].rstrip().endswith(""=""): # uncovered
                        features.add(Feature.DEBUG_F_STRINGS) # uncovered
                        break # uncovered
    elif is_number_token(n): # uncovered
        if ""_"" in n.value: # uncovered
            features.add(Feature.NUMERIC_UNDERSCORES) # uncovered
    elif n.type == token.SLASH: # uncovered
        if n.parent and n.parent.type in { # uncovered
            syms.typedargslist, # uncovered
            syms.arglist, # uncovered
            syms.varargslist, # uncovered
        }: # uncovered
            features.add(Feature.POS_ONLY_ARGUMENTS) # uncovered
    elif n.type == token.COLONEQUAL: # uncovered
        features.add(Feature.ASSIGNMENT_EXPRESSIONS) # uncovered
    elif n.type == syms.decorator: # uncovered
        if len(n.children) > 1 and not is_simple_decorator_expression( # uncovered
            n.children[1] # uncovered
        ): # uncovered
            features.add(Feature.RELAXED_DECORATORS) # uncovered
    elif ( # uncovered
        n.type in {syms.typedargslist, syms.arglist} # uncovered
        and n.children # uncovered
        and n.children[-1].type == token.COMMA # uncovered
    ): # uncovered
        if n.type == syms.typedargslist: # uncovered
            feature = Feature.TRAILING_COMMA_IN_DEF # uncovered
        else: # uncovered
            feature = Feature.TRAILING_COMMA_IN_CALL # uncovered
        for ch in n.children: # uncovered
            if ch.type in STARS: # uncovered
                features.add(feature) # uncovered
            if ch.type == syms.argument: # uncovered
                for argch in ch.children: # uncovered
                    if argch.type in STARS: # uncovered
                        features.add(feature) # uncovered
    elif ( # uncovered
        n.type in {syms.return_stmt, syms.yield_expr} # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == syms.testlist_star_expr # uncovered
        and any(child.type == syms.star_expr for child in n.children[1].children) # uncovered
    ): # uncovered
        features.add(Feature.UNPACKING_ON_FLOW) # uncovered
    elif ( # uncovered
        n.type == syms.annassign # uncovered
        and len(n.children) >= 4 # uncovered
        and n.children[3].type == syms.testlist_star_expr # uncovered
    ): # uncovered
        features.add(Feature.ANN_ASSIGN_EXTENDED_RHS) # uncovered
    elif ( # uncovered
        n.type == syms.with_stmt # uncovered
        and len(n.children) > 2 # uncovered
        and n.children[1].type == syms.atom # uncovered
    ): # uncovered
        atom_children = n.children[1].children # uncovered
        if ( # uncovered
            len(atom_children) == 3 # uncovered
            and atom_children[0].type == token.LPAR # uncovered
            and atom_children[1].type == syms.testlist_gexp # uncovered
            and atom_children[2].type == token.RPAR # uncovered
        ): # uncovered
            features.add(Feature.PARENTHESIZED_CONTEXT_MANAGERS) # uncovered
    elif n.type == syms.match_stmt: # uncovered
        features.add(Feature.PATTERN_MATCHING) # uncovered
    elif ( # uncovered
        n.type == syms.except_clause # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == token.STAR # uncovered
    ): # uncovered
        features.add(Feature.EXCEPT_STAR) # uncovered
    elif n.type in {syms.subscriptlist, syms.trailer} and any( # uncovered
        child.type == syms.star_expr for child in n.children # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
    elif ( # uncovered
        n.type == syms.tname_star # uncovered
        and len(n.children) == 3 # uncovered
        and n.children[2].type == syms.star_expr # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
aux = features # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = { 'annotations': Feature.RELAXED_DECORATORS }"",
            ""future_imports = { 'annotations' }"",
            ""class MockNode:"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and len(n.value) > 0"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and len(n.value) > 0"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = { token.STAR }"",
            ""node = MockNode(type=token.SLASH, parent=MockNode(type=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = MockNode(typ=token.SLASH, parent=MockNode(typ=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, type=None, value='', children=None, parent=None):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return n.type == token.STRING"",
            ""def is_number_token(n):"",
            ""    return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = MockNode(type=token.SLASH, parent=MockNode(type=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, type=None, value='', children=None, parent=None):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self] + [child for c in self.children for child in c.pre_order()]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.type == token.STRING"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""node = MockNode(type=token.SLASH, parent=MockNode(type=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith('f')"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = MockNode(type=token.SLASH, parent=MockNode(type=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith('f')"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""node = MockNode(type=token.SLASH, parent=MockNode(type=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and len(n.value) > 0"",
            ""def is_number_token(n):"",
            ""    return False"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = MockNode(typ=token.SLASH, parent=MockNode(typ=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, value='', typ=None, children=None, parent=None):"",
            ""        self.value = value"",
            ""        self.type = typ"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = MockNode(value='/', typ=token.SLASH, parent=MockNode(typ=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, value='', typ=None, children=None, parent=None):"",
            ""        self.value = value"",
            ""        self.type = typ"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""node = MockNode(typ=token.SLASH, parent=MockNode(typ=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""class MockNode:"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""node = MockNode(type=token.SLASH, parent=MockNode(type=syms.typedargslist))""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { 'annotations': Feature.RELAXED_DECORATORS } # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and len(n.value) > 0 # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and len(n.value) > 0 # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = { token.STAR } # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""node = MockNode(typ=token.SLASH, parent=MockNode(typ=syms.typedargslist)) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, type=None, value='', children=None, parent=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return n.type == token.STRING # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return n.type == token.NUMBER # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""node = MockNode(type=token.SLASH, parent=MockNode(type=syms.typedargslist)) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, type=None, value='', children=None, parent=None): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] + [child for c in self.children for child in c.pre_order()] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.type == token.STRING # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.type == token.NUMBER # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""node = MockNode(type=token.SLASH, parent=MockNode(type=syms.typedargslist)) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.RELAXED_DECORATORS} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith('f') # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith('f') # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and len(n.value) > 0 # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""node = MockNode(typ=token.SLASH, parent=MockNode(typ=syms.typedargslist)) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, value='', typ=None, children=None, parent=None): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""node = MockNode(value='/', typ=token.SLASH, parent=MockNode(typ=syms.typedargslist)) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, value='', typ=None, children=None, parent=None): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""node = MockNode(typ=token.SLASH, parent=MockNode(typ=syms.typedargslist)) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover""
        ]
    }
]",3,10019,0.0050095,6771,0.0101565,0.015166
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return a set of (relatively) new Python features used in this file.
    Currently looking for:
    - f-strings;
    - self-documenting expressions in f-strings (f""{x=}"");
    - underscores in numeric literals;
    - trailing commas after * or ** in function signatures and calls;
    - positional only arguments in function signatures and lambdas;
    - assignment expression;
    - relaxed decorator syntax;
    - usage of __future__ flags (annotations);
    - print / exec statements;
    - parenthesized context managers;
    - match statements;
    - except* clause;
    - variadic generics;
    """"""
features: Set[Feature] = set()
if future_imports: # uncovered
    features |= { # uncovered
        FUTURE_FLAG_TO_FEATURE[future_import] # uncovered
        for future_import in future_imports # uncovered
        if future_import in FUTURE_FLAG_TO_FEATURE # uncovered
    } # uncovered
for n in node.pre_order(): # uncovered
    if is_string_token(n): # uncovered
        value_head = n.value[:2] # uncovered
        if value_head in {'f""', 'F""', ""f'"", ""F'"", ""rf"", ""fr"", ""RF"", ""FR""}: # uncovered
            features.add(Feature.F_STRINGS) # uncovered
            if Feature.DEBUG_F_STRINGS not in features: # uncovered
                for span_beg, span_end in iter_fexpr_spans(n.value): # uncovered
                    if n.value[span_beg : span_end - 1].rstrip().endswith(""=""): # uncovered
                        features.add(Feature.DEBUG_F_STRINGS) # uncovered
                        break # uncovered
    elif is_number_token(n): # uncovered
        if ""_"" in n.value: # uncovered
            features.add(Feature.NUMERIC_UNDERSCORES) # uncovered
    elif n.type == token.SLASH: # uncovered
        if n.parent and n.parent.type in { # uncovered
            syms.typedargslist, # uncovered
            syms.arglist, # uncovered
            syms.varargslist, # uncovered
        }: # uncovered
            features.add(Feature.POS_ONLY_ARGUMENTS) # uncovered
    elif n.type == token.COLONEQUAL: # uncovered
        features.add(Feature.ASSIGNMENT_EXPRESSIONS) # uncovered
    elif n.type == syms.decorator: # uncovered
        if len(n.children) > 1 and not is_simple_decorator_expression( # uncovered
            n.children[1] # uncovered
        ): # uncovered
            features.add(Feature.RELAXED_DECORATORS) # uncovered
    elif ( # uncovered
        n.type in {syms.typedargslist, syms.arglist} # uncovered
        and n.children # uncovered
        and n.children[-1].type == token.COMMA # uncovered
    ): # uncovered
        if n.type == syms.typedargslist: # uncovered
            feature = Feature.TRAILING_COMMA_IN_DEF # uncovered
        else: # uncovered
            feature = Feature.TRAILING_COMMA_IN_CALL # uncovered
        for ch in n.children: # uncovered
            if ch.type in STARS: # uncovered
                features.add(feature) # uncovered
            if ch.type == syms.argument: # uncovered
                for argch in ch.children: # uncovered
                    if argch.type in STARS: # uncovered
                        features.add(feature) # uncovered
    elif ( # uncovered
        n.type in {syms.return_stmt, syms.yield_expr} # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == syms.testlist_star_expr # uncovered
        and any(child.type == syms.star_expr for child in n.children[1].children) # uncovered
    ): # uncovered
        features.add(Feature.UNPACKING_ON_FLOW) # uncovered
    elif ( # uncovered
        n.type == syms.annassign # uncovered
        and len(n.children) >= 4 # uncovered
        and n.children[3].type == syms.testlist_star_expr # uncovered
    ): # uncovered
        features.add(Feature.ANN_ASSIGN_EXTENDED_RHS) # uncovered
    elif ( # uncovered
        n.type == syms.with_stmt # uncovered
        and len(n.children) > 2 # uncovered
        and n.children[1].type == syms.atom # uncovered
    ): # uncovered
        atom_children = n.children[1].children # uncovered
        if ( # uncovered
            len(atom_children) == 3 # uncovered
            and atom_children[0].type == token.LPAR # uncovered
            and atom_children[1].type == syms.testlist_gexp # uncovered
            and atom_children[2].type == token.RPAR # uncovered
        ): # uncovered
            features.add(Feature.PARENTHESIZED_CONTEXT_MANAGERS) # uncovered
    elif n.type == syms.match_stmt: # uncovered
        features.add(Feature.PATTERN_MATCHING) # uncovered
    elif ( # uncovered
        n.type == syms.except_clause # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == token.STAR # uncovered
    ): # uncovered
        features.add(Feature.EXCEPT_STAR) # uncovered
    elif n.type in {syms.subscriptlist, syms.trailer} and any( # uncovered
        child.type == syms.star_expr for child in n.children # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
    elif ( # uncovered
        n.type == syms.tname_star # uncovered
        and len(n.children) == 3 # uncovered
        and n.children[2].type == syms.star_expr # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
aux = features # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""class MockNode:"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""node = MockNode(typ=token.SLASH, parent=MockNode(typ=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, value='', typ=None, children=None, parent=None):"",
            ""        self.value = value"",
            ""        self.type = typ"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith('f')"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""node = MockNode(value='/', typ=token.SLASH, parent=MockNode(typ=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self] + [child for c in self.children for child in c.pre_order()]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""node = MockNode(type=token.SLASH, parent=MockNode(type=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self] + [child for c in self.children for child in c.pre_order()]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.type == token.STRING"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = MockNode(typ=token.SLASH, parent=MockNode(typ=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""class MockNode:"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self] + [child for c in self.children for child in c.pre_order()]"",
            ""node = MockNode("",
            ""    typ=syms.decorator,"",
            ""    children=[MockNode(), MockNode('complex', '')]"",
            "")""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""class MockNode:"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""node = MockNode(type=token.SLASH, parent=MockNode(type=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self] + [descendant for child in self.children for descendant in child.pre_order()]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""node = MockNode(typ=token.SLASH, parent=MockNode(typ=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum, auto"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and len(n.value) > 0"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and len(n.value) > 0"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR}"",
            ""node = MockNode(type=token.SLASH, parent=MockNode(type=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.RELAXED_DECORATORS"",
            ""}"",
            ""future_imports = {'annotations'}"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""class MockNode:"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""node = MockNode(type=token.SLASH, parent=MockNode(type=syms.typedargslist))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum, auto""
        ],
        ""initialization"": [
            ""class Feature(Enum):"",
            ""    F_STRINGS = auto()"",
            ""    DEBUG_F_STRINGS = auto()"",
            ""    NUMERIC_UNDERSCORES = auto()"",
            ""    POS_ONLY_ARGUMENTS = auto()"",
            ""    ASSIGNMENT_EXPRESSIONS = auto()"",
            ""    RELAXED_DECORATORS = auto()"",
            ""    TRAILING_COMMA_IN_DEF = auto()"",
            ""    TRAILING_COMMA_IN_CALL = auto()"",
            ""    UNPACKING_ON_FLOW = auto()"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto()"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto()"",
            ""    PATTERN_MATCHING = auto()"",
            ""    EXCEPT_STAR = auto()"",
            ""    VARIADIC_GENERICS = auto()"",
            ""FUTURE_FLAG_TO_FEATURE = { 'annotations': Feature.RELAXED_DECORATORS }"",
            ""future_imports = {'annotations'}"",
            ""class MockNode:"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.children = children if children else []"",
            ""        self.parent = parent"",
            ""    def pre_order(self):"",
            ""        return [self]"",
            ""def is_string_token(n):"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):"",
            ""    return isinstance(n.value, str) and '_' in n.value"",
            ""def iter_fexpr_spans(value):"",
            ""    yield (0, len(value))"",
            ""def is_simple_decorator_expression(n):"",
            ""    return False"",
            ""syms = type('syms', (object,), {"",
            ""    'typedargslist': 1,"",
            ""    'arglist': 2,"",
            ""    'varargslist': 3,"",
            ""    'decorator': 4,"",
            ""    'return_stmt': 5,"",
            ""    'yield_expr': 6,"",
            ""    'testlist_star_expr': 7,"",
            ""    'star_expr': 8,"",
            ""    'annassign': 9,"",
            ""    'with_stmt': 10,"",
            ""    'atom': 11,"",
            ""    'testlist_gexp': 12,"",
            ""    'match_stmt': 13,"",
            ""    'except_clause': 14,"",
            ""    'subscriptlist': 15,"",
            ""    'trailer': 16,"",
            ""    'tname_star': 17,"",
            ""    'argument': 18"",
            ""})"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""node = MockNode(type=token.SLASH, parent=MockNode(type=syms.typedargslist))""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""node = MockNode(typ=token.SLASH, parent=MockNode(typ=syms.typedargslist)) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, value='', typ=None, children=None, parent=None): # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith('f') # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""node = MockNode(value='/', typ=token.SLASH, parent=MockNode(typ=syms.typedargslist)) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] + [child for c in self.children for child in c.pre_order()] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] + [child for c in self.children for child in c.pre_order()] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.type == token.STRING # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.type == token.NUMBER # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""node = MockNode(typ=token.SLASH, parent=MockNode(typ=syms.typedargslist)) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] + [child for c in self.children for child in c.pre_order()] # pragma: no cover"",
            ""node = MockNode( # pragma: no cover"",
            ""    typ=syms.decorator, # pragma: no cover"",
            ""    children=[MockNode(), MockNode('complex', '')] # pragma: no cover"",
            "") # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] + [descendant for child in self.children for descendant in child.pre_order()] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""node = MockNode(typ=token.SLASH, parent=MockNode(typ=syms.typedargslist)) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and len(n.value) > 0 # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and len(n.value) > 0 # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.RELAXED_DECORATORS # pragma: no cover"",
            ""} # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum, auto # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum): # pragma: no cover"",
            ""    F_STRINGS = auto() # pragma: no cover"",
            ""    DEBUG_F_STRINGS = auto() # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = auto() # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = auto() # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = auto() # pragma: no cover"",
            ""    RELAXED_DECORATORS = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = auto() # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = auto() # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = auto() # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = auto() # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = auto() # pragma: no cover"",
            ""    PATTERN_MATCHING = auto() # pragma: no cover"",
            ""    EXCEPT_STAR = auto() # pragma: no cover"",
            ""    VARIADIC_GENERICS = auto() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { 'annotations': Feature.RELAXED_DECORATORS } # pragma: no cover"",
            ""class MockNode: # pragma: no cover"",
            ""    def __init__(self, typ=None, value='', children=None, parent=None): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.children = children if children else [] # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""    def pre_order(self): # pragma: no cover"",
            ""        return [self] # pragma: no cover"",
            ""def is_string_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n): # pragma: no cover"",
            ""    return isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def iter_fexpr_spans(value): # pragma: no cover"",
            ""    yield (0, len(value)) # pragma: no cover"",
            ""def is_simple_decorator_expression(n): # pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""syms = type('syms', (object,), { # pragma: no cover"",
            ""    'typedargslist': 1, # pragma: no cover"",
            ""    'arglist': 2, # pragma: no cover"",
            ""    'varargslist': 3, # pragma: no cover"",
            ""    'decorator': 4, # pragma: no cover"",
            ""    'return_stmt': 5, # pragma: no cover"",
            ""    'yield_expr': 6, # pragma: no cover"",
            ""    'testlist_star_expr': 7, # pragma: no cover"",
            ""    'star_expr': 8, # pragma: no cover"",
            ""    'annassign': 9, # pragma: no cover"",
            ""    'with_stmt': 10, # pragma: no cover"",
            ""    'atom': 11, # pragma: no cover"",
            ""    'testlist_gexp': 12, # pragma: no cover"",
            ""    'match_stmt': 13, # pragma: no cover"",
            ""    'except_clause': 14, # pragma: no cover"",
            ""    'subscriptlist': 15, # pragma: no cover"",
            ""    'trailer': 16, # pragma: no cover"",
            ""    'tname_star': 17, # pragma: no cover"",
            ""    'argument': 18 # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover""
        ]
    }
]",3,9870,0.004935,7055,0.0105825,0.0155175
