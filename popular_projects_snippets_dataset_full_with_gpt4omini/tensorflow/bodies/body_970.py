# Extracted from ./data/repos/tensorflow/tensorflow/compiler/tests/unary_ops_test.py
for dtype in self.complex_types:

    self._assertOpOutputMatchesExpected(
        math_ops.acosh,
        np.array([0.1, 0.2j, 0.3 - 0.1j, 0.4 + 0.5j], dtype=dtype),
        expected=np.arccosh(
            np.array([0.1, 0.2j, 0.3 - 0.1j, 0.4 + 0.5j], dtype=dtype)))

    self._assertOpOutputMatchesExpected(
        math_ops.asinh,
        np.array([0.1, 0.2j, 0.3 - 0.1j, 0.4 + 0.5j], dtype=dtype),
        expected=np.arcsinh(
            np.array([0.1, 0.2j, 0.3 - 0.1j, 0.4 + 0.5j], dtype=dtype)))

    self._assertOpOutputMatchesExpected(
        math_ops.atanh,
        np.array([0.1, 0.2j, 0.3 - 0.1j, 0.4 + 0.5j], dtype=dtype),
        expected=np.arctanh(
            np.array([0.1, 0.2j, 0.3 - 0.1j, 0.4 + 0.5j], dtype=dtype)))

    self._assertOpOutputMatchesExpected(
        math_ops.cosh,
        np.array([1j, 2 - 3j, 3, 4 + 2j], dtype=dtype),
        expected=np.cosh(np.array([1j, 2 - 3j, 3, 4 + 2j], dtype=dtype)))

    self._assertOpOutputMatchesExpected(
        math_ops.sinh,
        np.array([1, 2j, 2 - 3j, 4 + 5j], dtype=dtype),
        expected=np.sinh(np.array([1, 2j, 2 - 3j, 4 + 5j], dtype=dtype)))

    self._assertOpOutputMatchesExpected(
        math_ops.exp,
        np.array([[-1 + 2j, 3j, 2 - 3j]], dtype=dtype),
        expected=np.exp(np.array([[-1 + 2j, 3j, 2 - 3j]], dtype=dtype)))

    self._assertOpOutputMatchesExpected(
        math_ops.expm1,
        np.array([[-1 + 2j, 3j, 2 - 3j]], dtype=dtype),
        expected=np.expm1(np.array([[-1 + 2j, 3j, 2 - 3j]], dtype=dtype)),
        rtol=1e-6,
        atol=1e-6)

    # For real part close to zero, or imaginary part close to a multiple of
    # pi.

    self._assertOpOutputMatchesExpected(
        math_ops.expm1,
        np.array([[1e-11 + 1j, -1e-11 - 1j, 1. + 1e-11j,
                   -1. - 1e-11j, 1e-13j + 1e-13j]], dtype=dtype),
        # TODO(srvasude): Use numpy as the source of truth after we depend on
        # latest numpy with this pull request:
        # https://github.com/numpy/numpy/pull/15110.
        # The numbers below were generated by scipy.special.expm1.
        expected=np.array([[
            -4.59697694e-01+8.41470985e-01j,
            -4.59697694e-01-8.41470985e-01j,
            1.71828183e+00+2.71828183e-11j,
            -6.32120559e-01-3.67879441e-12j,
            -2.00000000e-26+2.00000000e-13j]], dtype=dtype),
        rtol=1e-09,
        atol=1e-20)

    self._assertOpOutputMatchesExpected(
        math_ops.reciprocal,
        np.array([[1, 2j, 2 + 3j]], dtype=dtype),
        expected=1.0 / np.array([[1, 2j, 2 + 3j]], dtype=dtype))

    self._assertOpOutputMatchesExpected(
        math_ops.log,
        np.array([[5j, 3 - 2j]], dtype=dtype),
        expected=np.log(np.array([[5j, 3 - 2j]], dtype=dtype)))

    self._assertOpOutputMatchesExpected(
        math_ops.sin,
        np.array([[5j, 3 - 2j]], dtype=dtype),
        expected=np.sin(np.array([[5j, 3 - 2j]], dtype=dtype)))

    self._assertOpOutputMatchesExpected(
        math_ops.cos,
        np.array([[5j, 3 - 2j]], dtype=dtype),
        expected=np.cos(np.array([[5j, 3 - 2j]], dtype=dtype)))

    self._assertOpOutputMatchesExpected(
        math_ops.log1p,
        np.array([[1e-14, 1e-15j, 0.6 - 0.3j]], dtype=dtype),
        expected=np.log1p(
            np.array([[1e-14, 1e-15j, 0.6 - 0.3j]], dtype=dtype)),
        rtol=1e-4,
        atol=1e-6)

    val = np.array([1, 2j, 2 - 3j, 4 + 5j], dtype=dtype)
    self._assertOpOutputMatchesExpected(
        math_ops.rsqrt, val, expected=1 / np.sqrt(val))

    self._assertOpOutputMatchesExpected(
        math_ops.sigmoid, val, expected=1 / (1 + np.exp(-val)))

    self._assertOpOutputMatchesExpected(
        math_ops.sqrt, val, expected=np.sqrt(val))

    self._assertOpOutputMatchesExpected(
        math_ops.tanh,
        np.array([1, 2j, 2 - 3j, 4 + 5j], dtype=dtype),
        expected=np.tanh(np.array([1, 2j, 2 - 3j, 4 + 5j], dtype=dtype)))

    self._assertOpOutputMatchesExpected(
        math_ops.tan,
        np.array([1, 2j, 2 - 3j, 4 + 5j], dtype=dtype),
        expected=np.tan(np.array([1, 2j, 2 - 3j, 4 + 5j], dtype=dtype)))

    ctypes = {np.complex64: np.float32, np.complex128: np.float64}
    self._assertOpOutputMatchesExpected(
        math_ops.abs,
        np.array([[3 - 4j, -1j, np.inf]], dtype=dtype),
        expected=np.array([[5, 1, np.inf]], dtype=ctypes[dtype]))

    self._assertOpOutputMatchesExpected(
        math_ops.negative,
        np.array([[-1 + 2j, -3j]], dtype=dtype),
        expected=np.array([[1 - 2j, 3j]], dtype=dtype))

    self._assertOpOutputMatchesExpected(
        math_ops.square,
        np.array([[-2 - 3j, 3 + 4j, 5j]], dtype=dtype),
        expected=np.array([[-2 - 3j, 3 + 4j, 5j]], dtype=dtype)**2)

    self._assertOpOutputMatchesExpected(
        array_ops.zeros_like,
        np.array([[4j, 3 - 2j], [2, -1j]], dtype=dtype),
        expected=np.array([[0, 0], [0, 0]], dtype=dtype))

    self._assertOpOutputMatchesExpected(
        array_ops.ones_like,
        np.array([[-4j, 3 + 2j], [2, -1j]], dtype=dtype),
        expected=np.array([[1, 1], [1, 1]], dtype=dtype))

    self._assertOpOutputMatchesExpected(
        math_ops.angle,
        np.array([1 + 3j, -4 + 7j, 2.7, -3j], dtype=dtype),
        expected=np.angle(np.array([1 + 3j, -4 + 7j, 2.7, -3j], dtype=dtype)))

    self._assertOpOutputMatchesExpected(
        math_ops.conj,
        np.array([1 + 3j, -4 + 7j, 2.7, -3j], dtype=dtype),
        expected=np.array([1 - 3j, -4 - 7j, 2.7, 3j], dtype=dtype))

    self._assertOpOutputMatchesExpected(
        math_ops.imag,
        np.array([1 + 3j, -4 + 7j, 2.7, -3j], dtype=dtype),
        expected=np.array([3, 7, 0, -3], dtype=ctypes[dtype]))

    self._assertOpOutputMatchesExpected(
        math_ops.real,
        np.array([1 + 3j, -4 + 7j, 2.7, -3j], dtype=dtype),
        expected=np.array([1, -4, 2.7, 0], dtype=ctypes[dtype]))
