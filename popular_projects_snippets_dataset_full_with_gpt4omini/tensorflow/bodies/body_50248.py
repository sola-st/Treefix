# Extracted from ./data/repos/tensorflow/tensorflow/python/keras/saving/saved_model/load.py
"""Runs the final steps of loading Keras Layers from SavedModel."""
# pylint: disable=protected-access
# 1. Set up call functions for all layers initialized from the SavedModel (
# and not the config)
for layer in layers:
    layer.built = True
    layer_call = getattr(_get_keras_attr(layer),
                         'call_and_return_conditional_losses', None)
    if layer_call and layer_call.concrete_functions:
        layer.call = utils.use_wrapped_call(
            layer, layer_call, return_method=True)
        expects_training_arg = layer._serialized_attributes['metadata'][
            'expects_training_arg']
        if 'training' in layer_call.function_spec.arg_names:
            # This could change the value of `expects_training_arg` if this layer
            # doesn't expect a training arg, but has a child layer that does.
            expects_training_arg = True
        layer._init_call_fn_args(expects_training_arg)
    else:
        layer.call = types.MethodType(
            _unable_to_call_layer_due_to_serialization_issue, layer)

for layer in layers:
    # 2. Set model inputs and outputs.
    if isinstance(layer, RevivedNetwork):
        _set_network_attributes_from_metadata(layer)

        if hasattr(_get_keras_attr(layer), 'call_and_return_conditional_losses'):
            call_fn = _get_keras_attr(layer).call_and_return_conditional_losses
            if not call_fn.concrete_functions:
                continue
            if call_fn.input_signature is None:
                inputs = infer_inputs_from_restored_call_function(call_fn)
            else:
                inputs = call_fn.input_signature[0]
            layer._set_inputs(inputs)  # pylint: disable=protected-access

    # 3. Add losses that aren't generated by the layer.call function.
    _restore_layer_unconditional_losses(layer)
    _restore_layer_activation_loss(layer)

    # 4. Restore metrics list
    _restore_layer_metrics(layer)
