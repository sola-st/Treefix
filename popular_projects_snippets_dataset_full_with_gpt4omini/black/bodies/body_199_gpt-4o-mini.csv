prompt,raw_predictions,predictions,prompt_type,input_size,input_price,output_size,output_price,total_price
"Provide self-contained and concrete Python values to initialize the undefined variables in the code snippet.

# begin code snippet
""""""Return a set of (relatively) new Python features used in this file.

    Currently looking for:
    - f-strings;
    - self-documenting expressions in f-strings (f""{x=}"");
    - underscores in numeric literals;
    - trailing commas after * or ** in function signatures and calls;
    - positional only arguments in function signatures and lambdas;
    - assignment expression;
    - relaxed decorator syntax;
    - usage of __future__ flags (annotations);
    - print / exec statements;
    - parenthesized context managers;
    - match statements;
    - except* clause;
    - variadic generics;
    """"""
features: Set[Feature] = set()
if future_imports:
    features |= {
        FUTURE_FLAG_TO_FEATURE[future_import]
        for future_import in future_imports
        if future_import in FUTURE_FLAG_TO_FEATURE
    }

for n in node.pre_order():
    if is_string_token(n):
        value_head = n.value[:2]
        if value_head in {'f""', 'F""', ""f'"", ""F'"", ""rf"", ""fr"", ""RF"", ""FR""}:
            features.add(Feature.F_STRINGS)
            if Feature.DEBUG_F_STRINGS not in features:
                for span_beg, span_end in iter_fexpr_spans(n.value):
                    if n.value[span_beg : span_end - 1].rstrip().endswith(""=""):
                        features.add(Feature.DEBUG_F_STRINGS)
                        break

    elif is_number_token(n):
        if ""_"" in n.value:
            features.add(Feature.NUMERIC_UNDERSCORES)

    elif n.type == token.SLASH:
        if n.parent and n.parent.type in {
            syms.typedargslist,
            syms.arglist,
            syms.varargslist,
        }:
            features.add(Feature.POS_ONLY_ARGUMENTS)

    elif n.type == token.COLONEQUAL:
        features.add(Feature.ASSIGNMENT_EXPRESSIONS)

    elif n.type == syms.decorator:
        if len(n.children) > 1 and not is_simple_decorator_expression(
            n.children[1]
        ):
            features.add(Feature.RELAXED_DECORATORS)

    elif (
        n.type in {syms.typedargslist, syms.arglist}
        and n.children
        and n.children[-1].type == token.COMMA
    ):
        if n.type == syms.typedargslist:
            feature = Feature.TRAILING_COMMA_IN_DEF
        else:
            feature = Feature.TRAILING_COMMA_IN_CALL

        for ch in n.children:
            if ch.type in STARS:
                features.add(feature)

            if ch.type == syms.argument:
                for argch in ch.children:
                    if argch.type in STARS:
                        features.add(feature)

    elif (
        n.type in {syms.return_stmt, syms.yield_expr}
        and len(n.children) >= 2
        and n.children[1].type == syms.testlist_star_expr
        and any(child.type == syms.star_expr for child in n.children[1].children)
    ):
        features.add(Feature.UNPACKING_ON_FLOW)

    elif (
        n.type == syms.annassign
        and len(n.children) >= 4
        and n.children[3].type == syms.testlist_star_expr
    ):
        features.add(Feature.ANN_ASSIGN_EXTENDED_RHS)

    elif (
        n.type == syms.with_stmt
        and len(n.children) > 2
        and n.children[1].type == syms.atom
    ):
        atom_children = n.children[1].children
        if (
            len(atom_children) == 3
            and atom_children[0].type == token.LPAR
            and atom_children[1].type == syms.testlist_gexp
            and atom_children[2].type == token.RPAR
        ):
            features.add(Feature.PARENTHESIZED_CONTEXT_MANAGERS)

    elif n.type == syms.match_stmt:
        features.add(Feature.PATTERN_MATCHING)

    elif (
        n.type == syms.except_clause
        and len(n.children) >= 2
        and n.children[1].type == token.STAR
    ):
        features.add(Feature.EXCEPT_STAR)

    elif n.type in {syms.subscriptlist, syms.trailer} and any(
        child.type == syms.star_expr for child in n.children
    ):
        features.add(Feature.VARIADIC_GENERICS)

    elif (
        n.type == syms.tname_star
        and len(n.children) == 3
        and n.children[2].type == syms.star_expr
    ):
        features.add(Feature.VARIADIC_GENERICS)

exit(features)

# end code snippet

# begin undefined variables
Set
Feature
future_imports
node
is_string_token
iter_fexpr_spans
is_number_token
token
syms
is_simple_decorator_expression
STARS
FUTURE_FLAG_TO_FEATURE
# end undefined variables

# begin undefined attributes and methods
node.pre_order
Feature.F_STRINGS
Feature.DEBUG_F_STRINGS
Feature.NUMERIC_UNDERSCORES
token.SLASH
syms.typedargslist
syms.arglist
syms.varargslist
Feature.POS_ONLY_ARGUMENTS
token.COLONEQUAL
Feature.ASSIGNMENT_EXPRESSIONS
syms.decorator
Feature.RELAXED_DECORATORS
token.COMMA
Feature.TRAILING_COMMA_IN_DEF
Feature.TRAILING_COMMA_IN_CALL
syms.argument
syms.return_stmt
syms.yield_expr
syms.testlist_star_expr
syms.star_expr
Feature.UNPACKING_ON_FLOW
syms.annassign
Feature.ANN_ASSIGN_EXTENDED_RHS
syms.with_stmt
syms.atom
token.LPAR
syms.testlist_gexp
token.RPAR
Feature.PARENTHESIZED_CONTEXT_MANAGERS
syms.match_stmt
Feature.PATTERN_MATCHING
syms.except_clause
token.STAR
Feature.EXCEPT_STAR
syms.subscriptlist
syms.trailer
Feature.VARIADIC_GENERICS
syms.tname_star
# end undefined attributes and methods

Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token"",
            ""import typing.sygments as syms""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return isinstance(n, str)"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""def is_number_token(n):\n    return isinstance(n, (int, float, str)) and '_' in n if isinstance(n, str) else False"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""STARS = [token.STAR]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'F_STRINGS'\n    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'\n    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'\n    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'\n    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'\n    RELAXED_DECORATORS = 'RELAXED_DECORATORS'\n    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'\n    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'\n    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'\n    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'\n    PATTERN_MATCHING = 'PATTERN_MATCHING'\n    EXCEPT_STAR = 'EXCEPT_STAR'\n    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""def is_number_token(n):\n    return hasattr(n, 'value') and n.value.isdigit()"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""STARS = [token.STAR, token.SLASH]"",
            ""is_simple_decorator_expression = lambda n: True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import sys"",
            ""from functools import singledispatch""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n): return isinstance(n, str)"",
            ""def is_number_token(n): return isinstance(n, (int, float))"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""is_simple_decorator_expression = lambda n: False"",
            ""STARS = [token.STAR]"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from anytree import Node""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'positional_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics';"",
            ""future_imports = []"",
            ""node = Node('/example')"",
            ""def is_string_token(n): return isinstance(n, str)"",
            ""def iter_fexpr_spans(value): return [(i, value.find('}', i) + 1) for i in range(len(value)) if value[i] == '{']"",
            ""def is_number_token(n): return isinstance(n, (int, float))"",
            ""class MockNode: def pre_order(self): return [\""f'example {x=}'\"", 42, token.SLASH]  # mock pre_order method"",
            ""node = MockNode()"",
            ""STARS = [token.STAR]"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any"",
            ""import token"",
            ""import grammar as syms""
        ],
        ""initialization"": [
            ""Feature = type('Feature', (), { 'F_STRINGS': 'f_strings', 'DEBUG_F_STRINGS': 'debug_f_strings', 'NUMERIC_UNDERSCORES': 'numeric_underscores', 'POS_ONLY_ARGUMENTS': 'pos_only_arguments', 'ASSIGNMENT_EXPRESSIONS': 'assignment_expressions', 'RELAXED_DECORATORS': 'relaxed_decorators', 'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call', 'UNPACKING_ON_FLOW': 'unpacking_on_flow', 'ANN_ASSIGN_EXTENDED_RHS': 'ann_assign_extended_rhs', 'PARENTHESIZED_CONTEXT_MANAGERS': 'parenthesized_context_managers', 'PATTERN_MATCHING': 'pattern_matching', 'EXCEPT_STAR': 'except_star', 'VARIADIC_GENERICS': 'variadic_generics' })"",
            ""future_imports = []"",
            ""node = type('MockNode', (), { 'pre_order': lambda self: [] })()"",
            ""is_string_token = lambda n: isinstance(n, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, (int, float))"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import pytest"",
            ""from unittest.mock import Mock""
        ],
        ""initialization"": [
            ""Feature = Mock()"",
            ""future_imports = []"",
            ""node = Mock(pre_order=Mock(return_value=[]))"",
            ""is_string_token = Mock(return_value=False)"",
            ""iter_fexpr_spans = Mock(return_value=[])"",
            ""is_number_token = Mock(return_value=False)"",
            ""syms = Mock()"",
            ""is_simple_decorator_expression = Mock(return_value=False)"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import sys"",
            ""from collections import namedtuple""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'f-strings'; DEBUG_F_STRINGS = 'debug-f-strings'; NUMERIC_UNDERSCORES = 'numeric-underscores'; POS_ONLY_ARGUMENTS = 'positional-only-arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment-expressions'; RELAXED_DECORATORS = 'relaxed-decorators'; TRAILING_COMMA_IN_DEF = 'trailing-comma-in-def'; TRAILING_COMMA_IN_CALL = 'trailing-comma-in-call'; UNPACKING_ON_FLOW = 'unpacking-on-flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann-assign-extended-rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized-context-managers'; PATTERN_MATCHING = 'pattern-matching'; EXCEPT_STAR = 'except-star'; VARIADIC_GENERICS = 'variadic-generics'"",
            ""future_imports = []"",
            ""node = type('Node', (object,), {'pre_order': lambda self: []})()"",
            ""is_string_token = lambda n: n.type == token.STRING"",
            ""def iter_fexpr_spans(value): return [(i, value.index('}', i) + 1) for i, char in enumerate(value) if char == '{']"",
            ""is_number_token = lambda n: n.type == token.NUMBER"",
            ""syms = sys.modules[__name__]; syms.typedargslist = 'typedargslist'; syms.arglist = 'arglist'; syms.varargslist = 'varargslist'; syms.return_stmt = 'return_stmt'; syms.yield_expr = 'yield_expr'; syms.testlist_star_expr = 'testlist_star_expr'; syms.star_expr = 'star_expr'; syms.decorator = 'decorator'; syms.argument = 'argument'; syms.with_stmt = 'with_stmt'; syms.atom = 'atom'; syms.match_stmt = 'match_stmt'; syms.except_clause = 'except_clause'; syms.subscriptlist = 'subscriptlist'; syms.trailer = 'trailer'; syms.tname_star = 'tname_star'"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {'*', '**'}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.UNPACKING_ON_FLOW}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms"",
            ""from unittest.mock import MagicMock""
        ],
        ""initialization"": [
            ""Feature = type('Feature', (), {"",
            ""    'F_STRINGS': 'f_strings',"",
            ""    'DEBUG_F_STRINGS': 'debug_f_strings',"",
            ""    'NUMERIC_UNDERSCORES': 'numeric_underscores',"",
            ""    'POS_ONLY_ARGUMENTS': 'pos_only_arguments',"",
            ""    'ASSIGNMENT_EXPRESSIONS': 'assignment_expressions',"",
            ""    'RELAXED_DECORATORS': 'relaxed_decorators',"",
            ""    'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def',"",
            ""    'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call',"",
            ""    'UNPACKING_ON_FLOW': 'unpacking_on_flow',"",
            ""    'ANN_ASSIGN_EXTENDED_RHS': 'ann_assign_extended_rhs',"",
            ""    'PARENTHESIZED_CONTEXT_MANAGERS': 'parenthesized_context_managers',"",
            ""    'PATTERN_MATCHING': 'pattern_matching',"",
            ""    'EXCEPT_STAR': 'except_star',"",
            ""    'VARIADIC_GENERICS': 'variadic_generics',"",
            ""})"",
            ""future_imports = []"",
            ""node = MagicMock()"",
            ""node.pre_order.return_value = []"",
            ""is_string_token = lambda n: isinstance(n, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, (int, float))"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': Feature.NUMERIC_UNDERSCORES"",
            ""}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict"",
            ""import token"",
            ""import syms"",
            ""from unittest.mock import MagicMock""
        ],
        ""initialization"": [
            ""Feature = type('Feature', (), { 'F_STRINGS': 'f_strings', 'DEBUG_F_STRINGS': 'debug_f_strings', 'NUMERIC_UNDERSCORES': 'numeric_underscores', 'POS_ONLY_ARGUMENTS': 'pos_only_arguments', 'ASSIGNMENT_EXPRESSIONS': 'assignment_expressions', 'RELAXED_DECORATORS': 'relaxed_decorators', 'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call', 'UNPACKING_ON_FLOW': 'unpacking_on_flow', 'ANN_ASSIGN_EXTENDED_RHS': 'ann_assign_extended_rhs', 'PARENTHESIZED_CONTEXT_MANAGERS': 'parenthesized_context_managers', 'PATTERN_MATCHING': 'pattern_matching', 'EXCEPT_STAR': 'except_star', 'VARIADIC_GENERICS': 'variadic_generics' })"",
            ""future_imports = []"",
            ""node = MagicMock()"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] if 'f' in value else []"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.isdigit()"",
            ""STARS = [token.STAR]"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Callable, Any"",
            ""import token"",
            ""from anytree import Node"",
            ""from dataclasses import dataclass""
        ],
        ""initialization"": [
            ""Feature = type('Feature', (), {"",
            ""    'F_STRINGS': 'f-strings',"",
            ""    'DEBUG_F_STRINGS': 'debug f-strings',"",
            ""    'NUMERIC_UNDERSCORES': 'numeric underscores',"",
            ""    'POS_ONLY_ARGUMENTS': 'positional only arguments',"",
            ""    'ASSIGNMENT_EXPRESSIONS': 'assignment expressions',"",
            ""    'RELAXED_DECORATORS': 'relaxed decorators',"",
            ""    'TRAILING_COMMA_IN_DEF': 'trailing comma in definition',"",
            ""    'TRAILING_COMMA_IN_CALL': 'trailing comma in call',"",
            ""    'UNPACKING_ON_FLOW': 'unpacking on flow',"",
            ""    'ANN_ASSIGN_EXTENDED_RHS': 'annotation assign extended rhs',"",
            ""    'PARENTHESIZED_CONTEXT_MANAGERS': 'parenthesized context managers',"",
            ""    'PATTERN_MATCHING': 'pattern matching',"",
            ""    'EXCEPT_STAR': 'except star',"",
            ""    'VARIADIC_GENERICS': 'variadic generics',"",
            ""    'DEBUGGING': 'debugging' "",
            ""})"",
            ""future_imports = []"",
            ""node = Node('root')"",
            ""def is_string_token(n): return isinstance(n, str)"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""def is_number_token(n): return isinstance(n, (int, float))"",
            ""STARS = {token.STAR, token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.DEBUGGING}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return isinstance(n, (int, float, str)) and '_' in n if isinstance(n, str) else False # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'# pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return hasattr(n, 'value') and n.value.isdigit() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""STARS = [token.STAR, token.SLASH] # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from functools import singledispatch # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, str) # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, (int, float)) # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(0, len(value))] # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: False # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from anytree import Node # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'positional_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; # pragma: no cover"",
            ""node = Node('/example') # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(i, value.find('}', i) + 1) for i in range(len(value)) if value[i] == '{'] # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, (int, float)) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import grammar as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = type('Feature', (), { 'F_STRINGS': 'f_strings', 'DEBUG_F_STRINGS': 'debug_f_strings', 'NUMERIC_UNDERSCORES': 'numeric_underscores', 'POS_ONLY_ARGUMENTS': 'pos_only_arguments', 'ASSIGNMENT_EXPRESSIONS': 'assignment_expressions', 'RELAXED_DECORATORS': 'relaxed_decorators', 'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call', 'UNPACKING_ON_FLOW': 'unpacking_on_flow', 'ANN_ASSIGN_EXTENDED_RHS': 'ann_assign_extended_rhs', 'PARENTHESIZED_CONTEXT_MANAGERS': 'parenthesized_context_managers', 'PATTERN_MATCHING': 'pattern_matching', 'EXCEPT_STAR': 'except_star', 'VARIADIC_GENERICS': 'variadic_generics' }) # pragma: no cover"",
            ""node = type('MockNode', (), { 'pre_order': lambda self: [] })() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float)) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import pytest # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = Mock() # pragma: no cover"",
            ""node = Mock(pre_order=Mock(return_value=[])) # pragma: no cover"",
            ""is_string_token = Mock(return_value=False) # pragma: no cover"",
            ""iter_fexpr_spans = Mock(return_value=[]) # pragma: no cover"",
            ""is_number_token = Mock(return_value=False) # pragma: no cover"",
            ""syms = Mock() # pragma: no cover"",
            ""is_simple_decorator_expression = Mock(return_value=False) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'f-strings'; DEBUG_F_STRINGS = 'debug-f-strings'; NUMERIC_UNDERSCORES = 'numeric-underscores'; POS_ONLY_ARGUMENTS = 'positional-only-arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment-expressions'; RELAXED_DECORATORS = 'relaxed-decorators'; TRAILING_COMMA_IN_DEF = 'trailing-comma-in-def'; TRAILING_COMMA_IN_CALL = 'trailing-comma-in-call'; UNPACKING_ON_FLOW = 'unpacking-on-flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann-assign-extended-rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized-context-managers'; PATTERN_MATCHING = 'pattern-matching'; EXCEPT_STAR = 'except-star'; VARIADIC_GENERICS = 'variadic-generics' # pragma: no cover"",
            ""node = type('Node', (object,), {'pre_order': lambda self: []})() # pragma: no cover"",
            ""is_string_token = lambda n: n.type == token.STRING # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(i, value.index('}', i) + 1) for i, char in enumerate(value) if char == '{'] # pragma: no cover"",
            ""is_number_token = lambda n: n.type == token.NUMBER # pragma: no cover"",
            ""syms = sys.modules[__name__]; syms.typedargslist = 'typedargslist'; syms.arglist = 'arglist'; syms.varargslist = 'varargslist'; syms.return_stmt = 'return_stmt'; syms.yield_expr = 'yield_expr'; syms.testlist_star_expr = 'testlist_star_expr'; syms.star_expr = 'star_expr'; syms.decorator = 'decorator'; syms.argument = 'argument'; syms.with_stmt = 'with_stmt'; syms.atom = 'atom'; syms.match_stmt = 'match_stmt'; syms.except_clause = 'except_clause'; syms.subscriptlist = 'subscriptlist'; syms.trailer = 'trailer'; syms.tname_star = 'tname_star' # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {'*', '**'} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.UNPACKING_ON_FLOW} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from unittest.mock import MagicMock # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = type('Feature', (), { # pragma: no cover"",
            ""    'F_STRINGS': 'f_strings', # pragma: no cover"",
            ""    'DEBUG_F_STRINGS': 'debug_f_strings', # pragma: no cover"",
            ""    'NUMERIC_UNDERSCORES': 'numeric_underscores', # pragma: no cover"",
            ""    'POS_ONLY_ARGUMENTS': 'pos_only_arguments', # pragma: no cover"",
            ""    'ASSIGNMENT_EXPRESSIONS': 'assignment_expressions', # pragma: no cover"",
            ""    'RELAXED_DECORATORS': 'relaxed_decorators', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call', # pragma: no cover"",
            ""    'UNPACKING_ON_FLOW': 'unpacking_on_flow', # pragma: no cover"",
            ""    'ANN_ASSIGN_EXTENDED_RHS': 'ann_assign_extended_rhs', # pragma: no cover"",
            ""    'PARENTHESIZED_CONTEXT_MANAGERS': 'parenthesized_context_managers', # pragma: no cover"",
            ""    'PATTERN_MATCHING': 'pattern_matching', # pragma: no cover"",
            ""    'EXCEPT_STAR': 'except_star', # pragma: no cover"",
            ""    'VARIADIC_GENERICS': 'variadic_generics', # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""node = MagicMock() # pragma: no cover"",
            ""node.pre_order.return_value = [] # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float)) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': Feature.NUMERIC_UNDERSCORES # pragma: no cover"",
            ""} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from unittest.mock import MagicMock # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = type('Feature', (), { 'F_STRINGS': 'f_strings', 'DEBUG_F_STRINGS': 'debug_f_strings', 'NUMERIC_UNDERSCORES': 'numeric_underscores', 'POS_ONLY_ARGUMENTS': 'pos_only_arguments', 'ASSIGNMENT_EXPRESSIONS': 'assignment_expressions', 'RELAXED_DECORATORS': 'relaxed_decorators', 'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call', 'UNPACKING_ON_FLOW': 'unpacking_on_flow', 'ANN_ASSIGN_EXTENDED_RHS': 'ann_assign_extended_rhs', 'PARENTHESIZED_CONTEXT_MANAGERS': 'parenthesized_context_managers', 'PATTERN_MATCHING': 'pattern_matching', 'EXCEPT_STAR': 'except_star', 'VARIADIC_GENERICS': 'variadic_generics' }) # pragma: no cover"",
            ""node = MagicMock() # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] if 'f' in value else [] # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.isdigit() # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Callable, Any # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from anytree import Node # pragma: no cover"",
            ""from dataclasses import dataclass # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = type('Feature', (), { # pragma: no cover"",
            ""    'F_STRINGS': 'f-strings', # pragma: no cover"",
            ""    'DEBUG_F_STRINGS': 'debug f-strings', # pragma: no cover"",
            ""    'NUMERIC_UNDERSCORES': 'numeric underscores', # pragma: no cover"",
            ""    'POS_ONLY_ARGUMENTS': 'positional only arguments', # pragma: no cover"",
            ""    'ASSIGNMENT_EXPRESSIONS': 'assignment expressions', # pragma: no cover"",
            ""    'RELAXED_DECORATORS': 'relaxed decorators', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'trailing comma in definition', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'trailing comma in call', # pragma: no cover"",
            ""    'UNPACKING_ON_FLOW': 'unpacking on flow', # pragma: no cover"",
            ""    'ANN_ASSIGN_EXTENDED_RHS': 'annotation assign extended rhs', # pragma: no cover"",
            ""    'PARENTHESIZED_CONTEXT_MANAGERS': 'parenthesized context managers', # pragma: no cover"",
            ""    'PATTERN_MATCHING': 'pattern matching', # pragma: no cover"",
            ""    'EXCEPT_STAR': 'except star', # pragma: no cover"",
            ""    'VARIADIC_GENERICS': 'variadic generics', # pragma: no cover"",
            ""    'DEBUGGING': 'debugging'  # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""node = Node('root') # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, (int, float)) # pragma: no cover"",
            ""STARS = {token.STAR, token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.DEBUGGING} # pragma: no cover""
        ]
    }
]",1,1572,0.000786,3774,0.005661,0.006447
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 53:
    if future_imports:
NameError: name 'future_imports' is not defined
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token"",
            ""import typing.sygments as syms""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return isinstance(n, str) and n.startswith(('f', 'F'))"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""def is_number_token(n):\n    return isinstance(n, str) and '_' in n"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""STARS = [token.STAR]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token"",
            ""import typing.sygments as syms""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return isinstance(n, str)"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""def is_number_token(n):\n    return isinstance(n, str) and '_' in n"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""STARS = [token.STAR]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token"",
            ""import typing.sygments as syms""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return isinstance(n, str) and n.startswith(('f', 'F'))"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))] if 'f' in value else []"",
            ""def is_number_token(n):\n    return isinstance(n, (int, float, str)) and '_' in n if isinstance(n, str) else False"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""STARS = [token.STAR]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token"",
            ""import typing.sygments as syms""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return isinstance(n, str)"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""def is_number_token(n):\n    return isinstance(n, (int, float, str)) and '_' in n if isinstance(n, str) else False"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""STARS = [token.STAR]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token"",
            ""import typing.sygments as syms""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return isinstance(n, str) and n.startswith(('f', 'F'))"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""def is_number_token(n):\n    return isinstance(n, (int, float, str)) and '_' in n if isinstance(n, str) else False"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""STARS = [token.STAR]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token"",
            ""import typing.sygments as syms""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return isinstance(n, str) and n.startswith(('f', 'F', 'r', 'R'))"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""def is_number_token(n):\n    return isinstance(n, str) and '_' in n"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""STARS = [token.STAR]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token"",
            ""import typing.sygments as syms""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return isinstance(n, str)"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""def is_number_token(n):\n    return isinstance(n, (int, float, str)) and '_' in n if isinstance(n, str) else False"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""STARS = [token.STAR]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token"",
            ""import typing.sygments as syms""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return isinstance(n, str) and n.startswith(('f', 'F'))"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""def is_number_token(n):\n    return isinstance(n, str) and '_' in n"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""STARS = [token.STAR]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token"",
            ""import typing.sygments as syms""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return isinstance(n, str) and n.startswith(('f', 'F'))"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""def is_number_token(n):\n    return isinstance(n, str) and '_' in n"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""STARS = [token.STAR]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""from enum import Enum"",
            ""import token"",
            ""import typing.sygments as syms""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 1\n    DEBUG_F_STRINGS = 2\n    NUMERIC_UNDERSCORES = 3\n    POS_ONLY_ARGUMENTS = 4\n    ASSIGNMENT_EXPRESSIONS = 5\n    RELAXED_DECORATORS = 6\n    TRAILING_COMMA_IN_DEF = 7\n    TRAILING_COMMA_IN_CALL = 8\n    UNPACKING_ON_FLOW = 9\n    ANN_ASSIGN_EXTENDED_RHS = 10\n    PARENTHESIZED_CONTEXT_MANAGERS = 11\n    PATTERN_MATCHING = 12\n    EXCEPT_STAR = 13\n    VARIADIC_GENERICS = 14"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return isinstance(n, str) and (n.startswith('f') or n.startswith('F'))"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""def is_number_token(n):\n    return isinstance(n, str) and '_' in n"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""STARS = [token.STAR]""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) and n.startswith(('f', 'F')) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) and '_' in n # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) and '_' in n # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) and n.startswith(('f', 'F')) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] if 'f' in value else [] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return isinstance(n, (int, float, str)) and '_' in n if isinstance(n, str) else False # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return isinstance(n, (int, float, str)) and '_' in n if isinstance(n, str) else False # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) and n.startswith(('f', 'F')) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return isinstance(n, (int, float, str)) and '_' in n if isinstance(n, str) else False # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) and n.startswith(('f', 'F', 'r', 'R')) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) and '_' in n # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return isinstance(n, (int, float, str)) and '_' in n if isinstance(n, str) else False # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) and n.startswith(('f', 'F')) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) and '_' in n # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) and n.startswith(('f', 'F')) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) and '_' in n # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 1# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 2# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 3# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 4# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 5# pragma: no cover"",
            ""    RELAXED_DECORATORS = 6# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 7# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 8# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 9# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 10# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 11# pragma: no cover"",
            ""    PATTERN_MATCHING = 12# pragma: no cover"",
            ""    EXCEPT_STAR = 13# pragma: no cover"",
            ""    VARIADIC_GENERICS = 14 # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) and (n.startswith('f') or n.startswith('F')) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) and '_' in n # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover""
        ]
    }
]",2,2198,0.001099,3351,0.0050265,0.0061255
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 53:
    if future_imports:
NameError: name 'future_imports' is not defined
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'F_STRINGS'\n    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'\n    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'\n    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'\n    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'\n    RELAXED_DECORATORS = 'RELAXED_DECORATORS'\n    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'\n    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'\n    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'\n    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'\n    PATTERN_MATCHING = 'PATTERN_MATCHING'\n    EXCEPT_STAR = 'EXCEPT_STAR'\n    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""def is_number_token(n):\n    return hasattr(n, 'value') and ('_' in n.value if isinstance(n.value, str) else False)"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""STARS = [token.STAR]"",
            ""is_simple_decorator_expression = lambda n: True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import typing.sygments as syms""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'F_STRINGS'\n    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'\n    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'\n    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'\n    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'\n    RELAXED_DECORATORS = 'RELAXED_DECORATORS'\n    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'\n    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'\n    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'\n    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'\n    PATTERN_MATCHING = 'PATTERN_MATCHING'\n    EXCEPT_STAR = 'EXCEPT_STAR'\n    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return isinstance(n, str) and n.startswith('f')"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""def is_number_token(n):\n    return isinstance(n, str) and '_' in n"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""STARS = [token.STAR]"",
            ""is_simple_decorator_expression = lambda n: True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'F_STRINGS'\n    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'\n    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'\n    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'\n    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'\n    RELAXED_DECORATORS = 'RELAXED_DECORATORS'\n    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'\n    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'\n    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'\n    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'\n    PATTERN_MATCHING = 'PATTERN_MATCHING'\n    EXCEPT_STAR = 'EXCEPT_STAR'\n    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""def is_number_token(n):\n    return hasattr(n, 'value') and (n.value.isdigit() or '_' in n.value)"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""STARS = [token.STAR]"",
            ""is_simple_decorator_expression = lambda n: True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'F_STRINGS'\n    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'\n    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'\n    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'\n    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'\n    RELAXED_DECORATORS = 'RELAXED_DECORATORS'\n    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'\n    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'\n    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'\n    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'\n    PATTERN_MATCHING = 'PATTERN_MATCHING'\n    EXCEPT_STAR = 'EXCEPT_STAR'\n    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return [{ 'value': 'f\""Hello, World!\""' }, { 'value': '1000' }, { 'type': token.SLASH }, { 'type': syms.typedargslist, 'children': [] }]  \n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""def is_number_token(n):\n    return hasattr(n, 'value') and isinstance(n.value, str) and '_' in n.value"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""STARS = [token.STAR]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'F_STRINGS'\n    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'\n    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'\n    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'\n    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'\n    RELAXED_DECORATORS = 'RELAXED_DECORATORS'\n    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'\n    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'\n    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'\n    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'\n    PATTERN_MATCHING = 'PATTERN_MATCHING'\n    EXCEPT_STAR = 'EXCEPT_STAR'\n    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""def is_number_token(n):\n    return hasattr(n, 'value') and ('_' in n.value if isinstance(n.value, str) else n.value.isdigit())"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""STARS = [token.STAR, token.SLASH]"",
            ""is_simple_decorator_expression = lambda n: True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'F_STRINGS'\n    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'\n    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'\n    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'\n    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'\n    RELAXED_DECORATORS = 'RELAXED_DECORATORS'\n    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'\n    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'\n    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'\n    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'\n    PATTERN_MATCHING = 'PATTERN_MATCHING'\n    EXCEPT_STAR = 'EXCEPT_STAR'\n    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""def is_number_token(n):\n    return hasattr(n, 'value') and (n.value.isdigit() or '_' in n.value)"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""STARS = [token.STAR, token.SLASH]"",
            ""is_simple_decorator_expression = lambda n: True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'F_STRINGS'\n    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'\n    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'\n    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'\n    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'\n    RELAXED_DECORATORS = 'RELAXED_DECORATORS'\n    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'\n    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'\n    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'\n    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'\n    PATTERN_MATCHING = 'PATTERN_MATCHING'\n    EXCEPT_STAR = 'EXCEPT_STAR'\n    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""def is_number_token(n):\n    return hasattr(n, 'value') and (isinstance(n.value, int) or isinstance(n.value, float) or '_' in n.value)"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""STARS = [token.STAR]"",
            ""is_simple_decorator_expression = lambda n: True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import typing.sygments as syms""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'F_STRINGS'\n    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'\n    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'\n    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'\n    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'\n    RELAXED_DECORATORS = 'RELAXED_DECORATORS'\n    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'\n    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'\n    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'\n    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'\n    PATTERN_MATCHING = 'PATTERN_MATCHING'\n    EXCEPT_STAR = 'EXCEPT_STAR'\n    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""def is_number_token(n):\n    return hasattr(n, 'value') and isinstance(n.value, str) and '_' in n.value"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""STARS = [token.STAR]"",
            ""is_simple_decorator_expression = lambda n: True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'F_STRINGS'\n    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'\n    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'\n    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'\n    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'\n    RELAXED_DECORATORS = 'RELAXED_DECORATORS'\n    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'\n    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'\n    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'\n    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'\n    PATTERN_MATCHING = 'PATTERN_MATCHING'\n    EXCEPT_STAR = 'EXCEPT_STAR'\n    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return isinstance(n, str) and (n.startswith('f') or n.startswith('F'))"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""def is_number_token(n):\n    return isinstance(n, str) and '_' in n"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""STARS = [token.STAR, token.SLASH]"",
            ""is_simple_decorator_expression = lambda n: True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'F_STRINGS'\n    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'\n    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'\n    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'\n    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'\n    RELAXED_DECORATORS = 'RELAXED_DECORATORS'\n    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'\n    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'\n    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'\n    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'\n    PATTERN_MATCHING = 'PATTERN_MATCHING'\n    EXCEPT_STAR = 'EXCEPT_STAR'\n    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""def is_number_token(n):\n    return hasattr(n, 'value') and isinstance(n.value, str) and '_' in n.value"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""STARS = [token.STAR]""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'# pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return hasattr(n, 'value') and ('_' in n.value if isinstance(n.value, str) else False) # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'# pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) and n.startswith('f') # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) and '_' in n # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'# pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return hasattr(n, 'value') and (n.value.isdigit() or '_' in n.value) # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'# pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [{ 'value': 'f\""Hello, World!\""' }, { 'value': '1000' }, { 'type': token.SLASH }, { 'type': syms.typedargslist, 'children': [] }]  # pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'# pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return hasattr(n, 'value') and ('_' in n.value if isinstance(n.value, str) else n.value.isdigit()) # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""STARS = [token.STAR, token.SLASH] # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'# pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return hasattr(n, 'value') and (n.value.isdigit() or '_' in n.value) # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""STARS = [token.STAR, token.SLASH] # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'# pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return hasattr(n, 'value') and (isinstance(n.value, int) or isinstance(n.value, float) or '_' in n.value) # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'# pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'# pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) and (n.startswith('f') or n.startswith('F')) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) and '_' in n # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""STARS = [token.STAR, token.SLASH] # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'# pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover""
        ]
    }
]",2,2902,0.001451,4183,0.0062745,0.0077255
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 52:
    if future_imports:
NameError: name 'future_imports' is not defined
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n): return isinstance(n, str)"",
            ""def is_number_token(n): return isinstance(n, str) and n.isdigit()"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = [1]"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'F_STRINGS'\n    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'\n    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'\n    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'\n    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'\n    RELAXED_DECORATORS = 'RELAXED_DECORATORS'\n    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'\n    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'\n    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'\n    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'\n    PATTERN_MATCHING = 'PATTERN_MATCHING'\n    EXCEPT_STAR = 'EXCEPT_STAR'\n    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return hasattr(n, 'value') and n.value.startswith(('f', 'F'))"",
            ""def is_number_token(n):\n    return isinstance(n, str) and all(c.isdigit() or c == '_' for c in n)\n"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}"",
            ""STARS = [None, None]"",
            ""is_simple_decorator_expression = lambda n: True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n): return isinstance(n, str)"",
            ""def is_number_token(n): return isinstance(n, (int, float)) or (isinstance(n, str) and '_' in n)"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""is_simple_decorator_expression = lambda n: False"",
            ""STARS = [0, 1]"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n): return isinstance(n, str) and n.startswith('f')"",
            ""def is_number_token(n): return isinstance(n, str) and '_' in n"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""STARS = [None]"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}"",
            ""is_simple_decorator_expression = lambda n: True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'F_STRINGS'\n    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'\n    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'\n    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'\n    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'\n    RELAXED_DECORATORS = 'RELAXED_DECORATORS'\n    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'\n    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'\n    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'\n    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'\n    PATTERN_MATCHING = 'PATTERN_MATCHING'\n    EXCEPT_STAR = 'EXCEPT_STAR'\n    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def is_number_token(n):\n    return hasattr(n, 'value') and (isinstance(n.value, int) or isinstance(n.value, float))"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}"",
            ""STARS = [token.STAR, token.SLASH]"",
            ""is_simple_decorator_expression = lambda n: True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, List"",
            ""import token"",
            ""import types""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'F_STRINGS'\n    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'\n    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'\n    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'\n    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'\n    RELAXED_DECORATORS = 'RELAXED_DECORATORS'\n    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'\n    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'\n    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'\n    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'\n    PATTERN_MATCHING = 'PATTERN_MATCHING'\n    EXCEPT_STAR = 'EXCEPT_STAR'\n    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n): return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def is_number_token(n): return hasattr(n, 'value') and (isinstance(n.value, int) or isinstance(n.value, float))"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""is_simple_decorator_expression = lambda n: False"",
            ""STARS = [token.STAR]"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n): return isinstance(n, str)"",
            ""def is_number_token(n): return isinstance(n, (int, float, str)) and (isinstance(n, str) and '_' in n or isinstance(n, int) or isinstance(n, float))"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = [token.STAR]"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports: List[str] = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n): return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def is_number_token(n): return hasattr(n, 'value') and isinstance(n.value, (int, float, str)) and '_' in n.value if isinstance(n.value, str) else False"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""is_simple_decorator_expression = lambda n: False"",
            ""STARS: List[int] = [token.STAR]"",
            ""FUTURE_FLAG_TO_FEATURE: Dict[str, Feature] = {'annotations': Feature.F_STRINGS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'F_STRINGS'\n    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'\n    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'\n    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'\n    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'\n    RELAXED_DECORATORS = 'RELAXED_DECORATORS'\n    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'\n    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'\n    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'\n    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'\n    PATTERN_MATCHING = 'PATTERN_MATCHING'\n    EXCEPT_STAR = 'EXCEPT_STAR'\n    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = ['annotations']"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n): return isinstance(n, str)"",
            ""def is_number_token(n): return isinstance(n, (int, float, str)) and isinstance(n, str) and '_' in n"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""is_simple_decorator_expression = lambda n: False"",
            ""STARS = [token.STAR]"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'F_STRINGS'\n    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'\n    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'\n    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'\n    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'\n    RELAXED_DECORATORS = 'RELAXED_DECORATORS'\n    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'\n    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'\n    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'\n    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'\n    PATTERN_MATCHING = 'PATTERN_MATCHING'\n    EXCEPT_STAR = 'EXCEPT_STAR'\n    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n): return isinstance(n, str)"",
            ""def is_number_token(n): return isinstance(n, str) and n.isdigit()"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""is_simple_decorator_expression = lambda n: False"",
            ""STARS = [1]"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, str) # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, str) and n.isdigit() # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(0, len(value))] # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = [1] # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'# pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return hasattr(n, 'value') and n.value.startswith(('f', 'F')) # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) and all(c.isdigit() or c == '_' for c in n)# pragma: no cover"",
            "" # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover"",
            ""STARS = [None, None] # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, str) # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, (int, float)) or (isinstance(n, str) and '_' in n) # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(0, len(value))] # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: False # pragma: no cover"",
            ""STARS = [0, 1] # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, str) and n.startswith('f') # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, str) and '_' in n # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(0, len(value))] # pragma: no cover"",
            ""STARS = [None] # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'# pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return hasattr(n, 'value') and (isinstance(n.value, int) or isinstance(n.value, float)) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, List # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import types # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'# pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n): return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def is_number_token(n): return hasattr(n, 'value') and (isinstance(n.value, int) or isinstance(n.value, float)) # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(0, len(value))] # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: False # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, str) # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, (int, float, str)) and (isinstance(n, str) and '_' in n or isinstance(n, int) or isinstance(n, float)) # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(0, len(value))] # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n): return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def is_number_token(n): return hasattr(n, 'value') and isinstance(n.value, (int, float, str)) and '_' in n.value if isinstance(n.value, str) else False # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(0, len(value))] # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: False # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE: Dict[str, Feature] = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'# pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, str) # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, (int, float, str)) and isinstance(n, str) and '_' in n # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(0, len(value))] # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: False # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'# pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, str) # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, str) and n.isdigit() # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(0, len(value))] # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: False # pragma: no cover"",
            ""STARS = [1] # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    }
]",2,3571,0.0017855,3939,0.0059085,0.0076939999999999
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 30:
    if future_imports:
NameError: name 'future_imports' is not defined
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'F_STRINGS'\n    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'\n    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'\n    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'\n    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'\n    RELAXED_DECORATORS = 'RELAXED_DECORATORS'\n    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'\n    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'\n    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'\n    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'\n    PATTERN_MATCHING = 'PATTERN_MATCHING'\n    EXCEPT_STAR = 'EXCEPT_STAR'\n    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return [ast.Constant(value='f\""Hello, {x=}\""'), ast.Constant(value='123_456'), token.SLASH, ast.Constant(value='x')]  # example nodes"",
            ""node = MockNode()"",
            ""def is_string_token(n): return isinstance(n, ast.Constant) and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]  # simplified span logic for testing"",
            ""def is_number_token(n): return isinstance(n, ast.Constant) and isinstance(n.value, (int, float, str)) and '_' in str(n.value)"",
            ""STARS = [token.STAR]"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}"",
            ""is_simple_decorator_expression = lambda n: False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import sys"",
            ""from unittest.mock import MagicMock""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return [MagicMock(value='f\""example {x=}\""'), MagicMock(value='123_456'), token.SLASH]\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))] if '{' in value and '}' in value else []"",
            ""def is_number_token(n):\n    return hasattr(n, 'value') and isinstance(n.value, str) and '_' in n.value"",
            ""def is_simple_decorator_expression(n):\n    return isinstance(n, str) and n.startswith('@')"",
            ""STARS = [token.STAR, token.SLASH]"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return [\""f'example {x=}'\"", 42, token.SLASH, 3.14]"",
            ""node = MockNode()"",
            ""def is_string_token(n):\n    return isinstance(n, str)"",
            ""def iter_fexpr_spans(value):\n    return [(i, j) for i, j in ((0, len(value)),) if '{' in value[i:j]]"",
            ""def is_number_token(n):\n    return isinstance(n, (int, float)) or (isinstance(n, str) and '_' in n)"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}"",
            ""STARS = [token.STAR]"",
            ""is_simple_decorator_expression = lambda n: False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return [\""f'example text {x=}'\"", 1234, token.SLASH, 'num_1_000', token.COLONEQUAL, token.STAR]"",
            ""node = MockNode()"",
            ""def is_string_token(n): return isinstance(n, str)"",
            ""def iter_fexpr_spans(value): return [(i, value.find('}', i) + 1) for i in range(len(value)) if value[i] == '{']"",
            ""def is_number_token(n): return isinstance(n, str) and '_' in n"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}"",
            ""STARS = [token.STAR]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return [\n            'f\""example {x=}\""',\n            '123_456',\n            token.SLASH,\n            token.COLONEQUAL,\n            (None,),\n            {'a': 1, 'b': 2},\n            'with statement',\n            'match statement',\n        ]\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return isinstance(n, str)"",
            ""def iter_fexpr_spans(value):\n    return [(i, value.index('}', i) + 1) for i in range(len(value)) if value[i] == '{']"",
            ""def is_number_token(n):\n    return isinstance(n, str) and '_' in n"",
            ""STARS = [token.STAR]"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}"",
            ""is_simple_decorator_expression = lambda n: True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from collections import namedtuple""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""MockNode = namedtuple('MockNode', ['type', 'value', 'children', 'parent'])"",
            ""def create_mock_node(value, node_type='string', children=None, parent=None):\n    if children is None:\n        children = []\n    return MockNode(node_type, value, children, parent)"",
            ""node = create_mock_node('f\\\""example {x=}\\\\', node_type='string')"",
            ""def is_string_token(n): return n.type == 'string'"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""def is_number_token(n): return isinstance(n, (int, float))"",
            ""STARS = [token.STAR]"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from enum import Enum""
        ],
        ""initialization"": [
            ""class Feature(Enum):\n    F_STRINGS = 'F_STRINGS'\n    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'\n    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'\n    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'\n    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'\n    RELAXED_DECORATORS = 'RELAXED_DECORATORS'\n    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'\n    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'\n    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'\n    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'\n    PATTERN_MATCHING = 'PATTERN_MATCHING'\n    EXCEPT_STAR = 'EXCEPT_STAR'\n    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return [MockStringToken('f\""Hello {x=}\""'), MockNumberToken('123_456'), MockToken(token.SLASH)]\n\nnode = MockNode()"",
            ""class MockStringToken:\n    def __init__(self, value):\n        self.value = value\n\nclass MockNumberToken:\n    def __init__(self, value):\n        self.value = value\n\nclass MockToken:\n    def __init__(self, type):\n        self.type = type"",
            ""def is_string_token(n): return isinstance(n, MockStringToken)"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]  # Placeholder implementation"",
            ""def is_number_token(n): return isinstance(n, MockNumberToken)"",
            ""STARS = [token.STAR]"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict"",
            ""import token"",
            ""from types import SimpleNamespace""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'F_STRINGS'\n    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'\n    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'\n    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'\n    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'\n    RELAXED_DECORATORS = 'RELAXED_DECORATORS'\n    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'\n    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'\n    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'\n    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'\n    PATTERN_MATCHING = 'PATTERN_MATCHING'\n    EXCEPT_STAR = 'EXCEPT_STAR'\n    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return [SimpleNamespace(value=\""f'example {x=}\""), SimpleNamespace(value='123_456'), SimpleNamespace(type=token.SLASH, parent=None)]\n\nnode = MockNode()"",
            ""def is_string_token(n): return isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str)"",
            ""def iter_fexpr_spans(value): return [(i, value.find('}', i) + 1) for i in range(len(value)) if value[i] == '{']"",
            ""def is_number_token(n): return isinstance(n, SimpleNamespace) and hasattr(n, 'value') and '_' in n.value"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}"",
            ""STARS = [token.STAR]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from collections import defaultdict""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'positional_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return [\""f'example {42}=example_value'\"", 42, token.SLASH]\n\nnode = MockNode()"",
            ""def is_string_token(n): return isinstance(n, str)"",
            ""def iter_fexpr_spans(value): return [(0, len(value))] if isinstance(value, str) else []"",
            ""def is_number_token(n): return isinstance(n, (int, float, str)) and ('_' in n if isinstance(n, str) else False)"",
            ""FUTURE_FLAG_TO_FEATURE = defaultdict(lambda: None, {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS})"",
            ""STARS = [token.STAR]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return [\n            'f\""Hello, {name=}\""',\n            '42',\n            token.SLASH\n        ]\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return isinstance(n, str)"",
            ""def iter_fexpr_spans(value):\n    return [(value.index('{'), value.index('}')+1)] if '{' in value and '}' in value else []"",
            ""def is_number_token(n):\n    return isinstance(n, (int, float)) or (isinstance(n, str) and '_' in n)"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}"",
            ""STARS = [token.STAR, token.SLASH]"",
            ""is_simple_decorator_expression = lambda n: True""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'# pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [ast.Constant(value='f\""Hello, {x=}\""'), ast.Constant(value='123_456'), token.SLASH, ast.Constant(value='x')]  # example nodes # pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, ast.Constant) and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]  # simplified span logic for testing # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, ast.Constant) and isinstance(n.value, (int, float, str)) and '_' in str(n.value) # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from unittest.mock import MagicMock # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [MagicMock(value='f\""example {x=}\""'), MagicMock(value='123_456'), token.SLASH]# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] if '{' in value and '}' in value else [] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return hasattr(n, 'value') and isinstance(n.value, str) and '_' in n.value # pragma: no cover"",
            ""def is_simple_decorator_expression(n):# pragma: no cover"",
            ""    return isinstance(n, str) and n.startswith('@') # pragma: no cover"",
            ""STARS = [token.STAR, token.SLASH] # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [\""f'example {x=}'\"", 42, token.SLASH, 3.14] # pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(i, j) for i, j in ((0, len(value)),) if '{' in value[i:j]] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return isinstance(n, (int, float)) or (isinstance(n, str) and '_' in n) # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [\""f'example text {x=}'\"", 1234, token.SLASH, 'num_1_000', token.COLONEQUAL, token.STAR] # pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(i, value.find('}', i) + 1) for i in range(len(value)) if value[i] == '{'] # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, str) and '_' in n # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [# pragma: no cover"",
            ""            'f\""example {x=}\""',# pragma: no cover"",
            ""            '123_456',# pragma: no cover"",
            ""            token.SLASH,# pragma: no cover"",
            ""            token.COLONEQUAL,# pragma: no cover"",
            ""            (None,),# pragma: no cover"",
            ""            {'a': 1, 'b': 2},# pragma: no cover"",
            ""            'with statement',# pragma: no cover"",
            ""            'match statement',# pragma: no cover"",
            ""        ]# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(i, value.index('}', i) + 1) for i in range(len(value)) if value[i] == '{'] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) and '_' in n # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""MockNode = namedtuple('MockNode', ['type', 'value', 'children', 'parent']) # pragma: no cover"",
            ""def create_mock_node(value, node_type='string', children=None, parent=None):# pragma: no cover"",
            ""    if children is None:# pragma: no cover"",
            ""        children = []# pragma: no cover"",
            ""    return MockNode(node_type, value, children, parent) # pragma: no cover"",
            ""node = create_mock_node('f\\\""example {x=}\\\\', node_type='string') # pragma: no cover"",
            ""def is_string_token(n): return n.type == 'string' # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, (int, float)) # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from enum import Enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature(Enum):# pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'# pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [MockStringToken('f\""Hello {x=}\""'), MockNumberToken('123_456'), MockToken(token.SLASH)]# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""class MockStringToken:# pragma: no cover"",
            ""    def __init__(self, value):# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""# pragma: no cover"",
            ""class MockNumberToken:# pragma: no cover"",
            ""    def __init__(self, value):# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""# pragma: no cover"",
            ""class MockToken:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, MockStringToken) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))]  # Placeholder implementation # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, MockNumberToken) # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from types import SimpleNamespace # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'# pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [SimpleNamespace(value=\""f'example {x=}\""), SimpleNamespace(value='123_456'), SimpleNamespace(type=token.SLASH, parent=None)]# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, SimpleNamespace) and hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(i, value.find('}', i) + 1) for i in range(len(value)) if value[i] == '{'] # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, SimpleNamespace) and hasattr(n, 'value') and '_' in n.value # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from collections import defaultdict # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'positional_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [\""f'example {42}=example_value'\"", 42, token.SLASH]# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(0, len(value))] if isinstance(value, str) else [] # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, (int, float, str)) and ('_' in n if isinstance(n, str) else False) # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = defaultdict(lambda: None, {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}) # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [# pragma: no cover"",
            ""            'f\""Hello, {name=}\""',# pragma: no cover"",
            ""            '42',# pragma: no cover"",
            ""            token.SLASH# pragma: no cover"",
            ""        ]# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(value.index('{'), value.index('}')+1)] if '{' in value and '}' in value else [] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return isinstance(n, (int, float)) or (isinstance(n, str) and '_' in n) # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover"",
            ""STARS = [token.STAR, token.SLASH] # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover""
        ]
    }
]",2,4247,0.0021235,4435,0.0066525,0.008776
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 32:
    if future_imports:
NameError: name 'future_imports' is not defined
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set, Dict, Any"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return [token.SLASH, 'f''example {x=}', '10_000']\n\nnode = MockNode()"",
            ""is_string_token = lambda n: isinstance(n, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, (int, float, str)) and ('_' in n if isinstance(n, str) else False)"",
            ""STARS = [token.STAR]"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.NUMERIC_UNDERSCORES}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any"",
            ""import token"",
            ""import types""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return ['f\""example {x=}\""', 42, token.SLASH]\n\nnode = MockNode()"",
            ""def is_string_token(n): return isinstance(n, str)"",
            ""def iter_fexpr_spans(value): return [(0, len(value))] if 'f' in value else []"",
            ""def is_number_token(n): return isinstance(n, (int, float))"",
            ""STARS = [token.STAR]"",
            ""FUTURE_FLAG_TO_FEATURE: Dict[str, Any] = {'annotations': Feature.F_STRINGS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return [\""f'example {x=}'\"", 42, token.SLASH]  # mock pre_order method\nnode = MockNode()"",
            ""def is_string_token(n): return isinstance(n, str)"",
            ""def iter_fexpr_spans(value): return [(i, value.find('}', i) + 1) for i in range(len(value)) if value[i] == '{']"",
            ""def is_number_token(n): return isinstance(n, (int, float))"",
            ""STARS = [token.STAR]"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import sys as syms""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'F_STRINGS'\n    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'\n    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'\n    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'\n    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'\n    RELAXED_DECORATORS = 'RELAXED_DECORATORS'\n    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'\n    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'\n    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'\n    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'\n    PATTERN_MATCHING = 'PATTERN_MATCHING'\n    EXCEPT_STAR = 'EXCEPT_STAR'\n    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return [\""f'post {x=}'\"", 42, token.SLASH]\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return isinstance(n, str)"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""def is_number_token(n):\n    return isinstance(n, (int, float, str)) and '_' in str(n) if isinstance(n, str) else False"",
            ""STARS = [token.STAR]"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return ['f\""Hello {x=}\""', '42', token.SLASH]\n\nnode = MockNode()"",
            ""def is_string_token(n): return isinstance(n, str)"",
            ""def iter_fexpr_spans(value): return [(i, value.find('}', i) + 1) for i in range(len(value)) if value[i] == '{']"",
            ""def is_number_token(n): return isinstance(n, (int, float))"",
            ""STARS = [token.STAR]"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any"",
            ""import token"",
            ""import grammar as syms""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'positional_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return ['f\""example {x=}\""', 42, token.SLASH]"",
            ""node = MockNode()"",
            ""def is_string_token(n): return isinstance(n, str)"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""def is_number_token(n): return isinstance(n, (int, str)) and '_' in str(n) if isinstance(n, str) else False"",
            ""STARS = [token.STAR]"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import typing""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return [\""f'example {42=}'\"", 12345, object()]  # replace with actual mock tokens\n\nnode = MockNode()"",
            ""def is_string_token(n): return isinstance(n, str)"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""def is_number_token(n): return isinstance(n, (int, float))"",
            ""STARS = [token.STAR]"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import types""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return ['f\""example {x=}\""', '_' * 10, 3.14]\n\nnode = MockNode()"",
            ""def is_string_token(n): return isinstance(n, str)"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""def is_number_token(n): return isinstance(n, (int, float))"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.DEBUG_F_STRINGS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Any"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return [\""f'example {x=}'\"", 42, token.SLASH]\n\nnode = MockNode()"",
            ""def is_string_token(n): return isinstance(n, str)"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""def is_number_token(n): return isinstance(n, (int, float))"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any"",
            ""import token"",
            ""import typing""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return ['f\""example {x=}\""', '42', token.SLASH]\n\nnode = MockNode()"",
            ""def is_string_token(n): return isinstance(n, str)"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""def is_number_token(n): return isinstance(n, (int, float))"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set, Dict, Any # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [token.SLASH, 'f''example {x=}', '10_000']# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float, str)) and ('_' in n if isinstance(n, str) else False) # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.NUMERIC_UNDERSCORES} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import types # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return ['f\""example {x=}\""', 42, token.SLASH]# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(0, len(value))] if 'f' in value else [] # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, (int, float)) # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE: Dict[str, Any] = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [\""f'example {x=}'\"", 42, token.SLASH]  # mock pre_order method# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(i, value.find('}', i) + 1) for i in range(len(value)) if value[i] == '{'] # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, (int, float)) # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'# pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [\""f'post {x=}'\"", 42, token.SLASH]# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return isinstance(n, (int, float, str)) and '_' in str(n) if isinstance(n, str) else False # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return ['f\""Hello {x=}\""', '42', token.SLASH]# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(i, value.find('}', i) + 1) for i in range(len(value)) if value[i] == '{'] # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, (int, float)) # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import grammar as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'positional_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return ['f\""example {x=}\""', 42, token.SLASH] # pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, (int, str)) and '_' in str(n) if isinstance(n, str) else False # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import typing # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [\""f'example {42=}'\"", 12345, object()]  # replace with actual mock tokens# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, (int, float)) # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import types # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return ['f\""example {x=}\""', '_' * 10, 3.14]# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, (int, float)) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.DEBUG_F_STRINGS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Any # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [\""f'example {x=}'\"", 42, token.SLASH]# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, (int, float)) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import typing # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return ['f\""example {x=}\""', '42', token.SLASH]# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, (int, float)) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    }
]",2,4885,0.0024425,3844,0.005766,0.0082085
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 35:
    if future_imports:
NameError: name 'future_imports' is not defined
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import pytest"",
            ""from unittest.mock import Mock""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'F_STRINGS'\n    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'\n    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'\n    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'\n    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'\n    RELAXED_DECORATORS = 'RELAXED_DECORATORS'\n    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'\n    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'\n    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'\n    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'\n    PATTERN_MATCHING = 'PATTERN_MATCHING'\n    EXCEPT_STAR = 'EXCEPT_STAR'\n    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = []"",
            ""node = Mock(pre_order=Mock(return_value=[]))"",
            ""is_string_token = Mock(return_value=False)"",
            ""iter_fexpr_spans = Mock(return_value=[])"",
            ""is_number_token = Mock(return_value=False)"",
            ""syms = Mock()"",
            ""is_simple_decorator_expression = Mock(return_value=False)"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'F_STRINGS'\n    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'\n    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'\n    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'\n    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'\n    RELAXED_DECORATORS = 'RELAXED_DECORATORS'\n    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'\n    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'\n    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'\n    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'\n    PATTERN_MATCHING = 'PATTERN_MATCHING'\n    EXCEPT_STAR = 'EXCEPT_STAR'\n    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return isinstance(n, str) and n.startswith('f')"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""def is_number_token(n):\n    return isinstance(n, (int, float, str)) and ('_' in str(n))"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import mock""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return [Mock(value='f\""example {x=}\""'), Mock(value='123_456'), token.SLASH]\n\nnode = MockNode()"",
            ""def is_string_token(n): return isinstance(n.value, str) if hasattr(n, 'value') else False"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""def is_number_token(n): return isinstance(n.value, str) and '_' in n.value if hasattr(n, 'value') else False"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict"",
            ""import token"",
            ""from unittest.mock import Mock""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""node = Mock()"",
            ""node.pre_order = Mock(return_value=[Mock(value=\""f'example {x=}'\""), Mock(value='42'), token.SLASH])"",
            ""is_string_token = lambda n: isinstance(n, str)"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, (int, float)) or (isinstance(n, str) and '_' in n)"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""is_simple_decorator_expression = lambda n: False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import types""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return [token.SLASH, 'f\""Hello, {name}\""', '100_000']\n\nnode = MockNode()"",
            ""def is_string_token(n): return isinstance(n, str)"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""def is_number_token(n): return isinstance(n, (int, float, str)) and ('_' in n if isinstance(n, str) else False)"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return ['f\""example {x=}\""', 1234, token.SLASH]\n\nnode = MockNode()"",
            ""def is_string_token(n): return isinstance(n, str)"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""def is_number_token(n): return isinstance(n, (int, float)) or (isinstance(n, str) and '_' in n)"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from unittest.mock import Mock""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""node = Mock()"",
            ""node.pre_order = Mock(return_value=[Mock(value='f\""test {x=}\""'), Mock(value='100_000'), token.SLASH])"",
            ""is_string_token = lambda n: isinstance(n, Mock) and hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, Mock) and hasattr(n, 'value') and '_' in n.value"",
            ""syms = Mock()"",
            ""syms.typedargslist = Mock()"",
            ""syms.arglist = Mock()"",
            ""syms.varargslist = Mock()"",
            ""syms.argument = Mock()"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""is_simple_decorator_expression = lambda n: False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import unittest.mock""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""mock_node = unittest.mock.Mock()\nmock_node.pre_order = lambda: []\nnode = mock_node"",
            ""is_string_token = lambda n: isinstance(n, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, (int, float))"",
            ""syms = unittest.mock.Mock()"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}"",
            ""is_simple_decorator_expression = lambda n: False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return [MockStringToken('f\""Hello, {world=}\""'), MockNumberToken(100), token.SLASH]"",
            ""node = MockNode()"",
            ""def is_string_token(n): return isinstance(n, MockStringToken)"",
            ""def is_number_token(n): return isinstance(n, MockNumberToken)"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""class MockStringToken:\n    def __init__(self, value):\n        self.value = value"",
            ""class MockNumberToken:\n    def __init__(self, value):\n        self.value = value"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return [\""f'example {x=}'\"", 42, token.SLASH]  # mock pre_order method\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return isinstance(n, str)"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""def is_number_token(n):\n    return isinstance(n, (int, float, str)) and '_' in (n if isinstance(n, str) else '')"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import pytest # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'# pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""node = Mock(pre_order=Mock(return_value=[])) # pragma: no cover"",
            ""is_string_token = Mock(return_value=False) # pragma: no cover"",
            ""iter_fexpr_spans = Mock(return_value=[]) # pragma: no cover"",
            ""is_number_token = Mock(return_value=False) # pragma: no cover"",
            ""syms = Mock() # pragma: no cover"",
            ""is_simple_decorator_expression = Mock(return_value=False) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'# pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) and n.startswith('f') # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return isinstance(n, (int, float, str)) and ('_' in str(n)) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import mock # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [Mock(value='f\""example {x=}\""'), Mock(value='123_456'), token.SLASH]# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n.value, str) if hasattr(n, 'value') else False # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n.value, str) and '_' in n.value if hasattr(n, 'value') else False # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""node = Mock() # pragma: no cover"",
            ""node.pre_order = Mock(return_value=[Mock(value=\""f'example {x=}'\""), Mock(value='42'), token.SLASH]) # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float)) or (isinstance(n, str) and '_' in n) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import types # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [token.SLASH, 'f\""Hello, {name}\""', '100_000']# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, (int, float, str)) and ('_' in n if isinstance(n, str) else False) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return ['f\""example {x=}\""', 1234, token.SLASH]# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, (int, float)) or (isinstance(n, str) and '_' in n) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""node = Mock() # pragma: no cover"",
            ""node.pre_order = Mock(return_value=[Mock(value='f\""test {x=}\""'), Mock(value='100_000'), token.SLASH]) # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, Mock) and hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, Mock) and hasattr(n, 'value') and '_' in n.value # pragma: no cover"",
            ""syms = Mock() # pragma: no cover"",
            ""syms.typedargslist = Mock() # pragma: no cover"",
            ""syms.arglist = Mock() # pragma: no cover"",
            ""syms.varargslist = Mock() # pragma: no cover"",
            ""syms.argument = Mock() # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import unittest.mock # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""mock_node = unittest.mock.Mock()# pragma: no cover"",
            ""mock_node.pre_order = lambda: []# pragma: no cover"",
            ""node = mock_node # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float)) # pragma: no cover"",
            ""syms = unittest.mock.Mock() # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [MockStringToken('f\""Hello, {world=}\""'), MockNumberToken(100), token.SLASH] # pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, MockStringToken) # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, MockNumberToken) # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(0, len(value))] # pragma: no cover"",
            ""class MockStringToken:# pragma: no cover"",
            ""    def __init__(self, value):# pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""class MockNumberToken:# pragma: no cover"",
            ""    def __init__(self, value):# pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [\""f'example {x=}'\"", 42, token.SLASH]  # mock pre_order method# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return isinstance(n, (int, float, str)) and '_' in (n if isinstance(n, str) else '') # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    }
]",2,5331,0.0026655,3996,0.005994,0.0086595
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 35:
    if future_imports:
NameError: name 'future_imports' is not defined
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set, Dict, Any"",
            ""import token"",
            ""import types""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'F_STRINGS'\n    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'\n    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'\n    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'\n    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'\n    RELAXED_DECORATORS = 'RELAXED_DECORATORS'\n    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'\n    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'\n    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'\n    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'\n    PATTERN_MATCHING = 'PATTERN_MATCHING'\n    EXCEPT_STAR = 'EXCEPT_STAR'\n    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return [types.SimpleNamespace(type='f-string'), types.SimpleNamespace(type='NUMBER'), types.SimpleNamespace(type=token.SLASH)]\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return hasattr(n, 'type') and n.type in { 'f-string', 'F-string' }"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""def is_number_token(n):\n    return hasattr(n, 'type') and n.type == 'NUMBER'"",
            ""syms = types.SimpleNamespace()"",
            ""syms.typedargslist = 'typedargslist'\nsyms.arglist = 'arglist'\nsyms.varargslist = 'varargslist'\nsyms.return_stmt = 'return_stmt'\nsyms.yield_expr = 'yield_expr'\nsyms.testlist_star_expr = 'testlist_star_expr'\nsyms.star_expr = 'star_expr'\nsyms.decorator = 'decorator'\nsyms.argument = 'argument'\nsyms.with_stmt = 'with_stmt'\nsyms.atom = 'atom'\nsyms.match_stmt = 'match_stmt'\nsyms.except_clause = 'except_clause'\nsyms.subscriptlist = 'subscriptlist'\nsyms.trailer = 'trailer'\nsyms.tname_star = 'tname_star'"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self): return ['f\""example {'sample'}\""', 1, token.SLASH]\n\nnode = MockNode()"",
            ""is_string_token = lambda n: isinstance(n, str) and n.startswith('f')"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, (int, float))"",
            ""syms = sys.modules[__name__]; syms.typedargslist = 'typedargslist'; syms.arglist = 'arglist'; syms.varargslist = 'varargslist'; syms.return_stmt = 'return_stmt'; syms.yield_expr = 'yield_expr'; syms.testlist_star_expr = 'testlist_star_expr'; syms.star_expr = 'star_expr'; syms.decorator = 'decorator'; syms.argument = 'argument'; syms.with_stmt = 'with_stmt'; syms.atom = 'atom'; syms.match_stmt = 'match_stmt'; syms.except_clause = 'except_clause'; syms.subscriptlist = 'subscriptlist'; syms.trailer = 'trailer'; syms.tname_star = 'tname_star'"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = [token.STAR, token.SLASH]"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.UNPACKING_ON_FLOW}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict"",
            ""import token"",
            ""import types""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""node = types.SimpleNamespace()  \nnode.pre_order = lambda: []"",
            ""is_string_token = lambda n: isinstance(n, str)"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, (int, float))"",
            ""syms = types.SimpleNamespace()\nsyms.typedargslist = 'typedargslist'\nsyms.arglist = 'arglist'\nsyms.varargslist = 'varargslist'\nsyms.return_stmt = 'return_stmt'\nsyms.yield_expr = 'yield_expr'\nsyms.testlist_star_expr = 'testlist_star_expr'\nsyms.star_expr = 'star_expr'\nsyms.decorator = 'decorator'\nsyms.argument = 'argument'\nsyms.with_stmt = 'with_stmt'\nsyms.atom = 'atom'\nsyms.match_stmt = 'match_stmt'\nsyms.except_clause = 'except_clause'\nsyms.subscriptlist = 'subscriptlist'\ns.y.trailer = 'trailer'\nsyms.tname_star = 'tname_star'"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import types""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""node = types.SimpleNamespace(pre_order=lambda: [])"",
            ""is_string_token = lambda n: isinstance(n, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, (int, float))"",
            ""syms = types.SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', decorator='decorator', argument='argument', with_stmt='with_stmt', atom='atom', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star')"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.SLASH}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict"",
            ""import token"",
            ""import types""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f-strings'\n    DEBUG_F_STRINGS = 'debug-f-strings'\n    NUMERIC_UNDERSCORES = 'numeric-underscores'\n    POS_ONLY_ARGUMENTS = 'positional-only-arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment-expressions'\n    RELAXED_DECORATORS = 'relaxed-decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing-comma-in-def'\n    TRAILING_COMMA_IN_CALL = 'trailing-comma-in-call'\n    UNPACKING_ON_FLOW = 'unpacking-on-flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann-assign-extended-rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized-context-managers'\n    PATTERN_MATCHING = 'pattern-matching'\n    EXCEPT_STAR = 'except-star'\n    VARIADIC_GENERICS = 'variadic-generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return ['f\""Hello, {name}!\"", 42, token.SLASH']\nnode = MockNode()"",
            ""def is_string_token(n):\n    return isinstance(n, str)"",
            ""def iter_fexpr_spans(value):\n    return [(0, len(value))]"",
            ""def is_number_token(n):\n    return isinstance(n, (int, float))"",
            ""syms = types.SimpleNamespace()\nsyms.typedargslist = 'typedargslist'\nsyms.arglist = 'arglist'\nsyms.varargslist = 'varargslist'\nsyms.return_stmt = 'return_stmt'\nsyms.yield_expr = 'yield_expr'\nsyms.testlist_star_expr = 'testlist_star_expr'\nsyms.star_expr = 'star_expr'\nsyms.decorator = 'decorator'\nsyms.argument = 'argument'\nsyms.with_stmt = 'with_stmt'\nsyms.atom = 'atom'\nsyms.match_stmt = 'match_stmt'\nsyms.except_clause = 'except_clause'\nsyms.subscriptlist = 'subscriptlist'\nsyms.trailer = 'trailer'\nsyms.tname_star = 'tname_star'"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.SLASH}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.UNPACKING_ON_FLOW}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from unittest.mock import Mock""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""node = Mock()"",
            ""node.pre_order = Mock(return_value=[])"",
            ""is_string_token = Mock(return_value=False)"",
            ""iter_fexpr_spans = Mock(return_value=[])"",
            ""is_number_token = Mock(return_value=False)"",
            ""STARS = {token.STAR, token.SLASH}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}"",
            ""is_simple_decorator_expression = Mock(return_value=False)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return [MockToken('f{var}'), MockToken('42'), token.SLASH]\n\nclass MockToken:\n    def __init__(self, value):\n        self.value = value\n        self.type = token.STRING if 'f' in value else token.NUMBER if value.isdigit() else None\n\nnode = MockNode()"",
            ""is_string_token = lambda n: n.type == token.STRING"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: n.type == token.NUMBER"",
            ""syms = sys.modules[__name__]; syms.typedargslist = type('syms', (), {'typedargslist': 1})\nsyms.arglist = type('syms', (), {'arglist': 2})\nsyms.varargslist = type('syms', (), {'varargslist': 3})\nsyms.return_stmt = type('syms', (), {'return_stmt': 4})\nsyms.yield_expr = type('syms', (), {'yield_expr': 5})\nsyms.testlist_star_expr = type('syms', (), {'testlist_star_expr': 6})\nsyms.star_expr = type('syms', (), {'star_expr': 7})\nsyms.decorator = type('syms', (), {'decorator': 8})\nsyms.argument = type('syms', (), {'argument': 9})\nsyms.with_stmt = type('syms', (), {'with_stmt': 10})\nsyms.atom = type('syms', (), {'atom': 11})\nsyms.match_stmt = type('syms', (), {'match_stmt': 12})\nsyms.except_clause = type('syms', (), {'except_clause': 13})\nsyms.subscriptlist = type('syms', (), {'subscriptlist': 14})\nsyms.trailer = type('syms', (), {'trailer': 15})\nsyms.tname_star = type('syms', (), {'tname_star': 16})"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from unittest.mock import Mock""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""node = Mock(pre_order=Mock(return_value=[]))"",
            ""is_string_token = lambda n: isinstance(n, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, (int, float)) and (n in {0, 1, 2, 3})"",
            ""syms = Mock()"",
            ""syms.typedargslist = 'typedargslist'"",
            ""syms.arglist = 'arglist'"",
            ""syms.varargslist = 'varargslist'"",
            ""syms.return_stmt = 'return_stmt'"",
            ""syms.yield_expr = 'yield_expr'"",
            ""syms.testlist_star_expr = 'testlist_star_expr'"",
            ""syms.star_expr = 'star_expr'"",
            ""syms.decorator = 'decorator'"",
            ""syms.argument = 'argument'"",
            ""syms.with_stmt = 'with_stmt'"",
            ""syms.atom = 'atom'"",
            ""syms.match_stmt = 'match_stmt'"",
            ""syms.except_clause = 'except_clause'"",
            ""syms.subscriptlist = 'subscriptlist'"",
            ""syms.trailer = 'trailer'"",
            ""syms.tname_star = 'tname_star'"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR, token.SLASH}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from unittest.mock import Mock""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""node = Mock()"",
            ""node.pre_order = Mock(return_value=[Mock(value='f-string'), Mock(value='42'), token.SLASH])"",
            ""is_string_token = Mock(return_value=False)"",
            ""iter_fexpr_spans = Mock(return_value=[(0, 10)])"",
            ""is_number_token = Mock(return_value=False)"",
            ""syms = Mock()"",
            ""syms.typedargslist = 'typedargslist'"",
            ""syms.arglist = 'arglist'"",
            ""syms.varargslist = 'varargslist'"",
            ""syms.return_stmt = 'return_stmt'"",
            ""syms.yield_expr = 'yield_expr'"",
            ""syms.testlist_star_expr = 'testlist_star_expr'"",
            ""syms.star_expr = 'star_expr'"",
            ""syms.decorator = 'decorator'"",
            ""syms.argument = 'argument'"",
            ""syms.with_stmt = 'with_stmt'"",
            ""syms.atom = 'atom'"",
            ""syms.match_stmt = 'match_stmt'"",
            ""syms.except_clause = 'except_clause'"",
            ""syms.subscriptlist = 'subscriptlist'"",
            ""syms.trailer = 'trailer'"",
            ""syms.tname_star = 'tname_star'"",
            ""is_simple_decorator_expression = Mock(return_value=True)"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'F_STRINGS'\n    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'\n    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'\n    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'\n    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'\n    RELAXED_DECORATORS = 'RELAXED_DECORATORS'\n    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'\n    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'\n    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'\n    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'\n    PATTERN_MATCHING = 'PATTERN_MATCHING'\n    EXCEPT_STAR = 'EXCEPT_STAR'\n    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return ['f\""Hello, {world}!\"""",
            42,
            3.14,
            1000,
            0.1,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20
        ],
        "",\n}\nnode = MockNode()"": ""def is_string_token(n):\n    return isinstance(n, str)\n"",
        ""def iter_fexpr_spans(value):\n    return [(0, len(value))]\n    \n    def is_number_token(n):\n    return isinstance(n, (int, float))\n\nsyms = sys.modules[__name__]\nsyms.typedargslist = 'typedargslist'\nsyms.arglist = 'arglist'\nsyms.varargslist = 'varargslist'\nsyms.return_stmt = 'return_stmt'\nsyms.yield_expr = 'yield_expr'\nsyms.testlist_star_expr = 'testlist_star_expr'\nsyms.star_expr = 'star_expr'\nsyms.decorator = 'decorator'\nsyms.argument = 'argument'\nsyms.with_stmt = 'with_stmt'\nsyms.atom = 'atom'\nsyms.match_stmt = 'match_stmt'\nsyms.except_clause = 'except_clause'\nsyms.subscriptlist = 'subscriptlist'\nsyms.trailer = 'trailer'\nsyms.tname_star = 'tname_star'\n\nis_simple_decorator_expression = lambda n: True\nSTARS = {token.STAR}\nFUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}"": true
    }
]","[
    {
        ""imports"": [
            ""from typing import Set, Dict, Any # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import types # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'# pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [types.SimpleNamespace(type='f-string'), types.SimpleNamespace(type='NUMBER'), types.SimpleNamespace(type=token.SLASH)]# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return hasattr(n, 'type') and n.type in { 'f-string', 'F-string' } # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return hasattr(n, 'type') and n.type == 'NUMBER' # pragma: no cover"",
            ""syms = types.SimpleNamespace() # pragma: no cover"",
            ""syms.typedargslist = 'typedargslist'# pragma: no cover"",
            ""syms.arglist = 'arglist'# pragma: no cover"",
            ""syms.varargslist = 'varargslist'# pragma: no cover"",
            ""syms.return_stmt = 'return_stmt'# pragma: no cover"",
            ""syms.yield_expr = 'yield_expr'# pragma: no cover"",
            ""syms.testlist_star_expr = 'testlist_star_expr'# pragma: no cover"",
            ""syms.star_expr = 'star_expr'# pragma: no cover"",
            ""syms.decorator = 'decorator'# pragma: no cover"",
            ""syms.argument = 'argument'# pragma: no cover"",
            ""syms.with_stmt = 'with_stmt'# pragma: no cover"",
            ""syms.atom = 'atom'# pragma: no cover"",
            ""syms.match_stmt = 'match_stmt'# pragma: no cover"",
            ""syms.except_clause = 'except_clause'# pragma: no cover"",
            ""syms.subscriptlist = 'subscriptlist'# pragma: no cover"",
            ""syms.trailer = 'trailer'# pragma: no cover"",
            ""syms.tname_star = 'tname_star' # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import types # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""node = types.SimpleNamespace()  # pragma: no cover"",
            ""node.pre_order = lambda: [] # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float)) # pragma: no cover"",
            ""syms = types.SimpleNamespace()# pragma: no cover"",
            ""syms.typedargslist = 'typedargslist'# pragma: no cover"",
            ""syms.arglist = 'arglist'# pragma: no cover"",
            ""syms.varargslist = 'varargslist'# pragma: no cover"",
            ""syms.return_stmt = 'return_stmt'# pragma: no cover"",
            ""syms.yield_expr = 'yield_expr'# pragma: no cover"",
            ""syms.testlist_star_expr = 'testlist_star_expr'# pragma: no cover"",
            ""syms.star_expr = 'star_expr'# pragma: no cover"",
            ""syms.decorator = 'decorator'# pragma: no cover"",
            ""syms.argument = 'argument'# pragma: no cover"",
            ""syms.with_stmt = 'with_stmt'# pragma: no cover"",
            ""syms.atom = 'atom'# pragma: no cover"",
            ""syms.match_stmt = 'match_stmt'# pragma: no cover"",
            ""syms.except_clause = 'except_clause'# pragma: no cover"",
            ""syms.subscriptlist = 'subscriptlist'# pragma: no cover"",
            ""syms.tname_star = 'tname_star' # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import types # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""node = types.SimpleNamespace(pre_order=lambda: []) # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float)) # pragma: no cover"",
            ""syms = types.SimpleNamespace(typedargslist='typedargslist', arglist='arglist', varargslist='varargslist', return_stmt='return_stmt', yield_expr='yield_expr', testlist_star_expr='testlist_star_expr', star_expr='star_expr', decorator='decorator', argument='argument', with_stmt='with_stmt', atom='atom', match_stmt='match_stmt', except_clause='except_clause', subscriptlist='subscriptlist', trailer='trailer', tname_star='tname_star') # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.SLASH} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import types # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f-strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug-f-strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric-underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'positional-only-arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment-expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed-decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing-comma-in-def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing-comma-in-call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking-on-flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann-assign-extended-rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized-context-managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern-matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except-star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic-generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return ['f\""Hello, {name}!\"", 42, token.SLASH']# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return isinstance(n, (int, float)) # pragma: no cover"",
            ""syms = types.SimpleNamespace()# pragma: no cover"",
            ""syms.typedargslist = 'typedargslist'# pragma: no cover"",
            ""syms.arglist = 'arglist'# pragma: no cover"",
            ""syms.varargslist = 'varargslist'# pragma: no cover"",
            ""syms.return_stmt = 'return_stmt'# pragma: no cover"",
            ""syms.yield_expr = 'yield_expr'# pragma: no cover"",
            ""syms.testlist_star_expr = 'testlist_star_expr'# pragma: no cover"",
            ""syms.star_expr = 'star_expr'# pragma: no cover"",
            ""syms.decorator = 'decorator'# pragma: no cover"",
            ""syms.argument = 'argument'# pragma: no cover"",
            ""syms.with_stmt = 'with_stmt'# pragma: no cover"",
            ""syms.atom = 'atom'# pragma: no cover"",
            ""syms.match_stmt = 'match_stmt'# pragma: no cover"",
            ""syms.except_clause = 'except_clause'# pragma: no cover"",
            ""syms.subscriptlist = 'subscriptlist'# pragma: no cover"",
            ""syms.trailer = 'trailer'# pragma: no cover"",
            ""syms.tname_star = 'tname_star' # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.SLASH} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.UNPACKING_ON_FLOW} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""node = Mock() # pragma: no cover"",
            ""node.pre_order = Mock(return_value=[]) # pragma: no cover"",
            ""is_string_token = Mock(return_value=False) # pragma: no cover"",
            ""iter_fexpr_spans = Mock(return_value=[]) # pragma: no cover"",
            ""is_number_token = Mock(return_value=False) # pragma: no cover"",
            ""STARS = {token.STAR, token.SLASH} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover"",
            ""is_simple_decorator_expression = Mock(return_value=False) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [MockToken('f{var}'), MockToken('42'), token.SLASH]# pragma: no cover"",
            ""# pragma: no cover"",
            ""class MockToken:# pragma: no cover"",
            ""    def __init__(self, value):# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.type = token.STRING if 'f' in value else token.NUMBER if value.isdigit() else None# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""is_string_token = lambda n: n.type == token.STRING # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: n.type == token.NUMBER # pragma: no cover"",
            ""syms = sys.modules[__name__]; syms.typedargslist = type('syms', (), {'typedargslist': 1})# pragma: no cover"",
            ""syms.arglist = type('syms', (), {'arglist': 2})# pragma: no cover"",
            ""syms.varargslist = type('syms', (), {'varargslist': 3})# pragma: no cover"",
            ""syms.return_stmt = type('syms', (), {'return_stmt': 4})# pragma: no cover"",
            ""syms.yield_expr = type('syms', (), {'yield_expr': 5})# pragma: no cover"",
            ""syms.testlist_star_expr = type('syms', (), {'testlist_star_expr': 6})# pragma: no cover"",
            ""syms.star_expr = type('syms', (), {'star_expr': 7})# pragma: no cover"",
            ""syms.decorator = type('syms', (), {'decorator': 8})# pragma: no cover"",
            ""syms.argument = type('syms', (), {'argument': 9})# pragma: no cover"",
            ""syms.with_stmt = type('syms', (), {'with_stmt': 10})# pragma: no cover"",
            ""syms.atom = type('syms', (), {'atom': 11})# pragma: no cover"",
            ""syms.match_stmt = type('syms', (), {'match_stmt': 12})# pragma: no cover"",
            ""syms.except_clause = type('syms', (), {'except_clause': 13})# pragma: no cover"",
            ""syms.subscriptlist = type('syms', (), {'subscriptlist': 14})# pragma: no cover"",
            ""syms.trailer = type('syms', (), {'trailer': 15})# pragma: no cover"",
            ""syms.tname_star = type('syms', (), {'tname_star': 16}) # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""node = Mock(pre_order=Mock(return_value=[])) # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float)) and (n in {0, 1, 2, 3}) # pragma: no cover"",
            ""syms = Mock() # pragma: no cover"",
            ""syms.typedargslist = 'typedargslist' # pragma: no cover"",
            ""syms.arglist = 'arglist' # pragma: no cover"",
            ""syms.varargslist = 'varargslist' # pragma: no cover"",
            ""syms.return_stmt = 'return_stmt' # pragma: no cover"",
            ""syms.yield_expr = 'yield_expr' # pragma: no cover"",
            ""syms.testlist_star_expr = 'testlist_star_expr' # pragma: no cover"",
            ""syms.star_expr = 'star_expr' # pragma: no cover"",
            ""syms.decorator = 'decorator' # pragma: no cover"",
            ""syms.argument = 'argument' # pragma: no cover"",
            ""syms.with_stmt = 'with_stmt' # pragma: no cover"",
            ""syms.atom = 'atom' # pragma: no cover"",
            ""syms.match_stmt = 'match_stmt' # pragma: no cover"",
            ""syms.except_clause = 'except_clause' # pragma: no cover"",
            ""syms.subscriptlist = 'subscriptlist' # pragma: no cover"",
            ""syms.trailer = 'trailer' # pragma: no cover"",
            ""syms.tname_star = 'tname_star' # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR, token.SLASH} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""node = Mock() # pragma: no cover"",
            ""node.pre_order = Mock(return_value=[Mock(value='f-string'), Mock(value='42'), token.SLASH]) # pragma: no cover"",
            ""is_string_token = Mock(return_value=False) # pragma: no cover"",
            ""iter_fexpr_spans = Mock(return_value=[(0, 10)]) # pragma: no cover"",
            ""is_number_token = Mock(return_value=False) # pragma: no cover"",
            ""syms = Mock() # pragma: no cover"",
            ""syms.typedargslist = 'typedargslist' # pragma: no cover"",
            ""syms.arglist = 'arglist' # pragma: no cover"",
            ""syms.varargslist = 'varargslist' # pragma: no cover"",
            ""syms.return_stmt = 'return_stmt' # pragma: no cover"",
            ""syms.yield_expr = 'yield_expr' # pragma: no cover"",
            ""syms.testlist_star_expr = 'testlist_star_expr' # pragma: no cover"",
            ""syms.star_expr = 'star_expr' # pragma: no cover"",
            ""syms.decorator = 'decorator' # pragma: no cover"",
            ""syms.argument = 'argument' # pragma: no cover"",
            ""syms.with_stmt = 'with_stmt' # pragma: no cover"",
            ""syms.atom = 'atom' # pragma: no cover"",
            ""syms.match_stmt = 'match_stmt' # pragma: no cover"",
            ""syms.except_clause = 'except_clause' # pragma: no cover"",
            ""syms.subscriptlist = 'subscriptlist' # pragma: no cover"",
            ""syms.trailer = 'trailer' # pragma: no cover"",
            ""syms.tname_star = 'tname_star' # pragma: no cover"",
            ""is_simple_decorator_expression = Mock(return_value=True) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    }
]",2,6163,0.0030815,5732,0.008598,0.0116794999999999
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 50:
    if future_imports:
NameError: name 'future_imports' is not defined
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import sys"",
            ""from unittest.mock import MagicMock""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""node = MagicMock()"",
            ""node.pre_order.return_value = []"",
            ""is_string_token = lambda n: isinstance(n, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, (int, float))"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return [create_token('f\""Hello, World! {x=}\"", token.STRING), create_token('123_456', token.NUMBER)]\n\ndef create_token(value, typ):\n    return type('MockToken', (object,), {'value': value, 'type': typ})()"",
            ""node = MockNode()"",
            ""is_string_token = lambda n: n.type == token.STRING"",
            ""iter_fexpr_spans = lambda value: [(i, value.index('}', i) + 1) for i in range(len(value)) if value[i] == '{']"",
            ""is_number_token = lambda n: n.type == token.NUMBER"",
            ""syms = sys.modules[__name__]; syms.typedargslist = 'typedargslist'; syms.arglist = 'arglist'; syms.varargslist = 'varargslist'; syms.return_stmt = 'return_stmt'; syms.yield_expr = 'yield_expr'; syms.testlist_star_expr = 'testlist_star_expr'; syms.star_expr = 'star_expr'; syms.decorator = 'decorator'; syms.argument = 'argument'; syms.with_stmt = 'with_stmt'; syms.atom = 'atom'; syms.match_stmt = 'match_stmt'; syms.except_clause = 'except_clause'; syms.subscriptlist = 'subscriptlist'; syms.trailer = 'trailer'; syms.tname_star = 'tname_star'"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.UNPACKING_ON_FLOW}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return [{'value': 'f\\'example {x=}'}, {'value': 42}, {'type': token.SLASH}]"",
            ""node = MockNode()"",
            ""is_string_token = lambda n: isinstance(n, dict) and 'value' in n"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, dict) and 'value' in n and isinstance(n['value'], (int, float))"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}"",
            ""syms = sys.modules[__name__]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: []})()"",
            ""is_string_token = lambda n: isinstance(n, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, (int, float))"",
            ""syms = sys.modules[__name__]; syms.typedargslist = 'typedargslist'; syms.arglist = 'arglist'; syms.varargslist = 'varargslist'; syms.return_stmt = 'return_stmt'; syms.yield_expr = 'yield_expr'; syms.testlist_star_expr = 'testlist_star_expr'; syms.star_expr = 'star_expr'; syms.decorator = 'decorator'; syms.argument = 'argument'; syms.with_stmt = 'with_stmt'; syms.atom = 'atom'; syms.match_stmt = 'match_stmt'; syms.except_clause = 'except_clause'; syms.subscriptlist = 'subscriptlist'; syms.trailer = 'trailer'; syms.tname_star = 'tname_star'"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return []\n\nnode = MockNode()"",
            ""is_string_token = lambda n: isinstance(n, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, (int, float))"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""node = type('Node', (), {'pre_order': lambda self: []})()"",
            ""is_string_token = lambda n: isinstance(n, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, (int, float))"",
            ""syms.typedargslist = 'typedargslist'"",
            ""syms.arglist = 'arglist'"",
            ""syms.varargslist = 'varargslist'"",
            ""STARS = {token.STAR, token.SLASH}"",
            ""FUTURE_FLAG_TO_FEATURE = {}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: []})()"",
            ""is_string_token = lambda n: isinstance(n, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, (int, float))"",
            ""syms = sys.modules[__name__]; syms.typedargslist = 'typedargslist'; syms.arglist = 'arglist'; syms.varargslist = 'varargslist'; syms.decorator = 'decorator'; syms.argument = 'argument'; syms.return_stmt = 'return_stmt'; syms.yield_expr = 'yield_expr'; syms.testlist_star_expr = 'testlist_star_expr'; syms.star_expr = 'star_expr'; syms.with_stmt = 'with_stmt'; syms.atom = 'atom'; syms.match_stmt = 'match_stmt'; syms.except_clause = 'except_clause'; syms.subscriptlist = 'subscriptlist'; syms.trailer = 'trailer'; syms.tname_star = 'tname_star'"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = [token.STAR]"",
            ""FUTURE_FLAG_TO_FEATURE = {}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import sys"",
            ""from unittest.mock import MagicMock""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""node = MagicMock()"",
            ""node.pre_order.return_value = []"",
            ""is_string_token = lambda n: isinstance(n, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, (int, float))"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.NUMERIC_UNDERSCORES}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Any"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return [\""f'example {x=} \"", 42, 3.14, token.SLASH]\n\nnode = MockNode()"",
            ""is_string_token = lambda n: isinstance(n, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, (int, float))"",
            ""syms = sys.modules[__name__]; syms.typedargslist = 'typedargslist'; syms.arglist = 'arglist'; syms.varargslist = 'varargslist'; syms.return_stmt = 'return_stmt'; syms.yield_expr = 'yield_expr'; syms.testlist_star_expr = 'testlist_star_expr'; syms.star_expr = 'star_expr'; syms.decorator = 'decorator'; syms.argument = 'argument'; syms.with_stmt = 'with_stmt'; syms.atom = 'atom'; syms.match_stmt = 'match_stmt'; syms.except_clause = 'except_clause'; syms.subscriptlist = 'subscriptlist'; syms.trailer = 'trailer'; syms.tname_star = 'tname_star'"",
            ""is_simple_decorator_expression = lambda n: isinstance(n, str) and n.startswith('@')"",
            ""STARS = {token.STAR, token.SLASH}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: []})()"",
            ""is_string_token = lambda n: isinstance(n, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, (int, float, str))"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from unittest.mock import MagicMock # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""node = MagicMock() # pragma: no cover"",
            ""node.pre_order.return_value = [] # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float)) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""# pragma: no cover"",
            ""def create_token(value, typ):# pragma: no cover"",
            ""    return type('MockToken', (object,), {'value': value, 'type': typ})() # pragma: no cover"",
            ""is_string_token = lambda n: n.type == token.STRING # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(i, value.index('}', i) + 1) for i in range(len(value)) if value[i] == '{'] # pragma: no cover"",
            ""is_number_token = lambda n: n.type == token.NUMBER # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [{'value': 'f\\'example {x=}'}, {'value': 42}, {'type': token.SLASH}] # pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, dict) and 'value' in n # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, dict) and 'value' in n and isinstance(n['value'], (int, float)) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover"",
            ""syms = sys.modules[__name__] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: []})() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float)) # pragma: no cover"",
            ""syms = sys.modules[__name__]; syms.typedargslist = 'typedargslist'; syms.arglist = 'arglist'; syms.varargslist = 'varargslist'; syms.return_stmt = 'return_stmt'; syms.yield_expr = 'yield_expr'; syms.testlist_star_expr = 'testlist_star_expr'; syms.star_expr = 'star_expr'; syms.decorator = 'decorator'; syms.argument = 'argument'; syms.with_stmt = 'with_stmt'; syms.atom = 'atom'; syms.match_stmt = 'match_stmt'; syms.except_clause = 'except_clause'; syms.subscriptlist = 'subscriptlist'; syms.trailer = 'trailer'; syms.tname_star = 'tname_star' # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float)) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""node = type('Node', (), {'pre_order': lambda self: []})() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float)) # pragma: no cover"",
            ""STARS = {token.STAR, token.SLASH} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: []})() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float)) # pragma: no cover"",
            ""syms = sys.modules[__name__]; syms.typedargslist = 'typedargslist'; syms.arglist = 'arglist'; syms.varargslist = 'varargslist'; syms.decorator = 'decorator'; syms.argument = 'argument'; syms.return_stmt = 'return_stmt'; syms.yield_expr = 'yield_expr'; syms.testlist_star_expr = 'testlist_star_expr'; syms.star_expr = 'star_expr'; syms.with_stmt = 'with_stmt'; syms.atom = 'atom'; syms.match_stmt = 'match_stmt'; syms.except_clause = 'except_clause'; syms.subscriptlist = 'subscriptlist'; syms.trailer = 'trailer'; syms.tname_star = 'tname_star' # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from unittest.mock import MagicMock # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""node = MagicMock() # pragma: no cover"",
            ""node.pre_order.return_value = [] # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float)) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.NUMERIC_UNDERSCORES} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Any # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [\""f'example {x=} \"", 42, 3.14, token.SLASH]# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float)) # pragma: no cover"",
            ""syms = sys.modules[__name__]; syms.typedargslist = 'typedargslist'; syms.arglist = 'arglist'; syms.varargslist = 'varargslist'; syms.return_stmt = 'return_stmt'; syms.yield_expr = 'yield_expr'; syms.testlist_star_expr = 'testlist_star_expr'; syms.star_expr = 'star_expr'; syms.decorator = 'decorator'; syms.argument = 'argument'; syms.with_stmt = 'with_stmt'; syms.atom = 'atom'; syms.match_stmt = 'match_stmt'; syms.except_clause = 'except_clause'; syms.subscriptlist = 'subscriptlist'; syms.trailer = 'trailer'; syms.tname_star = 'tname_star' # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: isinstance(n, str) and n.startswith('@') # pragma: no cover"",
            ""STARS = {token.STAR, token.SLASH} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: []})() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float, str)) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    }
]",2,6879,0.0034395,4411,0.0066165,0.0100559999999999
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 32:
    if future_imports:
NameError: name 'future_imports' is not defined
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set, Dict"",
            ""import token"",
            ""from unittest.mock import MagicMock""
        ],
        ""initialization"": [
            ""class Feature: \n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""node = MagicMock()"",
            ""node.pre_order.return_value = []"",
            ""is_string_token = lambda n: isinstance(n, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] if 'f' in value else []"",
            ""is_number_token = lambda n: isinstance(n, (int, float)),  # Simply checks if n is a number"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = { 'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS }""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict"",
            ""import token"",
            ""import sys"",
            ""from unittest.mock import MagicMock""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""node = MagicMock()"",
            ""node.pre_order.return_value = []"",
            ""is_string_token = lambda n: isinstance(n, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, (int, float))"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import sys"",
            ""from unittest.mock import MagicMock""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""node = MagicMock()"",
            ""node.pre_order.return_value = []"",
            ""is_string_token = lambda n: isinstance(n, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, (int, float))"",
            ""STARS = [token.STAR]"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.UNPACKING_ON_FLOW}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any"",
            ""import token"",
            ""import sys""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return ['f\""Hello {world=}\""', 'number_1_000', '/', '*']\n\nnode = MockNode()"",
            ""is_string_token = lambda n: isinstance(n, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, (int, float, str)) and isinstance(n, str) and '_' in n"",
            ""STARS = [token.STAR]"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import sys"",
            ""from unittest.mock import MagicMock""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""node = MagicMock()"",
            ""node.pre_order.return_value = []"",
            ""is_string_token = lambda n: isinstance(n, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, (int, float))"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = { 'annotations': Feature.UNPACKING_ON_FLOW }""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict"",
            ""import token"",
            ""import sys"",
            ""from unittest.mock import Mock""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""node = Mock()"",
            ""node.pre_order.return_value = []"",
            ""is_string_token = lambda n: isinstance(n, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, (int, float))"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import grammar as syms"",
            ""from unittest.mock import MagicMock""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""node = MagicMock()"",
            ""node.pre_order.return_value = []"",
            ""is_string_token = lambda n: isinstance(n, str) and n.startswith('f')"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] if 'f' in value else []"",
            ""is_number_token = lambda n: isinstance(n, (int, float))"",
            ""syms.typedargslist = 'typedargslist'; syms.arglist = 'arglist'; syms.varargslist = 'varargslist'; syms.return_stmt = 'return_stmt'; syms.yield_expr = 'yield_expr'; syms.testlist_star_expr = 'testlist_star_expr'; syms.star_expr = 'star_expr'; syms.decorator = 'decorator'; syms.argument = 'argument'; syms.with_stmt = 'with_stmt'; syms.atom = 'atom'; syms.match_stmt = 'match_stmt'; syms.except_clause = 'except_clause'; syms.subscriptlist = 'subscriptlist'; syms.trailer = 'trailer'; syms.tname_star = 'tname_star'"",
            ""is_simple_decorator_expression = lambda n: True"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.UNPACKING_ON_FLOW}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms"",
            ""from unittest.mock import MagicMock""
        ],
        ""initialization"": [
            ""Feature = type('Feature', (), { 'F_STRINGS': 'f_strings', 'DEBUG_F_STRINGS': 'debug_f_strings', 'NUMERIC_UNDERSCORES': 'numeric_underscores', 'POS_ONLY_ARGUMENTS': 'pos_only_arguments', 'ASSIGNMENT_EXPRESSIONS': 'assignment_expressions', 'RELAXED_DECORATORS': 'relaxed_decorators', 'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call', 'UNPACKING_ON_FLOW': 'unpacking_on_flow', 'ANN_ASSIGN_EXTENDED_RHS': 'ann_assign_extended_rhs', 'PARENTHESIZED_CONTEXT_MANAGERS': 'parenthesized_context_managers', 'PATTERN_MATCHING': 'pattern_matching', 'EXCEPT_STAR': 'except_star', 'VARIADIC_GENERICS': 'variadic_generics' })"",
            ""future_imports = []"",
            ""node = MagicMock()"",
            ""node.pre_order.return_value = []"",
            ""is_string_token = lambda n: isinstance(n, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, (int, float))"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = { 'annotations': Feature.UNPACKING_ON_FLOW }""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any"",
            ""import token"",
            ""import syms"",
            ""from unittest.mock import MagicMock""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""node = MagicMock()"",
            ""node.pre_order.return_value = []"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, int)"",
            ""syms.typedargslist = 'typedargslist'"",
            ""syms.arglist = 'arglist'"",
            ""syms.varargslist = 'varargslist'"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = { 'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS }""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict"",
            ""import token"",
            ""import sys"",
            ""from unittest.mock import MagicMock""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""node = MagicMock()"",
            ""node.pre_order.return_value = []"",
            ""is_string_token = lambda n: isinstance(n, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] if value.startswith('f') else []"",
            ""is_number_token = lambda n: isinstance(n, (int, float))"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set, Dict # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from unittest.mock import MagicMock # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""node = MagicMock() # pragma: no cover"",
            ""node.pre_order.return_value = [] # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] if 'f' in value else [] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float)),  # Simply checks if n is a number # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { 'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS } # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from unittest.mock import MagicMock # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""node = MagicMock() # pragma: no cover"",
            ""node.pre_order.return_value = [] # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float)) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from unittest.mock import MagicMock # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""node = MagicMock() # pragma: no cover"",
            ""node.pre_order.return_value = [] # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float)) # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.UNPACKING_ON_FLOW} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return ['f\""Hello {world=}\""', 'number_1_000', '/', '*']# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float, str)) and isinstance(n, str) and '_' in n # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from unittest.mock import MagicMock # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""node = MagicMock() # pragma: no cover"",
            ""node.pre_order.return_value = [] # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float)) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { 'annotations': Feature.UNPACKING_ON_FLOW } # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""node = Mock() # pragma: no cover"",
            ""node.pre_order.return_value = [] # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float)) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import grammar as syms # pragma: no cover"",
            ""from unittest.mock import MagicMock # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""node = MagicMock() # pragma: no cover"",
            ""node.pre_order.return_value = [] # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) and n.startswith('f') # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] if 'f' in value else [] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float)) # pragma: no cover"",
            ""syms.typedargslist = 'typedargslist'; syms.arglist = 'arglist'; syms.varargslist = 'varargslist'; syms.return_stmt = 'return_stmt'; syms.yield_expr = 'yield_expr'; syms.testlist_star_expr = 'testlist_star_expr'; syms.star_expr = 'star_expr'; syms.decorator = 'decorator'; syms.argument = 'argument'; syms.with_stmt = 'with_stmt'; syms.atom = 'atom'; syms.match_stmt = 'match_stmt'; syms.except_clause = 'except_clause'; syms.subscriptlist = 'subscriptlist'; syms.trailer = 'trailer'; syms.tname_star = 'tname_star' # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: True # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.UNPACKING_ON_FLOW} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from unittest.mock import MagicMock # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = type('Feature', (), { 'F_STRINGS': 'f_strings', 'DEBUG_F_STRINGS': 'debug_f_strings', 'NUMERIC_UNDERSCORES': 'numeric_underscores', 'POS_ONLY_ARGUMENTS': 'pos_only_arguments', 'ASSIGNMENT_EXPRESSIONS': 'assignment_expressions', 'RELAXED_DECORATORS': 'relaxed_decorators', 'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call', 'UNPACKING_ON_FLOW': 'unpacking_on_flow', 'ANN_ASSIGN_EXTENDED_RHS': 'ann_assign_extended_rhs', 'PARENTHESIZED_CONTEXT_MANAGERS': 'parenthesized_context_managers', 'PATTERN_MATCHING': 'pattern_matching', 'EXCEPT_STAR': 'except_star', 'VARIADIC_GENERICS': 'variadic_generics' }) # pragma: no cover"",
            ""node = MagicMock() # pragma: no cover"",
            ""node.pre_order.return_value = [] # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float)) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { 'annotations': Feature.UNPACKING_ON_FLOW } # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from unittest.mock import MagicMock # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""node = MagicMock() # pragma: no cover"",
            ""node.pre_order.return_value = [] # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, int) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = { 'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS } # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from unittest.mock import MagicMock # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""node = MagicMock() # pragma: no cover"",
            ""node.pre_order.return_value = [] # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] if value.startswith('f') else [] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float)) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover""
        ]
    }
]",2,7539,0.0037695,3773,0.0056595,0.009429
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 49:
    if future_imports:
NameError: name 'future_imports' is not defined
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import sys"",
            ""from unittest.mock import MagicMock""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""node = MagicMock()"",
            ""node.pre_order.return_value = []"",
            ""is_string_token = lambda n: isinstance(n, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, (int, float))"",
            ""STARS = [token.STAR]"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.NUMERIC_UNDERSCORES}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from unittest.mock import MagicMock""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""node = MagicMock()"",
            ""node.pre_order.return_value = []"",
            ""is_string_token = lambda n: isinstance(n, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, (int, float))"",
            ""STARS = [token.STAR]"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms"",
            ""from unittest.mock import Mock""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""node = Mock()"",
            ""node.pre_order = Mock(return_value=[])"",
            ""def is_string_token(n): return isinstance(n, str)"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""def is_number_token(n): return isinstance(n, (int, float, str)) and '_' in n if isinstance(n, str) else False"",
            ""STARS = [token.STAR]"",
            ""FUTURE_FLAG_TO_FEATURE = {}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, List, Dict, Any"",
            ""import token""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return ['f\""Example of f-string: {var}\""', '42']\nnode = MockNode()"",
            ""def is_string_token(n): return isinstance(n, str)"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""def is_number_token(n): return isinstance(n, (int, float))"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any"",
            ""import token"",
            ""import syms"",
            ""from unittest.mock import MagicMock""
        ],
        ""initialization"": [
            ""Feature = type('Feature', (), { 'F_STRINGS': 'f_strings', 'DEBUG_F_STRINGS': 'debug_f_strings', 'NUMERIC_UNDERSCORES': 'numeric_underscores', 'POS_ONLY_ARGUMENTS': 'pos_only_arguments', 'ASSIGNMENT_EXPRESSIONS': 'assignment_expressions', 'RELAXED_DECORATORS': 'relaxed_decorators', 'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call', 'UNPACKING_ON_FLOW': 'unpacking_on_flow', 'ANN_ASSIGN_EXTENDED_RHS': 'ann_assign_extended_rhs', 'PARENTHESIZED_CONTEXT_MANAGERS': 'parenthesized_context_managers', 'PATTERN_MATCHING': 'pattern_matching', 'EXCEPT_STAR': 'except_star', 'VARIADIC_GENERICS': 'variadic_generics', })"",
            ""future_imports = []"",
            ""node = MagicMock()"",
            ""node.pre_order.return_value = [{'type': token.String, 'value': 'f\""example {x=}\""'}, {'type': token.NUMBER, 'value': '12345'}]"",
            ""is_string_token = lambda n: n['type'] == token.String"",
            ""iter_fexpr_spans = lambda value: [(i, j) for i, j in enumerate(value) if '{' in value[i:j]]"",
            ""is_number_token = lambda n: n['type'] == token.NUMBER"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any"",
            ""import token"",
            ""import ast""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return ['f\""example {1=}\""', 42, token.SLASH]\n\nnode = MockNode()"",
            ""is_string_token = lambda n: isinstance(n, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, (int, float))"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""class MockNode:\n    def pre_order(self):\n        return [token.STRING, 42]  # Sample node containing a string and an integer\n\nnode = MockNode()"",
            ""def is_string_token(n):\n    return isinstance(n, str) or (hasattr(n, 'type') and n.type == token.STRING)"",
            ""def iter_fexpr_spans(value):\n    if 'f' in value:\n        return [(0, len(value))]\n    return []"",
            ""def is_number_token(n):\n    return isinstance(n, (int, float))"",
            ""STARS = {token.STAR, token.SLASH}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.UNPACKING_ON_FLOW}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict"",
            ""import token"",
            ""import sys"",
            ""from unittest.mock import Mock""
        ],
        ""initialization"": [
            ""class Feature:\n    F_STRINGS = 'f_strings'\n    DEBUG_F_STRINGS = 'debug_f_strings'\n    NUMERIC_UNDERSCORES = 'numeric_underscores'\n    POS_ONLY_ARGUMENTS = 'pos_only_arguments'\n    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'\n    RELAXED_DECORATORS = 'relaxed_decorators'\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'\n    UNPACKING_ON_FLOW = 'unpacking_on_flow'\n    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'\n    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'\n    PATTERN_MATCHING = 'pattern_matching'\n    EXCEPT_STAR = 'except_star'\n    VARIADIC_GENERICS = 'variadic_generics'"",
            ""future_imports = []"",
            ""node = Mock()"",
            ""node.pre_order.return_value = []"",
            ""is_string_token = lambda n: isinstance(n, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))]"",
            ""is_number_token = lambda n: isinstance(n, (int, float))"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS}"",
            ""STARS = {token.STAR}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict"",
            ""import token"",
            ""import sys"",
            ""from unittest.mock import MagicMock""
        ],
        ""initialization"": [
            ""Feature = type('Feature', (), { 'F_STRINGS': 'f_strings', 'DEBUG_F_STRINGS': 'debug_f_strings', 'NUMERIC_UNDERSCORES': 'numeric_underscores', 'POS_ONLY_ARGUMENTS': 'pos_only_arguments', 'ASSIGNMENT_EXPRESSIONS': 'assignment_expressions', 'RELAXED_DECORATORS': 'relaxed_decorators', 'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call', 'UNPACKING_ON_FLOW': 'unpacking_on_flow', 'ANN_ASSIGN_EXTENDED_RHS': 'ann_assign_extended_rhs', 'PARENTHESIZED_CONTEXT_MANAGERS': 'parenthesized_context_managers', 'PATTERN_MATCHING': 'pattern_matching', 'EXCEPT_STAR': 'except_star', 'VARIADIC_GENERICS': 'variadic_generics' })"",
            ""future_imports = []"",
            ""node = MagicMock()"",
            ""node.pre_order.return_value = [[MagicMock(value='f-string example')], MagicMock(value='42'), token.SLASH]"",
            ""is_string_token = lambda n: isinstance(n, str)"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] if 'f' in value else []"",
            ""is_number_token = lambda n: isinstance(n, (int, float))"",
            ""STARS = {token.STAR, token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.NUMERIC_UNDERSCORES}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any"",
            ""import token"",
            ""import syms"",
            ""from unittest.mock import MagicMock""
        ],
        ""initialization"": [
            ""Feature = type('Feature', (), { 'F_STRINGS': 'f_strings', 'DEBUG_F_STRINGS': 'debug_f_strings', 'NUMERIC_UNDERSCORES': 'numeric_underscores', 'POS_ONLY_ARGUMENTS': 'pos_only_arguments', 'ASSIGNMENT_EXPRESSIONS': 'assignment_expressions', 'RELAXED_DECORATORS': 'relaxed_decorators', 'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call', 'UNPACKING_ON_FLOW': 'unpacking_on_flow', 'ANN_ASSIGN_EXTENDED_RHS': 'ann_assign_extended_rhs', 'PARENTHESIZED_CONTEXT_MANAGERS': 'parenthesized_context_managers', 'PATTERN_MATCHING': 'pattern_matching', 'EXCEPT_STAR': 'except_star', 'VARIADIC_GENERICS': 'variadic_generics' })"",
            ""future_imports = []"",
            ""node = MagicMock()"",
            ""node.pre_order.return_value = []"",
            ""is_string_token = lambda n: isinstance(n, str) and n.startswith('f')"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] if 'f' in value else []"",
            ""is_number_token = lambda n: isinstance(n, (int, float, str)) and '_' in str(n)"",
            ""STARS = {token.STAR}"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.NUMERIC_UNDERSCORES}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from unittest.mock import MagicMock # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""node = MagicMock() # pragma: no cover"",
            ""node.pre_order.return_value = [] # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float)) # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.NUMERIC_UNDERSCORES} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from unittest.mock import MagicMock # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""node = MagicMock() # pragma: no cover"",
            ""node.pre_order.return_value = [] # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float)) # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""node = Mock() # pragma: no cover"",
            ""node.pre_order = Mock(return_value=[]) # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, (int, float, str)) and '_' in n if isinstance(n, str) else False # pragma: no cover"",
            ""STARS = [token.STAR] # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, List, Dict, Any # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return ['f\""Example of f-string: {var}\""', '42']# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n): return isinstance(n, str) # pragma: no cover"",
            ""def iter_fexpr_spans(value): return [(0, len(value))] # pragma: no cover"",
            ""def is_number_token(n): return isinstance(n, (int, float)) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from unittest.mock import MagicMock # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = type('Feature', (), { 'F_STRINGS': 'f_strings', 'DEBUG_F_STRINGS': 'debug_f_strings', 'NUMERIC_UNDERSCORES': 'numeric_underscores', 'POS_ONLY_ARGUMENTS': 'pos_only_arguments', 'ASSIGNMENT_EXPRESSIONS': 'assignment_expressions', 'RELAXED_DECORATORS': 'relaxed_decorators', 'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call', 'UNPACKING_ON_FLOW': 'unpacking_on_flow', 'ANN_ASSIGN_EXTENDED_RHS': 'ann_assign_extended_rhs', 'PARENTHESIZED_CONTEXT_MANAGERS': 'parenthesized_context_managers', 'PATTERN_MATCHING': 'pattern_matching', 'EXCEPT_STAR': 'except_star', 'VARIADIC_GENERICS': 'variadic_generics', }) # pragma: no cover"",
            ""node = MagicMock() # pragma: no cover"",
            ""is_string_token = lambda n: n['type'] == token.String # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(i, j) for i, j in enumerate(value) if '{' in value[i:j]] # pragma: no cover"",
            ""is_number_token = lambda n: n['type'] == token.NUMBER # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import ast # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return ['f\""example {1=}\""', 42, token.SLASH]# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float)) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.F_STRINGS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [token.STRING, 42]  # Sample node containing a string and an integer# pragma: no cover"",
            ""# pragma: no cover"",
            ""node = MockNode() # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return isinstance(n, str) or (hasattr(n, 'type') and n.type == token.STRING) # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    if 'f' in value:# pragma: no cover"",
            ""        return [(0, len(value))]# pragma: no cover"",
            ""    return [] # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return isinstance(n, (int, float)) # pragma: no cover"",
            ""STARS = {token.STAR, token.SLASH} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.UNPACKING_ON_FLOW} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from unittest.mock import Mock # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature:# pragma: no cover"",
            ""    F_STRINGS = 'f_strings'# pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'debug_f_strings'# pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'numeric_underscores'# pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'pos_only_arguments'# pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'# pragma: no cover"",
            ""    RELAXED_DECORATORS = 'relaxed_decorators'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'# pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'unpacking_on_flow'# pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'# pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'# pragma: no cover"",
            ""    PATTERN_MATCHING = 'pattern_matching'# pragma: no cover"",
            ""    EXCEPT_STAR = 'except_star'# pragma: no cover"",
            ""    VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""node = Mock() # pragma: no cover"",
            ""node.pre_order.return_value = [] # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float)) # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.ANN_ASSIGN_EXTENDED_RHS} # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from unittest.mock import MagicMock # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = type('Feature', (), { 'F_STRINGS': 'f_strings', 'DEBUG_F_STRINGS': 'debug_f_strings', 'NUMERIC_UNDERSCORES': 'numeric_underscores', 'POS_ONLY_ARGUMENTS': 'pos_only_arguments', 'ASSIGNMENT_EXPRESSIONS': 'assignment_expressions', 'RELAXED_DECORATORS': 'relaxed_decorators', 'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call', 'UNPACKING_ON_FLOW': 'unpacking_on_flow', 'ANN_ASSIGN_EXTENDED_RHS': 'ann_assign_extended_rhs', 'PARENTHESIZED_CONTEXT_MANAGERS': 'parenthesized_context_managers', 'PATTERN_MATCHING': 'pattern_matching', 'EXCEPT_STAR': 'except_star', 'VARIADIC_GENERICS': 'variadic_generics' }) # pragma: no cover"",
            ""node = MagicMock() # pragma: no cover"",
            ""node.pre_order.return_value = [[MagicMock(value='f-string example')], MagicMock(value='42'), token.SLASH] # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] if 'f' in value else [] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float)) # pragma: no cover"",
            ""STARS = {token.STAR, token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.NUMERIC_UNDERSCORES} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set, Dict, Any # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from unittest.mock import MagicMock # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = type('Feature', (), { 'F_STRINGS': 'f_strings', 'DEBUG_F_STRINGS': 'debug_f_strings', 'NUMERIC_UNDERSCORES': 'numeric_underscores', 'POS_ONLY_ARGUMENTS': 'pos_only_arguments', 'ASSIGNMENT_EXPRESSIONS': 'assignment_expressions', 'RELAXED_DECORATORS': 'relaxed_decorators', 'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', 'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call', 'UNPACKING_ON_FLOW': 'unpacking_on_flow', 'ANN_ASSIGN_EXTENDED_RHS': 'ann_assign_extended_rhs', 'PARENTHESIZED_CONTEXT_MANAGERS': 'parenthesized_context_managers', 'PATTERN_MATCHING': 'pattern_matching', 'EXCEPT_STAR': 'except_star', 'VARIADIC_GENERICS': 'variadic_generics' }) # pragma: no cover"",
            ""node = MagicMock() # pragma: no cover"",
            ""node.pre_order.return_value = [] # pragma: no cover"",
            ""is_string_token = lambda n: isinstance(n, str) and n.startswith('f') # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(0, len(value))] if 'f' in value else [] # pragma: no cover"",
            ""is_number_token = lambda n: isinstance(n, (int, float, str)) and '_' in str(n) # pragma: no cover"",
            ""STARS = {token.STAR} # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.NUMERIC_UNDERSCORES} # pragma: no cover""
        ]
    }
]",2,8266,0.004133,3744,0.005616,0.009749
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return a set of (relatively) new Python features used in this file.
    Currently looking for:
    - f-strings;
    - self-documenting expressions in f-strings (f""{x=}"");
    - underscores in numeric literals;
    - trailing commas after * or ** in function signatures and calls;
    - positional only arguments in function signatures and lambdas;
    - assignment expression;
    - relaxed decorator syntax;
    - usage of __future__ flags (annotations);
    - print / exec statements;
    - parenthesized context managers;
    - match statements;
    - except* clause;
    - variadic generics;
    """"""
features: Set[Feature] = set()
if future_imports: # uncovered
    features |= { # uncovered
        FUTURE_FLAG_TO_FEATURE[future_import] # uncovered
        for future_import in future_imports # uncovered
        if future_import in FUTURE_FLAG_TO_FEATURE # uncovered
    } # uncovered
for n in node.pre_order(): # uncovered
    if is_string_token(n): # uncovered
        value_head = n.value[:2] # uncovered
        if value_head in {'f""', 'F""', ""f'"", ""F'"", ""rf"", ""fr"", ""RF"", ""FR""}: # uncovered
            features.add(Feature.F_STRINGS) # uncovered
            if Feature.DEBUG_F_STRINGS not in features: # uncovered
                for span_beg, span_end in iter_fexpr_spans(n.value): # uncovered
                    if n.value[span_beg : span_end - 1].rstrip().endswith(""=""): # uncovered
                        features.add(Feature.DEBUG_F_STRINGS) # uncovered
                        break # uncovered
    elif is_number_token(n): # uncovered
        if ""_"" in n.value: # uncovered
            features.add(Feature.NUMERIC_UNDERSCORES) # uncovered
    elif n.type == token.SLASH: # uncovered
        if n.parent and n.parent.type in { # uncovered
            syms.typedargslist, # uncovered
            syms.arglist, # uncovered
            syms.varargslist, # uncovered
        }: # uncovered
            features.add(Feature.POS_ONLY_ARGUMENTS) # uncovered
    elif n.type == token.COLONEQUAL: # uncovered
        features.add(Feature.ASSIGNMENT_EXPRESSIONS) # uncovered
    elif n.type == syms.decorator: # uncovered
        if len(n.children) > 1 and not is_simple_decorator_expression( # uncovered
            n.children[1] # uncovered
        ): # uncovered
            features.add(Feature.RELAXED_DECORATORS) # uncovered
    elif ( # uncovered
        n.type in {syms.typedargslist, syms.arglist} # uncovered
        and n.children # uncovered
        and n.children[-1].type == token.COMMA # uncovered
    ): # uncovered
        if n.type == syms.typedargslist: # uncovered
            feature = Feature.TRAILING_COMMA_IN_DEF # uncovered
        else: # uncovered
            feature = Feature.TRAILING_COMMA_IN_CALL # uncovered
        for ch in n.children: # uncovered
            if ch.type in STARS: # uncovered
                features.add(feature) # uncovered
            if ch.type == syms.argument: # uncovered
                for argch in ch.children: # uncovered
                    if argch.type in STARS: # uncovered
                        features.add(feature) # uncovered
    elif ( # uncovered
        n.type in {syms.return_stmt, syms.yield_expr} # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == syms.testlist_star_expr # uncovered
        and any(child.type == syms.star_expr for child in n.children[1].children) # uncovered
    ): # uncovered
        features.add(Feature.UNPACKING_ON_FLOW) # uncovered
    elif ( # uncovered
        n.type == syms.annassign # uncovered
        and len(n.children) >= 4 # uncovered
        and n.children[3].type == syms.testlist_star_expr # uncovered
    ): # uncovered
        features.add(Feature.ANN_ASSIGN_EXTENDED_RHS) # uncovered
    elif ( # uncovered
        n.type == syms.with_stmt # uncovered
        and len(n.children) > 2 # uncovered
        and n.children[1].type == syms.atom # uncovered
    ): # uncovered
        atom_children = n.children[1].children # uncovered
        if ( # uncovered
            len(atom_children) == 3 # uncovered
            and atom_children[0].type == token.LPAR # uncovered
            and atom_children[1].type == syms.testlist_gexp # uncovered
            and atom_children[2].type == token.RPAR # uncovered
        ): # uncovered
            features.add(Feature.PARENTHESIZED_CONTEXT_MANAGERS) # uncovered
    elif n.type == syms.match_stmt: # uncovered
        features.add(Feature.PATTERN_MATCHING) # uncovered
    elif ( # uncovered
        n.type == syms.except_clause # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == token.STAR # uncovered
    ): # uncovered
        features.add(Feature.EXCEPT_STAR) # uncovered
    elif n.type in {syms.subscriptlist, syms.trailer} and any( # uncovered
        child.type == syms.star_expr for child in n.children # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
    elif ( # uncovered
        n.type == syms.tname_star # uncovered
        and len(n.children) == 3 # uncovered
        and n.children[2].type == syms.star_expr # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
aux = features # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from my_module import Feature, FUTURE_FLAG_TO_FEATURE, syms, is_string_token, is_number_token, iter_fexpr_spans, is_simple_decorator_expression""
        ],
        ""initialization"": [
            ""future_imports = ['annotations']"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.FUTURE_ANNOTATIONS}"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [{'type': token.STRING, 'value': 'f\""test=\""', 'parent': None}]})()"",
            ""STARS = {token.STAR, token.STARCOMMA}"",
            ""Feature = type('Feature', (object,), {'F_STRINGS': 1, 'DEBUG_F_STRINGS': 2, 'NUMERIC_UNDERSCORES': 3, 'POS_ONLY_ARGUMENTS': 4, 'ASSIGNMENT_EXPRESSIONS': 5, 'RELAXED_DECORATORS': 6, 'TRAILING_COMMA_IN_DEF': 7, 'TRAILING_COMMA_IN_CALL': 8, 'UNPACKING_ON_FLOW': 9, 'ANN_ASSIGN_EXTENDED_RHS': 10, 'PARENTHESIZED_CONTEXT_MANAGERS': 11, 'PATTERN_MATCHING': 12, 'EXCEPT_STAR': 13, 'VARIADIC_GENERICS': 14, 'FUTURE_ANNOTATIONS': 15})"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'star_expr': 14, 'atom': 15, 'testlist_gexp': 16, 'argument': 17})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms"",
            ""from your_feature_module import Feature, FUTURE_FLAG_TO_FEATURE""
        ],
        ""initialization"": [
            ""future_imports = ['annotations']"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.FUTURE_ANNOTATIONS}"",
            ""class MockNode:  # Mock class to simulate nodes in a parse tree\n    def pre_order(self):\n        return [MockToken('f\""Hello, World!\""'), MockToken('42')]"",
            ""class MockToken:\n    def __init__(self, value):\n        self.value = value\n        self.type = token.STRING if value.startswith('f') else token.NUMBER\n        self.parent = None"",
            ""def is_string_token(n):\n    return n.type == token.STRING"",
            ""def is_number_token(n):\n    return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value):\n    # Dummy implementation to simulate f-string span extraction\n    return [(0, len(value))]"",
            ""STARS = {token.STAR, token.DOUBLE_STAR}"",
            ""nodes = MockNode()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""future_imports = []"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""class MockNode: def __init__(self, value, node_type, parent=None, children=None): self.value = value; self.type = node_type; self.parent = parent; self.children = children or []"",
            ""def is_string_token(n): return isinstance(n, MockNode) and n.type == token.STRING"",
            ""def is_number_token(n): return isinstance(n, MockNode) and n.type == token.NUMBER"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""n = MockNode('f\""example=\""', token.STRING); node = type('MockNodeList', (list,), {'pre_order': lambda self: [n]})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""future_imports = ['annotations']"",
            ""Feature = type('Feature', (), {"",
            ""    'F_STRINGS': 'f_strings',"",
            ""    'DEBUG_F_STRINGS': 'debug_f_strings',"",
            ""    'NUMERIC_UNDERSCORES': 'numeric_underscores',"",
            ""    'POS_ONLY_ARGUMENTS': 'pos_only_arguments',"",
            ""    'ASSIGNMENT_EXPRESSIONS': 'assignment_expressions',"",
            ""    'RELAXED_DECORATORS': 'relaxed_decorators',"",
            ""    'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def',"",
            ""    'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call',"",
            ""    'UNPACKING_ON_FLOW': 'unpacking_on_flow',"",
            ""    'ANN_ASSIGN_EXTENDED_RHS': 'ann_assign_extended_rhs',"",
            ""    'PARENTHESIZED_CONTEXT_MANAGERS': 'parenthesized_context_managers',"",
            ""    'PATTERN_MATCHING': 'pattern_matching',"",
            ""    'EXCEPT_STAR': 'except_star',"",
            ""    'VARIADIC_GENERICS': 'variadic_generics',"",
            ""})"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('MockToken', (object,), {'type': token.STRING, 'value': 'f{var}', 'parent': None})()]})()"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.isdigit()"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""aux = None""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': 'Feature.FUTURE_ANNOTATIONS',"",
            ""}"",
            ""future_imports = ['annotations']"",
            ""class Feature:"",
            ""    F_STRINGS = 'F_STRINGS'"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [], 'children': []})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""future_imports = []"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""def is_string_token(n): return hasattr(n, 'type') and n.type == token.STRING"",
            ""def is_number_token(n): return hasattr(n, 'type') and n.type == token.NUMBER"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('MockToken', (object,), {'type': token.STRING, 'value': 'f{var}', 'parent': None})())]})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from some_module import Feature, FUTURE_FLAG_TO_FEATURE, future_imports, is_string_token, is_number_token, iter_fexpr_spans, is_simple_decorator_expression, STARS, syms""
        ],
        ""initialization"": [
            ""future_imports = ['annotations']"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.FUTURE_ANNOTATIONS}"",
            ""class Feature: F_STRINGS = 'f-strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'positional_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations'"",
            ""class MockNode: def __init__(self, value, typ, children=[]): self.value = value; self.type = typ; self.children = children; self.parent = None for child in children: child.parent = self"",
            ""node = MockNode('', token.STRING, [MockNode('f\""Hello, {name=} f-string!\""', token.STRING)])"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value): return [(2, 3)]"",
            ""def is_simple_decorator_expression(n): return True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('syms', (), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'varargslist': 'varargslist', 'return_stmt': 'return_stmt', 'yield_expr': 'yield_expr', 'annassign': 'annassign', 'with_stmt': 'with_stmt', 'except_clause': 'except_clause', 'match_stmt': 'match_stmt', 'argument': 'argument', 'testlist_star_expr': 'testlist_star_expr', 'tname_star': 'tname_star', 'subscriptlist': 'subscriptlist', 'trailer': 'trailer'})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.DEBUG_F_STRINGS'}"",
            ""future_imports = ['annotations']"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('MockToken', (object,), {'value': 'f{x=1}', 'type': token.STRING})()]})()})()"",
            ""Feature = type('Feature', (), {'F_STRINGS': 'F_STRINGS', 'DEBUG_F_STRINGS': 'DEBUG_F_STRINGS', 'NUMERIC_UNDERSCORES': 'NUMERIC_UNDERSCORES', 'POS_ONLY_ARGUMENTS': 'POS_ONLY_ARGUMENTS', 'ASSIGNMENT_EXPRESSIONS': 'ASSIGNMENT_EXPRESSIONS', 'RELAXED_DECORATORS': 'RELAXED_DECORATORS', 'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL', 'UNPACKING_ON_FLOW': 'UNPACKING_ON_FLOW', 'ANN_ASSIGN_EXTENDED_RHS': 'ANN_ASSIGN_EXTENDED_RHS', 'PARENTHESIZED_CONTEXT_MANAGERS': 'PARENTHESIZED_CONTEXT_MANAGERS', 'PATTERN_MATCHING': 'PATTERN_MATCHING', 'EXCEPT_STAR': 'EXCEPT_STAR', 'VARIADIC_GENERICS': 'VARIADIC_GENERICS'})"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.isdigit()"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))]"",
            ""STARS = {token.STAR, token.DOUBLESTAR}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from lib2to3.pgen2 import token"",
            ""from lib2to3 import pygram, pgen2""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS, DEBUG_F_STRINGS, NUMERIC_UNDERSCORES, POS_ONLY_ARGUMENTS, ASSIGNMENT_EXPRESSIONS, RELAXED_DECORATORS, TRAILING_COMMA_IN_DEF, TRAILING_COMMA_IN_CALL, UNPACKING_ON_FLOW, ANN_ASSIGN_EXTENDED_RHS, PARENTHESIZED_CONTEXT_MANAGERS, PATTERN_MATCHING, EXCEPT_STAR, VARIADIC_GENERICS = range(13)"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [MockToken('f\""', token.STRING), MockToken('1_000', token.NUMBER)]})()"",
            ""class MockToken: def __init__(self, value, type): self.value = value; self.type = type; self.parent = None"",
            ""STARS = {token.STAR, token.STAR_expr}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 'typedargslist', 'arglist':'arglist', 'varargslist':'varargslist', 'return_stmt':'return_stmt', 'yield_expr':'yield_expr', 'annassign':'annassign', 'with_stmt':'with_stmt', 'match_stmt':'match_stmt', 'except_clause':'except_clause', 'subscriptlist':'subscriptlist', 'trailer':'trailer', 'tname_star':'tname_star', 'testlist_star_expr':'testlist_star_expr', 'star_expr':'star_expr', 'testlist_gexp':'testlist_gexp', 'atom':'atom', 'argument':'argument'})"",
            ""def is_string_token(token): return token.type == token.STRING"",
            ""def is_number_token(token): return token.type == token.NUMBER"",
            ""def is_simple_decorator_expression(child): return False"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms"",
            ""from collections import namedtuple""
        ],
        ""initialization"": [
            ""Feature = namedtuple('Feature', ['F_STRINGS', 'DEBUG_F_STRINGS', 'NUMERIC_UNDERSCORES', 'POS_ONLY_ARGUMENTS', 'ASSIGNMENT_EXPRESSIONS', 'RELAXED_DECORATORS', 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL', 'UNPACKING_ON_FLOW', 'ANN_ASSIGN_EXTENDED_RHS', 'PARENTHESIZED_CONTEXT_MANAGERS', 'PATTERN_MATCHING', 'EXCEPT_STAR', 'VARIADIC_GENERICS'])"",
            ""Feature.F_STRINGS = 'f-strings'"",
            ""Feature.DEBUG_F_STRINGS = 'debug f-strings'"",
            ""Feature.NUMERIC_UNDERSCORES = 'numeric underscores'"",
            ""Feature.POS_ONLY_ARGUMENTS = 'positional only arguments'"",
            ""Feature.ASSIGNMENT_EXPRESSIONS = 'assignment expressions'"",
            ""Feature.RELAXED_DECORATORS = 'relaxed decorators'"",
            ""Feature.TRAILING_COMMA_IN_DEF = 'trailing comma in function definition'"",
            ""Feature.TRAILING_COMMA_IN_CALL = 'trailing comma in function call'"",
            ""Feature.UNPACKING_ON_FLOW = 'unpacking on flow'"",
            ""Feature.ANN_ASSIGN_EXTENDED_RHS = 'annotation assignment with extended rhs'"",
            ""Feature.PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers'"",
            ""Feature.PATTERN_MATCHING = 'pattern matching'"",
            ""Feature.EXCEPT_STAR = 'except star'"",
            ""Feature.VARIADIC_GENERICS = 'variadic generics'"",
            ""future_imports = ['annotations']"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.NUMERIC_UNDERSCORES}"",
            ""node = Mock(pre_order=Mock(return_value=[Mock(type=token.STRING, value='f{var=}')]))"",
            ""is_string_token = lambda n: n.type == token.STRING"",
            ""is_number_token = lambda n: n.type == token.NUMBER"",
            ""iter_fexpr_spans = lambda value: [(2, 9)]"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""is_simple_decorator_expression = lambda n: False"",
            ""aux = set()""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [{'type': token.STRING, 'value': 'f\""test=\""', 'parent': None}]})() # pragma: no cover"",
            ""Feature = type('Feature', (object,), {'F_STRINGS': 1, 'DEBUG_F_STRINGS': 2, 'NUMERIC_UNDERSCORES': 3, 'POS_ONLY_ARGUMENTS': 4, 'ASSIGNMENT_EXPRESSIONS': 5, 'RELAXED_DECORATORS': 6, 'TRAILING_COMMA_IN_DEF': 7, 'TRAILING_COMMA_IN_CALL': 8, 'UNPACKING_ON_FLOW': 9, 'ANN_ASSIGN_EXTENDED_RHS': 10, 'PARENTHESIZED_CONTEXT_MANAGERS': 11, 'PATTERN_MATCHING': 12, 'EXCEPT_STAR': 13, 'VARIADIC_GENERICS': 14, 'FUTURE_ANNOTATIONS': 15}) # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'star_expr': 14, 'atom': 15, 'testlist_gexp': 16, 'argument': 17}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockNode:  # Mock class to simulate nodes in a parse tree# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [MockToken('f\""Hello, World!\""'), MockToken('42')] # pragma: no cover"",
            ""class MockToken:# pragma: no cover"",
            ""    def __init__(self, value):# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.type = token.STRING if value.startswith('f') else token.NUMBER# pragma: no cover"",
            ""        self.parent = None # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return n.type == token.STRING # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return n.type == token.NUMBER # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    # Dummy implementation to simulate f-string span extraction# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""nodes = MockNode() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""Feature = type('Feature', (), { # pragma: no cover"",
            ""    'F_STRINGS': 'f_strings', # pragma: no cover"",
            ""    'DEBUG_F_STRINGS': 'debug_f_strings', # pragma: no cover"",
            ""    'NUMERIC_UNDERSCORES': 'numeric_underscores', # pragma: no cover"",
            ""    'POS_ONLY_ARGUMENTS': 'pos_only_arguments', # pragma: no cover"",
            ""    'ASSIGNMENT_EXPRESSIONS': 'assignment_expressions', # pragma: no cover"",
            ""    'RELAXED_DECORATORS': 'relaxed_decorators', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call', # pragma: no cover"",
            ""    'UNPACKING_ON_FLOW': 'unpacking_on_flow', # pragma: no cover"",
            ""    'ANN_ASSIGN_EXTENDED_RHS': 'ann_assign_extended_rhs', # pragma: no cover"",
            ""    'PARENTHESIZED_CONTEXT_MANAGERS': 'parenthesized_context_managers', # pragma: no cover"",
            ""    'PATTERN_MATCHING': 'pattern_matching', # pragma: no cover"",
            ""    'EXCEPT_STAR': 'except_star', # pragma: no cover"",
            ""    'VARIADIC_GENERICS': 'variadic_generics', # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('MockToken', (object,), {'type': token.STRING, 'value': 'f{var}', 'parent': None})()]})() # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.isdigit() # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""aux = None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': 'Feature.FUTURE_ANNOTATIONS', # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING' # pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [], 'children': []})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'f-strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'positional_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = type('Feature', (), {'F_STRINGS': 'F_STRINGS', 'DEBUG_F_STRINGS': 'DEBUG_F_STRINGS', 'NUMERIC_UNDERSCORES': 'NUMERIC_UNDERSCORES', 'POS_ONLY_ARGUMENTS': 'POS_ONLY_ARGUMENTS', 'ASSIGNMENT_EXPRESSIONS': 'ASSIGNMENT_EXPRESSIONS', 'RELAXED_DECORATORS': 'RELAXED_DECORATORS', 'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL', 'UNPACKING_ON_FLOW': 'UNPACKING_ON_FLOW', 'ANN_ASSIGN_EXTENDED_RHS': 'ANN_ASSIGN_EXTENDED_RHS', 'PARENTHESIZED_CONTEXT_MANAGERS': 'PARENTHESIZED_CONTEXT_MANAGERS', 'PATTERN_MATCHING': 'PATTERN_MATCHING', 'EXCEPT_STAR': 'EXCEPT_STAR', 'VARIADIC_GENERICS': 'VARIADIC_GENERICS'}) # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.isdigit() # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from lib2to3.pgen2 import token # pragma: no cover"",
            ""from lib2to3 import pygram, pgen2 # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [MockToken('f\""', token.STRING), MockToken('1_000', token.NUMBER)]})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = namedtuple('Feature', ['F_STRINGS', 'DEBUG_F_STRINGS', 'NUMERIC_UNDERSCORES', 'POS_ONLY_ARGUMENTS', 'ASSIGNMENT_EXPRESSIONS', 'RELAXED_DECORATORS', 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL', 'UNPACKING_ON_FLOW', 'ANN_ASSIGN_EXTENDED_RHS', 'PARENTHESIZED_CONTEXT_MANAGERS', 'PATTERN_MATCHING', 'EXCEPT_STAR', 'VARIADIC_GENERICS']) # pragma: no cover"",
            ""Feature.F_STRINGS = 'f-strings' # pragma: no cover"",
            ""Feature.DEBUG_F_STRINGS = 'debug f-strings' # pragma: no cover"",
            ""Feature.NUMERIC_UNDERSCORES = 'numeric underscores' # pragma: no cover"",
            ""Feature.POS_ONLY_ARGUMENTS = 'positional only arguments' # pragma: no cover"",
            ""Feature.ASSIGNMENT_EXPRESSIONS = 'assignment expressions' # pragma: no cover"",
            ""Feature.RELAXED_DECORATORS = 'relaxed decorators' # pragma: no cover"",
            ""Feature.TRAILING_COMMA_IN_DEF = 'trailing comma in function definition' # pragma: no cover"",
            ""Feature.TRAILING_COMMA_IN_CALL = 'trailing comma in function call' # pragma: no cover"",
            ""Feature.UNPACKING_ON_FLOW = 'unpacking on flow' # pragma: no cover"",
            ""Feature.ANN_ASSIGN_EXTENDED_RHS = 'annotation assignment with extended rhs' # pragma: no cover"",
            ""Feature.PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers' # pragma: no cover"",
            ""Feature.PATTERN_MATCHING = 'pattern matching' # pragma: no cover"",
            ""Feature.EXCEPT_STAR = 'except star' # pragma: no cover"",
            ""Feature.VARIADIC_GENERICS = 'variadic generics' # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.NUMERIC_UNDERSCORES} # pragma: no cover"",
            ""is_string_token = lambda n: n.type == token.STRING # pragma: no cover"",
            ""is_number_token = lambda n: n.type == token.NUMBER # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(2, 9)] # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: False # pragma: no cover"",
            ""aux = set() # pragma: no cover""
        ]
    }
]",3,1561,0.0007805,4251,0.0063765,0.007157
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return a set of (relatively) new Python features used in this file.
    Currently looking for:
    - f-strings;
    - self-documenting expressions in f-strings (f""{x=}"");
    - underscores in numeric literals;
    - trailing commas after * or ** in function signatures and calls;
    - positional only arguments in function signatures and lambdas;
    - assignment expression;
    - relaxed decorator syntax;
    - usage of __future__ flags (annotations);
    - print / exec statements;
    - parenthesized context managers;
    - match statements;
    - except* clause;
    - variadic generics;
    """"""
features: Set[Feature] = set()
if future_imports: # uncovered
    features |= { # uncovered
        FUTURE_FLAG_TO_FEATURE[future_import] # uncovered
        for future_import in future_imports # uncovered
        if future_import in FUTURE_FLAG_TO_FEATURE # uncovered
    } # uncovered
for n in node.pre_order(): # uncovered
    if is_string_token(n): # uncovered
        value_head = n.value[:2] # uncovered
        if value_head in {'f""', 'F""', ""f'"", ""F'"", ""rf"", ""fr"", ""RF"", ""FR""}: # uncovered
            features.add(Feature.F_STRINGS) # uncovered
            if Feature.DEBUG_F_STRINGS not in features: # uncovered
                for span_beg, span_end in iter_fexpr_spans(n.value): # uncovered
                    if n.value[span_beg : span_end - 1].rstrip().endswith(""=""): # uncovered
                        features.add(Feature.DEBUG_F_STRINGS) # uncovered
                        break # uncovered
    elif is_number_token(n): # uncovered
        if ""_"" in n.value: # uncovered
            features.add(Feature.NUMERIC_UNDERSCORES) # uncovered
    elif n.type == token.SLASH: # uncovered
        if n.parent and n.parent.type in { # uncovered
            syms.typedargslist, # uncovered
            syms.arglist, # uncovered
            syms.varargslist, # uncovered
        }: # uncovered
            features.add(Feature.POS_ONLY_ARGUMENTS) # uncovered
    elif n.type == token.COLONEQUAL: # uncovered
        features.add(Feature.ASSIGNMENT_EXPRESSIONS) # uncovered
    elif n.type == syms.decorator: # uncovered
        if len(n.children) > 1 and not is_simple_decorator_expression( # uncovered
            n.children[1] # uncovered
        ): # uncovered
            features.add(Feature.RELAXED_DECORATORS) # uncovered
    elif ( # uncovered
        n.type in {syms.typedargslist, syms.arglist} # uncovered
        and n.children # uncovered
        and n.children[-1].type == token.COMMA # uncovered
    ): # uncovered
        if n.type == syms.typedargslist: # uncovered
            feature = Feature.TRAILING_COMMA_IN_DEF # uncovered
        else: # uncovered
            feature = Feature.TRAILING_COMMA_IN_CALL # uncovered
        for ch in n.children: # uncovered
            if ch.type in STARS: # uncovered
                features.add(feature) # uncovered
            if ch.type == syms.argument: # uncovered
                for argch in ch.children: # uncovered
                    if argch.type in STARS: # uncovered
                        features.add(feature) # uncovered
    elif ( # uncovered
        n.type in {syms.return_stmt, syms.yield_expr} # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == syms.testlist_star_expr # uncovered
        and any(child.type == syms.star_expr for child in n.children[1].children) # uncovered
    ): # uncovered
        features.add(Feature.UNPACKING_ON_FLOW) # uncovered
    elif ( # uncovered
        n.type == syms.annassign # uncovered
        and len(n.children) >= 4 # uncovered
        and n.children[3].type == syms.testlist_star_expr # uncovered
    ): # uncovered
        features.add(Feature.ANN_ASSIGN_EXTENDED_RHS) # uncovered
    elif ( # uncovered
        n.type == syms.with_stmt # uncovered
        and len(n.children) > 2 # uncovered
        and n.children[1].type == syms.atom # uncovered
    ): # uncovered
        atom_children = n.children[1].children # uncovered
        if ( # uncovered
            len(atom_children) == 3 # uncovered
            and atom_children[0].type == token.LPAR # uncovered
            and atom_children[1].type == syms.testlist_gexp # uncovered
            and atom_children[2].type == token.RPAR # uncovered
        ): # uncovered
            features.add(Feature.PARENTHESIZED_CONTEXT_MANAGERS) # uncovered
    elif n.type == syms.match_stmt: # uncovered
        features.add(Feature.PATTERN_MATCHING) # uncovered
    elif ( # uncovered
        n.type == syms.except_clause # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == token.STAR # uncovered
    ): # uncovered
        features.add(Feature.EXCEPT_STAR) # uncovered
    elif n.type in {syms.subscriptlist, syms.trailer} and any( # uncovered
        child.type == syms.star_expr for child in n.children # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
    elif ( # uncovered
        n.type == syms.tname_star # uncovered
        and len(n.children) == 3 # uncovered
        and n.children[2].type == syms.star_expr # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
aux = features # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""class MockNode: def __init__(self, value, n_type, parent=None): self.value = value; self.type = n_type; self.parent = parent; self.children = []"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""node = MockNode('f\""test={1}\""', token.STRING)"",
            ""def iter_fexpr_spans(value): return [(2, 6)]"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('syms', (object,), {'typedargslist': 'TYPEDARGSLIST', 'arglist': 'ARGLIST', 'varargslist': 'VARARGSLIST', 'return_stmt': 'RETURN_STMT', 'yield_expr': 'YIELD_EXPR', 'annassign': 'ANNASSIGN', 'with_stmt': 'WITH_STMT', 'match_stmt': 'MATCH_STMT', 'except_clause': 'EXCEPT_CLAUSE', 'argument': 'ARGUMENT'})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""class MockNode: def __init__(self, value, node_type, children=None): self.value = value; self.type = node_type; self.children = children if children else []; self.parent = None"",
            ""node = MockNode('f\""Hello, {name=}=\""', token.STRING, [])"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""iter_fexpr_spans = lambda value: [(2, len(value) - 1)]"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('MockSyms', (object,), { 'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'argument': 12, 'testlist_star_expr': 13 })""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""future_imports = ['annotations']"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.FUTURE_ANNOTATIONS}"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations'"",
            ""class MockToken: def __init__(self, value, type): self.value = value; self.type = type; self.parent = None"",
            ""class MockNode: def __init__(self, children): self.children = children"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value): return [(2, len(value))]"",
            ""node = MockNode([MockToken('f\""example={1=}\""', token.STRING)])"",
            ""STARS = {token.STAR, token.DOUBLESTAR}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""class MockNode: def __init__(self, value, node_type, parent=None, children=None): self.value = value; self.type = node_type; self.parent = parent; self.children = children or []"",
            ""node = MockNode('f\""example=\""', token.STRING)"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""iter_fexpr_spans = lambda value: [(2, len(value)-1)]"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'star_expr': 14, 'atom': 15, 'argument': 16})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""class MockNode: def __init__(self, value, typ): self.value = value; self.type = typ; self.parent = None; self.children = []"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""node = MockNode('f\""Hello, {name=}!\""', token.STRING)"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('syms', (), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'argument': 14})"",
            ""def iter_fexpr_spans(value): return [(4, 11)]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.NUMERIC_UNDERSCORES'}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""class MockNode: def __init__(self, value, type): self.value = value; self.type = type; self.parent = None; self.children = []"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""node = type('MockNodeList', (object,), {'pre_order': lambda self: [MockNode('f\""example={1=}\""', token.STRING), MockNode('1000', token.NUMBER)]})()"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'star_expr': 14, 'atom': 15 })"",
            ""def iter_fexpr_spans(value): return [(10, len(value))]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""future_imports = ['annotations']"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.FUTURE_ANNOTATIONS}"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS';"",
            ""class MockNode: def __init__(self, value, type, children=None): self.value = value; self.type = type; self.children = children if children is not None else []"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""node = MockNode('f\""example={x=}\""', token.STRING, [])"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('syms', (), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'varargslist': 'varargslist', 'return_stmt': 'return_stmt', 'yield_expr': 'yield_expr', 'annassign': 'annassign', 'with_stmt': 'with_stmt', 'match_stmt': 'match_stmt', 'except_clause': 'except_clause', 'subscriptlist': 'subscriptlist', 'trailer': 'trailer', 'tname_star': 'tname_star', 'testlist_star_expr': 'testlist_star_expr', 'star_expr': 'star_expr', 'atom': 'atom', 'argument': 'argument'})"",
            ""def iter_fexpr_spans(value): return [(2, 10)]"",
            ""aux = None""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from types import SimpleNamespace as syms""
        ],
        ""initialization"": [
            ""future_imports = ['annotations']"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""features = set()"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""class MockNode:  # Mock class to simulate nodes in a parse tree\n    def pre_order(self):\n        return [MockToken('f\""x={0}\""', token.STRING), MockToken('1_000', token.NUMBER)]"",
            ""class MockToken:\n    def __init__(self, value, typ=None):\n        self.value = value\n        self.type = typ or token.STRING\n        self.parent = None"",
            ""def is_string_token(n):\n    return n.type == token.STRING"",
            ""def is_number_token(n):\n    return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value):\n    return [(2, len(value)-1)]"",
            ""node = MockNode()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.FUTURE_ANNOTATIONS}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations'"",
            ""class MockNode: def __init__(self, type, value='', children=None): self.type = type; self.value = value; self.children = children if children is not None else []; self.parent = None"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value): return [(2, len(value) - 1)]"",
            ""node = MockNode(token.SLASH, '', [MockNode(token.STRING, 'f\""Hello, {x=} f-string!\""')])"",
            ""STARS = {token.STAR, token.DOUBLESTAR}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from my_module import Feature, FUTURE_FLAG_TO_FEATURE, syms""
        ],
        ""initialization"": [
            ""future_imports = ['annotations']"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.FUTURE_ANNOTATIONS}"",
            ""class MockNode: def __init__(self, value, type_, children=None): self.value = value; self.type = type_; self.children = children or []; self.parent = None"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""node = MockNode('f\""Hello, {world=}\""', token.STRING, [])"",
            ""def iter_fexpr_spans(value): return [(2, len(value) - 1)]"",
            ""STARS = {token.STAR, token.STAR_COMMA}"",
            ""def is_simple_decorator_expression(n): return False"",
            ""syms = type('MockSyms', (), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'atom': 14, 'argument': 15})""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.NUMERIC_UNDERSCORES'} # pragma: no cover"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS'; # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from types import SimpleNamespace as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:  # Mock class to simulate nodes in a parse tree# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [MockToken('f\""x={0}\""', token.STRING), MockToken('1_000', token.NUMBER)] # pragma: no cover"",
            ""class MockToken:# pragma: no cover"",
            ""    def __init__(self, value, typ=None):# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.type = typ or token.STRING# pragma: no cover"",
            ""        self.parent = None # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return n.type == token.STRING # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return n.type == token.NUMBER # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(2, len(value)-1)] # pragma: no cover"",
            ""node = MockNode() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    }
]",3,7350,0.003675,4608,0.006912,0.010587
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return a set of (relatively) new Python features used in this file.
    Currently looking for:
    - f-strings;
    - self-documenting expressions in f-strings (f""{x=}"");
    - underscores in numeric literals;
    - trailing commas after * or ** in function signatures and calls;
    - positional only arguments in function signatures and lambdas;
    - assignment expression;
    - relaxed decorator syntax;
    - usage of __future__ flags (annotations);
    - print / exec statements;
    - parenthesized context managers;
    - match statements;
    - except* clause;
    - variadic generics;
    """"""
features: Set[Feature] = set()
if future_imports: # uncovered
    features |= { # uncovered
        FUTURE_FLAG_TO_FEATURE[future_import] # uncovered
        for future_import in future_imports # uncovered
        if future_import in FUTURE_FLAG_TO_FEATURE # uncovered
    } # uncovered
for n in node.pre_order(): # uncovered
    if is_string_token(n): # uncovered
        value_head = n.value[:2] # uncovered
        if value_head in {'f""', 'F""', ""f'"", ""F'"", ""rf"", ""fr"", ""RF"", ""FR""}: # uncovered
            features.add(Feature.F_STRINGS) # uncovered
            if Feature.DEBUG_F_STRINGS not in features: # uncovered
                for span_beg, span_end in iter_fexpr_spans(n.value): # uncovered
                    if n.value[span_beg : span_end - 1].rstrip().endswith(""=""): # uncovered
                        features.add(Feature.DEBUG_F_STRINGS) # uncovered
                        break # uncovered
    elif is_number_token(n): # uncovered
        if ""_"" in n.value: # uncovered
            features.add(Feature.NUMERIC_UNDERSCORES) # uncovered
    elif n.type == token.SLASH: # uncovered
        if n.parent and n.parent.type in { # uncovered
            syms.typedargslist, # uncovered
            syms.arglist, # uncovered
            syms.varargslist, # uncovered
        }: # uncovered
            features.add(Feature.POS_ONLY_ARGUMENTS) # uncovered
    elif n.type == token.COLONEQUAL: # uncovered
        features.add(Feature.ASSIGNMENT_EXPRESSIONS) # uncovered
    elif n.type == syms.decorator: # uncovered
        if len(n.children) > 1 and not is_simple_decorator_expression( # uncovered
            n.children[1] # uncovered
        ): # uncovered
            features.add(Feature.RELAXED_DECORATORS) # uncovered
    elif ( # uncovered
        n.type in {syms.typedargslist, syms.arglist} # uncovered
        and n.children # uncovered
        and n.children[-1].type == token.COMMA # uncovered
    ): # uncovered
        if n.type == syms.typedargslist: # uncovered
            feature = Feature.TRAILING_COMMA_IN_DEF # uncovered
        else: # uncovered
            feature = Feature.TRAILING_COMMA_IN_CALL # uncovered
        for ch in n.children: # uncovered
            if ch.type in STARS: # uncovered
                features.add(feature) # uncovered
            if ch.type == syms.argument: # uncovered
                for argch in ch.children: # uncovered
                    if argch.type in STARS: # uncovered
                        features.add(feature) # uncovered
    elif ( # uncovered
        n.type in {syms.return_stmt, syms.yield_expr} # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == syms.testlist_star_expr # uncovered
        and any(child.type == syms.star_expr for child in n.children[1].children) # uncovered
    ): # uncovered
        features.add(Feature.UNPACKING_ON_FLOW) # uncovered
    elif ( # uncovered
        n.type == syms.annassign # uncovered
        and len(n.children) >= 4 # uncovered
        and n.children[3].type == syms.testlist_star_expr # uncovered
    ): # uncovered
        features.add(Feature.ANN_ASSIGN_EXTENDED_RHS) # uncovered
    elif ( # uncovered
        n.type == syms.with_stmt # uncovered
        and len(n.children) > 2 # uncovered
        and n.children[1].type == syms.atom # uncovered
    ): # uncovered
        atom_children = n.children[1].children # uncovered
        if ( # uncovered
            len(atom_children) == 3 # uncovered
            and atom_children[0].type == token.LPAR # uncovered
            and atom_children[1].type == syms.testlist_gexp # uncovered
            and atom_children[2].type == token.RPAR # uncovered
        ): # uncovered
            features.add(Feature.PARENTHESIZED_CONTEXT_MANAGERS) # uncovered
    elif n.type == syms.match_stmt: # uncovered
        features.add(Feature.PATTERN_MATCHING) # uncovered
    elif ( # uncovered
        n.type == syms.except_clause # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == token.STAR # uncovered
    ): # uncovered
        features.add(Feature.EXCEPT_STAR) # uncovered
    elif n.type in {syms.subscriptlist, syms.trailer} and any( # uncovered
        child.type == syms.star_expr for child in n.children # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
    elif ( # uncovered
        n.type == syms.tname_star # uncovered
        and len(n.children) == 3 # uncovered
        and n.children[2].type == syms.star_expr # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
aux = features # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""features = set()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""class MockNode: def __init__(self, value, type_, children=None): self.value = value; self.type = type_; self.children = children or []; self.parent = None"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value): return [(2, len(value)-1)]"",
            ""node = MockNode('f\""example={x=}\""', token.STRING, [MockNode('1_000', token.NUMBER)])"",
            ""class MockSyms: typedargslist, arglist, varargslist = range(3)"",
            ""syms = MockSyms()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""features = set()"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations'"",
            ""class MockNode: def __init__(self, value, type, children=None): self.value = value; self.type = type; self.children = children if children else []; self.parent = None"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value): return [(2, len(value) - 1)]"",
            ""node = MockNode('f\""example={x=}\""', token.STRING, []), node.pre_order = lambda: [MockNode('f\""example={x=}\""', token.STRING), MockNode('1_000', token.NUMBER)]"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'star_expr': 14, 'atom': 15})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""features = set()"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS';"",
            ""class MockNode: def __init__(self, node_type, value='', parent=None): self.type = node_type; self.value = value; self.parent = parent; self.children = []"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value): return [(2, len(value) - 1)]"",
            ""node = MockNode(token.STRING, 'f\""example={x=}\""')"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'star_expr': 14, 'argument': 15})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""features = set()"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""class MockNode: def __init__(self, type, value='', children=None): self.value = value; self.type = type; self.parent = None; self.children = children or []"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""syms = type('syms', (), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'argument': 14})"",
            ""def iter_fexpr_spans(value): return [(2, len(value)-1)]"",
            ""node = MockNode(token.SLASH, '', [MockNode(token.STRING, 'f\""value={1}\""')])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""features = set()"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""class MockNode: def __init__(self, type_, children=None): self.type = type_; self.children = children or []"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value): return [(2, len(value)-1)]"",
            ""node = type('MockNodeList', (object,), {'pre_order': lambda self: [MockNode(token.SLASH, []), MockNode(token.NUMBER, '1_000')]})()"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'star_expr': 14, 'atom': 15, 'argument': 16})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations'"",
            ""class MockNode: def __init__(self, value, type_, children=None): self.value = value; self.type = type_; self.children = children if children is not None else []; self.parent = None"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value): return [(2, len(value) - 1)]"",
            ""node = MockNode('f\""x={1}\""', token.STRING)"",
            ""def mock_pre_order(): return [node, MockNode('1_000', token.NUMBER)]"",
            ""node.pre_order = mock_pre_order"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'varargslist': 'varargslist', 'return_stmt': 'return_stmt', 'yield_expr': 'yield_expr', 'annassign': 'annassign', 'with_stmt': 'with_stmt', 'match_stmt': 'match_stmt', 'except_clause': 'except_clause', 'subscriptlist': 'subscriptlist', 'trailer': 'trailer', 'tname_star': 'tname_star', 'testlist_star_expr': 'testlist_star_expr', 'star_expr': 'star_expr', 'argument': 'argument'})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""class MockNode: def __init__(self, type, children=None): self.type = type; self.children = children if children is not None else []"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value): return [(2, len(value)-1)]"",
            ""node = MockNode(token.SLASH, [MockNode(token.STRING, 'f\""x={0}\""')])"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'argument': 14})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""features = set()"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations'"",
            ""class MockNode: def __init__(self, value, n_type, parent=None): self.value = value; self.type = n_type; self.parent = parent; self.children = []"",
            ""class MockToken: def __init__(self, value, typ=None): self.value = value; self.type = typ or token.STRING; self.children = []"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""node = MockNode('f\""x={42}\""', token.STRING, [])"",
            ""def iter_fexpr_spans(value): return [(2, len(value) - 1)]"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'star_expr': 14, 'atom': 15, 'argument': 16})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""features = set()"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS'; FUTURE_ANNOTATIONS = 'FUTURE_ANNOTATIONS'"",
            ""class MockNode: def __init__(self, value, ntype, children=None): self.value = value; self.type = ntype; self.parent = None; self.children = children if children is not None else []"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""node = MockNode('f\""Val={x=}\""', token.STRING, [])"",
            ""def iter_fexpr_spans(value): return [(2, len(value) - 1)]"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'varargslist': 'varargslist', 'return_stmt': 'return_stmt', 'yield_expr': 'yield_expr', 'annassign': 'annassign', 'with_stmt': 'with_stmt', 'match_stmt': 'match_stmt', 'except_clause': 'except_clause', 'subscriptlist': 'subscriptlist', 'trailer': 'trailer', 'tname_star': 'tname_star', 'testlist_star_expr': 'testlist_star_expr', 'star_expr': 'star_expr', 'atom': 'atom', 'argument': 'argument'})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations'"",
            ""class MockNode: def __init__(self, value, n_type, parent=None): self.value = value; self.type = n_type; self.parent = parent; self.children = []"",
            ""node = MockNode('f\""example={x=}\"""",
            1,
            [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                31,
                32,
                33,
                34,
                35,
                36,
                37,
                38,
                39,
                40,
                41,
                42,
                43,
                44,
                45,
                46,
                47,
                48,
                49,
                50,
                51,
                52,
                53,
                54,
                55,
                56,
                57,
                58,
                59,
                60,
                61,
                62,
                63,
                64,
                65,
                66,
                67,
                68,
                69,
                70,
                71,
                72,
                73,
                74,
                75,
                76,
                77,
                78,
                79,
                80,
                81,
                82,
                83,
                84,
                85,
                86,
                87,
                88,
                89,
                90,
                91,
                92,
                93,
                94,
                95,
                96,
                97,
                98,
                99,
                100,
                101,
                102,
                103,
                104,
                105,
                106,
                107,
                108,
                109,
                110,
                111,
                112,
                113,
                114,
                115,
                116,
                117,
                118,
                119,
                120,
                121,
                122,
                123,
                124,
                125,
                126,
                127,
                128,
                129,
                130,
                131,
                132,
                133,
                134,
                135,
                136,
                137,
                138,
                139,
                140,
                141,
                142,
                143,
                144,
                145,
                146,
                147,
                148,
                149,
                150,
                151,
                152,
                153,
                154,
                155,
                156,
                157,
                158,
                159,
                160,
                161,
                162,
                163,
                164,
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                174,
                175,
                176,
                177,
                178,
                179,
                180,
                181,
                182,
                183,
                184,
                185,
                186,
                187,
                188,
                189,
                190,
                191,
                192,
                193,
                194,
                195,
                196,
                197,
                198,
                199,
                200,
                201,
                202,
                203,
                204,
                205,
                206,
                207,
                208,
                209,
                210,
                211,
                212,
                213,
                214,
                215,
                216,
                217,
                218,
                219,
                220,
                221,
                222,
                223,
                224,
                225,
                226,
                227,
                228,
                229,
                230,
                231,
                232,
                233,
                234,
                235,
                236,
                237,
                238,
                239,
                240,
                241,
                242,
                243,
                244,
                245,
                246,
                247,
                248,
                249,
                250,
                251,
                252,
                253,
                254,
                255,
                256,
                257,
                258,
                259,
                260,
                261,
                262,
                263,
                264,
                265,
                266,
                267,
                268,
                269,
                270,
                271,
                272,
                273,
                274,
                275,
                276,
                277,
                278,
                279,
                280,
                281,
                282,
                283,
                284,
                285,
                286,
                287,
                288,
                289,
                290,
                291,
                292,
                293,
                294,
                295,
                296,
                297,
                298,
                299,
                300,
                301,
                302,
                303,
                304,
                305,
                306,
                307,
                308,
                309,
                310,
                311,
                312,
                313,
                314,
                315,
                316,
                317,
                318,
                319,
                320,
                321,
                322,
                323,
                324,
                325,
                326,
                327,
                328,
                329,
                330,
                331,
                332,
                333,
                334,
                335,
                336,
                337,
                338,
                339,
                340,
                341,
                342,
                343,
                344,
                345,
                346,
                347,
                348,
                349,
                350,
                351,
                352,
                353,
                354,
                355,
                356,
                357,
                358,
                359,
                360,
                361,
                362,
                363,
                364,
                365,
                366,
                367,
                368,
                369,
                370,
                371,
                372,
                373,
                374,
                375,
                376,
                377,
                378,
                379,
                380,
                381,
                382,
                383,
                384,
                385,
                386,
                387,
                388,
                389,
                390,
                391,
                392,
                393,
                394,
                395,
                396,
                397,
                398,
                399,
                400,
                401,
                402,
                403,
                404,
                405,
                406,
                407,
                408,
                409,
                410,
                411,
                412,
                413,
                414,
                415,
                416,
                417,
                418,
                419
            ]
        ],
        ""STARS = {token.STAR, token.DOUBLESTAR}"": ""def is_string_token(n): return n.type == token.STRING"",
        ""def is_number_token(n): return n.type == token.NUMBER"": 0,
        ""iter_fexpr_spans = lambda value: [(2, len(value) - 1)]"": """",
        ""node = MockNode('1000', token.NUMBER)"": {}
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""features = set() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS'; # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS'; FUTURE_ANNOTATIONS = 'FUTURE_ANNOTATIONS' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    }
]",3,7707,0.0038535,20630,0.030945,0.0347985
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return a set of (relatively) new Python features used in this file.
    Currently looking for:
    - f-strings;
    - self-documenting expressions in f-strings (f""{x=}"");
    - underscores in numeric literals;
    - trailing commas after * or ** in function signatures and calls;
    - positional only arguments in function signatures and lambdas;
    - assignment expression;
    - relaxed decorator syntax;
    - usage of __future__ flags (annotations);
    - print / exec statements;
    - parenthesized context managers;
    - match statements;
    - except* clause;
    - variadic generics;
    """"""
features: Set[Feature] = set()
if future_imports: # uncovered
    features |= { # uncovered
        FUTURE_FLAG_TO_FEATURE[future_import] # uncovered
        for future_import in future_imports # uncovered
        if future_import in FUTURE_FLAG_TO_FEATURE # uncovered
    } # uncovered
for n in node.pre_order(): # uncovered
    if is_string_token(n): # uncovered
        value_head = n.value[:2] # uncovered
        if value_head in {'f""', 'F""', ""f'"", ""F'"", ""rf"", ""fr"", ""RF"", ""FR""}: # uncovered
            features.add(Feature.F_STRINGS) # uncovered
            if Feature.DEBUG_F_STRINGS not in features: # uncovered
                for span_beg, span_end in iter_fexpr_spans(n.value): # uncovered
                    if n.value[span_beg : span_end - 1].rstrip().endswith(""=""): # uncovered
                        features.add(Feature.DEBUG_F_STRINGS) # uncovered
                        break # uncovered
    elif is_number_token(n): # uncovered
        if ""_"" in n.value: # uncovered
            features.add(Feature.NUMERIC_UNDERSCORES) # uncovered
    elif n.type == token.SLASH: # uncovered
        if n.parent and n.parent.type in { # uncovered
            syms.typedargslist, # uncovered
            syms.arglist, # uncovered
            syms.varargslist, # uncovered
        }: # uncovered
            features.add(Feature.POS_ONLY_ARGUMENTS) # uncovered
    elif n.type == token.COLONEQUAL: # uncovered
        features.add(Feature.ASSIGNMENT_EXPRESSIONS) # uncovered
    elif n.type == syms.decorator: # uncovered
        if len(n.children) > 1 and not is_simple_decorator_expression( # uncovered
            n.children[1] # uncovered
        ): # uncovered
            features.add(Feature.RELAXED_DECORATORS) # uncovered
    elif ( # uncovered
        n.type in {syms.typedargslist, syms.arglist} # uncovered
        and n.children # uncovered
        and n.children[-1].type == token.COMMA # uncovered
    ): # uncovered
        if n.type == syms.typedargslist: # uncovered
            feature = Feature.TRAILING_COMMA_IN_DEF # uncovered
        else: # uncovered
            feature = Feature.TRAILING_COMMA_IN_CALL # uncovered
        for ch in n.children: # uncovered
            if ch.type in STARS: # uncovered
                features.add(feature) # uncovered
            if ch.type == syms.argument: # uncovered
                for argch in ch.children: # uncovered
                    if argch.type in STARS: # uncovered
                        features.add(feature) # uncovered
    elif ( # uncovered
        n.type in {syms.return_stmt, syms.yield_expr} # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == syms.testlist_star_expr # uncovered
        and any(child.type == syms.star_expr for child in n.children[1].children) # uncovered
    ): # uncovered
        features.add(Feature.UNPACKING_ON_FLOW) # uncovered
    elif ( # uncovered
        n.type == syms.annassign # uncovered
        and len(n.children) >= 4 # uncovered
        and n.children[3].type == syms.testlist_star_expr # uncovered
    ): # uncovered
        features.add(Feature.ANN_ASSIGN_EXTENDED_RHS) # uncovered
    elif ( # uncovered
        n.type == syms.with_stmt # uncovered
        and len(n.children) > 2 # uncovered
        and n.children[1].type == syms.atom # uncovered
    ): # uncovered
        atom_children = n.children[1].children # uncovered
        if ( # uncovered
            len(atom_children) == 3 # uncovered
            and atom_children[0].type == token.LPAR # uncovered
            and atom_children[1].type == syms.testlist_gexp # uncovered
            and atom_children[2].type == token.RPAR # uncovered
        ): # uncovered
            features.add(Feature.PARENTHESIZED_CONTEXT_MANAGERS) # uncovered
    elif n.type == syms.match_stmt: # uncovered
        features.add(Feature.PATTERN_MATCHING) # uncovered
    elif ( # uncovered
        n.type == syms.except_clause # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == token.STAR # uncovered
    ): # uncovered
        features.add(Feature.EXCEPT_STAR) # uncovered
    elif n.type in {syms.subscriptlist, syms.trailer} and any( # uncovered
        child.type == syms.star_expr for child in n.children # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
    elif ( # uncovered
        n.type == syms.tname_star # uncovered
        and len(n.children) == 3 # uncovered
        and n.children[2].type == syms.star_expr # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
aux = features # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from my_module import Feature, FUTURE_FLAG_TO_FEATURE, syms, is_string_token, is_number_token, iter_fexpr_spans, is_simple_decorator_expression""
        ],
        ""initialization"": [
            ""future_imports = ['annotations']"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.FUTURE_ANNOTATIONS}"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [{'type': token.STRING, 'value': 'f\""test=\""', 'parent': None}]})()"",
            ""STARS = {token.STAR, token.STARCOMMA}"",
            ""Feature = type('Feature', (object,), {'F_STRINGS': 1, 'DEBUG_F_STRINGS': 2, 'NUMERIC_UNDERSCORES': 3, 'POS_ONLY_ARGUMENTS': 4, 'ASSIGNMENT_EXPRESSIONS': 5, 'RELAXED_DECORATORS': 6, 'TRAILING_COMMA_IN_DEF': 7, 'TRAILING_COMMA_IN_CALL': 8, 'UNPACKING_ON_FLOW': 9, 'ANN_ASSIGN_EXTENDED_RHS': 10, 'PARENTHESIZED_CONTEXT_MANAGERS': 11, 'PATTERN_MATCHING': 12, 'EXCEPT_STAR': 13, 'VARIADIC_GENERICS': 14, 'FUTURE_ANNOTATIONS': 15})"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'star_expr': 14, 'atom': 15, 'testlist_gexp': 16, 'argument': 17})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms"",
            ""from your_feature_module import Feature, FUTURE_FLAG_TO_FEATURE""
        ],
        ""initialization"": [
            ""future_imports = ['annotations']"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.FUTURE_ANNOTATIONS}"",
            ""class MockNode:  # Mock class to simulate nodes in a parse tree\n    def pre_order(self):\n        return [MockToken('f\""Hello, World!\""'), MockToken('42')]"",
            ""class MockToken:\n    def __init__(self, value):\n        self.value = value\n        self.type = token.STRING if value.startswith('f') else token.NUMBER\n        self.parent = None"",
            ""def is_string_token(n):\n    return n.type == token.STRING"",
            ""def is_number_token(n):\n    return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value):\n    # Dummy implementation to simulate f-string span extraction\n    return [(0, len(value))]"",
            ""STARS = {token.STAR, token.DOUBLE_STAR}"",
            ""nodes = MockNode()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""future_imports = []"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""class MockNode: def __init__(self, value, node_type, parent=None, children=None): self.value = value; self.type = node_type; self.parent = parent; self.children = children or []"",
            ""def is_string_token(n): return isinstance(n, MockNode) and n.type == token.STRING"",
            ""def is_number_token(n): return isinstance(n, MockNode) and n.type == token.NUMBER"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""n = MockNode('f\""example=\""', token.STRING); node = type('MockNodeList', (list,), {'pre_order': lambda self: [n]})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""future_imports = ['annotations']"",
            ""Feature = type('Feature', (), {"",
            ""    'F_STRINGS': 'f_strings',"",
            ""    'DEBUG_F_STRINGS': 'debug_f_strings',"",
            ""    'NUMERIC_UNDERSCORES': 'numeric_underscores',"",
            ""    'POS_ONLY_ARGUMENTS': 'pos_only_arguments',"",
            ""    'ASSIGNMENT_EXPRESSIONS': 'assignment_expressions',"",
            ""    'RELAXED_DECORATORS': 'relaxed_decorators',"",
            ""    'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def',"",
            ""    'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call',"",
            ""    'UNPACKING_ON_FLOW': 'unpacking_on_flow',"",
            ""    'ANN_ASSIGN_EXTENDED_RHS': 'ann_assign_extended_rhs',"",
            ""    'PARENTHESIZED_CONTEXT_MANAGERS': 'parenthesized_context_managers',"",
            ""    'PATTERN_MATCHING': 'pattern_matching',"",
            ""    'EXCEPT_STAR': 'except_star',"",
            ""    'VARIADIC_GENERICS': 'variadic_generics',"",
            ""})"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('MockToken', (object,), {'type': token.STRING, 'value': 'f{var}', 'parent': None})()]})()"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.isdigit()"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""aux = None""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': 'Feature.FUTURE_ANNOTATIONS',"",
            ""}"",
            ""future_imports = ['annotations']"",
            ""class Feature:"",
            ""    F_STRINGS = 'F_STRINGS'"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [], 'children': []})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""future_imports = []"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""def is_string_token(n): return hasattr(n, 'type') and n.type == token.STRING"",
            ""def is_number_token(n): return hasattr(n, 'type') and n.type == token.NUMBER"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('MockToken', (object,), {'type': token.STRING, 'value': 'f{var}', 'parent': None})())]})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from some_module import Feature, FUTURE_FLAG_TO_FEATURE, future_imports, is_string_token, is_number_token, iter_fexpr_spans, is_simple_decorator_expression, STARS, syms""
        ],
        ""initialization"": [
            ""future_imports = ['annotations']"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.FUTURE_ANNOTATIONS}"",
            ""class Feature: F_STRINGS = 'f-strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'positional_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations'"",
            ""class MockNode: def __init__(self, value, typ, children=[]): self.value = value; self.type = typ; self.children = children; self.parent = None for child in children: child.parent = self"",
            ""node = MockNode('', token.STRING, [MockNode('f\""Hello, {name=} f-string!\""', token.STRING)])"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value): return [(2, 3)]"",
            ""def is_simple_decorator_expression(n): return True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('syms', (), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'varargslist': 'varargslist', 'return_stmt': 'return_stmt', 'yield_expr': 'yield_expr', 'annassign': 'annassign', 'with_stmt': 'with_stmt', 'except_clause': 'except_clause', 'match_stmt': 'match_stmt', 'argument': 'argument', 'testlist_star_expr': 'testlist_star_expr', 'tname_star': 'tname_star', 'subscriptlist': 'subscriptlist', 'trailer': 'trailer'})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.DEBUG_F_STRINGS'}"",
            ""future_imports = ['annotations']"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('MockToken', (object,), {'value': 'f{x=1}', 'type': token.STRING})()]})()})()"",
            ""Feature = type('Feature', (), {'F_STRINGS': 'F_STRINGS', 'DEBUG_F_STRINGS': 'DEBUG_F_STRINGS', 'NUMERIC_UNDERSCORES': 'NUMERIC_UNDERSCORES', 'POS_ONLY_ARGUMENTS': 'POS_ONLY_ARGUMENTS', 'ASSIGNMENT_EXPRESSIONS': 'ASSIGNMENT_EXPRESSIONS', 'RELAXED_DECORATORS': 'RELAXED_DECORATORS', 'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL', 'UNPACKING_ON_FLOW': 'UNPACKING_ON_FLOW', 'ANN_ASSIGN_EXTENDED_RHS': 'ANN_ASSIGN_EXTENDED_RHS', 'PARENTHESIZED_CONTEXT_MANAGERS': 'PARENTHESIZED_CONTEXT_MANAGERS', 'PATTERN_MATCHING': 'PATTERN_MATCHING', 'EXCEPT_STAR': 'EXCEPT_STAR', 'VARIADIC_GENERICS': 'VARIADIC_GENERICS'})"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.isdigit()"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))]"",
            ""STARS = {token.STAR, token.DOUBLESTAR}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from lib2to3.pgen2 import token"",
            ""from lib2to3 import pygram, pgen2""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS, DEBUG_F_STRINGS, NUMERIC_UNDERSCORES, POS_ONLY_ARGUMENTS, ASSIGNMENT_EXPRESSIONS, RELAXED_DECORATORS, TRAILING_COMMA_IN_DEF, TRAILING_COMMA_IN_CALL, UNPACKING_ON_FLOW, ANN_ASSIGN_EXTENDED_RHS, PARENTHESIZED_CONTEXT_MANAGERS, PATTERN_MATCHING, EXCEPT_STAR, VARIADIC_GENERICS = range(13)"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [MockToken('f\""', token.STRING), MockToken('1_000', token.NUMBER)]})()"",
            ""class MockToken: def __init__(self, value, type): self.value = value; self.type = type; self.parent = None"",
            ""STARS = {token.STAR, token.STAR_expr}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 'typedargslist', 'arglist':'arglist', 'varargslist':'varargslist', 'return_stmt':'return_stmt', 'yield_expr':'yield_expr', 'annassign':'annassign', 'with_stmt':'with_stmt', 'match_stmt':'match_stmt', 'except_clause':'except_clause', 'subscriptlist':'subscriptlist', 'trailer':'trailer', 'tname_star':'tname_star', 'testlist_star_expr':'testlist_star_expr', 'star_expr':'star_expr', 'testlist_gexp':'testlist_gexp', 'atom':'atom', 'argument':'argument'})"",
            ""def is_string_token(token): return token.type == token.STRING"",
            ""def is_number_token(token): return token.type == token.NUMBER"",
            ""def is_simple_decorator_expression(child): return False"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms"",
            ""from collections import namedtuple""
        ],
        ""initialization"": [
            ""Feature = namedtuple('Feature', ['F_STRINGS', 'DEBUG_F_STRINGS', 'NUMERIC_UNDERSCORES', 'POS_ONLY_ARGUMENTS', 'ASSIGNMENT_EXPRESSIONS', 'RELAXED_DECORATORS', 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL', 'UNPACKING_ON_FLOW', 'ANN_ASSIGN_EXTENDED_RHS', 'PARENTHESIZED_CONTEXT_MANAGERS', 'PATTERN_MATCHING', 'EXCEPT_STAR', 'VARIADIC_GENERICS'])"",
            ""Feature.F_STRINGS = 'f-strings'"",
            ""Feature.DEBUG_F_STRINGS = 'debug f-strings'"",
            ""Feature.NUMERIC_UNDERSCORES = 'numeric underscores'"",
            ""Feature.POS_ONLY_ARGUMENTS = 'positional only arguments'"",
            ""Feature.ASSIGNMENT_EXPRESSIONS = 'assignment expressions'"",
            ""Feature.RELAXED_DECORATORS = 'relaxed decorators'"",
            ""Feature.TRAILING_COMMA_IN_DEF = 'trailing comma in function definition'"",
            ""Feature.TRAILING_COMMA_IN_CALL = 'trailing comma in function call'"",
            ""Feature.UNPACKING_ON_FLOW = 'unpacking on flow'"",
            ""Feature.ANN_ASSIGN_EXTENDED_RHS = 'annotation assignment with extended rhs'"",
            ""Feature.PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers'"",
            ""Feature.PATTERN_MATCHING = 'pattern matching'"",
            ""Feature.EXCEPT_STAR = 'except star'"",
            ""Feature.VARIADIC_GENERICS = 'variadic generics'"",
            ""future_imports = ['annotations']"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.NUMERIC_UNDERSCORES}"",
            ""node = Mock(pre_order=Mock(return_value=[Mock(type=token.STRING, value='f{var=}')]))"",
            ""is_string_token = lambda n: n.type == token.STRING"",
            ""is_number_token = lambda n: n.type == token.NUMBER"",
            ""iter_fexpr_spans = lambda value: [(2, 9)]"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""is_simple_decorator_expression = lambda n: False"",
            ""aux = set()""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [{'type': token.STRING, 'value': 'f\""test=\""', 'parent': None}]})() # pragma: no cover"",
            ""Feature = type('Feature', (object,), {'F_STRINGS': 1, 'DEBUG_F_STRINGS': 2, 'NUMERIC_UNDERSCORES': 3, 'POS_ONLY_ARGUMENTS': 4, 'ASSIGNMENT_EXPRESSIONS': 5, 'RELAXED_DECORATORS': 6, 'TRAILING_COMMA_IN_DEF': 7, 'TRAILING_COMMA_IN_CALL': 8, 'UNPACKING_ON_FLOW': 9, 'ANN_ASSIGN_EXTENDED_RHS': 10, 'PARENTHESIZED_CONTEXT_MANAGERS': 11, 'PATTERN_MATCHING': 12, 'EXCEPT_STAR': 13, 'VARIADIC_GENERICS': 14, 'FUTURE_ANNOTATIONS': 15}) # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'star_expr': 14, 'atom': 15, 'testlist_gexp': 16, 'argument': 17}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockNode:  # Mock class to simulate nodes in a parse tree# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [MockToken('f\""Hello, World!\""'), MockToken('42')] # pragma: no cover"",
            ""class MockToken:# pragma: no cover"",
            ""    def __init__(self, value):# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.type = token.STRING if value.startswith('f') else token.NUMBER# pragma: no cover"",
            ""        self.parent = None # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return n.type == token.STRING # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return n.type == token.NUMBER # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    # Dummy implementation to simulate f-string span extraction# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""nodes = MockNode() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""Feature = type('Feature', (), { # pragma: no cover"",
            ""    'F_STRINGS': 'f_strings', # pragma: no cover"",
            ""    'DEBUG_F_STRINGS': 'debug_f_strings', # pragma: no cover"",
            ""    'NUMERIC_UNDERSCORES': 'numeric_underscores', # pragma: no cover"",
            ""    'POS_ONLY_ARGUMENTS': 'pos_only_arguments', # pragma: no cover"",
            ""    'ASSIGNMENT_EXPRESSIONS': 'assignment_expressions', # pragma: no cover"",
            ""    'RELAXED_DECORATORS': 'relaxed_decorators', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call', # pragma: no cover"",
            ""    'UNPACKING_ON_FLOW': 'unpacking_on_flow', # pragma: no cover"",
            ""    'ANN_ASSIGN_EXTENDED_RHS': 'ann_assign_extended_rhs', # pragma: no cover"",
            ""    'PARENTHESIZED_CONTEXT_MANAGERS': 'parenthesized_context_managers', # pragma: no cover"",
            ""    'PATTERN_MATCHING': 'pattern_matching', # pragma: no cover"",
            ""    'EXCEPT_STAR': 'except_star', # pragma: no cover"",
            ""    'VARIADIC_GENERICS': 'variadic_generics', # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('MockToken', (object,), {'type': token.STRING, 'value': 'f{var}', 'parent': None})()]})() # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.isdigit() # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""aux = None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': 'Feature.FUTURE_ANNOTATIONS', # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING' # pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [], 'children': []})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'f-strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'positional_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = type('Feature', (), {'F_STRINGS': 'F_STRINGS', 'DEBUG_F_STRINGS': 'DEBUG_F_STRINGS', 'NUMERIC_UNDERSCORES': 'NUMERIC_UNDERSCORES', 'POS_ONLY_ARGUMENTS': 'POS_ONLY_ARGUMENTS', 'ASSIGNMENT_EXPRESSIONS': 'ASSIGNMENT_EXPRESSIONS', 'RELAXED_DECORATORS': 'RELAXED_DECORATORS', 'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL', 'UNPACKING_ON_FLOW': 'UNPACKING_ON_FLOW', 'ANN_ASSIGN_EXTENDED_RHS': 'ANN_ASSIGN_EXTENDED_RHS', 'PARENTHESIZED_CONTEXT_MANAGERS': 'PARENTHESIZED_CONTEXT_MANAGERS', 'PATTERN_MATCHING': 'PATTERN_MATCHING', 'EXCEPT_STAR': 'EXCEPT_STAR', 'VARIADIC_GENERICS': 'VARIADIC_GENERICS'}) # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.isdigit() # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from lib2to3.pgen2 import token # pragma: no cover"",
            ""from lib2to3 import pygram, pgen2 # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [MockToken('f\""', token.STRING), MockToken('1_000', token.NUMBER)]})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = namedtuple('Feature', ['F_STRINGS', 'DEBUG_F_STRINGS', 'NUMERIC_UNDERSCORES', 'POS_ONLY_ARGUMENTS', 'ASSIGNMENT_EXPRESSIONS', 'RELAXED_DECORATORS', 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL', 'UNPACKING_ON_FLOW', 'ANN_ASSIGN_EXTENDED_RHS', 'PARENTHESIZED_CONTEXT_MANAGERS', 'PATTERN_MATCHING', 'EXCEPT_STAR', 'VARIADIC_GENERICS']) # pragma: no cover"",
            ""Feature.F_STRINGS = 'f-strings' # pragma: no cover"",
            ""Feature.DEBUG_F_STRINGS = 'debug f-strings' # pragma: no cover"",
            ""Feature.NUMERIC_UNDERSCORES = 'numeric underscores' # pragma: no cover"",
            ""Feature.POS_ONLY_ARGUMENTS = 'positional only arguments' # pragma: no cover"",
            ""Feature.ASSIGNMENT_EXPRESSIONS = 'assignment expressions' # pragma: no cover"",
            ""Feature.RELAXED_DECORATORS = 'relaxed decorators' # pragma: no cover"",
            ""Feature.TRAILING_COMMA_IN_DEF = 'trailing comma in function definition' # pragma: no cover"",
            ""Feature.TRAILING_COMMA_IN_CALL = 'trailing comma in function call' # pragma: no cover"",
            ""Feature.UNPACKING_ON_FLOW = 'unpacking on flow' # pragma: no cover"",
            ""Feature.ANN_ASSIGN_EXTENDED_RHS = 'annotation assignment with extended rhs' # pragma: no cover"",
            ""Feature.PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers' # pragma: no cover"",
            ""Feature.PATTERN_MATCHING = 'pattern matching' # pragma: no cover"",
            ""Feature.EXCEPT_STAR = 'except star' # pragma: no cover"",
            ""Feature.VARIADIC_GENERICS = 'variadic generics' # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.NUMERIC_UNDERSCORES} # pragma: no cover"",
            ""is_string_token = lambda n: n.type == token.STRING # pragma: no cover"",
            ""is_number_token = lambda n: n.type == token.NUMBER # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(2, 9)] # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: False # pragma: no cover"",
            ""aux = set() # pragma: no cover""
        ]
    }
]",3,1561,0.0007805,4251,0.0063765,0.007157
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return a set of (relatively) new Python features used in this file.
    Currently looking for:
    - f-strings;
    - self-documenting expressions in f-strings (f""{x=}"");
    - underscores in numeric literals;
    - trailing commas after * or ** in function signatures and calls;
    - positional only arguments in function signatures and lambdas;
    - assignment expression;
    - relaxed decorator syntax;
    - usage of __future__ flags (annotations);
    - print / exec statements;
    - parenthesized context managers;
    - match statements;
    - except* clause;
    - variadic generics;
    """"""
features: Set[Feature] = set()
if future_imports: # uncovered
    features |= { # uncovered
        FUTURE_FLAG_TO_FEATURE[future_import] # uncovered
        for future_import in future_imports # uncovered
        if future_import in FUTURE_FLAG_TO_FEATURE # uncovered
    } # uncovered
for n in node.pre_order(): # uncovered
    if is_string_token(n): # uncovered
        value_head = n.value[:2] # uncovered
        if value_head in {'f""', 'F""', ""f'"", ""F'"", ""rf"", ""fr"", ""RF"", ""FR""}: # uncovered
            features.add(Feature.F_STRINGS) # uncovered
            if Feature.DEBUG_F_STRINGS not in features: # uncovered
                for span_beg, span_end in iter_fexpr_spans(n.value): # uncovered
                    if n.value[span_beg : span_end - 1].rstrip().endswith(""=""): # uncovered
                        features.add(Feature.DEBUG_F_STRINGS) # uncovered
                        break # uncovered
    elif is_number_token(n): # uncovered
        if ""_"" in n.value: # uncovered
            features.add(Feature.NUMERIC_UNDERSCORES) # uncovered
    elif n.type == token.SLASH: # uncovered
        if n.parent and n.parent.type in { # uncovered
            syms.typedargslist, # uncovered
            syms.arglist, # uncovered
            syms.varargslist, # uncovered
        }: # uncovered
            features.add(Feature.POS_ONLY_ARGUMENTS) # uncovered
    elif n.type == token.COLONEQUAL: # uncovered
        features.add(Feature.ASSIGNMENT_EXPRESSIONS) # uncovered
    elif n.type == syms.decorator: # uncovered
        if len(n.children) > 1 and not is_simple_decorator_expression( # uncovered
            n.children[1] # uncovered
        ): # uncovered
            features.add(Feature.RELAXED_DECORATORS) # uncovered
    elif ( # uncovered
        n.type in {syms.typedargslist, syms.arglist} # uncovered
        and n.children # uncovered
        and n.children[-1].type == token.COMMA # uncovered
    ): # uncovered
        if n.type == syms.typedargslist: # uncovered
            feature = Feature.TRAILING_COMMA_IN_DEF # uncovered
        else: # uncovered
            feature = Feature.TRAILING_COMMA_IN_CALL # uncovered
        for ch in n.children: # uncovered
            if ch.type in STARS: # uncovered
                features.add(feature) # uncovered
            if ch.type == syms.argument: # uncovered
                for argch in ch.children: # uncovered
                    if argch.type in STARS: # uncovered
                        features.add(feature) # uncovered
    elif ( # uncovered
        n.type in {syms.return_stmt, syms.yield_expr} # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == syms.testlist_star_expr # uncovered
        and any(child.type == syms.star_expr for child in n.children[1].children) # uncovered
    ): # uncovered
        features.add(Feature.UNPACKING_ON_FLOW) # uncovered
    elif ( # uncovered
        n.type == syms.annassign # uncovered
        and len(n.children) >= 4 # uncovered
        and n.children[3].type == syms.testlist_star_expr # uncovered
    ): # uncovered
        features.add(Feature.ANN_ASSIGN_EXTENDED_RHS) # uncovered
    elif ( # uncovered
        n.type == syms.with_stmt # uncovered
        and len(n.children) > 2 # uncovered
        and n.children[1].type == syms.atom # uncovered
    ): # uncovered
        atom_children = n.children[1].children # uncovered
        if ( # uncovered
            len(atom_children) == 3 # uncovered
            and atom_children[0].type == token.LPAR # uncovered
            and atom_children[1].type == syms.testlist_gexp # uncovered
            and atom_children[2].type == token.RPAR # uncovered
        ): # uncovered
            features.add(Feature.PARENTHESIZED_CONTEXT_MANAGERS) # uncovered
    elif n.type == syms.match_stmt: # uncovered
        features.add(Feature.PATTERN_MATCHING) # uncovered
    elif ( # uncovered
        n.type == syms.except_clause # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == token.STAR # uncovered
    ): # uncovered
        features.add(Feature.EXCEPT_STAR) # uncovered
    elif n.type in {syms.subscriptlist, syms.trailer} and any( # uncovered
        child.type == syms.star_expr for child in n.children # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
    elif ( # uncovered
        n.type == syms.tname_star # uncovered
        and len(n.children) == 3 # uncovered
        and n.children[2].type == syms.star_expr # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
aux = features # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""class MockNode: def __init__(self, value, n_type, parent=None): self.value = value; self.type = n_type; self.parent = parent; self.children = []"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""node = MockNode('f\""test={1}\""', token.STRING)"",
            ""def iter_fexpr_spans(value): return [(2, 6)]"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('syms', (object,), {'typedargslist': 'TYPEDARGSLIST', 'arglist': 'ARGLIST', 'varargslist': 'VARARGSLIST', 'return_stmt': 'RETURN_STMT', 'yield_expr': 'YIELD_EXPR', 'annassign': 'ANNASSIGN', 'with_stmt': 'WITH_STMT', 'match_stmt': 'MATCH_STMT', 'except_clause': 'EXCEPT_CLAUSE', 'argument': 'ARGUMENT'})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""class MockNode: def __init__(self, value, node_type, children=None): self.value = value; self.type = node_type; self.children = children if children else []; self.parent = None"",
            ""node = MockNode('f\""Hello, {name=}=\""', token.STRING, [])"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""iter_fexpr_spans = lambda value: [(2, len(value) - 1)]"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('MockSyms', (object,), { 'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'argument': 12, 'testlist_star_expr': 13 })""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""future_imports = ['annotations']"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.FUTURE_ANNOTATIONS}"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations'"",
            ""class MockToken: def __init__(self, value, type): self.value = value; self.type = type; self.parent = None"",
            ""class MockNode: def __init__(self, children): self.children = children"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value): return [(2, len(value))]"",
            ""node = MockNode([MockToken('f\""example={1=}\""', token.STRING)])"",
            ""STARS = {token.STAR, token.DOUBLESTAR}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""class MockNode: def __init__(self, value, node_type, parent=None, children=None): self.value = value; self.type = node_type; self.parent = parent; self.children = children or []"",
            ""node = MockNode('f\""example=\""', token.STRING)"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""iter_fexpr_spans = lambda value: [(2, len(value)-1)]"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'star_expr': 14, 'atom': 15, 'argument': 16})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""class MockNode: def __init__(self, value, typ): self.value = value; self.type = typ; self.parent = None; self.children = []"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""node = MockNode('f\""Hello, {name=}!\""', token.STRING)"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('syms', (), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'argument': 14})"",
            ""def iter_fexpr_spans(value): return [(4, 11)]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.NUMERIC_UNDERSCORES'}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""class MockNode: def __init__(self, value, type): self.value = value; self.type = type; self.parent = None; self.children = []"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""node = type('MockNodeList', (object,), {'pre_order': lambda self: [MockNode('f\""example={1=}\""', token.STRING), MockNode('1000', token.NUMBER)]})()"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'star_expr': 14, 'atom': 15 })"",
            ""def iter_fexpr_spans(value): return [(10, len(value))]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""future_imports = ['annotations']"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.FUTURE_ANNOTATIONS}"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS';"",
            ""class MockNode: def __init__(self, value, type, children=None): self.value = value; self.type = type; self.children = children if children is not None else []"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""node = MockNode('f\""example={x=}\""', token.STRING, [])"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('syms', (), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'varargslist': 'varargslist', 'return_stmt': 'return_stmt', 'yield_expr': 'yield_expr', 'annassign': 'annassign', 'with_stmt': 'with_stmt', 'match_stmt': 'match_stmt', 'except_clause': 'except_clause', 'subscriptlist': 'subscriptlist', 'trailer': 'trailer', 'tname_star': 'tname_star', 'testlist_star_expr': 'testlist_star_expr', 'star_expr': 'star_expr', 'atom': 'atom', 'argument': 'argument'})"",
            ""def iter_fexpr_spans(value): return [(2, 10)]"",
            ""aux = None""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from types import SimpleNamespace as syms""
        ],
        ""initialization"": [
            ""future_imports = ['annotations']"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""features = set()"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""class MockNode:  # Mock class to simulate nodes in a parse tree\n    def pre_order(self):\n        return [MockToken('f\""x={0}\""', token.STRING), MockToken('1_000', token.NUMBER)]"",
            ""class MockToken:\n    def __init__(self, value, typ=None):\n        self.value = value\n        self.type = typ or token.STRING\n        self.parent = None"",
            ""def is_string_token(n):\n    return n.type == token.STRING"",
            ""def is_number_token(n):\n    return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value):\n    return [(2, len(value)-1)]"",
            ""node = MockNode()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.FUTURE_ANNOTATIONS}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations'"",
            ""class MockNode: def __init__(self, type, value='', children=None): self.type = type; self.value = value; self.children = children if children is not None else []; self.parent = None"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value): return [(2, len(value) - 1)]"",
            ""node = MockNode(token.SLASH, '', [MockNode(token.STRING, 'f\""Hello, {x=} f-string!\""')])"",
            ""STARS = {token.STAR, token.DOUBLESTAR}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from my_module import Feature, FUTURE_FLAG_TO_FEATURE, syms""
        ],
        ""initialization"": [
            ""future_imports = ['annotations']"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.FUTURE_ANNOTATIONS}"",
            ""class MockNode: def __init__(self, value, type_, children=None): self.value = value; self.type = type_; self.children = children or []; self.parent = None"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""node = MockNode('f\""Hello, {world=}\""', token.STRING, [])"",
            ""def iter_fexpr_spans(value): return [(2, len(value) - 1)]"",
            ""STARS = {token.STAR, token.STAR_COMMA}"",
            ""def is_simple_decorator_expression(n): return False"",
            ""syms = type('MockSyms', (), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'atom': 14, 'argument': 15})""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.NUMERIC_UNDERSCORES'} # pragma: no cover"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS'; # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from types import SimpleNamespace as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:  # Mock class to simulate nodes in a parse tree# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [MockToken('f\""x={0}\""', token.STRING), MockToken('1_000', token.NUMBER)] # pragma: no cover"",
            ""class MockToken:# pragma: no cover"",
            ""    def __init__(self, value, typ=None):# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.type = typ or token.STRING# pragma: no cover"",
            ""        self.parent = None # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return n.type == token.STRING # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return n.type == token.NUMBER # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(2, len(value)-1)] # pragma: no cover"",
            ""node = MockNode() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    }
]",3,7350,0.003675,4608,0.006912,0.010587
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return a set of (relatively) new Python features used in this file.
    Currently looking for:
    - f-strings;
    - self-documenting expressions in f-strings (f""{x=}"");
    - underscores in numeric literals;
    - trailing commas after * or ** in function signatures and calls;
    - positional only arguments in function signatures and lambdas;
    - assignment expression;
    - relaxed decorator syntax;
    - usage of __future__ flags (annotations);
    - print / exec statements;
    - parenthesized context managers;
    - match statements;
    - except* clause;
    - variadic generics;
    """"""
features: Set[Feature] = set()
if future_imports: # uncovered
    features |= { # uncovered
        FUTURE_FLAG_TO_FEATURE[future_import] # uncovered
        for future_import in future_imports # uncovered
        if future_import in FUTURE_FLAG_TO_FEATURE # uncovered
    } # uncovered
for n in node.pre_order(): # uncovered
    if is_string_token(n): # uncovered
        value_head = n.value[:2] # uncovered
        if value_head in {'f""', 'F""', ""f'"", ""F'"", ""rf"", ""fr"", ""RF"", ""FR""}: # uncovered
            features.add(Feature.F_STRINGS) # uncovered
            if Feature.DEBUG_F_STRINGS not in features: # uncovered
                for span_beg, span_end in iter_fexpr_spans(n.value): # uncovered
                    if n.value[span_beg : span_end - 1].rstrip().endswith(""=""): # uncovered
                        features.add(Feature.DEBUG_F_STRINGS) # uncovered
                        break # uncovered
    elif is_number_token(n): # uncovered
        if ""_"" in n.value: # uncovered
            features.add(Feature.NUMERIC_UNDERSCORES) # uncovered
    elif n.type == token.SLASH: # uncovered
        if n.parent and n.parent.type in { # uncovered
            syms.typedargslist, # uncovered
            syms.arglist, # uncovered
            syms.varargslist, # uncovered
        }: # uncovered
            features.add(Feature.POS_ONLY_ARGUMENTS) # uncovered
    elif n.type == token.COLONEQUAL: # uncovered
        features.add(Feature.ASSIGNMENT_EXPRESSIONS) # uncovered
    elif n.type == syms.decorator: # uncovered
        if len(n.children) > 1 and not is_simple_decorator_expression( # uncovered
            n.children[1] # uncovered
        ): # uncovered
            features.add(Feature.RELAXED_DECORATORS) # uncovered
    elif ( # uncovered
        n.type in {syms.typedargslist, syms.arglist} # uncovered
        and n.children # uncovered
        and n.children[-1].type == token.COMMA # uncovered
    ): # uncovered
        if n.type == syms.typedargslist: # uncovered
            feature = Feature.TRAILING_COMMA_IN_DEF # uncovered
        else: # uncovered
            feature = Feature.TRAILING_COMMA_IN_CALL # uncovered
        for ch in n.children: # uncovered
            if ch.type in STARS: # uncovered
                features.add(feature) # uncovered
            if ch.type == syms.argument: # uncovered
                for argch in ch.children: # uncovered
                    if argch.type in STARS: # uncovered
                        features.add(feature) # uncovered
    elif ( # uncovered
        n.type in {syms.return_stmt, syms.yield_expr} # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == syms.testlist_star_expr # uncovered
        and any(child.type == syms.star_expr for child in n.children[1].children) # uncovered
    ): # uncovered
        features.add(Feature.UNPACKING_ON_FLOW) # uncovered
    elif ( # uncovered
        n.type == syms.annassign # uncovered
        and len(n.children) >= 4 # uncovered
        and n.children[3].type == syms.testlist_star_expr # uncovered
    ): # uncovered
        features.add(Feature.ANN_ASSIGN_EXTENDED_RHS) # uncovered
    elif ( # uncovered
        n.type == syms.with_stmt # uncovered
        and len(n.children) > 2 # uncovered
        and n.children[1].type == syms.atom # uncovered
    ): # uncovered
        atom_children = n.children[1].children # uncovered
        if ( # uncovered
            len(atom_children) == 3 # uncovered
            and atom_children[0].type == token.LPAR # uncovered
            and atom_children[1].type == syms.testlist_gexp # uncovered
            and atom_children[2].type == token.RPAR # uncovered
        ): # uncovered
            features.add(Feature.PARENTHESIZED_CONTEXT_MANAGERS) # uncovered
    elif n.type == syms.match_stmt: # uncovered
        features.add(Feature.PATTERN_MATCHING) # uncovered
    elif ( # uncovered
        n.type == syms.except_clause # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == token.STAR # uncovered
    ): # uncovered
        features.add(Feature.EXCEPT_STAR) # uncovered
    elif n.type in {syms.subscriptlist, syms.trailer} and any( # uncovered
        child.type == syms.star_expr for child in n.children # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
    elif ( # uncovered
        n.type == syms.tname_star # uncovered
        and len(n.children) == 3 # uncovered
        and n.children[2].type == syms.star_expr # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
aux = features # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""features = set()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""class MockNode: def __init__(self, value, type_, children=None): self.value = value; self.type = type_; self.children = children or []; self.parent = None"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value): return [(2, len(value)-1)]"",
            ""node = MockNode('f\""example={x=}\""', token.STRING, [MockNode('1_000', token.NUMBER)])"",
            ""class MockSyms: typedargslist, arglist, varargslist = range(3)"",
            ""syms = MockSyms()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""features = set()"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations'"",
            ""class MockNode: def __init__(self, value, type, children=None): self.value = value; self.type = type; self.children = children if children else []; self.parent = None"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value): return [(2, len(value) - 1)]"",
            ""node = MockNode('f\""example={x=}\""', token.STRING, []), node.pre_order = lambda: [MockNode('f\""example={x=}\""', token.STRING), MockNode('1_000', token.NUMBER)]"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'star_expr': 14, 'atom': 15})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""features = set()"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS';"",
            ""class MockNode: def __init__(self, node_type, value='', parent=None): self.type = node_type; self.value = value; self.parent = parent; self.children = []"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value): return [(2, len(value) - 1)]"",
            ""node = MockNode(token.STRING, 'f\""example={x=}\""')"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'star_expr': 14, 'argument': 15})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""features = set()"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""class MockNode: def __init__(self, type, value='', children=None): self.value = value; self.type = type; self.parent = None; self.children = children or []"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""syms = type('syms', (), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'argument': 14})"",
            ""def iter_fexpr_spans(value): return [(2, len(value)-1)]"",
            ""node = MockNode(token.SLASH, '', [MockNode(token.STRING, 'f\""value={1}\""')])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""features = set()"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""class MockNode: def __init__(self, type_, children=None): self.type = type_; self.children = children or []"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value): return [(2, len(value)-1)]"",
            ""node = type('MockNodeList', (object,), {'pre_order': lambda self: [MockNode(token.SLASH, []), MockNode(token.NUMBER, '1_000')]})()"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'star_expr': 14, 'atom': 15, 'argument': 16})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations'"",
            ""class MockNode: def __init__(self, value, type_, children=None): self.value = value; self.type = type_; self.children = children if children is not None else []; self.parent = None"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value): return [(2, len(value) - 1)]"",
            ""node = MockNode('f\""x={1}\""', token.STRING)"",
            ""def mock_pre_order(): return [node, MockNode('1_000', token.NUMBER)]"",
            ""node.pre_order = mock_pre_order"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'varargslist': 'varargslist', 'return_stmt': 'return_stmt', 'yield_expr': 'yield_expr', 'annassign': 'annassign', 'with_stmt': 'with_stmt', 'match_stmt': 'match_stmt', 'except_clause': 'except_clause', 'subscriptlist': 'subscriptlist', 'trailer': 'trailer', 'tname_star': 'tname_star', 'testlist_star_expr': 'testlist_star_expr', 'star_expr': 'star_expr', 'argument': 'argument'})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""class MockNode: def __init__(self, type, children=None): self.type = type; self.children = children if children is not None else []"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value): return [(2, len(value)-1)]"",
            ""node = MockNode(token.SLASH, [MockNode(token.STRING, 'f\""x={0}\""')])"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'argument': 14})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""features = set()"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations'"",
            ""class MockNode: def __init__(self, value, n_type, parent=None): self.value = value; self.type = n_type; self.parent = parent; self.children = []"",
            ""class MockToken: def __init__(self, value, typ=None): self.value = value; self.type = typ or token.STRING; self.children = []"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""node = MockNode('f\""x={42}\""', token.STRING, [])"",
            ""def iter_fexpr_spans(value): return [(2, len(value) - 1)]"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'star_expr': 14, 'atom': 15, 'argument': 16})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""features = set()"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS'; FUTURE_ANNOTATIONS = 'FUTURE_ANNOTATIONS'"",
            ""class MockNode: def __init__(self, value, ntype, children=None): self.value = value; self.type = ntype; self.parent = None; self.children = children if children is not None else []"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""node = MockNode('f\""Val={x=}\""', token.STRING, [])"",
            ""def iter_fexpr_spans(value): return [(2, len(value) - 1)]"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'varargslist': 'varargslist', 'return_stmt': 'return_stmt', 'yield_expr': 'yield_expr', 'annassign': 'annassign', 'with_stmt': 'with_stmt', 'match_stmt': 'match_stmt', 'except_clause': 'except_clause', 'subscriptlist': 'subscriptlist', 'trailer': 'trailer', 'tname_star': 'tname_star', 'testlist_star_expr': 'testlist_star_expr', 'star_expr': 'star_expr', 'atom': 'atom', 'argument': 'argument'})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations'"",
            ""class MockNode: def __init__(self, value, n_type, parent=None): self.value = value; self.type = n_type; self.parent = parent; self.children = []"",
            ""node = MockNode('f\""example={x=}\"""",
            1,
            [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                31,
                32,
                33,
                34,
                35,
                36,
                37,
                38,
                39,
                40,
                41,
                42,
                43,
                44,
                45,
                46,
                47,
                48,
                49,
                50,
                51,
                52,
                53,
                54,
                55,
                56,
                57,
                58,
                59,
                60,
                61,
                62,
                63,
                64,
                65,
                66,
                67,
                68,
                69,
                70,
                71,
                72,
                73,
                74,
                75,
                76,
                77,
                78,
                79,
                80,
                81,
                82,
                83,
                84,
                85,
                86,
                87,
                88,
                89,
                90,
                91,
                92,
                93,
                94,
                95,
                96,
                97,
                98,
                99,
                100,
                101,
                102,
                103,
                104,
                105,
                106,
                107,
                108,
                109,
                110,
                111,
                112,
                113,
                114,
                115,
                116,
                117,
                118,
                119,
                120,
                121,
                122,
                123,
                124,
                125,
                126,
                127,
                128,
                129,
                130,
                131,
                132,
                133,
                134,
                135,
                136,
                137,
                138,
                139,
                140,
                141,
                142,
                143,
                144,
                145,
                146,
                147,
                148,
                149,
                150,
                151,
                152,
                153,
                154,
                155,
                156,
                157,
                158,
                159,
                160,
                161,
                162,
                163,
                164,
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                174,
                175,
                176,
                177,
                178,
                179,
                180,
                181,
                182,
                183,
                184,
                185,
                186,
                187,
                188,
                189,
                190,
                191,
                192,
                193,
                194,
                195,
                196,
                197,
                198,
                199,
                200,
                201,
                202,
                203,
                204,
                205,
                206,
                207,
                208,
                209,
                210,
                211,
                212,
                213,
                214,
                215,
                216,
                217,
                218,
                219,
                220,
                221,
                222,
                223,
                224,
                225,
                226,
                227,
                228,
                229,
                230,
                231,
                232,
                233,
                234,
                235,
                236,
                237,
                238,
                239,
                240,
                241,
                242,
                243,
                244,
                245,
                246,
                247,
                248,
                249,
                250,
                251,
                252,
                253,
                254,
                255,
                256,
                257,
                258,
                259,
                260,
                261,
                262,
                263,
                264,
                265,
                266,
                267,
                268,
                269,
                270,
                271,
                272,
                273,
                274,
                275,
                276,
                277,
                278,
                279,
                280,
                281,
                282,
                283,
                284,
                285,
                286,
                287,
                288,
                289,
                290,
                291,
                292,
                293,
                294,
                295,
                296,
                297,
                298,
                299,
                300,
                301,
                302,
                303,
                304,
                305,
                306,
                307,
                308,
                309,
                310,
                311,
                312,
                313,
                314,
                315,
                316,
                317,
                318,
                319,
                320,
                321,
                322,
                323,
                324,
                325,
                326,
                327,
                328,
                329,
                330,
                331,
                332,
                333,
                334,
                335,
                336,
                337,
                338,
                339,
                340,
                341,
                342,
                343,
                344,
                345,
                346,
                347,
                348,
                349,
                350,
                351,
                352,
                353,
                354,
                355,
                356,
                357,
                358,
                359,
                360,
                361,
                362,
                363,
                364,
                365,
                366,
                367,
                368,
                369,
                370,
                371,
                372,
                373,
                374,
                375,
                376,
                377,
                378,
                379,
                380,
                381,
                382,
                383,
                384,
                385,
                386,
                387,
                388,
                389,
                390,
                391,
                392,
                393,
                394,
                395,
                396,
                397,
                398,
                399,
                400,
                401,
                402,
                403,
                404,
                405,
                406,
                407,
                408,
                409,
                410,
                411,
                412,
                413,
                414,
                415,
                416,
                417,
                418,
                419
            ]
        ],
        ""STARS = {token.STAR, token.DOUBLESTAR}"": ""def is_string_token(n): return n.type == token.STRING"",
        ""def is_number_token(n): return n.type == token.NUMBER"": 0,
        ""iter_fexpr_spans = lambda value: [(2, len(value) - 1)]"": """",
        ""node = MockNode('1000', token.NUMBER)"": {}
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""features = set() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS'; # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS'; FUTURE_ANNOTATIONS = 'FUTURE_ANNOTATIONS' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    }
]",3,7707,0.0038535,20630,0.030945,0.0347985
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return a set of (relatively) new Python features used in this file.
    Currently looking for:
    - f-strings;
    - self-documenting expressions in f-strings (f""{x=}"");
    - underscores in numeric literals;
    - trailing commas after * or ** in function signatures and calls;
    - positional only arguments in function signatures and lambdas;
    - assignment expression;
    - relaxed decorator syntax;
    - usage of __future__ flags (annotations);
    - print / exec statements;
    - parenthesized context managers;
    - match statements;
    - except* clause;
    - variadic generics;
    """"""
features: Set[Feature] = set()
if future_imports: # uncovered
    features |= { # uncovered
        FUTURE_FLAG_TO_FEATURE[future_import] # uncovered
        for future_import in future_imports # uncovered
        if future_import in FUTURE_FLAG_TO_FEATURE # uncovered
    } # uncovered
for n in node.pre_order(): # uncovered
    if is_string_token(n): # uncovered
        value_head = n.value[:2] # uncovered
        if value_head in {'f""', 'F""', ""f'"", ""F'"", ""rf"", ""fr"", ""RF"", ""FR""}: # uncovered
            features.add(Feature.F_STRINGS) # uncovered
            if Feature.DEBUG_F_STRINGS not in features: # uncovered
                for span_beg, span_end in iter_fexpr_spans(n.value): # uncovered
                    if n.value[span_beg : span_end - 1].rstrip().endswith(""=""): # uncovered
                        features.add(Feature.DEBUG_F_STRINGS) # uncovered
                        break # uncovered
    elif is_number_token(n): # uncovered
        if ""_"" in n.value: # uncovered
            features.add(Feature.NUMERIC_UNDERSCORES) # uncovered
    elif n.type == token.SLASH: # uncovered
        if n.parent and n.parent.type in { # uncovered
            syms.typedargslist, # uncovered
            syms.arglist, # uncovered
            syms.varargslist, # uncovered
        }: # uncovered
            features.add(Feature.POS_ONLY_ARGUMENTS) # uncovered
    elif n.type == token.COLONEQUAL: # uncovered
        features.add(Feature.ASSIGNMENT_EXPRESSIONS) # uncovered
    elif n.type == syms.decorator: # uncovered
        if len(n.children) > 1 and not is_simple_decorator_expression( # uncovered
            n.children[1] # uncovered
        ): # uncovered
            features.add(Feature.RELAXED_DECORATORS) # uncovered
    elif ( # uncovered
        n.type in {syms.typedargslist, syms.arglist} # uncovered
        and n.children # uncovered
        and n.children[-1].type == token.COMMA # uncovered
    ): # uncovered
        if n.type == syms.typedargslist: # uncovered
            feature = Feature.TRAILING_COMMA_IN_DEF # uncovered
        else: # uncovered
            feature = Feature.TRAILING_COMMA_IN_CALL # uncovered
        for ch in n.children: # uncovered
            if ch.type in STARS: # uncovered
                features.add(feature) # uncovered
            if ch.type == syms.argument: # uncovered
                for argch in ch.children: # uncovered
                    if argch.type in STARS: # uncovered
                        features.add(feature) # uncovered
    elif ( # uncovered
        n.type in {syms.return_stmt, syms.yield_expr} # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == syms.testlist_star_expr # uncovered
        and any(child.type == syms.star_expr for child in n.children[1].children) # uncovered
    ): # uncovered
        features.add(Feature.UNPACKING_ON_FLOW) # uncovered
    elif ( # uncovered
        n.type == syms.annassign # uncovered
        and len(n.children) >= 4 # uncovered
        and n.children[3].type == syms.testlist_star_expr # uncovered
    ): # uncovered
        features.add(Feature.ANN_ASSIGN_EXTENDED_RHS) # uncovered
    elif ( # uncovered
        n.type == syms.with_stmt # uncovered
        and len(n.children) > 2 # uncovered
        and n.children[1].type == syms.atom # uncovered
    ): # uncovered
        atom_children = n.children[1].children # uncovered
        if ( # uncovered
            len(atom_children) == 3 # uncovered
            and atom_children[0].type == token.LPAR # uncovered
            and atom_children[1].type == syms.testlist_gexp # uncovered
            and atom_children[2].type == token.RPAR # uncovered
        ): # uncovered
            features.add(Feature.PARENTHESIZED_CONTEXT_MANAGERS) # uncovered
    elif n.type == syms.match_stmt: # uncovered
        features.add(Feature.PATTERN_MATCHING) # uncovered
    elif ( # uncovered
        n.type == syms.except_clause # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == token.STAR # uncovered
    ): # uncovered
        features.add(Feature.EXCEPT_STAR) # uncovered
    elif n.type in {syms.subscriptlist, syms.trailer} and any( # uncovered
        child.type == syms.star_expr for child in n.children # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
    elif ( # uncovered
        n.type == syms.tname_star # uncovered
        and len(n.children) == 3 # uncovered
        and n.children[2].type == syms.star_expr # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
aux = features # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from my_module import Feature, FUTURE_FLAG_TO_FEATURE, syms, is_string_token, is_number_token, iter_fexpr_spans, is_simple_decorator_expression""
        ],
        ""initialization"": [
            ""future_imports = ['annotations']"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.FUTURE_ANNOTATIONS}"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [{'type': token.STRING, 'value': 'f\""test=\""', 'parent': None}]})()"",
            ""STARS = {token.STAR, token.STARCOMMA}"",
            ""Feature = type('Feature', (object,), {'F_STRINGS': 1, 'DEBUG_F_STRINGS': 2, 'NUMERIC_UNDERSCORES': 3, 'POS_ONLY_ARGUMENTS': 4, 'ASSIGNMENT_EXPRESSIONS': 5, 'RELAXED_DECORATORS': 6, 'TRAILING_COMMA_IN_DEF': 7, 'TRAILING_COMMA_IN_CALL': 8, 'UNPACKING_ON_FLOW': 9, 'ANN_ASSIGN_EXTENDED_RHS': 10, 'PARENTHESIZED_CONTEXT_MANAGERS': 11, 'PATTERN_MATCHING': 12, 'EXCEPT_STAR': 13, 'VARIADIC_GENERICS': 14, 'FUTURE_ANNOTATIONS': 15})"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'star_expr': 14, 'atom': 15, 'testlist_gexp': 16, 'argument': 17})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms"",
            ""from your_feature_module import Feature, FUTURE_FLAG_TO_FEATURE""
        ],
        ""initialization"": [
            ""future_imports = ['annotations']"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.FUTURE_ANNOTATIONS}"",
            ""class MockNode:  # Mock class to simulate nodes in a parse tree\n    def pre_order(self):\n        return [MockToken('f\""Hello, World!\""'), MockToken('42')]"",
            ""class MockToken:\n    def __init__(self, value):\n        self.value = value\n        self.type = token.STRING if value.startswith('f') else token.NUMBER\n        self.parent = None"",
            ""def is_string_token(n):\n    return n.type == token.STRING"",
            ""def is_number_token(n):\n    return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value):\n    # Dummy implementation to simulate f-string span extraction\n    return [(0, len(value))]"",
            ""STARS = {token.STAR, token.DOUBLE_STAR}"",
            ""nodes = MockNode()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""future_imports = []"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""class MockNode: def __init__(self, value, node_type, parent=None, children=None): self.value = value; self.type = node_type; self.parent = parent; self.children = children or []"",
            ""def is_string_token(n): return isinstance(n, MockNode) and n.type == token.STRING"",
            ""def is_number_token(n): return isinstance(n, MockNode) and n.type == token.NUMBER"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""n = MockNode('f\""example=\""', token.STRING); node = type('MockNodeList', (list,), {'pre_order': lambda self: [n]})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""future_imports = ['annotations']"",
            ""Feature = type('Feature', (), {"",
            ""    'F_STRINGS': 'f_strings',"",
            ""    'DEBUG_F_STRINGS': 'debug_f_strings',"",
            ""    'NUMERIC_UNDERSCORES': 'numeric_underscores',"",
            ""    'POS_ONLY_ARGUMENTS': 'pos_only_arguments',"",
            ""    'ASSIGNMENT_EXPRESSIONS': 'assignment_expressions',"",
            ""    'RELAXED_DECORATORS': 'relaxed_decorators',"",
            ""    'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def',"",
            ""    'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call',"",
            ""    'UNPACKING_ON_FLOW': 'unpacking_on_flow',"",
            ""    'ANN_ASSIGN_EXTENDED_RHS': 'ann_assign_extended_rhs',"",
            ""    'PARENTHESIZED_CONTEXT_MANAGERS': 'parenthesized_context_managers',"",
            ""    'PATTERN_MATCHING': 'pattern_matching',"",
            ""    'EXCEPT_STAR': 'except_star',"",
            ""    'VARIADIC_GENERICS': 'variadic_generics',"",
            ""})"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('MockToken', (object,), {'type': token.STRING, 'value': 'f{var}', 'parent': None})()]})()"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.isdigit()"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""aux = None""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': 'Feature.FUTURE_ANNOTATIONS',"",
            ""}"",
            ""future_imports = ['annotations']"",
            ""class Feature:"",
            ""    F_STRINGS = 'F_STRINGS'"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [], 'children': []})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""future_imports = []"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""def is_string_token(n): return hasattr(n, 'type') and n.type == token.STRING"",
            ""def is_number_token(n): return hasattr(n, 'type') and n.type == token.NUMBER"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('MockToken', (object,), {'type': token.STRING, 'value': 'f{var}', 'parent': None})())]})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from some_module import Feature, FUTURE_FLAG_TO_FEATURE, future_imports, is_string_token, is_number_token, iter_fexpr_spans, is_simple_decorator_expression, STARS, syms""
        ],
        ""initialization"": [
            ""future_imports = ['annotations']"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.FUTURE_ANNOTATIONS}"",
            ""class Feature: F_STRINGS = 'f-strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'positional_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations'"",
            ""class MockNode: def __init__(self, value, typ, children=[]): self.value = value; self.type = typ; self.children = children; self.parent = None for child in children: child.parent = self"",
            ""node = MockNode('', token.STRING, [MockNode('f\""Hello, {name=} f-string!\""', token.STRING)])"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value): return [(2, 3)]"",
            ""def is_simple_decorator_expression(n): return True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('syms', (), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'varargslist': 'varargslist', 'return_stmt': 'return_stmt', 'yield_expr': 'yield_expr', 'annassign': 'annassign', 'with_stmt': 'with_stmt', 'except_clause': 'except_clause', 'match_stmt': 'match_stmt', 'argument': 'argument', 'testlist_star_expr': 'testlist_star_expr', 'tname_star': 'tname_star', 'subscriptlist': 'subscriptlist', 'trailer': 'trailer'})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.DEBUG_F_STRINGS'}"",
            ""future_imports = ['annotations']"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('MockToken', (object,), {'value': 'f{x=1}', 'type': token.STRING})()]})()})()"",
            ""Feature = type('Feature', (), {'F_STRINGS': 'F_STRINGS', 'DEBUG_F_STRINGS': 'DEBUG_F_STRINGS', 'NUMERIC_UNDERSCORES': 'NUMERIC_UNDERSCORES', 'POS_ONLY_ARGUMENTS': 'POS_ONLY_ARGUMENTS', 'ASSIGNMENT_EXPRESSIONS': 'ASSIGNMENT_EXPRESSIONS', 'RELAXED_DECORATORS': 'RELAXED_DECORATORS', 'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL', 'UNPACKING_ON_FLOW': 'UNPACKING_ON_FLOW', 'ANN_ASSIGN_EXTENDED_RHS': 'ANN_ASSIGN_EXTENDED_RHS', 'PARENTHESIZED_CONTEXT_MANAGERS': 'PARENTHESIZED_CONTEXT_MANAGERS', 'PATTERN_MATCHING': 'PATTERN_MATCHING', 'EXCEPT_STAR': 'EXCEPT_STAR', 'VARIADIC_GENERICS': 'VARIADIC_GENERICS'})"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.isdigit()"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))]"",
            ""STARS = {token.STAR, token.DOUBLESTAR}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from lib2to3.pgen2 import token"",
            ""from lib2to3 import pygram, pgen2""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS, DEBUG_F_STRINGS, NUMERIC_UNDERSCORES, POS_ONLY_ARGUMENTS, ASSIGNMENT_EXPRESSIONS, RELAXED_DECORATORS, TRAILING_COMMA_IN_DEF, TRAILING_COMMA_IN_CALL, UNPACKING_ON_FLOW, ANN_ASSIGN_EXTENDED_RHS, PARENTHESIZED_CONTEXT_MANAGERS, PATTERN_MATCHING, EXCEPT_STAR, VARIADIC_GENERICS = range(13)"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [MockToken('f\""', token.STRING), MockToken('1_000', token.NUMBER)]})()"",
            ""class MockToken: def __init__(self, value, type): self.value = value; self.type = type; self.parent = None"",
            ""STARS = {token.STAR, token.STAR_expr}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 'typedargslist', 'arglist':'arglist', 'varargslist':'varargslist', 'return_stmt':'return_stmt', 'yield_expr':'yield_expr', 'annassign':'annassign', 'with_stmt':'with_stmt', 'match_stmt':'match_stmt', 'except_clause':'except_clause', 'subscriptlist':'subscriptlist', 'trailer':'trailer', 'tname_star':'tname_star', 'testlist_star_expr':'testlist_star_expr', 'star_expr':'star_expr', 'testlist_gexp':'testlist_gexp', 'atom':'atom', 'argument':'argument'})"",
            ""def is_string_token(token): return token.type == token.STRING"",
            ""def is_number_token(token): return token.type == token.NUMBER"",
            ""def is_simple_decorator_expression(child): return False"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms"",
            ""from collections import namedtuple""
        ],
        ""initialization"": [
            ""Feature = namedtuple('Feature', ['F_STRINGS', 'DEBUG_F_STRINGS', 'NUMERIC_UNDERSCORES', 'POS_ONLY_ARGUMENTS', 'ASSIGNMENT_EXPRESSIONS', 'RELAXED_DECORATORS', 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL', 'UNPACKING_ON_FLOW', 'ANN_ASSIGN_EXTENDED_RHS', 'PARENTHESIZED_CONTEXT_MANAGERS', 'PATTERN_MATCHING', 'EXCEPT_STAR', 'VARIADIC_GENERICS'])"",
            ""Feature.F_STRINGS = 'f-strings'"",
            ""Feature.DEBUG_F_STRINGS = 'debug f-strings'"",
            ""Feature.NUMERIC_UNDERSCORES = 'numeric underscores'"",
            ""Feature.POS_ONLY_ARGUMENTS = 'positional only arguments'"",
            ""Feature.ASSIGNMENT_EXPRESSIONS = 'assignment expressions'"",
            ""Feature.RELAXED_DECORATORS = 'relaxed decorators'"",
            ""Feature.TRAILING_COMMA_IN_DEF = 'trailing comma in function definition'"",
            ""Feature.TRAILING_COMMA_IN_CALL = 'trailing comma in function call'"",
            ""Feature.UNPACKING_ON_FLOW = 'unpacking on flow'"",
            ""Feature.ANN_ASSIGN_EXTENDED_RHS = 'annotation assignment with extended rhs'"",
            ""Feature.PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers'"",
            ""Feature.PATTERN_MATCHING = 'pattern matching'"",
            ""Feature.EXCEPT_STAR = 'except star'"",
            ""Feature.VARIADIC_GENERICS = 'variadic generics'"",
            ""future_imports = ['annotations']"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.NUMERIC_UNDERSCORES}"",
            ""node = Mock(pre_order=Mock(return_value=[Mock(type=token.STRING, value='f{var=}')]))"",
            ""is_string_token = lambda n: n.type == token.STRING"",
            ""is_number_token = lambda n: n.type == token.NUMBER"",
            ""iter_fexpr_spans = lambda value: [(2, 9)]"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""is_simple_decorator_expression = lambda n: False"",
            ""aux = set()""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [{'type': token.STRING, 'value': 'f\""test=\""', 'parent': None}]})() # pragma: no cover"",
            ""Feature = type('Feature', (object,), {'F_STRINGS': 1, 'DEBUG_F_STRINGS': 2, 'NUMERIC_UNDERSCORES': 3, 'POS_ONLY_ARGUMENTS': 4, 'ASSIGNMENT_EXPRESSIONS': 5, 'RELAXED_DECORATORS': 6, 'TRAILING_COMMA_IN_DEF': 7, 'TRAILING_COMMA_IN_CALL': 8, 'UNPACKING_ON_FLOW': 9, 'ANN_ASSIGN_EXTENDED_RHS': 10, 'PARENTHESIZED_CONTEXT_MANAGERS': 11, 'PATTERN_MATCHING': 12, 'EXCEPT_STAR': 13, 'VARIADIC_GENERICS': 14, 'FUTURE_ANNOTATIONS': 15}) # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'star_expr': 14, 'atom': 15, 'testlist_gexp': 16, 'argument': 17}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockNode:  # Mock class to simulate nodes in a parse tree# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [MockToken('f\""Hello, World!\""'), MockToken('42')] # pragma: no cover"",
            ""class MockToken:# pragma: no cover"",
            ""    def __init__(self, value):# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.type = token.STRING if value.startswith('f') else token.NUMBER# pragma: no cover"",
            ""        self.parent = None # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return n.type == token.STRING # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return n.type == token.NUMBER # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    # Dummy implementation to simulate f-string span extraction# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""nodes = MockNode() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""Feature = type('Feature', (), { # pragma: no cover"",
            ""    'F_STRINGS': 'f_strings', # pragma: no cover"",
            ""    'DEBUG_F_STRINGS': 'debug_f_strings', # pragma: no cover"",
            ""    'NUMERIC_UNDERSCORES': 'numeric_underscores', # pragma: no cover"",
            ""    'POS_ONLY_ARGUMENTS': 'pos_only_arguments', # pragma: no cover"",
            ""    'ASSIGNMENT_EXPRESSIONS': 'assignment_expressions', # pragma: no cover"",
            ""    'RELAXED_DECORATORS': 'relaxed_decorators', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call', # pragma: no cover"",
            ""    'UNPACKING_ON_FLOW': 'unpacking_on_flow', # pragma: no cover"",
            ""    'ANN_ASSIGN_EXTENDED_RHS': 'ann_assign_extended_rhs', # pragma: no cover"",
            ""    'PARENTHESIZED_CONTEXT_MANAGERS': 'parenthesized_context_managers', # pragma: no cover"",
            ""    'PATTERN_MATCHING': 'pattern_matching', # pragma: no cover"",
            ""    'EXCEPT_STAR': 'except_star', # pragma: no cover"",
            ""    'VARIADIC_GENERICS': 'variadic_generics', # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('MockToken', (object,), {'type': token.STRING, 'value': 'f{var}', 'parent': None})()]})() # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.isdigit() # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""aux = None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': 'Feature.FUTURE_ANNOTATIONS', # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING' # pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [], 'children': []})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'f-strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'positional_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = type('Feature', (), {'F_STRINGS': 'F_STRINGS', 'DEBUG_F_STRINGS': 'DEBUG_F_STRINGS', 'NUMERIC_UNDERSCORES': 'NUMERIC_UNDERSCORES', 'POS_ONLY_ARGUMENTS': 'POS_ONLY_ARGUMENTS', 'ASSIGNMENT_EXPRESSIONS': 'ASSIGNMENT_EXPRESSIONS', 'RELAXED_DECORATORS': 'RELAXED_DECORATORS', 'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL', 'UNPACKING_ON_FLOW': 'UNPACKING_ON_FLOW', 'ANN_ASSIGN_EXTENDED_RHS': 'ANN_ASSIGN_EXTENDED_RHS', 'PARENTHESIZED_CONTEXT_MANAGERS': 'PARENTHESIZED_CONTEXT_MANAGERS', 'PATTERN_MATCHING': 'PATTERN_MATCHING', 'EXCEPT_STAR': 'EXCEPT_STAR', 'VARIADIC_GENERICS': 'VARIADIC_GENERICS'}) # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.isdigit() # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from lib2to3.pgen2 import token # pragma: no cover"",
            ""from lib2to3 import pygram, pgen2 # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [MockToken('f\""', token.STRING), MockToken('1_000', token.NUMBER)]})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = namedtuple('Feature', ['F_STRINGS', 'DEBUG_F_STRINGS', 'NUMERIC_UNDERSCORES', 'POS_ONLY_ARGUMENTS', 'ASSIGNMENT_EXPRESSIONS', 'RELAXED_DECORATORS', 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL', 'UNPACKING_ON_FLOW', 'ANN_ASSIGN_EXTENDED_RHS', 'PARENTHESIZED_CONTEXT_MANAGERS', 'PATTERN_MATCHING', 'EXCEPT_STAR', 'VARIADIC_GENERICS']) # pragma: no cover"",
            ""Feature.F_STRINGS = 'f-strings' # pragma: no cover"",
            ""Feature.DEBUG_F_STRINGS = 'debug f-strings' # pragma: no cover"",
            ""Feature.NUMERIC_UNDERSCORES = 'numeric underscores' # pragma: no cover"",
            ""Feature.POS_ONLY_ARGUMENTS = 'positional only arguments' # pragma: no cover"",
            ""Feature.ASSIGNMENT_EXPRESSIONS = 'assignment expressions' # pragma: no cover"",
            ""Feature.RELAXED_DECORATORS = 'relaxed decorators' # pragma: no cover"",
            ""Feature.TRAILING_COMMA_IN_DEF = 'trailing comma in function definition' # pragma: no cover"",
            ""Feature.TRAILING_COMMA_IN_CALL = 'trailing comma in function call' # pragma: no cover"",
            ""Feature.UNPACKING_ON_FLOW = 'unpacking on flow' # pragma: no cover"",
            ""Feature.ANN_ASSIGN_EXTENDED_RHS = 'annotation assignment with extended rhs' # pragma: no cover"",
            ""Feature.PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers' # pragma: no cover"",
            ""Feature.PATTERN_MATCHING = 'pattern matching' # pragma: no cover"",
            ""Feature.EXCEPT_STAR = 'except star' # pragma: no cover"",
            ""Feature.VARIADIC_GENERICS = 'variadic generics' # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.NUMERIC_UNDERSCORES} # pragma: no cover"",
            ""is_string_token = lambda n: n.type == token.STRING # pragma: no cover"",
            ""is_number_token = lambda n: n.type == token.NUMBER # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(2, 9)] # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: False # pragma: no cover"",
            ""aux = set() # pragma: no cover""
        ]
    }
]",3,1561,0.0007805,4251,0.0063765,0.007157
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return a set of (relatively) new Python features used in this file.
    Currently looking for:
    - f-strings;
    - self-documenting expressions in f-strings (f""{x=}"");
    - underscores in numeric literals;
    - trailing commas after * or ** in function signatures and calls;
    - positional only arguments in function signatures and lambdas;
    - assignment expression;
    - relaxed decorator syntax;
    - usage of __future__ flags (annotations);
    - print / exec statements;
    - parenthesized context managers;
    - match statements;
    - except* clause;
    - variadic generics;
    """"""
features: Set[Feature] = set()
if future_imports: # uncovered
    features |= { # uncovered
        FUTURE_FLAG_TO_FEATURE[future_import] # uncovered
        for future_import in future_imports # uncovered
        if future_import in FUTURE_FLAG_TO_FEATURE # uncovered
    } # uncovered
for n in node.pre_order(): # uncovered
    if is_string_token(n): # uncovered
        value_head = n.value[:2] # uncovered
        if value_head in {'f""', 'F""', ""f'"", ""F'"", ""rf"", ""fr"", ""RF"", ""FR""}: # uncovered
            features.add(Feature.F_STRINGS) # uncovered
            if Feature.DEBUG_F_STRINGS not in features: # uncovered
                for span_beg, span_end in iter_fexpr_spans(n.value): # uncovered
                    if n.value[span_beg : span_end - 1].rstrip().endswith(""=""): # uncovered
                        features.add(Feature.DEBUG_F_STRINGS) # uncovered
                        break # uncovered
    elif is_number_token(n): # uncovered
        if ""_"" in n.value: # uncovered
            features.add(Feature.NUMERIC_UNDERSCORES) # uncovered
    elif n.type == token.SLASH: # uncovered
        if n.parent and n.parent.type in { # uncovered
            syms.typedargslist, # uncovered
            syms.arglist, # uncovered
            syms.varargslist, # uncovered
        }: # uncovered
            features.add(Feature.POS_ONLY_ARGUMENTS) # uncovered
    elif n.type == token.COLONEQUAL: # uncovered
        features.add(Feature.ASSIGNMENT_EXPRESSIONS) # uncovered
    elif n.type == syms.decorator: # uncovered
        if len(n.children) > 1 and not is_simple_decorator_expression( # uncovered
            n.children[1] # uncovered
        ): # uncovered
            features.add(Feature.RELAXED_DECORATORS) # uncovered
    elif ( # uncovered
        n.type in {syms.typedargslist, syms.arglist} # uncovered
        and n.children # uncovered
        and n.children[-1].type == token.COMMA # uncovered
    ): # uncovered
        if n.type == syms.typedargslist: # uncovered
            feature = Feature.TRAILING_COMMA_IN_DEF # uncovered
        else: # uncovered
            feature = Feature.TRAILING_COMMA_IN_CALL # uncovered
        for ch in n.children: # uncovered
            if ch.type in STARS: # uncovered
                features.add(feature) # uncovered
            if ch.type == syms.argument: # uncovered
                for argch in ch.children: # uncovered
                    if argch.type in STARS: # uncovered
                        features.add(feature) # uncovered
    elif ( # uncovered
        n.type in {syms.return_stmt, syms.yield_expr} # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == syms.testlist_star_expr # uncovered
        and any(child.type == syms.star_expr for child in n.children[1].children) # uncovered
    ): # uncovered
        features.add(Feature.UNPACKING_ON_FLOW) # uncovered
    elif ( # uncovered
        n.type == syms.annassign # uncovered
        and len(n.children) >= 4 # uncovered
        and n.children[3].type == syms.testlist_star_expr # uncovered
    ): # uncovered
        features.add(Feature.ANN_ASSIGN_EXTENDED_RHS) # uncovered
    elif ( # uncovered
        n.type == syms.with_stmt # uncovered
        and len(n.children) > 2 # uncovered
        and n.children[1].type == syms.atom # uncovered
    ): # uncovered
        atom_children = n.children[1].children # uncovered
        if ( # uncovered
            len(atom_children) == 3 # uncovered
            and atom_children[0].type == token.LPAR # uncovered
            and atom_children[1].type == syms.testlist_gexp # uncovered
            and atom_children[2].type == token.RPAR # uncovered
        ): # uncovered
            features.add(Feature.PARENTHESIZED_CONTEXT_MANAGERS) # uncovered
    elif n.type == syms.match_stmt: # uncovered
        features.add(Feature.PATTERN_MATCHING) # uncovered
    elif ( # uncovered
        n.type == syms.except_clause # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == token.STAR # uncovered
    ): # uncovered
        features.add(Feature.EXCEPT_STAR) # uncovered
    elif n.type in {syms.subscriptlist, syms.trailer} and any( # uncovered
        child.type == syms.star_expr for child in n.children # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
    elif ( # uncovered
        n.type == syms.tname_star # uncovered
        and len(n.children) == 3 # uncovered
        and n.children[2].type == syms.star_expr # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
aux = features # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""class MockNode: def __init__(self, value, n_type, parent=None): self.value = value; self.type = n_type; self.parent = parent; self.children = []"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""node = MockNode('f\""test={1}\""', token.STRING)"",
            ""def iter_fexpr_spans(value): return [(2, 6)]"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('syms', (object,), {'typedargslist': 'TYPEDARGSLIST', 'arglist': 'ARGLIST', 'varargslist': 'VARARGSLIST', 'return_stmt': 'RETURN_STMT', 'yield_expr': 'YIELD_EXPR', 'annassign': 'ANNASSIGN', 'with_stmt': 'WITH_STMT', 'match_stmt': 'MATCH_STMT', 'except_clause': 'EXCEPT_CLAUSE', 'argument': 'ARGUMENT'})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""class MockNode: def __init__(self, value, node_type, children=None): self.value = value; self.type = node_type; self.children = children if children else []; self.parent = None"",
            ""node = MockNode('f\""Hello, {name=}=\""', token.STRING, [])"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""iter_fexpr_spans = lambda value: [(2, len(value) - 1)]"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('MockSyms', (object,), { 'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'argument': 12, 'testlist_star_expr': 13 })""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""future_imports = ['annotations']"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.FUTURE_ANNOTATIONS}"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations'"",
            ""class MockToken: def __init__(self, value, type): self.value = value; self.type = type; self.parent = None"",
            ""class MockNode: def __init__(self, children): self.children = children"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value): return [(2, len(value))]"",
            ""node = MockNode([MockToken('f\""example={1=}\""', token.STRING)])"",
            ""STARS = {token.STAR, token.DOUBLESTAR}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""class MockNode: def __init__(self, value, node_type, parent=None, children=None): self.value = value; self.type = node_type; self.parent = parent; self.children = children or []"",
            ""node = MockNode('f\""example=\""', token.STRING)"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""iter_fexpr_spans = lambda value: [(2, len(value)-1)]"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'star_expr': 14, 'atom': 15, 'argument': 16})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""class MockNode: def __init__(self, value, typ): self.value = value; self.type = typ; self.parent = None; self.children = []"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""node = MockNode('f\""Hello, {name=}!\""', token.STRING)"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('syms', (), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'argument': 14})"",
            ""def iter_fexpr_spans(value): return [(4, 11)]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.NUMERIC_UNDERSCORES'}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""class MockNode: def __init__(self, value, type): self.value = value; self.type = type; self.parent = None; self.children = []"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""node = type('MockNodeList', (object,), {'pre_order': lambda self: [MockNode('f\""example={1=}\""', token.STRING), MockNode('1000', token.NUMBER)]})()"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'star_expr': 14, 'atom': 15 })"",
            ""def iter_fexpr_spans(value): return [(10, len(value))]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""future_imports = ['annotations']"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.FUTURE_ANNOTATIONS}"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS';"",
            ""class MockNode: def __init__(self, value, type, children=None): self.value = value; self.type = type; self.children = children if children is not None else []"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""node = MockNode('f\""example={x=}\""', token.STRING, [])"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('syms', (), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'varargslist': 'varargslist', 'return_stmt': 'return_stmt', 'yield_expr': 'yield_expr', 'annassign': 'annassign', 'with_stmt': 'with_stmt', 'match_stmt': 'match_stmt', 'except_clause': 'except_clause', 'subscriptlist': 'subscriptlist', 'trailer': 'trailer', 'tname_star': 'tname_star', 'testlist_star_expr': 'testlist_star_expr', 'star_expr': 'star_expr', 'atom': 'atom', 'argument': 'argument'})"",
            ""def iter_fexpr_spans(value): return [(2, 10)]"",
            ""aux = None""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from types import SimpleNamespace as syms""
        ],
        ""initialization"": [
            ""future_imports = ['annotations']"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""features = set()"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""class MockNode:  # Mock class to simulate nodes in a parse tree\n    def pre_order(self):\n        return [MockToken('f\""x={0}\""', token.STRING), MockToken('1_000', token.NUMBER)]"",
            ""class MockToken:\n    def __init__(self, value, typ=None):\n        self.value = value\n        self.type = typ or token.STRING\n        self.parent = None"",
            ""def is_string_token(n):\n    return n.type == token.STRING"",
            ""def is_number_token(n):\n    return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value):\n    return [(2, len(value)-1)]"",
            ""node = MockNode()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.FUTURE_ANNOTATIONS}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations'"",
            ""class MockNode: def __init__(self, type, value='', children=None): self.type = type; self.value = value; self.children = children if children is not None else []; self.parent = None"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value): return [(2, len(value) - 1)]"",
            ""node = MockNode(token.SLASH, '', [MockNode(token.STRING, 'f\""Hello, {x=} f-string!\""')])"",
            ""STARS = {token.STAR, token.DOUBLESTAR}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from my_module import Feature, FUTURE_FLAG_TO_FEATURE, syms""
        ],
        ""initialization"": [
            ""future_imports = ['annotations']"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.FUTURE_ANNOTATIONS}"",
            ""class MockNode: def __init__(self, value, type_, children=None): self.value = value; self.type = type_; self.children = children or []; self.parent = None"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""node = MockNode('f\""Hello, {world=}\""', token.STRING, [])"",
            ""def iter_fexpr_spans(value): return [(2, len(value) - 1)]"",
            ""STARS = {token.STAR, token.STAR_COMMA}"",
            ""def is_simple_decorator_expression(n): return False"",
            ""syms = type('MockSyms', (), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'atom': 14, 'argument': 15})""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.NUMERIC_UNDERSCORES'} # pragma: no cover"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS'; # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from types import SimpleNamespace as syms # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover"",
            ""class MockNode:  # Mock class to simulate nodes in a parse tree# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [MockToken('f\""x={0}\""', token.STRING), MockToken('1_000', token.NUMBER)] # pragma: no cover"",
            ""class MockToken:# pragma: no cover"",
            ""    def __init__(self, value, typ=None):# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.type = typ or token.STRING# pragma: no cover"",
            ""        self.parent = None # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return n.type == token.STRING # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return n.type == token.NUMBER # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    return [(2, len(value)-1)] # pragma: no cover"",
            ""node = MockNode() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    }
]",3,7350,0.003675,4608,0.006912,0.010587
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return a set of (relatively) new Python features used in this file.
    Currently looking for:
    - f-strings;
    - self-documenting expressions in f-strings (f""{x=}"");
    - underscores in numeric literals;
    - trailing commas after * or ** in function signatures and calls;
    - positional only arguments in function signatures and lambdas;
    - assignment expression;
    - relaxed decorator syntax;
    - usage of __future__ flags (annotations);
    - print / exec statements;
    - parenthesized context managers;
    - match statements;
    - except* clause;
    - variadic generics;
    """"""
features: Set[Feature] = set()
if future_imports: # uncovered
    features |= { # uncovered
        FUTURE_FLAG_TO_FEATURE[future_import] # uncovered
        for future_import in future_imports # uncovered
        if future_import in FUTURE_FLAG_TO_FEATURE # uncovered
    } # uncovered
for n in node.pre_order(): # uncovered
    if is_string_token(n): # uncovered
        value_head = n.value[:2] # uncovered
        if value_head in {'f""', 'F""', ""f'"", ""F'"", ""rf"", ""fr"", ""RF"", ""FR""}: # uncovered
            features.add(Feature.F_STRINGS) # uncovered
            if Feature.DEBUG_F_STRINGS not in features: # uncovered
                for span_beg, span_end in iter_fexpr_spans(n.value): # uncovered
                    if n.value[span_beg : span_end - 1].rstrip().endswith(""=""): # uncovered
                        features.add(Feature.DEBUG_F_STRINGS) # uncovered
                        break # uncovered
    elif is_number_token(n): # uncovered
        if ""_"" in n.value: # uncovered
            features.add(Feature.NUMERIC_UNDERSCORES) # uncovered
    elif n.type == token.SLASH: # uncovered
        if n.parent and n.parent.type in { # uncovered
            syms.typedargslist, # uncovered
            syms.arglist, # uncovered
            syms.varargslist, # uncovered
        }: # uncovered
            features.add(Feature.POS_ONLY_ARGUMENTS) # uncovered
    elif n.type == token.COLONEQUAL: # uncovered
        features.add(Feature.ASSIGNMENT_EXPRESSIONS) # uncovered
    elif n.type == syms.decorator: # uncovered
        if len(n.children) > 1 and not is_simple_decorator_expression( # uncovered
            n.children[1] # uncovered
        ): # uncovered
            features.add(Feature.RELAXED_DECORATORS) # uncovered
    elif ( # uncovered
        n.type in {syms.typedargslist, syms.arglist} # uncovered
        and n.children # uncovered
        and n.children[-1].type == token.COMMA # uncovered
    ): # uncovered
        if n.type == syms.typedargslist: # uncovered
            feature = Feature.TRAILING_COMMA_IN_DEF # uncovered
        else: # uncovered
            feature = Feature.TRAILING_COMMA_IN_CALL # uncovered
        for ch in n.children: # uncovered
            if ch.type in STARS: # uncovered
                features.add(feature) # uncovered
            if ch.type == syms.argument: # uncovered
                for argch in ch.children: # uncovered
                    if argch.type in STARS: # uncovered
                        features.add(feature) # uncovered
    elif ( # uncovered
        n.type in {syms.return_stmt, syms.yield_expr} # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == syms.testlist_star_expr # uncovered
        and any(child.type == syms.star_expr for child in n.children[1].children) # uncovered
    ): # uncovered
        features.add(Feature.UNPACKING_ON_FLOW) # uncovered
    elif ( # uncovered
        n.type == syms.annassign # uncovered
        and len(n.children) >= 4 # uncovered
        and n.children[3].type == syms.testlist_star_expr # uncovered
    ): # uncovered
        features.add(Feature.ANN_ASSIGN_EXTENDED_RHS) # uncovered
    elif ( # uncovered
        n.type == syms.with_stmt # uncovered
        and len(n.children) > 2 # uncovered
        and n.children[1].type == syms.atom # uncovered
    ): # uncovered
        atom_children = n.children[1].children # uncovered
        if ( # uncovered
            len(atom_children) == 3 # uncovered
            and atom_children[0].type == token.LPAR # uncovered
            and atom_children[1].type == syms.testlist_gexp # uncovered
            and atom_children[2].type == token.RPAR # uncovered
        ): # uncovered
            features.add(Feature.PARENTHESIZED_CONTEXT_MANAGERS) # uncovered
    elif n.type == syms.match_stmt: # uncovered
        features.add(Feature.PATTERN_MATCHING) # uncovered
    elif ( # uncovered
        n.type == syms.except_clause # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == token.STAR # uncovered
    ): # uncovered
        features.add(Feature.EXCEPT_STAR) # uncovered
    elif n.type in {syms.subscriptlist, syms.trailer} and any( # uncovered
        child.type == syms.star_expr for child in n.children # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
    elif ( # uncovered
        n.type == syms.tname_star # uncovered
        and len(n.children) == 3 # uncovered
        and n.children[2].type == syms.star_expr # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
aux = features # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""features = set()"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""class MockNode: def __init__(self, value, type_, children=None): self.value = value; self.type = type_; self.children = children or []; self.parent = None"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value): return [(2, len(value)-1)]"",
            ""node = MockNode('f\""example={x=}\""', token.STRING, [MockNode('1_000', token.NUMBER)])"",
            ""class MockSyms: typedargslist, arglist, varargslist = range(3)"",
            ""syms = MockSyms()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""features = set()"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations'"",
            ""class MockNode: def __init__(self, value, type, children=None): self.value = value; self.type = type; self.children = children if children else []; self.parent = None"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value): return [(2, len(value) - 1)]"",
            ""node = MockNode('f\""example={x=}\""', token.STRING, []), node.pre_order = lambda: [MockNode('f\""example={x=}\""', token.STRING), MockNode('1_000', token.NUMBER)]"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'star_expr': 14, 'atom': 15})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""features = set()"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS';"",
            ""class MockNode: def __init__(self, node_type, value='', parent=None): self.type = node_type; self.value = value; self.parent = parent; self.children = []"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value): return [(2, len(value) - 1)]"",
            ""node = MockNode(token.STRING, 'f\""example={x=}\""')"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'star_expr': 14, 'argument': 15})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""features = set()"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""class MockNode: def __init__(self, type, value='', children=None): self.value = value; self.type = type; self.parent = None; self.children = children or []"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""syms = type('syms', (), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'argument': 14})"",
            ""def iter_fexpr_spans(value): return [(2, len(value)-1)]"",
            ""node = MockNode(token.SLASH, '', [MockNode(token.STRING, 'f\""value={1}\""')])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""features = set()"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""class MockNode: def __init__(self, type_, children=None): self.type = type_; self.children = children or []"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value): return [(2, len(value)-1)]"",
            ""node = type('MockNodeList', (object,), {'pre_order': lambda self: [MockNode(token.SLASH, []), MockNode(token.NUMBER, '1_000')]})()"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'star_expr': 14, 'atom': 15, 'argument': 16})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations'"",
            ""class MockNode: def __init__(self, value, type_, children=None): self.value = value; self.type = type_; self.children = children if children is not None else []; self.parent = None"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value): return [(2, len(value) - 1)]"",
            ""node = MockNode('f\""x={1}\""', token.STRING)"",
            ""def mock_pre_order(): return [node, MockNode('1_000', token.NUMBER)]"",
            ""node.pre_order = mock_pre_order"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'varargslist': 'varargslist', 'return_stmt': 'return_stmt', 'yield_expr': 'yield_expr', 'annassign': 'annassign', 'with_stmt': 'with_stmt', 'match_stmt': 'match_stmt', 'except_clause': 'except_clause', 'subscriptlist': 'subscriptlist', 'trailer': 'trailer', 'tname_star': 'tname_star', 'testlist_star_expr': 'testlist_star_expr', 'star_expr': 'star_expr', 'argument': 'argument'})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""class MockNode: def __init__(self, type, children=None): self.type = type; self.children = children if children is not None else []"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value): return [(2, len(value)-1)]"",
            ""node = MockNode(token.SLASH, [MockNode(token.STRING, 'f\""x={0}\""')])"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'argument': 14})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""features = set()"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations'"",
            ""class MockNode: def __init__(self, value, n_type, parent=None): self.value = value; self.type = n_type; self.parent = parent; self.children = []"",
            ""class MockToken: def __init__(self, value, typ=None): self.value = value; self.type = typ or token.STRING; self.children = []"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""node = MockNode('f\""x={42}\""', token.STRING, [])"",
            ""def iter_fexpr_spans(value): return [(2, len(value) - 1)]"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'star_expr': 14, 'atom': 15, 'argument': 16})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""features = set()"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS'; FUTURE_ANNOTATIONS = 'FUTURE_ANNOTATIONS'"",
            ""class MockNode: def __init__(self, value, ntype, children=None): self.value = value; self.type = ntype; self.parent = None; self.children = children if children is not None else []"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""node = MockNode('f\""Val={x=}\""', token.STRING, [])"",
            ""def iter_fexpr_spans(value): return [(2, len(value) - 1)]"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'varargslist': 'varargslist', 'return_stmt': 'return_stmt', 'yield_expr': 'yield_expr', 'annassign': 'annassign', 'with_stmt': 'with_stmt', 'match_stmt': 'match_stmt', 'except_clause': 'except_clause', 'subscriptlist': 'subscriptlist', 'trailer': 'trailer', 'tname_star': 'tname_star', 'testlist_star_expr': 'testlist_star_expr', 'star_expr': 'star_expr', 'atom': 'atom', 'argument': 'argument'})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations'"",
            ""class MockNode: def __init__(self, value, n_type, parent=None): self.value = value; self.type = n_type; self.parent = parent; self.children = []"",
            ""node = MockNode('f\""example={x=}\"""",
            1,
            [
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20,
                21,
                22,
                23,
                24,
                25,
                26,
                27,
                28,
                29,
                30,
                31,
                32,
                33,
                34,
                35,
                36,
                37,
                38,
                39,
                40,
                41,
                42,
                43,
                44,
                45,
                46,
                47,
                48,
                49,
                50,
                51,
                52,
                53,
                54,
                55,
                56,
                57,
                58,
                59,
                60,
                61,
                62,
                63,
                64,
                65,
                66,
                67,
                68,
                69,
                70,
                71,
                72,
                73,
                74,
                75,
                76,
                77,
                78,
                79,
                80,
                81,
                82,
                83,
                84,
                85,
                86,
                87,
                88,
                89,
                90,
                91,
                92,
                93,
                94,
                95,
                96,
                97,
                98,
                99,
                100,
                101,
                102,
                103,
                104,
                105,
                106,
                107,
                108,
                109,
                110,
                111,
                112,
                113,
                114,
                115,
                116,
                117,
                118,
                119,
                120,
                121,
                122,
                123,
                124,
                125,
                126,
                127,
                128,
                129,
                130,
                131,
                132,
                133,
                134,
                135,
                136,
                137,
                138,
                139,
                140,
                141,
                142,
                143,
                144,
                145,
                146,
                147,
                148,
                149,
                150,
                151,
                152,
                153,
                154,
                155,
                156,
                157,
                158,
                159,
                160,
                161,
                162,
                163,
                164,
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                174,
                175,
                176,
                177,
                178,
                179,
                180,
                181,
                182,
                183,
                184,
                185,
                186,
                187,
                188,
                189,
                190,
                191,
                192,
                193,
                194,
                195,
                196,
                197,
                198,
                199,
                200,
                201,
                202,
                203,
                204,
                205,
                206,
                207,
                208,
                209,
                210,
                211,
                212,
                213,
                214,
                215,
                216,
                217,
                218,
                219,
                220,
                221,
                222,
                223,
                224,
                225,
                226,
                227,
                228,
                229,
                230,
                231,
                232,
                233,
                234,
                235,
                236,
                237,
                238,
                239,
                240,
                241,
                242,
                243,
                244,
                245,
                246,
                247,
                248,
                249,
                250,
                251,
                252,
                253,
                254,
                255,
                256,
                257,
                258,
                259,
                260,
                261,
                262,
                263,
                264,
                265,
                266,
                267,
                268,
                269,
                270,
                271,
                272,
                273,
                274,
                275,
                276,
                277,
                278,
                279,
                280,
                281,
                282,
                283,
                284,
                285,
                286,
                287,
                288,
                289,
                290,
                291,
                292,
                293,
                294,
                295,
                296,
                297,
                298,
                299,
                300,
                301,
                302,
                303,
                304,
                305,
                306,
                307,
                308,
                309,
                310,
                311,
                312,
                313,
                314,
                315,
                316,
                317,
                318,
                319,
                320,
                321,
                322,
                323,
                324,
                325,
                326,
                327,
                328,
                329,
                330,
                331,
                332,
                333,
                334,
                335,
                336,
                337,
                338,
                339,
                340,
                341,
                342,
                343,
                344,
                345,
                346,
                347,
                348,
                349,
                350,
                351,
                352,
                353,
                354,
                355,
                356,
                357,
                358,
                359,
                360,
                361,
                362,
                363,
                364,
                365,
                366,
                367,
                368,
                369,
                370,
                371,
                372,
                373,
                374,
                375,
                376,
                377,
                378,
                379,
                380,
                381,
                382,
                383,
                384,
                385,
                386,
                387,
                388,
                389,
                390,
                391,
                392,
                393,
                394,
                395,
                396,
                397,
                398,
                399,
                400,
                401,
                402,
                403,
                404,
                405,
                406,
                407,
                408,
                409,
                410,
                411,
                412,
                413,
                414,
                415,
                416,
                417,
                418,
                419
            ]
        ],
        ""STARS = {token.STAR, token.DOUBLESTAR}"": ""def is_string_token(n): return n.type == token.STRING"",
        ""def is_number_token(n): return n.type == token.NUMBER"": 0,
        ""iter_fexpr_spans = lambda value: [(2, len(value) - 1)]"": """",
        ""node = MockNode('1000', token.NUMBER)"": {}
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""features = set() # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS'; # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.FUTURE_ANNOTATIONS'} # pragma: no cover"",
            ""features = set() # pragma: no cover"",
            ""class Feature: F_STRINGS = 'F_STRINGS'; DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'; NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'; POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'; ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'; RELAXED_DECORATORS = 'RELAXED_DECORATORS'; TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'; TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'; UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'; ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'; PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'; PATTERN_MATCHING = 'PATTERN_MATCHING'; EXCEPT_STAR = 'EXCEPT_STAR'; VARIADIC_GENERICS = 'VARIADIC_GENERICS'; FUTURE_ANNOTATIONS = 'FUTURE_ANNOTATIONS' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    }
]",3,7707,0.0038535,20630,0.030945,0.0347985
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return a set of (relatively) new Python features used in this file.
    Currently looking for:
    - f-strings;
    - self-documenting expressions in f-strings (f""{x=}"");
    - underscores in numeric literals;
    - trailing commas after * or ** in function signatures and calls;
    - positional only arguments in function signatures and lambdas;
    - assignment expression;
    - relaxed decorator syntax;
    - usage of __future__ flags (annotations);
    - print / exec statements;
    - parenthesized context managers;
    - match statements;
    - except* clause;
    - variadic generics;
    """"""
features: Set[Feature] = set()
if future_imports: # uncovered
    features |= { # uncovered
        FUTURE_FLAG_TO_FEATURE[future_import] # uncovered
        for future_import in future_imports # uncovered
        if future_import in FUTURE_FLAG_TO_FEATURE # uncovered
    } # uncovered
for n in node.pre_order(): # uncovered
    if is_string_token(n): # uncovered
        value_head = n.value[:2] # uncovered
        if value_head in {'f""', 'F""', ""f'"", ""F'"", ""rf"", ""fr"", ""RF"", ""FR""}: # uncovered
            features.add(Feature.F_STRINGS) # uncovered
            if Feature.DEBUG_F_STRINGS not in features: # uncovered
                for span_beg, span_end in iter_fexpr_spans(n.value): # uncovered
                    if n.value[span_beg : span_end - 1].rstrip().endswith(""=""): # uncovered
                        features.add(Feature.DEBUG_F_STRINGS) # uncovered
                        break # uncovered
    elif is_number_token(n): # uncovered
        if ""_"" in n.value: # uncovered
            features.add(Feature.NUMERIC_UNDERSCORES) # uncovered
    elif n.type == token.SLASH: # uncovered
        if n.parent and n.parent.type in { # uncovered
            syms.typedargslist, # uncovered
            syms.arglist, # uncovered
            syms.varargslist, # uncovered
        }: # uncovered
            features.add(Feature.POS_ONLY_ARGUMENTS) # uncovered
    elif n.type == token.COLONEQUAL: # uncovered
        features.add(Feature.ASSIGNMENT_EXPRESSIONS) # uncovered
    elif n.type == syms.decorator: # uncovered
        if len(n.children) > 1 and not is_simple_decorator_expression( # uncovered
            n.children[1] # uncovered
        ): # uncovered
            features.add(Feature.RELAXED_DECORATORS) # uncovered
    elif ( # uncovered
        n.type in {syms.typedargslist, syms.arglist} # uncovered
        and n.children # uncovered
        and n.children[-1].type == token.COMMA # uncovered
    ): # uncovered
        if n.type == syms.typedargslist: # uncovered
            feature = Feature.TRAILING_COMMA_IN_DEF # uncovered
        else: # uncovered
            feature = Feature.TRAILING_COMMA_IN_CALL # uncovered
        for ch in n.children: # uncovered
            if ch.type in STARS: # uncovered
                features.add(feature) # uncovered
            if ch.type == syms.argument: # uncovered
                for argch in ch.children: # uncovered
                    if argch.type in STARS: # uncovered
                        features.add(feature) # uncovered
    elif ( # uncovered
        n.type in {syms.return_stmt, syms.yield_expr} # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == syms.testlist_star_expr # uncovered
        and any(child.type == syms.star_expr for child in n.children[1].children) # uncovered
    ): # uncovered
        features.add(Feature.UNPACKING_ON_FLOW) # uncovered
    elif ( # uncovered
        n.type == syms.annassign # uncovered
        and len(n.children) >= 4 # uncovered
        and n.children[3].type == syms.testlist_star_expr # uncovered
    ): # uncovered
        features.add(Feature.ANN_ASSIGN_EXTENDED_RHS) # uncovered
    elif ( # uncovered
        n.type == syms.with_stmt # uncovered
        and len(n.children) > 2 # uncovered
        and n.children[1].type == syms.atom # uncovered
    ): # uncovered
        atom_children = n.children[1].children # uncovered
        if ( # uncovered
            len(atom_children) == 3 # uncovered
            and atom_children[0].type == token.LPAR # uncovered
            and atom_children[1].type == syms.testlist_gexp # uncovered
            and atom_children[2].type == token.RPAR # uncovered
        ): # uncovered
            features.add(Feature.PARENTHESIZED_CONTEXT_MANAGERS) # uncovered
    elif n.type == syms.match_stmt: # uncovered
        features.add(Feature.PATTERN_MATCHING) # uncovered
    elif ( # uncovered
        n.type == syms.except_clause # uncovered
        and len(n.children) >= 2 # uncovered
        and n.children[1].type == token.STAR # uncovered
    ): # uncovered
        features.add(Feature.EXCEPT_STAR) # uncovered
    elif n.type in {syms.subscriptlist, syms.trailer} and any( # uncovered
        child.type == syms.star_expr for child in n.children # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
    elif ( # uncovered
        n.type == syms.tname_star # uncovered
        and len(n.children) == 3 # uncovered
        and n.children[2].type == syms.star_expr # uncovered
    ): # uncovered
        features.add(Feature.VARIADIC_GENERICS) # uncovered
aux = features # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from my_module import Feature, FUTURE_FLAG_TO_FEATURE, syms, is_string_token, is_number_token, iter_fexpr_spans, is_simple_decorator_expression""
        ],
        ""initialization"": [
            ""future_imports = ['annotations']"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.FUTURE_ANNOTATIONS}"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [{'type': token.STRING, 'value': 'f\""test=\""', 'parent': None}]})()"",
            ""STARS = {token.STAR, token.STARCOMMA}"",
            ""Feature = type('Feature', (object,), {'F_STRINGS': 1, 'DEBUG_F_STRINGS': 2, 'NUMERIC_UNDERSCORES': 3, 'POS_ONLY_ARGUMENTS': 4, 'ASSIGNMENT_EXPRESSIONS': 5, 'RELAXED_DECORATORS': 6, 'TRAILING_COMMA_IN_DEF': 7, 'TRAILING_COMMA_IN_CALL': 8, 'UNPACKING_ON_FLOW': 9, 'ANN_ASSIGN_EXTENDED_RHS': 10, 'PARENTHESIZED_CONTEXT_MANAGERS': 11, 'PATTERN_MATCHING': 12, 'EXCEPT_STAR': 13, 'VARIADIC_GENERICS': 14, 'FUTURE_ANNOTATIONS': 15})"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'star_expr': 14, 'atom': 15, 'testlist_gexp': 16, 'argument': 17})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms"",
            ""from your_feature_module import Feature, FUTURE_FLAG_TO_FEATURE""
        ],
        ""initialization"": [
            ""future_imports = ['annotations']"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.FUTURE_ANNOTATIONS}"",
            ""class MockNode:  # Mock class to simulate nodes in a parse tree\n    def pre_order(self):\n        return [MockToken('f\""Hello, World!\""'), MockToken('42')]"",
            ""class MockToken:\n    def __init__(self, value):\n        self.value = value\n        self.type = token.STRING if value.startswith('f') else token.NUMBER\n        self.parent = None"",
            ""def is_string_token(n):\n    return n.type == token.STRING"",
            ""def is_number_token(n):\n    return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value):\n    # Dummy implementation to simulate f-string span extraction\n    return [(0, len(value))]"",
            ""STARS = {token.STAR, token.DOUBLE_STAR}"",
            ""nodes = MockNode()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""future_imports = []"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""class MockNode: def __init__(self, value, node_type, parent=None, children=None): self.value = value; self.type = node_type; self.parent = parent; self.children = children or []"",
            ""def is_string_token(n): return isinstance(n, MockNode) and n.type == token.STRING"",
            ""def is_number_token(n): return isinstance(n, MockNode) and n.type == token.NUMBER"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]"",
            ""n = MockNode('f\""example=\""', token.STRING); node = type('MockNodeList', (list,), {'pre_order': lambda self: [n]})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""future_imports = ['annotations']"",
            ""Feature = type('Feature', (), {"",
            ""    'F_STRINGS': 'f_strings',"",
            ""    'DEBUG_F_STRINGS': 'debug_f_strings',"",
            ""    'NUMERIC_UNDERSCORES': 'numeric_underscores',"",
            ""    'POS_ONLY_ARGUMENTS': 'pos_only_arguments',"",
            ""    'ASSIGNMENT_EXPRESSIONS': 'assignment_expressions',"",
            ""    'RELAXED_DECORATORS': 'relaxed_decorators',"",
            ""    'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def',"",
            ""    'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call',"",
            ""    'UNPACKING_ON_FLOW': 'unpacking_on_flow',"",
            ""    'ANN_ASSIGN_EXTENDED_RHS': 'ann_assign_extended_rhs',"",
            ""    'PARENTHESIZED_CONTEXT_MANAGERS': 'parenthesized_context_managers',"",
            ""    'PATTERN_MATCHING': 'pattern_matching',"",
            ""    'EXCEPT_STAR': 'except_star',"",
            ""    'VARIADIC_GENERICS': 'variadic_generics',"",
            ""})"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('MockToken', (object,), {'type': token.STRING, 'value': 'f{var}', 'parent': None})()]})()"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.isdigit()"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""aux = None""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {"",
            ""    'annotations': 'Feature.FUTURE_ANNOTATIONS',"",
            ""}"",
            ""future_imports = ['annotations']"",
            ""class Feature:"",
            ""    F_STRINGS = 'F_STRINGS'"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS'"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES'"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS'"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS'"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS'"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF'"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL'"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW'"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS'"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS'"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING'"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR'"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS'"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [], 'children': []})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""future_imports = []"",
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'"",
            ""def is_string_token(n): return hasattr(n, 'type') and n.type == token.STRING"",
            ""def is_number_token(n): return hasattr(n, 'type') and n.type == token.NUMBER"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('MockToken', (object,), {'type': token.STRING, 'value': 'f{var}', 'parent': None})())]})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from some_module import Feature, FUTURE_FLAG_TO_FEATURE, future_imports, is_string_token, is_number_token, iter_fexpr_spans, is_simple_decorator_expression, STARS, syms""
        ],
        ""initialization"": [
            ""future_imports = ['annotations']"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.FUTURE_ANNOTATIONS}"",
            ""class Feature: F_STRINGS = 'f-strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'positional_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations'"",
            ""class MockNode: def __init__(self, value, typ, children=[]): self.value = value; self.type = typ; self.children = children; self.parent = None for child in children: child.parent = self"",
            ""node = MockNode('', token.STRING, [MockNode('f\""Hello, {name=} f-string!\""', token.STRING)])"",
            ""def is_string_token(n): return n.type == token.STRING"",
            ""def is_number_token(n): return n.type == token.NUMBER"",
            ""def iter_fexpr_spans(value): return [(2, 3)]"",
            ""def is_simple_decorator_expression(n): return True"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""syms = type('syms', (), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'varargslist': 'varargslist', 'return_stmt': 'return_stmt', 'yield_expr': 'yield_expr', 'annassign': 'annassign', 'with_stmt': 'with_stmt', 'except_clause': 'except_clause', 'match_stmt': 'match_stmt', 'argument': 'argument', 'testlist_star_expr': 'testlist_star_expr', 'tname_star': 'tname_star', 'subscriptlist': 'subscriptlist', 'trailer': 'trailer'})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': 'Feature.DEBUG_F_STRINGS'}"",
            ""future_imports = ['annotations']"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('MockToken', (object,), {'value': 'f{x=1}', 'type': token.STRING})()]})()})()"",
            ""Feature = type('Feature', (), {'F_STRINGS': 'F_STRINGS', 'DEBUG_F_STRINGS': 'DEBUG_F_STRINGS', 'NUMERIC_UNDERSCORES': 'NUMERIC_UNDERSCORES', 'POS_ONLY_ARGUMENTS': 'POS_ONLY_ARGUMENTS', 'ASSIGNMENT_EXPRESSIONS': 'ASSIGNMENT_EXPRESSIONS', 'RELAXED_DECORATORS': 'RELAXED_DECORATORS', 'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL', 'UNPACKING_ON_FLOW': 'UNPACKING_ON_FLOW', 'ANN_ASSIGN_EXTENDED_RHS': 'ANN_ASSIGN_EXTENDED_RHS', 'PARENTHESIZED_CONTEXT_MANAGERS': 'PARENTHESIZED_CONTEXT_MANAGERS', 'PATTERN_MATCHING': 'PATTERN_MATCHING', 'EXCEPT_STAR': 'EXCEPT_STAR', 'VARIADIC_GENERICS': 'VARIADIC_GENERICS'})"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str)"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.isdigit()"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))]"",
            ""STARS = {token.STAR, token.DOUBLESTAR}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""from lib2to3.pgen2 import token"",
            ""from lib2to3 import pygram, pgen2""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {}"",
            ""future_imports = ['annotations']"",
            ""class Feature: F_STRINGS, DEBUG_F_STRINGS, NUMERIC_UNDERSCORES, POS_ONLY_ARGUMENTS, ASSIGNMENT_EXPRESSIONS, RELAXED_DECORATORS, TRAILING_COMMA_IN_DEF, TRAILING_COMMA_IN_CALL, UNPACKING_ON_FLOW, ANN_ASSIGN_EXTENDED_RHS, PARENTHESIZED_CONTEXT_MANAGERS, PATTERN_MATCHING, EXCEPT_STAR, VARIADIC_GENERICS = range(13)"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [MockToken('f\""', token.STRING), MockToken('1_000', token.NUMBER)]})()"",
            ""class MockToken: def __init__(self, value, type): self.value = value; self.type = type; self.parent = None"",
            ""STARS = {token.STAR, token.STAR_expr}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 'typedargslist', 'arglist':'arglist', 'varargslist':'varargslist', 'return_stmt':'return_stmt', 'yield_expr':'yield_expr', 'annassign':'annassign', 'with_stmt':'with_stmt', 'match_stmt':'match_stmt', 'except_clause':'except_clause', 'subscriptlist':'subscriptlist', 'trailer':'trailer', 'tname_star':'tname_star', 'testlist_star_expr':'testlist_star_expr', 'star_expr':'star_expr', 'testlist_gexp':'testlist_gexp', 'atom':'atom', 'argument':'argument'})"",
            ""def is_string_token(token): return token.type == token.STRING"",
            ""def is_number_token(token): return token.type == token.NUMBER"",
            ""def is_simple_decorator_expression(child): return False"",
            ""def iter_fexpr_spans(value): return [(0, len(value))]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set"",
            ""import token"",
            ""import syms"",
            ""from collections import namedtuple""
        ],
        ""initialization"": [
            ""Feature = namedtuple('Feature', ['F_STRINGS', 'DEBUG_F_STRINGS', 'NUMERIC_UNDERSCORES', 'POS_ONLY_ARGUMENTS', 'ASSIGNMENT_EXPRESSIONS', 'RELAXED_DECORATORS', 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL', 'UNPACKING_ON_FLOW', 'ANN_ASSIGN_EXTENDED_RHS', 'PARENTHESIZED_CONTEXT_MANAGERS', 'PATTERN_MATCHING', 'EXCEPT_STAR', 'VARIADIC_GENERICS'])"",
            ""Feature.F_STRINGS = 'f-strings'"",
            ""Feature.DEBUG_F_STRINGS = 'debug f-strings'"",
            ""Feature.NUMERIC_UNDERSCORES = 'numeric underscores'"",
            ""Feature.POS_ONLY_ARGUMENTS = 'positional only arguments'"",
            ""Feature.ASSIGNMENT_EXPRESSIONS = 'assignment expressions'"",
            ""Feature.RELAXED_DECORATORS = 'relaxed decorators'"",
            ""Feature.TRAILING_COMMA_IN_DEF = 'trailing comma in function definition'"",
            ""Feature.TRAILING_COMMA_IN_CALL = 'trailing comma in function call'"",
            ""Feature.UNPACKING_ON_FLOW = 'unpacking on flow'"",
            ""Feature.ANN_ASSIGN_EXTENDED_RHS = 'annotation assignment with extended rhs'"",
            ""Feature.PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers'"",
            ""Feature.PATTERN_MATCHING = 'pattern matching'"",
            ""Feature.EXCEPT_STAR = 'except star'"",
            ""Feature.VARIADIC_GENERICS = 'variadic generics'"",
            ""future_imports = ['annotations']"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.NUMERIC_UNDERSCORES}"",
            ""node = Mock(pre_order=Mock(return_value=[Mock(type=token.STRING, value='f{var=}')]))"",
            ""is_string_token = lambda n: n.type == token.STRING"",
            ""is_number_token = lambda n: n.type == token.NUMBER"",
            ""iter_fexpr_spans = lambda value: [(2, 9)]"",
            ""STARS = {token.STAR, token.DOUBLESTAR}"",
            ""is_simple_decorator_expression = lambda n: False"",
            ""aux = set()""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [{'type': token.STRING, 'value': 'f\""test=\""', 'parent': None}]})() # pragma: no cover"",
            ""Feature = type('Feature', (object,), {'F_STRINGS': 1, 'DEBUG_F_STRINGS': 2, 'NUMERIC_UNDERSCORES': 3, 'POS_ONLY_ARGUMENTS': 4, 'ASSIGNMENT_EXPRESSIONS': 5, 'RELAXED_DECORATORS': 6, 'TRAILING_COMMA_IN_DEF': 7, 'TRAILING_COMMA_IN_CALL': 8, 'UNPACKING_ON_FLOW': 9, 'ANN_ASSIGN_EXTENDED_RHS': 10, 'PARENTHESIZED_CONTEXT_MANAGERS': 11, 'PATTERN_MATCHING': 12, 'EXCEPT_STAR': 13, 'VARIADIC_GENERICS': 14, 'FUTURE_ANNOTATIONS': 15}) # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'varargslist': 3, 'return_stmt': 4, 'yield_expr': 5, 'annassign': 6, 'with_stmt': 7, 'match_stmt': 8, 'except_clause': 9, 'subscriptlist': 10, 'trailer': 11, 'tname_star': 12, 'testlist_star_expr': 13, 'star_expr': 14, 'atom': 15, 'testlist_gexp': 16, 'argument': 17}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockNode:  # Mock class to simulate nodes in a parse tree# pragma: no cover"",
            ""    def pre_order(self):# pragma: no cover"",
            ""        return [MockToken('f\""Hello, World!\""'), MockToken('42')] # pragma: no cover"",
            ""class MockToken:# pragma: no cover"",
            ""    def __init__(self, value):# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.type = token.STRING if value.startswith('f') else token.NUMBER# pragma: no cover"",
            ""        self.parent = None # pragma: no cover"",
            ""def is_string_token(n):# pragma: no cover"",
            ""    return n.type == token.STRING # pragma: no cover"",
            ""def is_number_token(n):# pragma: no cover"",
            ""    return n.type == token.NUMBER # pragma: no cover"",
            ""def iter_fexpr_spans(value):# pragma: no cover"",
            ""    # Dummy implementation to simulate f-string span extraction# pragma: no cover"",
            ""    return [(0, len(value))] # pragma: no cover"",
            ""nodes = MockNode() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""class Feature: F_STRINGS = 'f_strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'pos_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""Feature = type('Feature', (), { # pragma: no cover"",
            ""    'F_STRINGS': 'f_strings', # pragma: no cover"",
            ""    'DEBUG_F_STRINGS': 'debug_f_strings', # pragma: no cover"",
            ""    'NUMERIC_UNDERSCORES': 'numeric_underscores', # pragma: no cover"",
            ""    'POS_ONLY_ARGUMENTS': 'pos_only_arguments', # pragma: no cover"",
            ""    'ASSIGNMENT_EXPRESSIONS': 'assignment_expressions', # pragma: no cover"",
            ""    'RELAXED_DECORATORS': 'relaxed_decorators', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 'trailing_comma_in_def', # pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 'trailing_comma_in_call', # pragma: no cover"",
            ""    'UNPACKING_ON_FLOW': 'unpacking_on_flow', # pragma: no cover"",
            ""    'ANN_ASSIGN_EXTENDED_RHS': 'ann_assign_extended_rhs', # pragma: no cover"",
            ""    'PARENTHESIZED_CONTEXT_MANAGERS': 'parenthesized_context_managers', # pragma: no cover"",
            ""    'PATTERN_MATCHING': 'pattern_matching', # pragma: no cover"",
            ""    'EXCEPT_STAR': 'except_star', # pragma: no cover"",
            ""    'VARIADIC_GENERICS': 'variadic_generics', # pragma: no cover"",
            ""}) # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [type('MockToken', (object,), {'type': token.STRING, 'value': 'f{var}', 'parent': None})()]})() # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.isdigit() # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""aux = None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = { # pragma: no cover"",
            ""    'annotations': 'Feature.FUTURE_ANNOTATIONS', # pragma: no cover"",
            ""} # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    F_STRINGS = 'F_STRINGS' # pragma: no cover"",
            ""    DEBUG_F_STRINGS = 'DEBUG_F_STRINGS' # pragma: no cover"",
            ""    NUMERIC_UNDERSCORES = 'NUMERIC_UNDERSCORES' # pragma: no cover"",
            ""    POS_ONLY_ARGUMENTS = 'POS_ONLY_ARGUMENTS' # pragma: no cover"",
            ""    ASSIGNMENT_EXPRESSIONS = 'ASSIGNMENT_EXPRESSIONS' # pragma: no cover"",
            ""    RELAXED_DECORATORS = 'RELAXED_DECORATORS' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'TRAILING_COMMA_IN_DEF' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'TRAILING_COMMA_IN_CALL' # pragma: no cover"",
            ""    UNPACKING_ON_FLOW = 'UNPACKING_ON_FLOW' # pragma: no cover"",
            ""    ANN_ASSIGN_EXTENDED_RHS = 'ANN_ASSIGN_EXTENDED_RHS' # pragma: no cover"",
            ""    PARENTHESIZED_CONTEXT_MANAGERS = 'PARENTHESIZED_CONTEXT_MANAGERS' # pragma: no cover"",
            ""    PATTERN_MATCHING = 'PATTERN_MATCHING' # pragma: no cover"",
            ""    EXCEPT_STAR = 'EXCEPT_STAR' # pragma: no cover"",
            ""    VARIADIC_GENERICS = 'VARIADIC_GENERICS' # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [], 'children': []})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Feature: F_STRINGS = 'f-strings'; DEBUG_F_STRINGS = 'debug_f_strings'; NUMERIC_UNDERSCORES = 'numeric_underscores'; POS_ONLY_ARGUMENTS = 'positional_only_arguments'; ASSIGNMENT_EXPRESSIONS = 'assignment_expressions'; RELAXED_DECORATORS = 'relaxed_decorators'; TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'; TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'; UNPACKING_ON_FLOW = 'unpacking_on_flow'; ANN_ASSIGN_EXTENDED_RHS = 'ann_assign_extended_rhs'; PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized_context_managers'; PATTERN_MATCHING = 'pattern_matching'; EXCEPT_STAR = 'except_star'; VARIADIC_GENERICS = 'variadic_generics'; FUTURE_ANNOTATIONS = 'future_annotations' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = type('Feature', (), {'F_STRINGS': 'F_STRINGS', 'DEBUG_F_STRINGS': 'DEBUG_F_STRINGS', 'NUMERIC_UNDERSCORES': 'NUMERIC_UNDERSCORES', 'POS_ONLY_ARGUMENTS': 'POS_ONLY_ARGUMENTS', 'ASSIGNMENT_EXPRESSIONS': 'ASSIGNMENT_EXPRESSIONS', 'RELAXED_DECORATORS': 'RELAXED_DECORATORS', 'TRAILING_COMMA_IN_DEF': 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL': 'TRAILING_COMMA_IN_CALL', 'UNPACKING_ON_FLOW': 'UNPACKING_ON_FLOW', 'ANN_ASSIGN_EXTENDED_RHS': 'ANN_ASSIGN_EXTENDED_RHS', 'PARENTHESIZED_CONTEXT_MANAGERS': 'PARENTHESIZED_CONTEXT_MANAGERS', 'PATTERN_MATCHING': 'PATTERN_MATCHING', 'EXCEPT_STAR': 'EXCEPT_STAR', 'VARIADIC_GENERICS': 'VARIADIC_GENERICS'}) # pragma: no cover"",
            ""is_string_token = lambda n: hasattr(n, 'value') and isinstance(n.value, str) # pragma: no cover"",
            ""is_number_token = lambda n: hasattr(n, 'value') and n.value.isdigit() # pragma: no cover"",
            ""iter_fexpr_spans = lambda s: [(0, len(s))] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from lib2to3.pgen2 import token # pragma: no cover"",
            ""from lib2to3 import pygram, pgen2 # pragma: no cover""
        ],
        ""initialization"": [
            ""FUTURE_FLAG_TO_FEATURE = {} # pragma: no cover"",
            ""node = type('MockNode', (object,), {'pre_order': lambda self: [MockToken('f\""', token.STRING), MockToken('1_000', token.NUMBER)]})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Set # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover""
        ],
        ""initialization"": [
            ""Feature = namedtuple('Feature', ['F_STRINGS', 'DEBUG_F_STRINGS', 'NUMERIC_UNDERSCORES', 'POS_ONLY_ARGUMENTS', 'ASSIGNMENT_EXPRESSIONS', 'RELAXED_DECORATORS', 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL', 'UNPACKING_ON_FLOW', 'ANN_ASSIGN_EXTENDED_RHS', 'PARENTHESIZED_CONTEXT_MANAGERS', 'PATTERN_MATCHING', 'EXCEPT_STAR', 'VARIADIC_GENERICS']) # pragma: no cover"",
            ""Feature.F_STRINGS = 'f-strings' # pragma: no cover"",
            ""Feature.DEBUG_F_STRINGS = 'debug f-strings' # pragma: no cover"",
            ""Feature.NUMERIC_UNDERSCORES = 'numeric underscores' # pragma: no cover"",
            ""Feature.POS_ONLY_ARGUMENTS = 'positional only arguments' # pragma: no cover"",
            ""Feature.ASSIGNMENT_EXPRESSIONS = 'assignment expressions' # pragma: no cover"",
            ""Feature.RELAXED_DECORATORS = 'relaxed decorators' # pragma: no cover"",
            ""Feature.TRAILING_COMMA_IN_DEF = 'trailing comma in function definition' # pragma: no cover"",
            ""Feature.TRAILING_COMMA_IN_CALL = 'trailing comma in function call' # pragma: no cover"",
            ""Feature.UNPACKING_ON_FLOW = 'unpacking on flow' # pragma: no cover"",
            ""Feature.ANN_ASSIGN_EXTENDED_RHS = 'annotation assignment with extended rhs' # pragma: no cover"",
            ""Feature.PARENTHESIZED_CONTEXT_MANAGERS = 'parenthesized context managers' # pragma: no cover"",
            ""Feature.PATTERN_MATCHING = 'pattern matching' # pragma: no cover"",
            ""Feature.EXCEPT_STAR = 'except star' # pragma: no cover"",
            ""Feature.VARIADIC_GENERICS = 'variadic generics' # pragma: no cover"",
            ""FUTURE_FLAG_TO_FEATURE = {'annotations': Feature.NUMERIC_UNDERSCORES} # pragma: no cover"",
            ""is_string_token = lambda n: n.type == token.STRING # pragma: no cover"",
            ""is_number_token = lambda n: n.type == token.NUMBER # pragma: no cover"",
            ""iter_fexpr_spans = lambda value: [(2, 9)] # pragma: no cover"",
            ""STARS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""is_simple_decorator_expression = lambda n: False # pragma: no cover"",
            ""aux = set() # pragma: no cover""
        ]
    }
]",3,1561,0.0007805,4251,0.0063765,0.007157
