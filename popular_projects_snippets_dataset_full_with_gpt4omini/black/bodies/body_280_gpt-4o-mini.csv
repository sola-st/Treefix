prompt,raw_predictions,predictions,prompt_type,input_size,input_price,output_size,output_price,total_price
"Provide self-contained and concrete Python values to initialize the undefined variables in the code snippet.

# begin code snippet
""""""Return whitespace prefix if needed for the given `leaf`.

    `complex_subscript` signals whether the given leaf is part of a subscription
    which has non-trivial arguments, like arithmetic expressions or function calls.
    """"""
NO: Final = """"
SPACE: Final = "" ""
DOUBLESPACE: Final = ""  ""
t = leaf.type
p = leaf.parent
v = leaf.value
if t in ALWAYS_NO_SPACE:
    exit(NO)

if t == token.COMMENT:
    exit(DOUBLESPACE)

assert p is not None, f""INTERNAL ERROR: hand-made leaf without parent: {leaf!r}""
if t == token.COLON and p.type not in {
    syms.subscript,
    syms.subscriptlist,
    syms.sliceop,
}:
    exit(NO)

prev = leaf.prev_sibling
if not prev:
    prevp = preceding_leaf(p)
    if not prevp or prevp.type in OPENING_BRACKETS:
        exit(NO)

    if t == token.COLON:
        if prevp.type == token.COLON:
            exit(NO)

        elif prevp.type != token.COMMA and not complex_subscript:
            exit(NO)

        exit(SPACE)

    if prevp.type == token.EQUAL:
        if prevp.parent:
            if prevp.parent.type in {
                syms.arglist,
                syms.argument,
                syms.parameters,
                syms.varargslist,
            }:
                exit(NO)

            elif prevp.parent.type == syms.typedargslist:
                # A bit hacky: if the equal sign has whitespace, it means we
                # previously found it's a typed argument.  So, we're using
                # that, too.
                exit(prevp.prefix)

    elif (
        prevp.type == token.STAR
        and parent_type(prevp) == syms.star_expr
        and parent_type(prevp.parent) == syms.subscriptlist
    ):
        # No space between typevar tuples.
        exit(NO)

    elif prevp.type in VARARGS_SPECIALS:
        if is_vararg(prevp, within=VARARGS_PARENTS | UNPACKING_PARENTS):
            exit(NO)

    elif prevp.type == token.COLON:
        if prevp.parent and prevp.parent.type in {syms.subscript, syms.sliceop}:
            exit(SPACE if complex_subscript else NO)

    elif (
        prevp.parent
        and prevp.parent.type == syms.factor
        and prevp.type in MATH_OPERATORS
    ):
        exit(NO)

    elif prevp.type == token.AT and p.parent and p.parent.type == syms.decorator:
        # no space in decorators
        exit(NO)

elif prev.type in OPENING_BRACKETS:
    exit(NO)

if p.type in {syms.parameters, syms.arglist}:
    # untyped function signatures or calls
    if not prev or prev.type != token.COMMA:
        exit(NO)

elif p.type == syms.varargslist:
    # lambdas
    if prev and prev.type != token.COMMA:
        exit(NO)

elif p.type == syms.typedargslist:
    # typed function signatures
    if not prev:
        exit(NO)

    if t == token.EQUAL:
        if prev.type not in TYPED_NAMES:
            exit(NO)

    elif prev.type == token.EQUAL:
        # A bit hacky: if the equal sign has whitespace, it means we
        # previously found it's a typed argument.  So, we're using that, too.
        exit(prev.prefix)

    elif prev.type != token.COMMA:
        exit(NO)

elif p.type in TYPED_NAMES:
    # type names
    if not prev:
        prevp = preceding_leaf(p)
        if not prevp or prevp.type != token.COMMA:
            exit(NO)

elif p.type == syms.trailer:
    # attributes and calls
    if t == token.LPAR or t == token.RPAR:
        exit(NO)

    if not prev:
        if t == token.DOT or t == token.LSQB:
            exit(NO)

    elif prev.type != token.COMMA:
        exit(NO)

elif p.type == syms.argument:
    # single argument
    if t == token.EQUAL:
        exit(NO)

    if not prev:
        prevp = preceding_leaf(p)
        if not prevp or prevp.type == token.LPAR:
            exit(NO)

    elif prev.type in {token.EQUAL} | VARARGS_SPECIALS:
        exit(NO)

elif p.type == syms.decorator:
    # decorators
    exit(NO)

elif p.type == syms.dotted_name:
    if prev:
        exit(NO)

    prevp = preceding_leaf(p)
    if not prevp or prevp.type == token.AT or prevp.type == token.DOT:
        exit(NO)

elif p.type == syms.classdef:
    if t == token.LPAR:
        exit(NO)

    if prev and prev.type == token.LPAR:
        exit(NO)

elif p.type in {syms.subscript, syms.sliceop}:
    # indexing
    if not prev:
        assert p.parent is not None, ""subscripts are always parented""
        if p.parent.type == syms.subscriptlist:
            exit(SPACE)

        exit(NO)

    elif not complex_subscript:
        exit(NO)

elif p.type == syms.atom:
    if prev and t == token.DOT:
        # dots, but not the first one.
        exit(NO)

elif p.type == syms.dictsetmaker:
    # dict unpacking
    if prev and prev.type == token.DOUBLESTAR:
        exit(NO)

elif p.type in {syms.factor, syms.star_expr}:
    # unary ops
    if not prev:
        prevp = preceding_leaf(p)
        if not prevp or prevp.type in OPENING_BRACKETS:
            exit(NO)

        prevp_parent = prevp.parent
        assert prevp_parent is not None
        if prevp.type == token.COLON and prevp_parent.type in {
            syms.subscript,
            syms.sliceop,
        }:
            exit(NO)

        elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument:
            exit(NO)

    elif t in {token.NAME, token.NUMBER, token.STRING}:
        exit(NO)

elif p.type == syms.import_from:
    if t == token.DOT:
        if prev and prev.type == token.DOT:
            exit(NO)

    elif t == token.NAME:
        if v == ""import"":
            exit(SPACE)

        if prev and prev.type == token.DOT:
            exit(NO)

elif p.type == syms.sliceop:
    exit(NO)

elif p.type == syms.except_clause:
    if t == token.STAR:
        exit(NO)

exit(SPACE)

# end code snippet

# begin undefined variables
Final
leaf
ALWAYS_NO_SPACE
token
syms
preceding_leaf
OPENING_BRACKETS
complex_subscript
parent_type
VARARGS_SPECIALS
is_vararg
VARARGS_PARENTS
UNPACKING_PARENTS
MATH_OPERATORS
TYPED_NAMES
# end undefined variables

# begin undefined attributes and methods
leaf.type
leaf.parent
leaf.value
token.COMMENT
token.COLON
syms.subscript
syms.subscriptlist
syms.sliceop
leaf.prev_sibling
token.COMMA
token.EQUAL
syms.arglist
syms.argument
syms.parameters
syms.varargslist
syms.typedargslist
token.STAR
syms.star_expr
syms.factor
token.AT
syms.decorator
syms.trailer
token.LPAR
token.RPAR
token.DOT
token.LSQB
syms.dotted_name
syms.classdef
syms.atom
syms.dictsetmaker
token.DOUBLESTAR
token.NAME
token.NUMBER
token.STRING
syms.import_from
syms.except_clause
# end undefined attributes and methods

Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'\ntoken = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'\nsyms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {'COMMENT'}"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB'}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(leaf): return None"",
            ""def parent_type(leaf): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(leaf, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'int', 'str', 'float'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional, Union""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None"",
            ""leaf = MockLeaf()"",
            ""leaf.type = 'mock_type'"",
            ""leaf.parent = None"",
            ""leaf.value = 'mock_value'"",
            ""ALWAYS_NO_SPACE = {'mock_type'}"",
            ""class MockToken: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; LPAR = 'lpar'; RPAR = 'rpar'; DOT = 'dot'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star' ;"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'; "",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '['}"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = {'mock_varargs_parent'}"",
            ""UNPACKING_PARENTS = {'mock_unpacking_parent'}"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'mock_typed_name'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = '('.; RPAR = ')'; LSQB = '['; DOUBLESTAR = '**'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING';"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""leaf = MockLeaf()"",
            ""token = MockToken()"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(leaf): return syms.factor"",
            ""def is_vararg(param, within): return False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.NUMBER, token.STRING}"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""def parent_type(prev): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(prev, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.NUMBER, token.STRING}"",
            ""import token; import syms"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(prev, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.ADD, token.SUB, token.MULT, token.FLOORDIV, token.DIV, token.MOD, token.POW}"",
            ""TYPED_NAMES = {token.NAME}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""class Mock: pass"",
            ""class Token: pass"",
            ""class Syms: pass""
        ],
        ""initialization"": [
            ""leaf = type('Leaf', (object,), {'type': 'token.NAME', 'parent': None, 'value': 'example', 'prev_sibling': None'})()"",
            ""ALWAYS_NO_SPACE = {'token.NAME', 'token.NUMBER'}"",
            ""token = type('Token', (object,), {'COMMENT': 'token.COMMENT', 'COLON': 'token.COLON', 'COMMA': 'token.COMMA', 'EQUAL': 'token.EQUAL', 'STAR': 'token.STAR', 'LPAR': 'token.LPAR', 'RPAR': 'token.RPAR', 'DOT': 'token.DOT', 'LSQB': 'token.LSQB', 'DOUBLESTAR': 'token.DOUBLESTAR', 'NAME': 'token.NAME', 'NUMBER': 'token.NUMBER', 'STRING': 'token.STRING'})"",
            ""syms = Syms()"",
            ""preceding_leaf = lambda p: type('LeafPrev', (object,), {'type': 'token.COMMA', 'parent': p})()"",
            ""OPENING_BRACKETS = {'token.LPAR', 'token.LSQB'}"",
            ""complex_subscript = False"",
            ""parent_type = lambda x: None"",
            ""VARARGS_SPECIALS = {'token.STAR', 'token.DOUBLESTAR'}"",
            ""is_vararg = lambda x, within: False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'token.PLUS', 'token.MINUS'}"",
            ""TYPED_NAMES = {'token.NAME'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (), {'type': None, 'parent': None, 'value': None, 'prev_sibling': None})()"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.NUMBER, token.STRING}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""def preceding_leaf(p): return None"",
            ""def is_vararg(node, within): return False"",
            ""def parent_type(node): return None""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class Token: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; DOT = 'dot'; LPAR = 'lpar'; RPAR = 'rpar'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star';"",
            ""class Syms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause';"",
            ""class Leaf: def __init__(self, type, parent, value, prev_sibling=None): self.type = type; self.parent = parent; self.value = value; self.prev_sibling = prev_sibling; "",
            ""leaf = Leaf(type='name', parent=type('MockParent', (object,), {'type': 'arglist', 'parent': None})(), value='leaf_value')"",
            ""ALWAYS_NO_SPACE = { 'comment' }"",
            ""token = Token()"",
            ""syms = Syms()"",
            ""def preceding_leaf(parent): return None"",
            ""OPENING_BRackets = { 'lpar', 'lsqb' }"",
            ""complex_subscript = False"",
            ""def parent_type(leaf): return 'arglist'"",
            ""VARARGS_SPECIALS = { 'star', 'double_star' }"",
            ""def is_vararg(prev_leaf, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = { 'add', 'subtract' }"",
            ""TYPED_NAMES = { 'typed_name' }""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'value': 'example', 'parent': None, 'prev_sibling': None'})()"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.NUMBER}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""TYPED_NAMES = {token.NAME, token.DOT}"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(node): return syms.factor"",
            ""def is_vararg(node, within): return False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""ALWAYS_NO_SPACE = {0, 1}"",
            ""class MockToken: COMMENT = 0; COLON = 1; COMMA = 2; EQUAL = 3; STAR = 4; NAME = 5; NUMBER = 6; STRING = 7; AT = 8; DOT = 9; DOUBLESTAR = 10; LPAR = 11; RPAR = 12; LSQB = 13\ntoken = MockToken()"",
            ""class MockSyms: subscript = 0; subscriptlist = 1; sliceop = 2; arglist = 3; argument = 4; parameters = 5; varargslist = 6; typedargslist = 7; star_expr = 8; factor = 9; decorator = 10; trailer = 11; dotted_name = 12; classdef = 13; atom = 14; dictsetmaker = 15; import_from = 16; except_clause = 17\nsyms = MockSyms()"",
            ""def preceding_leaf(p): return leaf  # Mock implementation\ndef parent_type(leaf): return syms.factor  # Mock implementation"",
            ""OPENING_BRACKETS = {4, 11}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = {3, 4}"",
            ""def is_vararg(leaf, within): return False  # Mock implementation"",
            ""VARARGS_PARENTS = {1}"",
            ""UNPACKING_PARENTS = {1}"",
            ""MATH_OPERATORS = {1, 2}"",
            ""TYPED_NAMES = {5, 6}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'# pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'COMMENT'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(leaf): return None # pragma: no cover"",
            ""def parent_type(leaf): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'str', 'float'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional, Union # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None # pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = 'mock_type' # pragma: no cover"",
            ""leaf.parent = None # pragma: no cover"",
            ""leaf.value = 'mock_value' # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'mock_type'} # pragma: no cover"",
            ""class MockToken: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; LPAR = 'lpar'; RPAR = 'rpar'; DOT = 'dot'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star' ; # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '['} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = {'mock_varargs_parent'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'mock_unpacking_parent'} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'mock_typed_name'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(prev): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(prev, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def is_vararg(prev, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""class Mock: pass # pragma: no cover"",
            ""class Token: pass # pragma: no cover"",
            ""class Syms: pass # pragma: no cover""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {'token.NAME', 'token.NUMBER'} # pragma: no cover"",
            ""token = type('Token', (object,), {'COMMENT': 'token.COMMENT', 'COLON': 'token.COLON', 'COMMA': 'token.COMMA', 'EQUAL': 'token.EQUAL', 'STAR': 'token.STAR', 'LPAR': 'token.LPAR', 'RPAR': 'token.RPAR', 'DOT': 'token.DOT', 'LSQB': 'token.LSQB', 'DOUBLESTAR': 'token.DOUBLESTAR', 'NAME': 'token.NAME', 'NUMBER': 'token.NUMBER', 'STRING': 'token.STRING'}) # pragma: no cover"",
            ""preceding_leaf = lambda p: type('LeafPrev', (object,), {'type': 'token.COMMA', 'parent': p})() # pragma: no cover"",
            ""OPENING_BRACKETS = {'token.LPAR', 'token.LSQB'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'token.STAR', 'token.DOUBLESTAR'} # pragma: no cover"",
            ""is_vararg = lambda x, within: False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'token.PLUS', 'token.MINUS'} # pragma: no cover"",
            ""TYPED_NAMES = {'token.NAME'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""leaf = type('MockLeaf', (), {'type': None, 'parent': None, 'value': None, 'prev_sibling': None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.NUMBER, token.STRING} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class Token: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; DOT = 'dot'; LPAR = 'lpar'; RPAR = 'rpar'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star'; # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def parent_type(node): return syms.factor # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {0, 1} # pragma: no cover"",
            ""class MockToken: COMMENT = 0; COLON = 1; COMMA = 2; EQUAL = 3; STAR = 4; NAME = 5; NUMBER = 6; STRING = 7; AT = 8; DOT = 9; DOUBLESTAR = 10; LPAR = 11; RPAR = 12; LSQB = 13# pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return leaf  # Mock implementation# pragma: no cover"",
            ""def parent_type(leaf): return syms.factor  # Mock implementation # pragma: no cover"",
            ""OPENING_BRACKETS = {4, 11} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""VARARGS_SPECIALS = {3, 4} # pragma: no cover"",
            ""def is_vararg(leaf, within): return False  # Mock implementation # pragma: no cover"",
            ""VARARGS_PARENTS = {1} # pragma: no cover"",
            ""UNPACKING_PARENTS = {1} # pragma: no cover"",
            ""MATH_OPERATORS = {1, 2} # pragma: no cover"",
            ""TYPED_NAMES = {5, 6} # pragma: no cover""
        ]
    }
]",1,1963,0.0009815,3618,0.005427,0.0064085
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 7:
    syms = MockSyms() # pragma: no cover
NameError: name 'MockSyms' is not defined
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'\ntoken = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'\nsyms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {'COMMENT'}"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB'}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(leaf): return None"",
            ""def parent_type(leaf): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(leaf, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'int', 'str', 'float'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'\ntoken = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'\nsyms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {'COMMENT'}"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB'}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(leaf): return None"",
            ""def parent_type(leaf): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(leaf, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'int', 'str', 'float'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'\ntoken = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'\nsyms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {'COMMENT'}"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB'}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(leaf): return None"",
            ""def parent_type(leaf): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(leaf, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'int', 'str', 'float'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'\ntoken = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'\nsyms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {'COMMENT'}"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB'}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(leaf): return None"",
            ""def parent_type(leaf): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(leaf, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'int', 'str', 'float'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'\ntoken = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'\nsyms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {'COMMENT'}"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB'}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(leaf): return None"",
            ""def parent_type(leaf): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(leaf, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'int', 'str', 'float'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'\ntoken = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'\nsyms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {'COMMENT'}"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB'}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(leaf): return None"",
            ""def parent_type(leaf): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(leaf, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'int', 'str', 'float'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'\ntoken = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'\nsyms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {'COMMENT'}"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB'}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(leaf): return None"",
            ""def parent_type(leaf): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(leaf, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'int', 'str', 'float'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'\ntoken = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'\nsyms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {'COMMENT'}"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB'}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(leaf): return None"",
            ""def parent_type(leaf): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(leaf, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'int', 'str', 'float'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'\ntoken = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'\nsyms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {'COMMENT'}"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB'}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(leaf): return None"",
            ""def parent_type(leaf): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(leaf, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'int', 'str', 'float'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'\ntoken = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'\nsyms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {'COMMENT'}"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB'}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(leaf): return None"",
            ""def parent_type(leaf): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(leaf, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'int', 'str', 'float'}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'# pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'COMMENT'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(leaf): return None # pragma: no cover"",
            ""def parent_type(leaf): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'str', 'float'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'# pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'COMMENT'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(leaf): return None # pragma: no cover"",
            ""def parent_type(leaf): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'str', 'float'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'# pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'COMMENT'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(leaf): return None # pragma: no cover"",
            ""def parent_type(leaf): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'str', 'float'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'# pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'COMMENT'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(leaf): return None # pragma: no cover"",
            ""def parent_type(leaf): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'str', 'float'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'# pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'COMMENT'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(leaf): return None # pragma: no cover"",
            ""def parent_type(leaf): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'str', 'float'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'# pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'COMMENT'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(leaf): return None # pragma: no cover"",
            ""def parent_type(leaf): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'str', 'float'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'# pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'COMMENT'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(leaf): return None # pragma: no cover"",
            ""def parent_type(leaf): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'str', 'float'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'# pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'COMMENT'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(leaf): return None # pragma: no cover"",
            ""def parent_type(leaf): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'str', 'float'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'# pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'COMMENT'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(leaf): return None # pragma: no cover"",
            ""def parent_type(leaf): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'str', 'float'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'# pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'COMMENT'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(leaf): return None # pragma: no cover"",
            ""def parent_type(leaf): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'str', 'float'} # pragma: no cover""
        ]
    }
]",2,2695,0.0013475,4320,0.00648,0.0078275
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 11:
    syms = MockSyms() # pragma: no cover
NameError: name 'MockSyms' is not defined
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final, Optional, Union""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None"",
            ""leaf = MockLeaf()"",
            ""leaf.type = 'mock_type'"",
            ""leaf.parent = None"",
            ""leaf.value = 'mock_value'"",
            ""ALWAYS_NO_SPACE = {'mock_type'}"",
            ""class MockToken: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; LPAR = 'lpar'; RPAR = 'rpar'; DOT = 'dot'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '['}"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = {'mock_varargs_parent'}"",
            ""UNPACKING_PARENTS = {'mock_unpacking_parent'}"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'mock_typed_name'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""leaf.type = 'mock_type'"",
            ""leaf.parent = None"",
            ""leaf.value = 'mock_value'"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; LPAR = 'LPAR'; RPAR = 'RPAR'; DOT = 'DOT'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'\ntoken = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'\nsyms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {'mock_type'}"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB'}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = {'mock_varargs_parent'}"",
            ""UNPACKING_PARENTS = {'mock_unpacking_parent'}"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'mock_typed_name'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional, Union""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None"",
            ""leaf = MockLeaf()"",
            ""leaf.type = 'mock_type'"",
            ""leaf.parent = None"",
            ""leaf.value = 'mock_value'"",
            ""ALWAYS_NO_SPACE = {'mock_type'}"",
            ""class MockToken: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; LPAR = 'lpar'; RPAR = 'rpar'; DOT = 'dot'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '['}"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = {'mock_varargs_parent'}"",
            ""UNPACKING_PARENTS = {'mock_unpacking_parent'}"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'mock_typed_name'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional, Union""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""leaf.type = 'mock_type'"",
            ""leaf.parent = None"",
            ""leaf.value = 'mock_value'"",
            ""ALWAYS_NO_SPACE = {'mock_type'}"",
            ""class MockToken: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; LPAR = 'lpar'; RPAR = 'rpar'; DOT = 'dot'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star'\ntoken = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'\nsyms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '['}"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = {'mock_varargs_parent'}"",
            ""UNPACKING_PARENTS = {'mock_unpacking_parent'}"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'mock_typed_name'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional, Union""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None"",
            ""leaf = MockLeaf()"",
            ""leaf.type = 'mock_type'"",
            ""leaf.parent = None"",
            ""leaf.value = 'mock_value'"",
            ""ALWAYS_NO_SPACE = {'mock_type'}"",
            ""class MockToken: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; LPAR = 'lpar'; RPAR = 'rpar'; DOT = 'dot'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star' "",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '['}"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = {'mock_varargs_parent'}"",
            ""UNPACKING_PARENTS = {'mock_unpacking_parent'}"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'mock_typed_name'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional, Union""
        ],
        ""initialization"": [
            ""class MockLeaf: type = 'mock_type'; parent = None; value = 'mock_value'; prev_sibling = None"",
            ""leaf = MockLeaf()"",
            ""ALWAYS_NO_SPACE = {'mock_type'}"",
            ""class MockToken: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; LPAR = 'lpar'; RPAR = 'rpar'; DOT = 'dot'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '['}"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = {'mock_varargs_parent'}"",
            ""UNPACKING_PARENTS = {'mock_unpacking_parent'}"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'mock_typed_name'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional, Union""
        ],
        ""initialization"": [
            ""class MockLeaf: pass"",
            ""leaf = MockLeaf()"",
            ""leaf.type = 'mock_type'"",
            ""leaf.parent = None"",
            ""leaf.value = 'mock_value'"",
            ""leaf.prev_sibling = None"",
            ""ALWAYS_NO_SPACE = {'mock_type'}"",
            ""class MockToken: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; LPAR = 'lpar'; RPAR = 'rpar'; DOT = 'dot'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '['}"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = {'mock_varargs_parent'}"",
            ""UNPACKING_PARENTS = {'mock_unpacking_parent'}"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'mock_typed_name'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional, Union""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""leaf.type = 'mock_type'"",
            ""leaf.parent = None"",
            ""leaf.value = 'mock_value'"",
            ""ALWAYS_NO_SPACE = {'mock_type'}"",
            ""class MockToken: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; LPAR = 'lpar'; RPAR = 'rpar'; DOT = 'dot'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star'\ntoken = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'\nsyms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '['}"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'int', 'str', 'float'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""leaf.type = 'mock_type'\nleaf.parent = None\nleaf.value = 'mock_value'"",
            ""ALWAYS_NO_SPACE = {'mock_type'}"",
            ""class MockToken: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; LPAR = 'lpar'; RPAR = 'rpar'; DOT = 'dot'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star'\ntoken = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'\nsyms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '['}"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = {'mock_varargs_parent'}"",
            ""UNPACKING_PARENTS = {'mock_unpacking_parent'}"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'mock_typed_name'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional, Union""
        ],
        ""initialization"": [
            ""class MockLeaf: type: Optional[str] = None; parent: Optional['MockLeaf'] = None; value: Optional[str] = None; prev_sibling: Optional['MockLeaf'] = None\nleaf = MockLeaf()"",
            ""leaf.type = 'mock_type'"",
            ""leaf.parent = None"",
            ""leaf.value = 'mock_value'"",
            ""ALWAYS_NO_SPACE = {'mock_type'}"",
            ""class MockToken: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; LPAR = 'lpar'; RPAR = 'rpar'; DOT = 'dot'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star'\ntoken = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'\nsyms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '['}"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = {'mock_varargs_parent'}"",
            ""UNPACKING_PARENTS = {'mock_unpacking_parent'}"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'mock_typed_name'}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final, Optional, Union # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None # pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = 'mock_type' # pragma: no cover"",
            ""leaf.parent = None # pragma: no cover"",
            ""leaf.value = 'mock_value' # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'mock_type'} # pragma: no cover"",
            ""class MockToken: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; LPAR = 'lpar'; RPAR = 'rpar'; DOT = 'dot'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '['} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = {'mock_varargs_parent'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'mock_unpacking_parent'} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'mock_typed_name'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = 'mock_type' # pragma: no cover"",
            ""leaf.parent = None # pragma: no cover"",
            ""leaf.value = 'mock_value' # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; LPAR = 'LPAR'; RPAR = 'RPAR'; DOT = 'DOT'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'# pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'mock_type'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'LPAR', 'LSQB'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = {'mock_varargs_parent'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'mock_unpacking_parent'} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'mock_typed_name'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional, Union # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None # pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = 'mock_type' # pragma: no cover"",
            ""leaf.parent = None # pragma: no cover"",
            ""leaf.value = 'mock_value' # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'mock_type'} # pragma: no cover"",
            ""class MockToken: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; LPAR = 'lpar'; RPAR = 'rpar'; DOT = 'dot'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '['} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = {'mock_varargs_parent'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'mock_unpacking_parent'} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'mock_typed_name'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional, Union # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = 'mock_type' # pragma: no cover"",
            ""leaf.parent = None # pragma: no cover"",
            ""leaf.value = 'mock_value' # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'mock_type'} # pragma: no cover"",
            ""class MockToken: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; LPAR = 'lpar'; RPAR = 'rpar'; DOT = 'dot'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star'# pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '['} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = {'mock_varargs_parent'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'mock_unpacking_parent'} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'mock_typed_name'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional, Union # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None # pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = 'mock_type' # pragma: no cover"",
            ""leaf.parent = None # pragma: no cover"",
            ""leaf.value = 'mock_value' # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'mock_type'} # pragma: no cover"",
            ""class MockToken: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; LPAR = 'lpar'; RPAR = 'rpar'; DOT = 'dot'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star'  # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '['} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = {'mock_varargs_parent'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'mock_unpacking_parent'} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'mock_typed_name'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional, Union # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = 'mock_type'; parent = None; value = 'mock_value'; prev_sibling = None # pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'mock_type'} # pragma: no cover"",
            ""class MockToken: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; LPAR = 'lpar'; RPAR = 'rpar'; DOT = 'dot'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '['} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = {'mock_varargs_parent'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'mock_unpacking_parent'} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'mock_typed_name'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional, Union # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: pass # pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = 'mock_type' # pragma: no cover"",
            ""leaf.parent = None # pragma: no cover"",
            ""leaf.value = 'mock_value' # pragma: no cover"",
            ""leaf.prev_sibling = None # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'mock_type'} # pragma: no cover"",
            ""class MockToken: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; LPAR = 'lpar'; RPAR = 'rpar'; DOT = 'dot'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '['} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = {'mock_varargs_parent'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'mock_unpacking_parent'} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'mock_typed_name'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional, Union # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = 'mock_type' # pragma: no cover"",
            ""leaf.parent = None # pragma: no cover"",
            ""leaf.value = 'mock_value' # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'mock_type'} # pragma: no cover"",
            ""class MockToken: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; LPAR = 'lpar'; RPAR = 'rpar'; DOT = 'dot'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star'# pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '['} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'str', 'float'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = 'mock_type'# pragma: no cover"",
            ""leaf.parent = None# pragma: no cover"",
            ""leaf.value = 'mock_value' # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'mock_type'} # pragma: no cover"",
            ""class MockToken: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; LPAR = 'lpar'; RPAR = 'rpar'; DOT = 'dot'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star'# pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '['} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = {'mock_varargs_parent'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'mock_unpacking_parent'} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'mock_typed_name'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional, Union # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type: Optional[str] = None; parent: Optional['MockLeaf'] = None; value: Optional[str] = None; prev_sibling: Optional['MockLeaf'] = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = 'mock_type' # pragma: no cover"",
            ""leaf.parent = None # pragma: no cover"",
            ""leaf.value = 'mock_value' # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'mock_type'} # pragma: no cover"",
            ""class MockToken: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; LPAR = 'lpar'; RPAR = 'rpar'; DOT = 'dot'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star'# pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '['} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = {'mock_varargs_parent'} # pragma: no cover"",
            ""UNPACKING_PARENTS = {'mock_unpacking_parent'} # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'mock_typed_name'} # pragma: no cover""
        ]
    }
]",2,3458,0.001729,4565,0.0068475,0.0085765
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 14:
    t = leaf.type
NameError: name 'leaf' is not defined
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final, Optional""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = '('.; RPAR = ')'; LSQB = '['; DOUBLESTAR = '**'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING';"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""leaf = MockLeaf()"",
            ""leaf.type = 'COMMENT'"",
            ""leaf.parent = None"",
            ""leaf.value = 'mock_value'"",
            ""leaf.prev_sibling = None"",
            ""token = MockToken()"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(leaf): return syms.factor"",
            ""def is_vararg(param, within): return False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""leaf.type = 'mock_type'"",
            ""leaf.parent = None"",
            ""leaf.value = 'mock_value'"",
            ""leaf.prev_sibling = None"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = '('; RPAR = ')'; LSQB = '['; DOUBLESTAR = '**'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'\nsyms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(leaf): return syms.factor"",
            ""def is_vararg(param, within): return False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = '('; RPAR = ')'; LSQB = '['; DOUBLESTAR = '**'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING';"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""leaf = MockLeaf()"",
            ""leaf.type = 'COMMENT'"",
            ""leaf.parent = None"",
            ""leaf.value = 'mock_value'"",
            ""leaf.prev_sibling = None"",
            ""token = MockToken()"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(leaf): return syms.factor"",
            ""def is_vararg(param, within): return False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None"",
            ""leaf = MockLeaf()"",
            ""leaf.type = 'mock_type'"",
            ""leaf.parent = None"",
            ""leaf.value = 'mock_value'"",
            ""leaf.prev_sibling = None"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = '('; RPAR = ')'; LSQB = '['; DOUBLESTAR = '**'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(leaf): return syms.factor"",
            ""def is_vararg(param, within): return False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: pass"",
            ""leaf = MockLeaf()"",
            ""leaf.type = 'mock_type'"",
            ""leaf.parent = None"",
            ""leaf.value = 'mock_value'"",
            ""leaf.prev_sibling = None"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = '('.; RPAR = ')'; LSQB = '['; DOUBLESTAR = '**'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(leaf): return syms.factor"",
            ""def is_vararg(param, within): return False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""leaf.type = 'mock_type'"",
            ""leaf.parent = None"",
            ""leaf.value = 'mock_value'"",
            ""leaf.prev_sibling = None"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = '('; RPAR = ')'; LSQB = '['; DOUBLESTAR = '**'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'\nsyms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(leaf): return syms.factor"",
            ""def is_vararg(param, within): return False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional""
        ],
        ""initialization"": [
            ""class MockLeaf: pass"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = '('.; RPAR = ')'; LSQB = '['; DOUBLESTAR = '**'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING';"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""leaf = MockLeaf()"",
            ""leaf.type = 'mock_type'"",
            ""leaf.parent = None"",
            ""leaf.value = 'mock_value'"",
            ""leaf.prev_sibling = None"",
            ""token = MockToken()"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(leaf): return syms.factor"",
            ""def is_vararg(param, within): return False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional""
        ],
        ""initialization"": [
            ""class MockLeaf: type = 'mock_type'; parent = None; value = 'mock_value'; prev_sibling = None"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = '('.; RPAR = ')'; LSQB = '['; DOUBLESTAR = '**'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING';"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""leaf = MockLeaf()"",
            ""token = MockToken()"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(leaf): return syms.factor"",
            ""def is_vararg(param, within): return False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = '('; RPAR = ')'; LSQB = '['; DOUBLESTAR = '**'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING';"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""leaf = MockLeaf()"",
            ""leaf.type = 'mock_type'"",
            ""leaf.parent = None"",
            ""leaf.value = 'mock_value'"",
            ""leaf.prev_sibling = None"",
            ""token = MockToken()"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(leaf): return None"",
            ""def is_vararg(param, within): return False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = '('.; RPAR = ')'; LSQB = '['; DOUBLESTAR = '**'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING';"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""leaf = MockLeaf()"",
            ""leaf.type = 'COMMENT'"",
            ""leaf.parent = None"",
            ""leaf.value = 'mock_value'"",
            ""leaf.prev_sibling = None"",
            ""token = MockToken()"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(leaf): return syms.factor"",
            ""def is_vararg(param, within): return False""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = 'mock_type' # pragma: no cover"",
            ""leaf.parent = None # pragma: no cover"",
            ""leaf.value = 'mock_value' # pragma: no cover"",
            ""leaf.prev_sibling = None # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = '('; RPAR = ')'; LSQB = '['; DOUBLESTAR = '**'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def parent_type(leaf): return syms.factor # pragma: no cover"",
            ""def is_vararg(param, within): return False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = '('; RPAR = ')'; LSQB = '['; DOUBLESTAR = '**'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; # pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = 'COMMENT' # pragma: no cover"",
            ""leaf.parent = None # pragma: no cover"",
            ""leaf.value = 'mock_value' # pragma: no cover"",
            ""leaf.prev_sibling = None # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def parent_type(leaf): return syms.factor # pragma: no cover"",
            ""def is_vararg(param, within): return False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None # pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = 'mock_type' # pragma: no cover"",
            ""leaf.parent = None # pragma: no cover"",
            ""leaf.value = 'mock_value' # pragma: no cover"",
            ""leaf.prev_sibling = None # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = '('; RPAR = ')'; LSQB = '['; DOUBLESTAR = '**'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def parent_type(leaf): return syms.factor # pragma: no cover"",
            ""def is_vararg(param, within): return False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: pass # pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = 'mock_type' # pragma: no cover"",
            ""leaf.parent = None # pragma: no cover"",
            ""leaf.value = 'mock_value' # pragma: no cover"",
            ""leaf.prev_sibling = None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = 'mock_type' # pragma: no cover"",
            ""leaf.parent = None # pragma: no cover"",
            ""leaf.value = 'mock_value' # pragma: no cover"",
            ""leaf.prev_sibling = None # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = '('; RPAR = ')'; LSQB = '['; DOUBLESTAR = '**'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def parent_type(leaf): return syms.factor # pragma: no cover"",
            ""def is_vararg(param, within): return False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = 'mock_type'; parent = None; value = 'mock_value'; prev_sibling = None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = '('; RPAR = ')'; LSQB = '['; DOUBLESTAR = '**'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; # pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = 'mock_type' # pragma: no cover"",
            ""leaf.parent = None # pragma: no cover"",
            ""leaf.value = 'mock_value' # pragma: no cover"",
            ""leaf.prev_sibling = None # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def parent_type(leaf): return None # pragma: no cover"",
            ""def is_vararg(param, within): return False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None # pragma: no cover""
        ]
    }
]",2,4150,0.002075,4274,0.006411,0.008486
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 7:
    syms = MockSyms() # pragma: no cover
NameError: name 'MockSyms' is not defined
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\nleaf = MockLeaf(type='mock_type', parent=None, value='mock_value', prev_sibling=None)"",
            ""class MockToken:\n    COMMENT = 'COMMENT'\n    COLON = 'COLON'\n    COMMA = 'COMMA'\n    EQUAL = 'EQUAL'\n    STAR = 'STAR'\n    DOT = 'DOT'\n    LPAR = '('\n    RPAR = ')'\n    LSQB = '['\n    DOUBLESTAR = '**'\n    NAME = 'NAME'\n    NUMBER = 'NUMBER'\n    STRING = 'STRING'\ntoken = MockToken()"",
            ""class MockSyms:\n    subscript = 'subscript'\n    subscriptlist = 'subscriptlist'\n    sliceop = 'sliceop'\n    arglist = 'arglist'\n    argument = 'argument'\n    parameters = 'parameters'\n    varargslist = 'varargslist'\n    typedargslist = 'typedargslist'\n    star_expr = 'star_expr'\n    factor = 'factor'\n    decorator = 'decorator'\n    trailer = 'trailer'\n    dotted_name = 'dotted_name'\n    classdef = 'classdef'\n    atom = 'atom'\n    dictsetmaker = 'dictsetmaker'\n    import_from = 'import_from'\n    except_clause = 'except_clause'\nsyms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(prev): return syms.factor"",
            ""def is_vararg(param, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: \n    def __init__(self):\n        self.type = 'mock_type'\n        self.parent = None\n        self.value = 'mock_value'\n        self.prev_sibling = None\nleaf = MockLeaf()"",
            ""class MockToken:\n    COMMENT = 'COMMENT'\n    COLON = 'COLON'\n    COMMA = 'COMMA'\n    EQUAL = 'EQUAL'\n    STAR = 'STAR'\n    DOT = 'DOT'\n    LPAR = '('\n    RPAR = ')'\n    LSQB = '['\n    DOUBLESTAR = '**'\n    NAME = 'NAME'\n    NUMBER = 'NUMBER'\n    STRING = 'STRING'"",
            ""token = MockToken()"",
            ""class MockSyms:\n    subscript = 'subscript'\n    subscriptlist = 'subscriptlist'\n    sliceop = 'sliceop'\n    arglist = 'arglist'\n    argument = 'argument'\n    parameters = 'parameters'\n    varargslist = 'varargslist'\n    typedargslist = 'typedargslist'\n    star_expr = 'star_expr'\n    factor = 'factor'\n    decorator = 'decorator'\n    trailer = 'trailer'\n    dotted_name = 'dotted_name'\n    classdef = 'classdef'\n    atom = 'atom'\n    dictsetmaker = 'dictsetmaker'\n    import_from = 'import_from'\n    except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(leaf): return None"",
            ""def is_vararg(param, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""leaf.type = 'mock_type'"",
            ""leaf.parent = None"",
            ""leaf.value = 'mock_value'"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(prev): return syms.factor"",
            ""def is_vararg(param, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""class MockToken: \n    COMMENT = 'COMMENT'; \n    COLON = 'COLON'; \n    COMMA = 'COMMA'; \n    EQUAL = 'EQUAL'; \n    STAR = 'STAR'; \n    DOT = 'DOT'; \n    LPAR = 'LPAR'; \n    RPAR = 'RPAR'; \n    LSQB = 'LSQB'; \n    DOUBLESTAR = 'DOUBLESTAR'; \n    NAME = 'NAME'; \n    NUMBER = 'NUMBER'; \n    STRING = 'STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: \n    subscript = 'subscript'; \n    subscriptlist = 'subscriptlist'; \n    sliceop = 'sliceop'; \n    arglist = 'arglist'; \n    argument = 'argument'; \n    parameters = 'parameters'; \n    varargslist = 'varargslist'; \n    typedargslist = 'typedargslist'; \n    star_expr = 'star_expr'; \n    factor = 'factor'; \n    decorator = 'decorator'; \n    trailer = 'trailer'; \n    dotted_name = 'dotted_name'; \n    classdef = 'classdef'; \n    atom = 'atom'; \n    dictsetmaker = 'dictsetmaker'; \n    import_from = 'import_from'; \n    except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(prev): return None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(prev, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent=None, value=None, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n\nleaf = MockLeaf(type='mock_type', parent=None, value='mock_value', prev_sibling=None)"",
            ""class MockToken:\n    COMMENT = 'COMMENT'\n    COLON = 'COLON'\n    COMMA = 'COMMA'\n    EQUAL = 'EQUAL'\n    STAR = 'STAR'\n    DOT = 'DOT'\n    LPAR = '('\n    RPAR = ')'\n    LSQB = '['\n    DOUBLESTAR = '**'\n    NAME = 'NAME'\n    NUMBER = 'NUMBER'\n    STRING = 'STRING'"",
            ""token = MockToken()"",
            ""class MockSyms:\n    subscript = 'subscript'\n    subscriptlist = 'subscriptlist'\n    sliceop = 'sliceop'\n    arglist = 'arglist'\n    argument = 'argument'\n    parameters = 'parameters'\n    varargslist = 'varargslist'\n    typedargslist = 'typedargslist'\n    star_expr = 'star_expr'\n    factor = 'factor'\n    decorator = 'decorator'\n    trailer = 'trailer'\n    dotted_name = 'dotted_name'\n    classdef = 'classdef'\n    atom = 'atom'\n    dictsetmaker = 'dictsetmaker'\n    import_from = 'import_from'\n    except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(node): return None"",
            ""def is_vararg(param, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'\nsyms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(node): return syms.factor"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(param, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""leaf.type = 'mock_type'; leaf.parent = None; leaf.value = 'mock_value'"",
            ""ALWAYS_NO_SPACE = {leaf.type}"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""def parent_type(prev): return 'parent_type_value'"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(prev, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""leaf.type = 'mock_type'; leaf.parent = None; leaf.value = 'mock_value'"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(prev): return 'mock_parent_type'"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(prev, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None"",
            ""leaf = MockLeaf()"",
            ""leaf.type = 'mock_type'"",
            ""leaf.parent = None"",
            ""leaf.value = 'mock_value'"",
            ""ALWAYS_NO_SPACE = {'mock_type'}"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = '('; RPAR = ')'; LSQB = '['; DOUBLESTAR = '**'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\nleaf = MockLeaf('mock_type', None, 'mock_value', None)"",
            ""class MockToken:\n    COMMENT = 'COMMENT'\n    COLON = 'COLON'\n    COMMA = 'COMMA'\n    EQUAL = 'EQUAL'\n    STAR = 'STAR'\n    DOT = 'DOT'\n    LPAR = '('\n    RPAR = ')'\n    LSQB = '['\n    DOUBLESTAR = '**'\n    NAME = 'NAME'\n    NUMBER = 'NUMBER'\n    STRING = 'STRING'"",
            ""token = MockToken()"",
            ""class MockSyms:\n    subscript = 'subscript'\n    subscriptlist = 'subscriptlist'\n    sliceop = 'sliceop'\n    arglist = 'arglist'\n    argument = 'argument'\n    parameters = 'parameters'\n    varargslist = 'varargslist'\n    typedargslist = 'typedargslist'\n    star_expr = 'star_expr'\n    factor = 'factor'\n    decorator = 'decorator'\n    trailer = 'trailer'\n    dotted_name = 'dotted_name'\n    classdef = 'classdef'\n    atom = 'atom'\n    dictsetmaker = 'dictsetmaker'\n    import_from = 'import_from'\n    except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(prev): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(prev, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            ""leaf = MockLeaf(type='mock_type', parent=None, value='mock_value', prev_sibling=None) # pragma: no cover"",
            ""class MockToken:# pragma: no cover"",
            ""    COMMENT = 'COMMENT'# pragma: no cover"",
            ""    COLON = 'COLON'# pragma: no cover"",
            ""    COMMA = 'COMMA'# pragma: no cover"",
            ""    EQUAL = 'EQUAL'# pragma: no cover"",
            ""    STAR = 'STAR'# pragma: no cover"",
            ""    DOT = 'DOT'# pragma: no cover"",
            ""    LPAR = '('# pragma: no cover"",
            ""    RPAR = ')'# pragma: no cover"",
            ""    LSQB = '['# pragma: no cover"",
            ""    DOUBLESTAR = '**'# pragma: no cover"",
            ""    NAME = 'NAME'# pragma: no cover"",
            ""    NUMBER = 'NUMBER'# pragma: no cover"",
            ""    STRING = 'STRING'# pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""class MockSyms:# pragma: no cover"",
            ""    subscript = 'subscript'# pragma: no cover"",
            ""    subscriptlist = 'subscriptlist'# pragma: no cover"",
            ""    sliceop = 'sliceop'# pragma: no cover"",
            ""    arglist = 'arglist'# pragma: no cover"",
            ""    argument = 'argument'# pragma: no cover"",
            ""    parameters = 'parameters'# pragma: no cover"",
            ""    varargslist = 'varargslist'# pragma: no cover"",
            ""    typedargslist = 'typedargslist'# pragma: no cover"",
            ""    star_expr = 'star_expr'# pragma: no cover"",
            ""    factor = 'factor'# pragma: no cover"",
            ""    decorator = 'decorator'# pragma: no cover"",
            ""    trailer = 'trailer'# pragma: no cover"",
            ""    dotted_name = 'dotted_name'# pragma: no cover"",
            ""    classdef = 'classdef'# pragma: no cover"",
            ""    atom = 'atom'# pragma: no cover"",
            ""    dictsetmaker = 'dictsetmaker'# pragma: no cover"",
            ""    except_clause = 'except_clause'# pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def parent_type(prev): return syms.factor # pragma: no cover"",
            ""def is_vararg(param, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.type = 'mock_type'# pragma: no cover"",
            ""        self.parent = None# pragma: no cover"",
            ""        self.value = 'mock_value'# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockToken:# pragma: no cover"",
            ""    COMMENT = 'COMMENT'# pragma: no cover"",
            ""    COLON = 'COLON'# pragma: no cover"",
            ""    COMMA = 'COMMA'# pragma: no cover"",
            ""    EQUAL = 'EQUAL'# pragma: no cover"",
            ""    STAR = 'STAR'# pragma: no cover"",
            ""    DOT = 'DOT'# pragma: no cover"",
            ""    LPAR = '('# pragma: no cover"",
            ""    RPAR = ')'# pragma: no cover"",
            ""    LSQB = '['# pragma: no cover"",
            ""    DOUBLESTAR = '**'# pragma: no cover"",
            ""    NAME = 'NAME'# pragma: no cover"",
            ""    NUMBER = 'NUMBER'# pragma: no cover"",
            ""    STRING = 'STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""class MockSyms:# pragma: no cover"",
            ""    subscript = 'subscript'# pragma: no cover"",
            ""    subscriptlist = 'subscriptlist'# pragma: no cover"",
            ""    sliceop = 'sliceop'# pragma: no cover"",
            ""    arglist = 'arglist'# pragma: no cover"",
            ""    argument = 'argument'# pragma: no cover"",
            ""    parameters = 'parameters'# pragma: no cover"",
            ""    varargslist = 'varargslist'# pragma: no cover"",
            ""    typedargslist = 'typedargslist'# pragma: no cover"",
            ""    star_expr = 'star_expr'# pragma: no cover"",
            ""    factor = 'factor'# pragma: no cover"",
            ""    decorator = 'decorator'# pragma: no cover"",
            ""    trailer = 'trailer'# pragma: no cover"",
            ""    dotted_name = 'dotted_name'# pragma: no cover"",
            ""    classdef = 'classdef'# pragma: no cover"",
            ""    atom = 'atom'# pragma: no cover"",
            ""    dictsetmaker = 'dictsetmaker'# pragma: no cover"",
            ""    except_clause = 'except_clause' # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def parent_type(leaf): return None # pragma: no cover"",
            ""def is_vararg(param, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = 'mock_type' # pragma: no cover"",
            ""leaf.parent = None # pragma: no cover"",
            ""leaf.value = 'mock_value' # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def parent_type(prev): return syms.factor # pragma: no cover"",
            ""def is_vararg(param, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockToken: # pragma: no cover"",
            ""    COMMENT = 'COMMENT'; # pragma: no cover"",
            ""    COLON = 'COLON'; # pragma: no cover"",
            ""    COMMA = 'COMMA'; # pragma: no cover"",
            ""    EQUAL = 'EQUAL'; # pragma: no cover"",
            ""    STAR = 'STAR'; # pragma: no cover"",
            ""    DOT = 'DOT'; # pragma: no cover"",
            ""    LPAR = 'LPAR'; # pragma: no cover"",
            ""    RPAR = 'RPAR'; # pragma: no cover"",
            ""    LSQB = 'LSQB'; # pragma: no cover"",
            ""    DOUBLESTAR = 'DOUBLESTAR'; # pragma: no cover"",
            ""    NAME = 'NAME'; # pragma: no cover"",
            ""    NUMBER = 'NUMBER'; # pragma: no cover"",
            ""    STRING = 'STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""class MockSyms: # pragma: no cover"",
            ""    subscript = 'subscript'; # pragma: no cover"",
            ""    subscriptlist = 'subscriptlist'; # pragma: no cover"",
            ""    sliceop = 'sliceop'; # pragma: no cover"",
            ""    arglist = 'arglist'; # pragma: no cover"",
            ""    argument = 'argument'; # pragma: no cover"",
            ""    parameters = 'parameters'; # pragma: no cover"",
            ""    varargslist = 'varargslist'; # pragma: no cover"",
            ""    typedargslist = 'typedargslist'; # pragma: no cover"",
            ""    star_expr = 'star_expr'; # pragma: no cover"",
            ""    factor = 'factor'; # pragma: no cover"",
            ""    decorator = 'decorator'; # pragma: no cover"",
            ""    trailer = 'trailer'; # pragma: no cover"",
            ""    dotted_name = 'dotted_name'; # pragma: no cover"",
            ""    classdef = 'classdef'; # pragma: no cover"",
            ""    atom = 'atom'; # pragma: no cover"",
            ""    dictsetmaker = 'dictsetmaker'; # pragma: no cover"",
            ""    except_clause = 'except_clause' # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def parent_type(prev): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""def is_vararg(prev, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent=None, value=None, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            ""# pragma: no cover"",
            ""leaf = MockLeaf(type='mock_type', parent=None, value='mock_value', prev_sibling=None) # pragma: no cover"",
            ""class MockToken:# pragma: no cover"",
            ""    COMMENT = 'COMMENT'# pragma: no cover"",
            ""    COLON = 'COLON'# pragma: no cover"",
            ""    COMMA = 'COMMA'# pragma: no cover"",
            ""    EQUAL = 'EQUAL'# pragma: no cover"",
            ""    STAR = 'STAR'# pragma: no cover"",
            ""    DOT = 'DOT'# pragma: no cover"",
            ""    LPAR = '('# pragma: no cover"",
            ""    RPAR = ')'# pragma: no cover"",
            ""    LSQB = '['# pragma: no cover"",
            ""    DOUBLESTAR = '**'# pragma: no cover"",
            ""    NAME = 'NAME'# pragma: no cover"",
            ""    NUMBER = 'NUMBER'# pragma: no cover"",
            ""    STRING = 'STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""class MockSyms:# pragma: no cover"",
            ""    subscript = 'subscript'# pragma: no cover"",
            ""    subscriptlist = 'subscriptlist'# pragma: no cover"",
            ""    sliceop = 'sliceop'# pragma: no cover"",
            ""    arglist = 'arglist'# pragma: no cover"",
            ""    argument = 'argument'# pragma: no cover"",
            ""    parameters = 'parameters'# pragma: no cover"",
            ""    varargslist = 'varargslist'# pragma: no cover"",
            ""    typedargslist = 'typedargslist'# pragma: no cover"",
            ""    star_expr = 'star_expr'# pragma: no cover"",
            ""    factor = 'factor'# pragma: no cover"",
            ""    decorator = 'decorator'# pragma: no cover"",
            ""    trailer = 'trailer'# pragma: no cover"",
            ""    dotted_name = 'dotted_name'# pragma: no cover"",
            ""    classdef = 'classdef'# pragma: no cover"",
            ""    atom = 'atom'# pragma: no cover"",
            ""    dictsetmaker = 'dictsetmaker'# pragma: no cover"",
            ""    except_clause = 'except_clause' # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""def is_vararg(param, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def parent_type(node): return syms.factor # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""def is_vararg(param, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = 'mock_type'; leaf.parent = None; leaf.value = 'mock_value' # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {leaf.type} # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(prev): return 'parent_type_value' # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(prev, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = 'mock_type'; leaf.parent = None; leaf.value = 'mock_value' # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def parent_type(prev): return 'mock_parent_type' # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""def is_vararg(prev, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None # pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = 'mock_type' # pragma: no cover"",
            ""leaf.parent = None # pragma: no cover"",
            ""leaf.value = 'mock_value' # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'mock_type'} # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = '('; RPAR = ')'; LSQB = '['; DOUBLESTAR = '**'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            ""leaf = MockLeaf('mock_type', None, 'mock_value', None) # pragma: no cover"",
            ""class MockToken:# pragma: no cover"",
            ""    COMMENT = 'COMMENT'# pragma: no cover"",
            ""    COLON = 'COLON'# pragma: no cover"",
            ""    COMMA = 'COMMA'# pragma: no cover"",
            ""    EQUAL = 'EQUAL'# pragma: no cover"",
            ""    STAR = 'STAR'# pragma: no cover"",
            ""    DOT = 'DOT'# pragma: no cover"",
            ""    LPAR = '('# pragma: no cover"",
            ""    RPAR = ')'# pragma: no cover"",
            ""    LSQB = '['# pragma: no cover"",
            ""    DOUBLESTAR = '**'# pragma: no cover"",
            ""    NAME = 'NAME'# pragma: no cover"",
            ""    NUMBER = 'NUMBER'# pragma: no cover"",
            ""    STRING = 'STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""class MockSyms:# pragma: no cover"",
            ""    subscript = 'subscript'# pragma: no cover"",
            ""    subscriptlist = 'subscriptlist'# pragma: no cover"",
            ""    sliceop = 'sliceop'# pragma: no cover"",
            ""    arglist = 'arglist'# pragma: no cover"",
            ""    argument = 'argument'# pragma: no cover"",
            ""    parameters = 'parameters'# pragma: no cover"",
            ""    varargslist = 'varargslist'# pragma: no cover"",
            ""    typedargslist = 'typedargslist'# pragma: no cover"",
            ""    star_expr = 'star_expr'# pragma: no cover"",
            ""    factor = 'factor'# pragma: no cover"",
            ""    decorator = 'decorator'# pragma: no cover"",
            ""    trailer = 'trailer'# pragma: no cover"",
            ""    dotted_name = 'dotted_name'# pragma: no cover"",
            ""    classdef = 'classdef'# pragma: no cover"",
            ""    atom = 'atom'# pragma: no cover"",
            ""    dictsetmaker = 'dictsetmaker'# pragma: no cover"",
            ""    except_clause = 'except_clause' # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def parent_type(prev): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(prev, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    }
]",2,4887,0.0024435,4931,0.0073965,0.00984
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 23:
    if t in ALWAYS_NO_SPACE:
NameError: name 'ALWAYS_NO_SPACE' is not defined
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.NAME, token.NUMBER, token.STRING}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(prev, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.ADD, token.SUB, token.MULT, token.FLOORDIV, token.DIV, token.MOD, token.POW}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""leaf.type = 'NAME'"",
            ""leaf.parent = None"",
            ""leaf.value = 'mock_value'"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(prev, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.ADD, token.SUB, token.MULT, token.FLOORDIV, token.DIV, token.MOD, token.POW}"",
            ""TYPED_NAMES = {token.NAME, 'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(prev): return syms.factor"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(prev, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.ADD, token.SUB, token.MULT, token.FLOORDIV, token.DIV, token.MOD, token.POW}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""class MockToken: NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; LPAR = '('.; RPAR = ')'; LSQB = '['; DOUBLESTAR = '**';"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.NAME}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(prev, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.ADD, token.SUB, token.STAR, token.DIV}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(prev, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.ADD, token.SUB, token.MULT, token.FLOORDIV, token.DIV, token.MOD, token.POW}"",
            ""TYPED_NAMES = {token.NAME}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: \n    def __init__(self):\n        self.type = 'mock_type'\n        self.parent = None\n        self.value = None\n        self.prev_sibling = None\nleaf = MockLeaf()"",
            ""class MockToken: \n    COMMENT = 'COMMENT'\n    COLON = 'COLON'\n    COMMA = 'COMMA'\n    EQUAL = 'EQUAL'\n    STAR = 'STAR'\n    DOT = 'DOT'\n    LPAR = '('\n    RPAR = ')'\n    LSQB = '['\n    NAME = 'NAME'\n    NUMBER = 'NUMBER'\n    STRING = 'STRING'\n    DOUBLESTAR = '**'\n\n"",
            ""token = MockToken()"",
            ""class MockSyms: \n    subscript = 'subscript'\n    subscriptlist = 'subscriptlist'\n    sliceop = 'sliceop'\n    arglist = 'arglist'\n    argument = 'argument'\n    parameters = 'parameters'\n    varargslist = 'varargslist'\n    typedargslist = 'typedargslist'\n    star_expr = 'star_expr'\n    factor = 'factor'\n    decorator = 'decorator'\n    trailer = 'trailer'\n    dotted_name = 'dotted_name'\n    classdef = 'classdef'\n    atom = 'atom'\n    dictsetmaker = 'dictsetmaker'\n    import_from = 'import_from'\n    except_clause = 'except_clause'\nsyms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(prev, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'int', 'str', 'float'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""leaf.type = 'NAME'"",
            ""leaf.parent = None"",
            ""leaf.value = 'mock_value'"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = '('.; RPAR = ')'; LSQB = '['; DOUBLESTAR = '**'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.NUMBER, token.STRING}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(prev, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""leaf.type = 'mock_type'"",
            ""leaf.parent = None"",
            ""leaf.value = 'mock_value'"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.NUMBER, token.STRING, token.COMMENT}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(prev, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.ADD, token.SUB, token.MULT, token.FLOORDIV}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""leaf.type = 'mock_type'"",
            ""leaf.parent = None"",
            ""leaf.value = 'mock_value'"",
            ""ALWAYS_NO_SPACE = {'mock_type'}"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = '('; RPAR = ')'; LSQB = '['; DOUBLESTAR = '**'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""def parent_type(leaf): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(param, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON, token.NAME, token.NUMBER, token.STRING}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(prev, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.ADD, token.SUB, token.MULT, token.FLOORDIV, token.DIV, token.MOD, token.POW}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.NAME, token.NUMBER, token.STRING} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""def is_vararg(prev, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = 'NAME' # pragma: no cover"",
            ""leaf.parent = None # pragma: no cover"",
            ""leaf.value = 'mock_value' # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""def is_vararg(prev, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME, 'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def parent_type(prev): return syms.factor # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""def is_vararg(prev, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""def is_vararg(prev, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.type = 'mock_type'# pragma: no cover"",
            ""        self.parent = None# pragma: no cover"",
            ""        self.value = None# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockToken: # pragma: no cover"",
            ""    COMMENT = 'COMMENT'# pragma: no cover"",
            ""    COLON = 'COLON'# pragma: no cover"",
            ""    COMMA = 'COMMA'# pragma: no cover"",
            ""    EQUAL = 'EQUAL'# pragma: no cover"",
            ""    STAR = 'STAR'# pragma: no cover"",
            ""    DOT = 'DOT'# pragma: no cover"",
            ""    LPAR = '('# pragma: no cover"",
            ""    RPAR = ')'# pragma: no cover"",
            ""    LSQB = '['# pragma: no cover"",
            ""    NAME = 'NAME'# pragma: no cover"",
            ""    NUMBER = 'NUMBER'# pragma: no cover"",
            ""    STRING = 'STRING'# pragma: no cover"",
            ""    DOUBLESTAR = '**'# pragma: no cover"",
            ""# pragma: no cover"",
            "" # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""class MockSyms: # pragma: no cover"",
            ""    subscript = 'subscript'# pragma: no cover"",
            ""    subscriptlist = 'subscriptlist'# pragma: no cover"",
            ""    sliceop = 'sliceop'# pragma: no cover"",
            ""    arglist = 'arglist'# pragma: no cover"",
            ""    argument = 'argument'# pragma: no cover"",
            ""    parameters = 'parameters'# pragma: no cover"",
            ""    varargslist = 'varargslist'# pragma: no cover"",
            ""    typedargslist = 'typedargslist'# pragma: no cover"",
            ""    star_expr = 'star_expr'# pragma: no cover"",
            ""    factor = 'factor'# pragma: no cover"",
            ""    decorator = 'decorator'# pragma: no cover"",
            ""    trailer = 'trailer'# pragma: no cover"",
            ""    dotted_name = 'dotted_name'# pragma: no cover"",
            ""    classdef = 'classdef'# pragma: no cover"",
            ""    atom = 'atom'# pragma: no cover"",
            ""    dictsetmaker = 'dictsetmaker'# pragma: no cover"",
            ""    except_clause = 'except_clause'# pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""def is_vararg(prev, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'str', 'float'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = 'NAME' # pragma: no cover"",
            ""leaf.parent = None # pragma: no cover"",
            ""leaf.value = 'mock_value' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = 'mock_type' # pragma: no cover"",
            ""leaf.parent = None # pragma: no cover"",
            ""leaf.value = 'mock_value' # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.NUMBER, token.STRING, token.COMMENT} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""def is_vararg(prev, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = 'mock_type' # pragma: no cover"",
            ""leaf.parent = None # pragma: no cover"",
            ""leaf.value = 'mock_value' # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'mock_type'} # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = '('; RPAR = ')'; LSQB = '['; DOUBLESTAR = '**'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(leaf): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(param, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON, token.NAME, token.NUMBER, token.STRING} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""def is_vararg(prev, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    }
]",2,5402,0.002701,4605,0.0069075,0.0096084999999999
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 28:
    t = leaf.type
NameError: name 'leaf' is not defined
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: pass"",
            ""leaf = MockLeaf()"",
            ""leaf.type = 'token.NAME'"",
            ""leaf.parent = None"",
            ""leaf.value = 'example_value'"",
            ""leaf.prev_sibling = None"",
            ""ALWAYS_NO_SPACE = {'token.NAME', 'token.NUMBER'}"",
            ""class MockToken: COMMENT = 'token.COMMENT'; COLON = 'token.COLON'; COMMA = 'token.COMMA'; EQUAL = 'token.EQUAL'; STAR = 'token.STAR'; LPAR = 'token.LPAR'; RPAR = 'token.RPAR'; DOT = 'token.DOT'; LSQB = 'token.LSQB'; DOUBLESTAR = 'token.DOUBLESTAR'; NAME = 'token.NAME'; NUMBER = 'token.NUMBER'; STRING = 'token.STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'syms.subscript'; subscriptlist = 'syms.subscriptlist'; sliceop = 'syms.sliceop'; arglist = 'syms.arglist'; argument = 'syms.argument'; parameters = 'syms.parameters'; varargslist = 'syms.varargslist'; typedargslist = 'syms.typedargslist'; star_expr = 'syms.star_expr'; factor = 'syms.factor'; decorator = 'syms.decorator'; trailer = 'syms.trailer'; dotted_name = 'syms.dotted_name'; classdef = 'syms.classdef'; atom = 'syms.atom'; dictsetmaker = 'syms.dictsetmaker'; import_from = 'syms.import_from'; except_clause = 'syms.except_clause'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""def parent_type(prev): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(prev, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = 'token.NAME'; parent = None; value = 'example'; prev_sibling = None\nleaf = MockLeaf()"",
            ""ALWAYS_NO_SPACE = {'token.NAME', 'token.NUMBER'}"",
            ""class MockToken: COMMENT = 'token.COMMENT'; COLON = 'token.COLON'; COMMA = 'token.COMMA'; EQUAL = 'token.EQUAL'; STAR = 'token.STAR'; LPAR = 'token.LPAR'; RPAR = 'token.RPAR'; DOT = 'token.DOT'; LSQB = 'token.LSQB'; DOUBLESTAR = 'token.DOUBLESTAR'; NAME = 'token.NAME'; NUMBER = 'token.NUMBER'; STRING = 'token.STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""def parent_type(prev): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(prev, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: pass"",
            ""leaf = MockLeaf()"",
            ""leaf.type = 'NAME'"",
            ""leaf.parent = None"",
            ""leaf.value = 'example_value'"",
            ""leaf.prev_sibling = None"",
            ""ALWAYS_NO_SPACE = {'NAME', 'NUMBER', 'STRING'}"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""def parent_type(leaf): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(prev, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = 'token.NAME'; parent = None; value = 'example'; prev_sibling = None"",
            ""leaf = MockLeaf()"",
            ""ALWAYS_NO_SPACE = {'token.NAME', 'token.NUMBER'}"",
            ""class MockToken: COMMENT = 'token.COMMENT'; COLON = 'token.COLON'; COMMA = 'token.COMMA'; EQUAL = 'token.EQUAL'; STAR = 'token.STAR'; LPAR = 'token.LPAR'; RPAR = 'token.RPAR'; DOT = 'token.DOT'; LSQB = 'token.LSQB'; DOUBLESTAR = 'token.DOUBLESTAR'; NAME = 'token.NAME'; NUMBER = 'token.NUMBER'; STRING = 'token.STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '['}"",
            ""complex_subscript = False"",
            ""def parent_type(node): return 'mock_parent_type'"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = 'mock_type'; parent = None; value = 'mock_value'; prev_sibling = None\nleaf = MockLeaf()"",
            ""ALWAYS_NO_SPACE = {'mock_type'}"",
            ""class MockToken: COMMENT = 'token.COMMENT'; COLON = 'token.COLON'; COMMA = 'token.COMMA'; EQUAL = 'token.EQUAL'; STAR = 'token.STAR'; LPAR = 'token.LPAR'; RPAR = 'token.RPAR'; DOT = 'token.DOT'; LSQB = 'token.LSQB'; DOUBLESTAR = 'token.DOUBLESTAR'; NAME = 'token.NAME'; NUMBER = 'token.NUMBER'; STRING = 'token.STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""def parent_type(leaf): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(param, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {token.NAME, token.NUMBER}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = 'mock_type'; parent = None; value = 'mock_value'; prev_sibling = None\nleaf = MockLeaf()"",
            ""ALWAYS_NO_SPACE = {'mock_type'}"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""def parent_type(leaf): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(param, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: pass"",
            ""leaf = MockLeaf()"",
            ""leaf.type = 'token.NAME'"",
            ""leaf.parent = None"",
            ""leaf.value = 'example_value'"",
            ""leaf.prev_sibling = None"",
            ""ALWAYS_NO_SPACE = {'token.NAME', 'token.NUMBER', 'token.STRING'}"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; LPAR = 'LPAR'; RPAR = 'RPAR'; DOT = 'DOT'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""def parent_type(prev): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(prev, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = 'mock_type'; parent = None; value = 'mock_value'; prev_sibling = None"",
            ""leaf = MockLeaf()"",
            ""ALWAYS_NO_SPACE = {'mock_type', 'token.NAME', 'token.NUMBER'}"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return MockLeaf()"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(param, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: pass"",
            ""leaf = MockLeaf()"",
            ""leaf.type = 'NAME'"",
            ""leaf.parent = None"",
            ""leaf.value = 'example_value'"",
            ""leaf.prev_sibling = None"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.NUMBER, token.STRING}"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def parent_type(prev): return syms.factor"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(prev, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""leaf.type = 'token.NAME'"",
            ""leaf.parent = None"",
            ""leaf.value = 'example'"",
            ""leaf.prev_sibling = None"",
            ""ALWAYS_NO_SPACE = {'token.NAME', 'token.NUMBER'}"",
            ""class MockToken: COMMENT = 'token.COMMENT'; COLON = 'token.COLON'; COMMA = 'token.COMMA'; EQUAL = 'token.EQUAL'; STAR = 'token.STAR'; LPAR = 'token.LPAR'; RPAR = 'token.RPAR'; DOT = 'token.DOT'; LSQB = 'token.LSQB'; DOUBLESTAR = 'token.DOUBLESTAR'; NAME = 'token.NAME'; NUMBER = 'token.NUMBER'; STRING = 'token.STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'token.SUBSCRIPT'; subscriptlist = 'token.SUBSCRIPTLIST'; sliceop = 'token.SLICEOP'; arglist = 'token.ARGLIST'; argument = 'token.ARGUMENT'; parameters = 'token.PARAMETERS'; varargslist = 'token.VARARGS'; typedargslist = 'token.TYPEDARGS'; star_expr = 'token.STAR_EXPR'; factor = 'token.FACTOR'; decorator = 'token.DECORATOR'; trailer = 'token.TRAILER'; dotted_name = 'token.DOTTED_NAME'; classdef = 'token.CLASSDEF'; atom = 'token.ATOM'; dictsetmaker = 'token.DICTSETMAKER'; import_from = 'token.IMPORT_FROM'; except_clause = 'token.EXCEPT_CLAUSE'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""def parent_type(prev): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(prev, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: pass # pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = 'token.NAME' # pragma: no cover"",
            ""leaf.parent = None # pragma: no cover"",
            ""leaf.value = 'example_value' # pragma: no cover"",
            ""leaf.prev_sibling = None # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'token.NAME', 'token.NUMBER'} # pragma: no cover"",
            ""class MockToken: COMMENT = 'token.COMMENT'; COLON = 'token.COLON'; COMMA = 'token.COMMA'; EQUAL = 'token.EQUAL'; STAR = 'token.STAR'; LPAR = 'token.LPAR'; RPAR = 'token.RPAR'; DOT = 'token.DOT'; LSQB = 'token.LSQB'; DOUBLESTAR = 'token.DOUBLESTAR'; NAME = 'token.NAME'; NUMBER = 'token.NUMBER'; STRING = 'token.STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(prev): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(prev, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = 'token.NAME'; parent = None; value = 'example'; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'token.NAME', 'token.NUMBER'} # pragma: no cover"",
            ""class MockToken: COMMENT = 'token.COMMENT'; COLON = 'token.COLON'; COMMA = 'token.COMMA'; EQUAL = 'token.EQUAL'; STAR = 'token.STAR'; LPAR = 'token.LPAR'; RPAR = 'token.RPAR'; DOT = 'token.DOT'; LSQB = 'token.LSQB'; DOUBLESTAR = 'token.DOUBLESTAR'; NAME = 'token.NAME'; NUMBER = 'token.NUMBER'; STRING = 'token.STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(prev): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(prev, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: pass # pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = 'NAME' # pragma: no cover"",
            ""leaf.parent = None # pragma: no cover"",
            ""leaf.value = 'example_value' # pragma: no cover"",
            ""leaf.prev_sibling = None # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'NAME', 'NUMBER', 'STRING'} # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(leaf): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(prev, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = 'token.NAME'; parent = None; value = 'example'; prev_sibling = None # pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'token.NAME', 'token.NUMBER'} # pragma: no cover"",
            ""class MockToken: COMMENT = 'token.COMMENT'; COLON = 'token.COLON'; COMMA = 'token.COMMA'; EQUAL = 'token.EQUAL'; STAR = 'token.STAR'; LPAR = 'token.LPAR'; RPAR = 'token.RPAR'; DOT = 'token.DOT'; LSQB = 'token.LSQB'; DOUBLESTAR = 'token.DOUBLESTAR'; NAME = 'token.NAME'; NUMBER = 'token.NUMBER'; STRING = 'token.STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '['} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return 'mock_parent_type' # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = 'mock_type'; parent = None; value = 'mock_value'; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'mock_type'} # pragma: no cover"",
            ""class MockToken: COMMENT = 'token.COMMENT'; COLON = 'token.COLON'; COMMA = 'token.COMMA'; EQUAL = 'token.EQUAL'; STAR = 'token.STAR'; LPAR = 'token.LPAR'; RPAR = 'token.RPAR'; DOT = 'token.DOT'; LSQB = 'token.LSQB'; DOUBLESTAR = 'token.DOUBLESTAR'; NAME = 'token.NAME'; NUMBER = 'token.NUMBER'; STRING = 'token.STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(leaf): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(param, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME, token.NUMBER} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = 'mock_type'; parent = None; value = 'mock_value'; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'mock_type'} # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(leaf): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(param, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: pass # pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = 'token.NAME' # pragma: no cover"",
            ""leaf.parent = None # pragma: no cover"",
            ""leaf.value = 'example_value' # pragma: no cover"",
            ""leaf.prev_sibling = None # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'token.NAME', 'token.NUMBER', 'token.STRING'} # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; LPAR = 'LPAR'; RPAR = 'RPAR'; DOT = 'DOT'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(prev): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(prev, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = 'mock_type'; parent = None; value = 'mock_value'; prev_sibling = None # pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'mock_type', 'token.NAME', 'token.NUMBER'} # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf() # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(param, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: pass # pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = 'NAME' # pragma: no cover"",
            ""leaf.parent = None # pragma: no cover"",
            ""leaf.value = 'example_value' # pragma: no cover"",
            ""leaf.prev_sibling = None # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(prev): return syms.factor # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""def is_vararg(prev, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = 'token.NAME' # pragma: no cover"",
            ""leaf.parent = None # pragma: no cover"",
            ""leaf.value = 'example' # pragma: no cover"",
            ""leaf.prev_sibling = None # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'token.NAME', 'token.NUMBER'} # pragma: no cover"",
            ""class MockToken: COMMENT = 'token.COMMENT'; COLON = 'token.COLON'; COMMA = 'token.COMMA'; EQUAL = 'token.EQUAL'; STAR = 'token.STAR'; LPAR = 'token.LPAR'; RPAR = 'token.RPAR'; DOT = 'token.DOT'; LSQB = 'token.LSQB'; DOUBLESTAR = 'token.DOUBLESTAR'; NAME = 'token.NAME'; NUMBER = 'token.NUMBER'; STRING = 'token.STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(prev): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(prev, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    }
]",2,6085,0.0030425,4676,0.007014,0.0100565
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 32:
    assert p is not None, f""INTERNAL ERROR: hand-made leaf without parent: {leaf!r}""
AssertionError: INTERNAL ERROR: hand-made leaf without parent: <__main__.MockLeaf object at 0x7f32a215c250>
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = 'token.NAME'; parent = None; value = None; prev_sibling = None"",
            ""leaf = MockLeaf()"",
            ""class MockParent: type = 'mock_parent_type'"",
            ""leaf.parent = MockParent()"",
            ""ALWAYS_NO_SPACE = {'token.NAME', 'token.NUMBER', 'token.STRING'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}"",
            ""def preceding_leaf(p): return None"",
            ""def is_vararg(prev, within): return False"",
            ""def parent_type(node): return None""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'\ntoken = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'\nsyms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON}"",
            ""leaf.parent = type('MockParent', (), {'type': 'mock_parent_type'})()"",
            ""leaf.type = 'token.NAME'"",
            ""leaf.value = 'mock_value'"",
            ""leaf.prev_sibling = None"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '['}"",
            ""complex_subscript = False"",
            ""def parent_type(prev): return None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(param, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""class MockParent: type = 'mock_parent_type'\nparent = MockParent()"",
            ""leaf.parent = parent"",
            ""ALWAYS_NO_SPACE = {'token.NAME', 'token.NUMBER', 'token.STRING'}"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(param, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockParent: type = 'arglist'"",
            ""leaf = type('MockLeaf', (), {'type': 'name', 'parent': MockParent(), 'value': 'example', 'prev_sibling': None})()"",
            ""ALWAYS_NO_SPACE = {'name', 'number', 'string'}"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}"",
            ""def preceding_leaf(p): return type('MockPrevLeaf', (), {'type': 'comma', 'parent': p})()"",
            ""def is_vararg(node, within): return False"",
            ""def parent_type(node): return 'factor'""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: def __init__(self, type=None, parent=None, value=None, prev_sibling=None): self.type = type; self.parent = parent; self.value = value; self.prev_sibling = prev_sibling"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; LPAR = 'LPAR'; RPAR = 'RPAR'; DOT = 'DOT'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""leaf = MockLeaf(type=token.NAME, parent=type('MockParent', (), {'type': syms.arglist, 'prev_sibling': None})(), value='example', prev_sibling=None)"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.NUMBER, token.STRING}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(node, within): return False"",
            ""def parent_type(node): return None"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {token.NAME}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = 'token.NAME'; parent = None; value = 'example'; prev_sibling = None"",
            ""leaf = MockLeaf()"",
            ""class MockParent: type = 'mock_parent'; parent = None\np = MockParent()"",
            ""ALWAYS_NO_SPACE = {'token.NAME', 'token.NUMBER'}"",
            ""class MockToken: COMMENT = 'token.COMMENT'; COLON = 'token.COLON'; COMMA = 'token.COMMA'; EQUAL = 'token.EQUAL'; STAR = 'token.STAR'; LPAR = 'token.LPAR'; RPAR = 'token.RPAR'; DOT = 'token.DOT'; LSQB = 'token.LSQB'; DOUBLESTAR = 'token.DOUBLESTAR'; NAME = 'token.NAME'; NUMBER = 'token.NUMBER'; STRING = 'token.STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""def parent_type(node): return 'mock_parent'"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = 'token.NAME'; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""class MockParent: type = 'syms.arglist'\np = MockParent()"",
            ""ALWAYS_NO_SPACE = {'token.NAME', 'token.NUMBER', 'token.STRING'}"",
            ""OPENING_BRACKETS = {'token.LPAR', 'token.LSQB'}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = {'token.STAR', 'token.DOUBLESTAR'}"",
            ""TYPED_NAMES = {'token.NAME'}"",
            ""def preceding_leaf(p): return None"",
            ""def is_vararg(param, within): return False"",
            ""def parent_type(node): return 'syms.factor'""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""class MockParent: type = 'mock_parent_type'  # Simulating a parent node with a type\nparent = MockParent()"",
            ""leaf.parent = parent"",
            ""ALWAYS_NO_SPACE = {'token.NAME', 'token.NUMBER', 'token.STRING'}"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""leaf.parent = type('MockParent', (), {'type': None, 'prev_sibling': None})()"",
            ""ALWAYS_NO_SPACE = {'token.NAME', 'token.NUMBER', 'token.STRING'}"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(param, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""class MockParent: type = 'parent_type'\nparent = MockParent()"",
            ""leaf.parent = parent"",
            ""ALWAYS_NO_SPACE = {'token.NAME', 'token.NUMBER', 'token.STRING'}"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; LPAR = 'LPAR'; RPAR = 'RPAR'; DOT = 'DOT'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""def parent_type(leaf): return None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = 'token.NAME'; parent = None; value = None; prev_sibling = None # pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockParent: type = 'mock_parent_type' # pragma: no cover"",
            ""leaf.parent = MockParent() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'token.NAME', 'token.NUMBER', 'token.STRING'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def is_vararg(prev, within): return False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'# pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON} # pragma: no cover"",
            ""leaf.parent = type('MockParent', (), {'type': 'mock_parent_type'})() # pragma: no cover"",
            ""leaf.type = 'token.NAME' # pragma: no cover"",
            ""leaf.value = 'mock_value' # pragma: no cover"",
            ""leaf.prev_sibling = None # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '['} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(prev): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""def is_vararg(param, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockParent: type = 'mock_parent_type'# pragma: no cover"",
            ""parent = MockParent() # pragma: no cover"",
            ""leaf.parent = parent # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'token.NAME', 'token.NUMBER', 'token.STRING'} # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(param, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockParent: type = 'arglist' # pragma: no cover"",
            ""leaf = type('MockLeaf', (), {'type': 'name', 'parent': MockParent(), 'value': 'example', 'prev_sibling': None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'name', 'number', 'string'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover"",
            ""def preceding_leaf(p): return type('MockPrevLeaf', (), {'type': 'comma', 'parent': p})() # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""def parent_type(node): return 'factor' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = 'token.NAME'; parent = None; value = 'example'; prev_sibling = None # pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockParent: type = 'mock_parent'; parent = None# pragma: no cover"",
            ""p = MockParent() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'token.NAME', 'token.NUMBER'} # pragma: no cover"",
            ""class MockToken: COMMENT = 'token.COMMENT'; COLON = 'token.COLON'; COMMA = 'token.COMMA'; EQUAL = 'token.EQUAL'; STAR = 'token.STAR'; LPAR = 'token.LPAR'; RPAR = 'token.RPAR'; DOT = 'token.DOT'; LSQB = 'token.LSQB'; DOUBLESTAR = 'token.DOUBLESTAR'; NAME = 'token.NAME'; NUMBER = 'token.NUMBER'; STRING = 'token.STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return 'mock_parent' # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = 'token.NAME'; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockParent: type = 'syms.arglist'# pragma: no cover"",
            ""p = MockParent() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'token.NAME', 'token.NUMBER', 'token.STRING'} # pragma: no cover"",
            ""OPENING_BRACKETS = {'token.LPAR', 'token.LSQB'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""VARARGS_SPECIALS = {'token.STAR', 'token.DOUBLESTAR'} # pragma: no cover"",
            ""TYPED_NAMES = {'token.NAME'} # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def is_vararg(param, within): return False # pragma: no cover"",
            ""def parent_type(node): return 'syms.factor' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockParent: type = 'mock_parent_type'  # Simulating a parent node with a type# pragma: no cover"",
            ""parent = MockParent() # pragma: no cover"",
            ""leaf.parent = parent # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'token.NAME', 'token.NUMBER', 'token.STRING'} # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.parent = type('MockParent', (), {'type': None, 'prev_sibling': None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'token.NAME', 'token.NUMBER', 'token.STRING'} # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(param, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockParent: type = 'parent_type'# pragma: no cover"",
            ""parent = MockParent() # pragma: no cover"",
            ""leaf.parent = parent # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'token.NAME', 'token.NUMBER', 'token.STRING'} # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; LPAR = 'LPAR'; RPAR = 'RPAR'; DOT = 'DOT'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '[', '{'} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(leaf): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    }
]",2,6592,0.003296,3912,0.005868,0.009164
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 14:
    t = leaf.type
NameError: name 'leaf' is not defined
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: def __init__(self, type, parent, value, prev_sibling=None): self.type = type; self.parent = parent; self.value = value; self.prev_sibling = prev_sibling"",
            ""parent = type('MockParent', (object,), {'type': 'arglist'})()"",
            ""leaf = MockLeaf(type='name', parent=parent, value='example')"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.NAME, token.NUMBER, token.STRING}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(node): return 'arglist'"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(param, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'add', 'subtract', 'multiply', 'divide'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: def __init__(self, type, parent, value, prev_sibling=None): self.type = type; self.parent = parent; self.value = value; self.prev_sibling = prev_sibling"",
            ""leaf = MockLeaf(type='NAME', parent=type('MockParent', (object,), {'type': 'arglist'})(), value='leaf_value')"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(node): return None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.ADD, token.SUB}"",
            ""TYPED_NAMES = {token.NAME}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: def __init__(self, type, parent, value, prev_sibling=None): self.type = type; self.parent = parent; self.value = value; self.prev_sibling = prev_sibling"",
            ""mock_parent = type('MockParent', (), {'type': 'arglist'})()"",
            ""leaf = MockLeaf(type='name', parent=mock_parent, value='leaf_value', prev_sibling=None)"",
            ""class Token: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'"",
            ""token = Token()"",
            ""class Syms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = Syms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(prev): return 'arglist'"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(leaf, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class Token: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'"",
            ""class Syms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""leaf = type('MockLeaf', (object,), {'type': 'NAME', 'parent': type('MockParent', (object,), {'type': 'arglist'})(), 'value': 'leaf value', 'prev_sibling': None})()"",
            ""ALWAYS_NO_SPACE = {Token.COMMENT, Token.COLON}"",
            ""token = Token()"",
            ""syms = Syms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def parent_type(node): return node.type"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: def __init__(self, type, parent, value, prev_sibling=None): self.type = type; self.parent = parent; self.value = value; self.prev_sibling = prev_sibling"",
            ""class MockParent: type = 'arglist'"",
            ""parent = MockParent()"",
            ""leaf = MockLeaf(type='NAME', parent=parent, value='example_value')"",
            ""ALWAYS_NO_SPACE = { 'comment', 'NAME', 'NUMBER' }"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""def parent_type(node): return syms.arglist"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: def __init__(self, type, parent, value, prev_sibling=None): self.type = type; self.parent = parent; self.value = value; self.prev_sibling = prev_sibling"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""token = MockToken()"",
            ""syms = MockSyms()"",
            ""leaf = MockLeaf(type='NAME', parent=syms.arglist, value='leaf_value', prev_sibling=None)"",
            ""ALWAYS_NO_SPACE = {token.COMMENT}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(node): return syms.arglist"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(leaf, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-'}"",
            ""TYPED_NAMES = {'int', 'str', 'float'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: def __init__(self, type, parent, value, prev_sibling=None): self.type = type; self.parent = parent; self.value = value; self.prev_sibling = prev_sibling"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""leaf = MockLeaf(type='NAME', parent=Mock(), value='mock_value')"",
            ""token = MockToken()"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(leaf): return None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-'}"",
            ""TYPED_NAMES = {'int', 'str'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: def __init__(self, type, parent, value, prev_sibling=None): self.type = type; self.parent = parent; self.value = value; self.prev_sibling = prev_sibling"",
            ""class MockParent: type = 'arglist'"",
            ""leaf = MockLeaf(type='token.NAME', parent=MockParent(), value='example_value')"",
            ""ALWAYS_NO_SPACE = {'token.COMMENT', 'token.NUMBER', 'token.STRING'}"",
            ""class Token: COMMENT = 'token.COMMENT'; COLON = 'token.COLON'; COMMA = 'token.COMMA'; EQUAL = 'token.EQUAL'; STAR = 'token.STAR'; LPAR = 'token.LPAR'; RPAR = 'token.RPAR'; LSQB = 'token.LSQB'; DOUBLESTAR = 'token.DOUBLESTAR'; NAME = 'token.NAME'; NUMBER = 'token.NUMBER'; STRING = 'token.STRING'"",
            ""token = Token()"",
            ""class Syms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = Syms()"",
            ""def preceding_leaf(parent): return None"",
            ""OPENING_BRACKETS = {'(', '['}"",
            ""complex_subscript = False"",
            ""def parent_type(leaf): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(param, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Optional, Final""
        ],
        ""initialization"": [
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""class MockLeaf: def __init__(self, type, parent, value, prev_sibling=None): self.type = type; self.parent = parent; self.value = value; self.prev_sibling = prev_sibling"",
            ""leaf = MockLeaf(type='NAME', parent=syms.arglist, value='example_value')"",
            ""ALWAYS_NO_SPACE = {'COMMENT', 'NAME', 'NUMBER', 'STRING'}"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def parent_type(node): return syms.arglist"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: def __init__(self, type, parent, value, prev_sibling=None): self.type = type; self.parent = parent; self.value = value; self.prev_sibling = prev_sibling"",
            ""parent = type('MockParent', (object,), {'type': 'arglist'})()"",
            ""leaf = MockLeaf(type='name', parent=parent, value='leaf_value')"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; DOUBLESTAR = 'DOUBLESTAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.NAME}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(leaf): return None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(prev, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName'}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class Token: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR' # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': 'NAME', 'parent': type('MockParent', (object,), {'type': 'arglist'})(), 'value': 'leaf value', 'prev_sibling': None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {Token.COMMENT, Token.COLON} # pragma: no cover"",
            ""token = Token() # pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return node.type # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from typing import Optional, Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    }
]",2,7373,0.0036865,4891,0.0073365,0.011023
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 18:
    t = leaf.type
NameError: name 'leaf' is not defined
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: def __init__(self, type, parent, value, prev_sibling=None): self.type = type; self.parent = parent; self.value = value; self.prev_sibling = prev_sibling"",
            ""leaf = MockLeaf(type='name', parent=type('MockParent', (object,), {'type': 'mock_parent_type'})(), value='leaf_value', prev_sibling=None)"",
            ""ALWAYS_NO_SPACE = {'comment', 'name', 'number'}"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'DOUBLESTAR'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(parent): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(param, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockToken:\n    COMMENT = 'comment'\n    COLON = 'colon'\n    COMMA = 'comma'\n    EQUAL = 'equal'\n    STAR = 'star'\n    DOT = 'dot'\n    LPAR = '('\n    RPAR = ')'\n    LSQB = '['\n    NAME = 'name'\n    NUMBER = 'number'\n    STRING = 'string'\n    DOUBLESTAR = '**'\n"",
            ""class MockSyms:\n    subscript = 'subscript'\n    subscriptlist = 'subscriptlist'\n    sliceop = 'sliceop'\n    arglist = 'arglist'\n    argument = 'argument'\n    parameters = 'parameters'\n    varargslist = 'varargslist'\n    typedargslist = 'typedargslist'\n    star_expr = 'star_expr'\n    factor = 'factor'\n    decorator = 'decorator'\n    trailer = 'trailer'\n    dotted_name = 'dotted_name'\n    classdef = 'classdef'\n    atom = 'atom'\n    dictsetmaker = 'dictsetmaker'\n    import_from = 'import_from'\n    except_clause = 'except_clause'\n"",
            ""token = MockToken()"",
            ""syms = MockSyms()"",
            ""leaf = MockLeaf(type=token.NAME, parent=syms.arglist, value='example')"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.NUMBER, token.STRING}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(node): return syms.factor"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(param, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = { '+' , '-' }"",
            ""TYPED_NAMES = { 'typed_name' }""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""leaf = type('MockLeaf', (object,), {'type': 'NAME', 'parent': type('MockParent', (object,), {'type': 'arglist'})(), 'value': 'example', 'prev_sibling': None})()"",
            ""ALWAYS_NO_SPACE = {MockToken.COMMENT}"",
            ""OPENING_BRACKETS = {MockToken.LPAR, MockToken.LSQB}"",
            ""complex_subscript = False"",
            ""token = MockToken()"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(prev): return 'arglist'"",
            ""VARARGS_SPECIALS = {MockToken.STAR, MockToken.DOUBLESTAR}"",
            ""def is_vararg(prev, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = { '+', '-', '*', '/' }"",
            ""TYPED_NAMES = { 'TypedName1', 'TypedName2' }""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockToken: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; DOT = 'dot'; LPAR = 'lpar'; RPAR = 'rpar'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star'"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""token = MockToken()"",
            ""syms = MockSyms()"",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': type('MockParent', (object,), {'type': syms.arglist})(), 'value': 'leaf_value', 'prev_sibling': None})()"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.NUMBER, token.STRING}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(prev, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.ADD, token.SUB}"",
            ""TYPED_NAMES = {token.NAME}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: def __init__(self, type, parent, value, prev_sibling=None): self.type = type; self.parent = parent; self.value = value; self.prev_sibling = prev_sibling"",
            ""leaf = MockLeaf(type='NAME', parent=type('MockParent', (object,), {'type': 'arglist', 'parent': None})(), value='example')"",
            ""ALWAYS_NO_SPACE = {'COMMENT', 'NAME'}"",
            ""class MockToken: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; DOT = 'dot'; LPAR = 'lpar'; RPAR = 'rpar'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '['}"",
            ""complex_subscript = False"",
            ""def parent_type(leaf): return None"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(prev_leaf, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'int', 'str', 'float'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class Mock: pass"",
            ""class Token: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; DOT = 'dot'; LPAR = 'lpar'; RPAR = 'rpar'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star'"",
            ""class Syms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""token = Token()"",
            ""syms = Syms()"",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': type('MockParent', (object,), {'type': syms.arglist, 'parent': None})(), 'value': 'leaf_value', 'prev_sibling': None})()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(parent): return None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(prev, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.ADD, token.SUB}"",
            ""TYPED_NAMES = {token.NAME}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""leaf = type('Leaf', (object,), {'type': token.NAME, 'value': 'test_value', 'parent': None, 'prev_sibling': None})()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(leaf): return 'mock_parent_type'"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(prev, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling"",
            ""class MockToken:\n    COMMENT = 'COMMENT'\n    COLON = 'COLON'\n    COMMA = 'COMMA'\n    EQUAL = 'EQUAL'\n    STAR = 'STAR'\n    DOT = 'DOT'\n    LPAR = '('\n    RPAR = ')'\n    LSQB = '['\n    NAME = 'NAME'\n    NUMBER = 'NUMBER'\n    STRING = 'STRING'\n    DOUBLESTAR = '**'"",
            ""class MockSyms:\n    subscript = 'subscript'\n    subscriptlist = 'subscriptlist'\n    sliceop = 'sliceop'\n    arglist = 'arglist'\n    argument = 'argument'\n    parameters = 'parameters'\n    varargslist = 'varargslist'\n    typedargslist = 'typedargslist'\n    star_expr = 'star_expr'\n    factor = 'factor'\n    decorator = 'decorator'\n    trailer = 'trailer'\n    dotted_name = 'dotted_name'\n    classdef = 'classdef'\n    atom = 'atom'\n    dictsetmaker = 'dictsetmaker'\n    import_from = 'import_from'\n    except_clause = 'except_clause'"",
            ""token = MockToken()"",
            ""syms = MockSyms()"",
            ""leaf = MockLeaf(type=token.NAME, parent=None, value='example')"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.NUMBER, token.NAME}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""TYPED_NAMES = {token.NAME, token.COMMA}"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(node): return syms.factor"",
            ""def is_vararg(node, within): return False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: def __init__(self, type, parent, value): self.type = type; self.parent = parent; self.value = value; self.prev_sibling = None"",
            ""leaf = MockLeaf(type='mock_type', parent='mock_parent', value='mock_value')"",
            ""ALWAYS_NO_SPACE = {'mock_type'}"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""def parent_type(prev): return 'arglist'"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(prev, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class Token: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'"",
            ""class Syms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""leaf = type('MockLeaf', (object,), {'type': 'NAME', 'parent': type('MockParent', (object,), {'type': 'arglist'})(), 'value': 'example', 'prev_sibling': None})()"",
            ""ALWAYS_NO_SPACE = {Token.COMMENT}"",
            ""token = Token()"",
            ""syms = Syms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '['}"",
            ""complex_subscript = False"",
            ""def parent_type(node): return syms.factor"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(param, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'int', 'str', 'float'}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockToken:# pragma: no cover"",
            ""    COMMENT = 'comment'# pragma: no cover"",
            ""    COLON = 'colon'# pragma: no cover"",
            ""    COMMA = 'comma'# pragma: no cover"",
            ""    EQUAL = 'equal'# pragma: no cover"",
            ""    STAR = 'star'# pragma: no cover"",
            ""    DOT = 'dot'# pragma: no cover"",
            ""    LPAR = '('# pragma: no cover"",
            ""    RPAR = ')'# pragma: no cover"",
            ""    LSQB = '['# pragma: no cover"",
            ""    NAME = 'name'# pragma: no cover"",
            ""    NUMBER = 'number'# pragma: no cover"",
            ""    STRING = 'string'# pragma: no cover"",
            ""    DOUBLESTAR = '**'# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockSyms:# pragma: no cover"",
            ""    subscript = 'subscript'# pragma: no cover"",
            ""    subscriptlist = 'subscriptlist'# pragma: no cover"",
            ""    sliceop = 'sliceop'# pragma: no cover"",
            ""    arglist = 'arglist'# pragma: no cover"",
            ""    argument = 'argument'# pragma: no cover"",
            ""    parameters = 'parameters'# pragma: no cover"",
            ""    varargslist = 'varargslist'# pragma: no cover"",
            ""    typedargslist = 'typedargslist'# pragma: no cover"",
            ""    star_expr = 'star_expr'# pragma: no cover"",
            ""    factor = 'factor'# pragma: no cover"",
            ""    decorator = 'decorator'# pragma: no cover"",
            ""    trailer = 'trailer'# pragma: no cover"",
            ""    dotted_name = 'dotted_name'# pragma: no cover"",
            ""    classdef = 'classdef'# pragma: no cover"",
            ""    atom = 'atom'# pragma: no cover"",
            ""    dictsetmaker = 'dictsetmaker'# pragma: no cover"",
            ""    except_clause = 'except_clause'# pragma: no cover"",
            "" # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""leaf = MockLeaf(type=token.NAME, parent=syms.arglist, value='example') # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.NUMBER, token.STRING} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def parent_type(node): return syms.factor # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""def is_vararg(param, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = { '+' , '-' } # pragma: no cover"",
            ""TYPED_NAMES = { 'typed_name' } # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR' # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': 'NAME', 'parent': type('MockParent', (object,), {'type': 'arglist'})(), 'value': 'example', 'prev_sibling': None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {MockToken.COMMENT} # pragma: no cover"",
            ""OPENING_BRACKETS = {MockToken.LPAR, MockToken.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def parent_type(prev): return 'arglist' # pragma: no cover"",
            ""VARARGS_SPECIALS = {MockToken.STAR, MockToken.DOUBLESTAR} # pragma: no cover"",
            ""def is_vararg(prev, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = { '+', '-', '*', '/' } # pragma: no cover"",
            ""TYPED_NAMES = { 'TypedName1', 'TypedName2' } # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockToken: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; DOT = 'dot'; LPAR = 'lpar'; RPAR = 'rpar'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': type('MockParent', (object,), {'type': syms.arglist})(), 'value': 'leaf_value', 'prev_sibling': None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.NUMBER, token.STRING} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""def is_vararg(prev, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class Mock: pass # pragma: no cover"",
            ""class Token: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; DOT = 'dot'; LPAR = 'lpar'; RPAR = 'rpar'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star' # pragma: no cover"",
            ""token = Token() # pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': token.NAME, 'parent': type('MockParent', (object,), {'type': syms.arglist, 'parent': None})(), 'value': 'leaf_value', 'prev_sibling': None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(parent): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""def is_vararg(prev, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""leaf = type('Leaf', (object,), {'type': token.NAME, 'value': 'test_value', 'parent': None, 'prev_sibling': None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def parent_type(leaf): return 'mock_parent_type' # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""def is_vararg(prev, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""class MockToken:# pragma: no cover"",
            ""    COMMENT = 'COMMENT'# pragma: no cover"",
            ""    COLON = 'COLON'# pragma: no cover"",
            ""    COMMA = 'COMMA'# pragma: no cover"",
            ""    EQUAL = 'EQUAL'# pragma: no cover"",
            ""    STAR = 'STAR'# pragma: no cover"",
            ""    DOT = 'DOT'# pragma: no cover"",
            ""    LPAR = '('# pragma: no cover"",
            ""    RPAR = ')'# pragma: no cover"",
            ""    LSQB = '['# pragma: no cover"",
            ""    NAME = 'NAME'# pragma: no cover"",
            ""    NUMBER = 'NUMBER'# pragma: no cover"",
            ""    STRING = 'STRING'# pragma: no cover"",
            ""    DOUBLESTAR = '**' # pragma: no cover"",
            ""class MockSyms:# pragma: no cover"",
            ""    subscript = 'subscript'# pragma: no cover"",
            ""    subscriptlist = 'subscriptlist'# pragma: no cover"",
            ""    sliceop = 'sliceop'# pragma: no cover"",
            ""    arglist = 'arglist'# pragma: no cover"",
            ""    argument = 'argument'# pragma: no cover"",
            ""    parameters = 'parameters'# pragma: no cover"",
            ""    varargslist = 'varargslist'# pragma: no cover"",
            ""    typedargslist = 'typedargslist'# pragma: no cover"",
            ""    star_expr = 'star_expr'# pragma: no cover"",
            ""    factor = 'factor'# pragma: no cover"",
            ""    decorator = 'decorator'# pragma: no cover"",
            ""    trailer = 'trailer'# pragma: no cover"",
            ""    dotted_name = 'dotted_name'# pragma: no cover"",
            ""    classdef = 'classdef'# pragma: no cover"",
            ""    atom = 'atom'# pragma: no cover"",
            ""    dictsetmaker = 'dictsetmaker'# pragma: no cover"",
            ""    except_clause = 'except_clause' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""leaf = MockLeaf(type=token.NAME, parent=None, value='example') # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.NUMBER, token.NAME} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME, token.COMMA} # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def parent_type(node): return syms.factor # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class Token: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR' # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': 'NAME', 'parent': type('MockParent', (object,), {'type': 'arglist'})(), 'value': 'example', 'prev_sibling': None})() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {Token.COMMENT} # pragma: no cover"",
            ""token = Token() # pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '['} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return syms.factor # pragma: no cover"",
            ""VARARGS_SPECIALS = {'*', '**'} # pragma: no cover"",
            ""def is_vararg(param, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'str', 'float'} # pragma: no cover""
        ]
    }
]",2,7850,0.003925,4741,0.0071115,0.0110365
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 8:
    syms = MockSyms() # pragma: no cover
NameError: name 'MockSyms' is not defined
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""class MockToken: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; DOT = 'dot'; LPAR = 'lpar'; RPAR = 'rpar'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(leaf): return syms.factor"",
            ""def is_vararg(prev_leaf, within): return False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type=None, parent=None, value=None, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling"",
            ""leaf = MockLeaf(type='name', parent=None, value='example')"",
            ""ALWAYS_NO_SPACE: Final = { 'comment', 'colon', 'comma' }"",
            ""class MockToken:\n    COMMENT = 'comment'\n    COLON = 'colon'\n    COMMA = 'comma'\n    EQUAL = 'equal'\n    STAR = 'star'\n    DOT = 'dot'\n    LPAR = '('\n    RPAR = ')'\n    LSQB = '['\n    NAME = 'name'\n    NUMBER = 'number'\n    STRING = 'string'\n    DOUBLESTAR = '**'"",
            ""token = MockToken()"",
            ""class MockSyms:\n    subscript = 'subscript'\n    subscriptlist = 'subscriptlist'\n    sliceop = 'sliceop'\n    arglist = 'arglist'\n    argument = 'argument'\n    parameters = 'parameters'\n    varargslist = 'varargslist'\n    typedargslist = 'typedargslist'\n    star_expr = 'star_expr'\n    factor = 'factor'\n    decorator = 'decorator'\n    trailer = 'trailer'\n    dotted_name = 'dotted_name'\n    classdef = 'classdef'\n    atom = 'atom'\n    dictsetmaker = 'dictsetmaker'\n    import_from = 'import_from'\n    except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = { '(', '[', '{' }"",
            ""complex_subscript = False"",
            ""def parent_type(leaf): return None"",
            ""VARARGS_SPECIALS = { '*', '**' }"",
            ""def is_vararg(prev_leaf, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = { '+', '-', '*', '/' }"",
            ""TYPED_NAMES = { 'TypedName1', 'TypedName2' }""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = 'NAME'; parent = None; value = 'example'; prev_sibling = None\nleaf = MockLeaf()"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(node): return syms.factor"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-'}"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""ALWAYS_NO_SPACE = {0, 1}"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB';"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return leaf"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""def is_vararg(leaf, within): return False"",
            ""def parent_type(node): return 'arglist'  # Mock implementation""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""class MockToken: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; DOT = 'dot'; LPAR = 'lpar'; RPAR = 'rpar'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.NUMBER, token.STRING}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(leaf): return syms.factor"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(prev, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-'}"",
            ""TYPED_NAMES = {'TypedName'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\nleaf = MockLeaf(type='name', parent=None, value='leaf_value')"",
            ""class MockToken:\n    COMMENT = 'COMMENT'\n    COLON = 'COLON'\n    COMMA = 'COMMA'\n    EQUAL = 'EQUAL'\n    STAR = 'STAR'\n    DOT = 'DOT'\n    LPAR = '('\n    RPAR = ')'\n    LSQB = '['\n    NAME = 'NAME'\n    NUMBER = 'NUMBER'\n    STRING = 'STRING'\n    DOUBLESTAR = '**'\n\ntoken = MockToken()"",
            ""class MockSyms:\n    subscript = 'subscript'\n    subscriptlist = 'subscriptlist'\n    sliceop = 'sliceop'\n    arglist = 'arglist'\n    argument = 'argument'\n    parameters = 'parameters'\n    varargslist = 'varargslist'\n    typedargslist = 'typedargslist'\n    star_expr = 'star_expr'\n    factor = 'factor'\n    decorator = 'decorator'\n    trailer = 'trailer'\n    dotted_name = 'dotted_name'\n    classdef = 'classdef'\n    atom = 'atom'\n    dictsetmaker = 'dictsetmaker'\n    import_from = 'import_from'\n    except_clause = 'except_clause'\n\ns yms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.NAME}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(leaf): return None"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(leaf, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {token.COLON, token.EQUAL}"",
            ""TYPED_NAMES = {token.NAME, token.NUMBER}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\nleaf = MockLeaf(type='mock_type', parent=None, value='example', prev_sibling=None)"",
            ""ALWAYS_NO_SPACE = {'mock_type'}"",
            ""class MockToken:\n    COMMENT = 'comment'\n    COLON = 'colon'\n    COMMA = 'comma'\n    EQUAL = 'equal'\n    STAR = 'star'\n    DOT = 'dot'\n    LPAR = 'lpar'\n    RPAR = 'rpar'\n    LSQB = 'lsqb'\n    NAME = 'name'\n    NUMBER = 'number'\n    STRING = 'string'\n    DOUBLESTAR = 'double_star'\ntoken = MockToken()"",
            ""class MockSyms:\n    subscript = 'subscript'\n    subscriptlist = 'subscriptlist'\n    sliceop = 'sliceop'\n    arglist = 'arglist'\n    argument = 'argument'\n    parameters = 'parameters'\n    varargslist = 'varargslist'\n    typedargslist = 'typedargslist'\n    star_expr = 'star_expr'\n    factor = 'factor'\n    decorator = 'decorator'\n    trailer = 'trailer'\n    dotted_name = 'dotted_name'\n    classdef = 'classdef'\n    atom = 'atom'\n    dictsetmaker = 'dictsetmaker'\n    import_from = 'import_from'\n    except_clause = 'except_clause'\nsyms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {'(', '['}"",
            ""complex_subscript = False"",
            ""def parent_type(node): return syms.arglist"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(node, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'int', 'str', 'float'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None\nleaf = MockLeaf()"",
            ""class MockToken: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equals'; STAR = 'star'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOT = 'dot'; LPAR = '('; RPAR = ')'; LSQB = '['; DOUBLESTAR = '**'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON, token.NAME}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(leaf): return syms.factor"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(prev, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'int', 'str', 'float'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: def __init__(self, leaf_type, parent, value, prev_sibling=None): self.type = leaf_type; self.parent = parent; self.value = value; self.prev_sibling = prev_sibling"",
            ""leaf = MockLeaf(5, None, 'example leaf')"",
            ""ALWAYS_NO_SPACE = {'token.NAME', 'token.NUMBER', 'token.STRING'}"",
            ""class MockToken: COMMENT = 0; COLON = 1; COMMA = 2; EQUAL = 3; STAR = 4; DOT = 5; LPAR = 6; RPAR = 7; LSQB = 8; NAME = 9; NUMBER = 10; STRING = 11; DOUBLESTAR = 12; LPAR = 13; RPAR = 14\n"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause';"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""complex_subscript = False"",
            ""def parent_type(node): return syms.factory"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""def is_vararg(prev, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'}"",
            ""TYPED_NAMES = {'int', 'str'}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final""
        ],
        ""initialization"": [
            ""class MockLeaf: def __init__(self, type, parent, value, prev_sibling=None): self.type = type; self.parent = parent; self.value = value; self.prev_sibling = prev_sibling"",
            ""leaf = MockLeaf(type='name', parent=None, value='example')"",
            ""ALWAYS_NO_SPACE = {'name'}"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'"",
            ""token = MockToken()"",
            ""class MockSyms: subscript = 'subscript'; subscriptlist = 'subscriptlist'; sliceop = 'sliceop'; arglist = 'arglist'; argument = 'argument'; parameters = 'parameters'; varargslist = 'varargslist'; typedargslist = 'typedargslist'; star_expr = 'star_expr'; factor = 'factor'; decorator = 'decorator'; trailer = 'trailer'; dotted_name = 'dotted_name'; classdef = 'classdef'; atom = 'atom'; dictsetmaker = 'dictsetmaker'; import_from = 'import_from'; except_clause = 'except_clause'"",
            ""syms = MockSyms()"",
            ""def preceding_leaf(parent): return None"",
            ""OPENING_BRACKETS = {'(', '[', '{'}"",
            ""complex_subscript = False"",
            ""def parent_type(leaf): return syms.factor"",
            ""VARARGS_SPECIALS = {'*', '**'}"",
            ""def is_vararg(leaf, within): return False"",
            ""VARARGS_PARENTS = set()"",
            ""UNPACKING_PARENTS = set()"",
            ""MATH_OPERATORS = {'+', '-'}"",
            ""TYPED_NAMES = {'TypedName'}""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockToken: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; DOT = 'dot'; LPAR = 'lpar'; RPAR = 'rpar'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def parent_type(leaf): return syms.factor # pragma: no cover"",
            ""def is_vararg(prev_leaf, within): return False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type=None, parent=None, value=None, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""leaf = MockLeaf(type='name', parent=None, value='example') # pragma: no cover"",
            ""ALWAYS_NO_SPACE: Final = { 'comment', 'colon', 'comma' } # pragma: no cover"",
            ""class MockToken:# pragma: no cover"",
            ""    COMMENT = 'comment'# pragma: no cover"",
            ""    COLON = 'colon'# pragma: no cover"",
            ""    COMMA = 'comma'# pragma: no cover"",
            ""    EQUAL = 'equal'# pragma: no cover"",
            ""    STAR = 'star'# pragma: no cover"",
            ""    DOT = 'dot'# pragma: no cover"",
            ""    LPAR = '('# pragma: no cover"",
            ""    RPAR = ')'# pragma: no cover"",
            ""    LSQB = '['# pragma: no cover"",
            ""    NAME = 'name'# pragma: no cover"",
            ""    NUMBER = 'number'# pragma: no cover"",
            ""    STRING = 'string'# pragma: no cover"",
            ""    DOUBLESTAR = '**' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""class MockSyms:# pragma: no cover"",
            ""    subscript = 'subscript'# pragma: no cover"",
            ""    subscriptlist = 'subscriptlist'# pragma: no cover"",
            ""    sliceop = 'sliceop'# pragma: no cover"",
            ""    arglist = 'arglist'# pragma: no cover"",
            ""    argument = 'argument'# pragma: no cover"",
            ""    parameters = 'parameters'# pragma: no cover"",
            ""    varargslist = 'varargslist'# pragma: no cover"",
            ""    typedargslist = 'typedargslist'# pragma: no cover"",
            ""    star_expr = 'star_expr'# pragma: no cover"",
            ""    factor = 'factor'# pragma: no cover"",
            ""    decorator = 'decorator'# pragma: no cover"",
            ""    trailer = 'trailer'# pragma: no cover"",
            ""    dotted_name = 'dotted_name'# pragma: no cover"",
            ""    classdef = 'classdef'# pragma: no cover"",
            ""    atom = 'atom'# pragma: no cover"",
            ""    dictsetmaker = 'dictsetmaker'# pragma: no cover"",
            ""    except_clause = 'except_clause' # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = { '(', '[', '{' } # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(leaf): return None # pragma: no cover"",
            ""VARARGS_SPECIALS = { '*', '**' } # pragma: no cover"",
            ""def is_vararg(prev_leaf, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = { '+', '-', '*', '/' } # pragma: no cover"",
            ""TYPED_NAMES = { 'TypedName1', 'TypedName2' } # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = 'NAME'; parent = None; value = 'example'; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; DOT = 'DOT'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def parent_type(node): return syms.factor # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName1', 'TypedName2'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {0, 1} # pragma: no cover"",
            ""class MockToken: COMMENT = 'COMMENT'; COLON = 'COLON'; COMMA = 'COMMA'; EQUAL = 'EQUAL'; STAR = 'STAR'; NAME = 'NAME'; NUMBER = 'NUMBER'; STRING = 'STRING'; DOUBLESTAR = 'DOUBLESTAR'; LPAR = 'LPAR'; RPAR = 'RPAR'; LSQB = 'LSQB'; # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return leaf # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""def parent_type(node): return 'arglist'  # Mock implementation # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockToken: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equal'; STAR = 'star'; DOT = 'dot'; LPAR = 'lpar'; RPAR = 'rpar'; LSQB = 'lsqb'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOUBLESTAR = 'double_star' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.NUMBER, token.STRING} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def parent_type(leaf): return syms.factor # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""def is_vararg(prev, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-'} # pragma: no cover"",
            ""TYPED_NAMES = {'TypedName'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            ""leaf = MockLeaf(type='name', parent=None, value='leaf_value') # pragma: no cover"",
            ""class MockToken:# pragma: no cover"",
            ""    COMMENT = 'COMMENT'# pragma: no cover"",
            ""    COLON = 'COLON'# pragma: no cover"",
            ""    COMMA = 'COMMA'# pragma: no cover"",
            ""    EQUAL = 'EQUAL'# pragma: no cover"",
            ""    STAR = 'STAR'# pragma: no cover"",
            ""    DOT = 'DOT'# pragma: no cover"",
            ""    LPAR = '('# pragma: no cover"",
            ""    RPAR = ')'# pragma: no cover"",
            ""    LSQB = '['# pragma: no cover"",
            ""    NAME = 'NAME'# pragma: no cover"",
            ""    NUMBER = 'NUMBER'# pragma: no cover"",
            ""    STRING = 'STRING'# pragma: no cover"",
            ""    DOUBLESTAR = '**'# pragma: no cover"",
            ""# pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""class MockSyms:# pragma: no cover"",
            ""    subscript = 'subscript'# pragma: no cover"",
            ""    subscriptlist = 'subscriptlist'# pragma: no cover"",
            ""    sliceop = 'sliceop'# pragma: no cover"",
            ""    arglist = 'arglist'# pragma: no cover"",
            ""    argument = 'argument'# pragma: no cover"",
            ""    parameters = 'parameters'# pragma: no cover"",
            ""    varargslist = 'varargslist'# pragma: no cover"",
            ""    typedargslist = 'typedargslist'# pragma: no cover"",
            ""    star_expr = 'star_expr'# pragma: no cover"",
            ""    factor = 'factor'# pragma: no cover"",
            ""    decorator = 'decorator'# pragma: no cover"",
            ""    trailer = 'trailer'# pragma: no cover"",
            ""    dotted_name = 'dotted_name'# pragma: no cover"",
            ""    classdef = 'classdef'# pragma: no cover"",
            ""    atom = 'atom'# pragma: no cover"",
            ""    dictsetmaker = 'dictsetmaker'# pragma: no cover"",
            ""    except_clause = 'except_clause'# pragma: no cover"",
            ""# pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            ""leaf = MockLeaf(type='mock_type', parent=None, value='example', prev_sibling=None) # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {'mock_type'} # pragma: no cover"",
            ""class MockToken:# pragma: no cover"",
            ""    COMMENT = 'comment'# pragma: no cover"",
            ""    COLON = 'colon'# pragma: no cover"",
            ""    COMMA = 'comma'# pragma: no cover"",
            ""    EQUAL = 'equal'# pragma: no cover"",
            ""    STAR = 'star'# pragma: no cover"",
            ""    DOT = 'dot'# pragma: no cover"",
            ""    LPAR = 'lpar'# pragma: no cover"",
            ""    RPAR = 'rpar'# pragma: no cover"",
            ""    LSQB = 'lsqb'# pragma: no cover"",
            ""    NAME = 'name'# pragma: no cover"",
            ""    NUMBER = 'number'# pragma: no cover"",
            ""    STRING = 'string'# pragma: no cover"",
            ""    DOUBLESTAR = 'double_star'# pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""class MockSyms:# pragma: no cover"",
            ""    subscript = 'subscript'# pragma: no cover"",
            ""    subscriptlist = 'subscriptlist'# pragma: no cover"",
            ""    sliceop = 'sliceop'# pragma: no cover"",
            ""    arglist = 'arglist'# pragma: no cover"",
            ""    argument = 'argument'# pragma: no cover"",
            ""    parameters = 'parameters'# pragma: no cover"",
            ""    varargslist = 'varargslist'# pragma: no cover"",
            ""    typedargslist = 'typedargslist'# pragma: no cover"",
            ""    star_expr = 'star_expr'# pragma: no cover"",
            ""    factor = 'factor'# pragma: no cover"",
            ""    decorator = 'decorator'# pragma: no cover"",
            ""    trailer = 'trailer'# pragma: no cover"",
            ""    dotted_name = 'dotted_name'# pragma: no cover"",
            ""    classdef = 'classdef'# pragma: no cover"",
            ""    atom = 'atom'# pragma: no cover"",
            ""    dictsetmaker = 'dictsetmaker'# pragma: no cover"",
            ""    except_clause = 'except_clause'# pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = {'(', '['} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def parent_type(node): return syms.arglist # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""def is_vararg(node, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'str', 'float'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: type = None; parent = None; value = None; prev_sibling = None# pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""class MockToken: COMMENT = 'comment'; COLON = 'colon'; COMMA = 'comma'; EQUAL = 'equals'; STAR = 'star'; NAME = 'name'; NUMBER = 'number'; STRING = 'string'; DOT = 'dot'; LPAR = '('; RPAR = ')'; LSQB = '['; DOUBLESTAR = '**' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT, token.COLON, token.NAME} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def parent_type(leaf): return syms.factor # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""def is_vararg(prev, within): return False # pragma: no cover"",
            ""VARARGS_PARENTS = set() # pragma: no cover"",
            ""UNPACKING_PARENTS = set() # pragma: no cover"",
            ""MATH_OPERATORS = {'+', '-', '*', '/'} # pragma: no cover"",
            ""TYPED_NAMES = {'int', 'str', 'float'} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    }
]",2,8564,0.004282,4680,0.00702,0.011302
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return whitespace prefix if needed for the given `leaf`.
    `complex_subscript` signals whether the given leaf is part of a subscription
    which has non-trivial arguments, like arithmetic expressions or function calls.
    """"""
NO: Final = """"
SPACE: Final = "" ""
DOUBLESPACE: Final = ""  ""
t = leaf.type
p = leaf.parent
v = leaf.value
if t in ALWAYS_NO_SPACE:
    aux = NO
    exit(aux) # uncovered
if t == token.COMMENT: # uncovered
    aux = DOUBLESPACE # uncovered
    exit(aux) # uncovered
assert p is not None, f""INTERNAL ERROR: hand-made leaf without parent: {leaf!r}""
if t == token.COLON and p.type not in { # uncovered
    syms.subscript, # uncovered
    syms.subscriptlist, # uncovered
    syms.sliceop, # uncovered
}: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
prev = leaf.prev_sibling
if not prev:
    prevp = preceding_leaf(p)
    if not prevp or prevp.type in OPENING_BRACKETS:
        aux = NO
        exit(aux) # uncovered
    if t == token.COLON: # uncovered
        if prevp.type == token.COLON: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type != token.COMMA and not complex_subscript: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        aux = SPACE # uncovered
        exit(aux) # uncovered
    if prevp.type == token.EQUAL: # uncovered
        if prevp.parent: # uncovered
            if prevp.parent.type in { # uncovered
                syms.arglist, # uncovered
                syms.argument, # uncovered
                syms.parameters, # uncovered
                syms.varargslist, # uncovered
            }: # uncovered
                aux = NO # uncovered
                exit(aux) # uncovered
            elif prevp.parent.type == syms.typedargslist: # uncovered
                aux = prevp.prefix # uncovered
                # A bit hacky: if the equal sign has whitespace, it means we
                # previously found it's a typed argument.  So, we're using
                # that, too.
                exit(aux) # uncovered
    elif ( # uncovered
        prevp.type == token.STAR # uncovered
        and parent_type(prevp) == syms.star_expr # uncovered
        and parent_type(prevp.parent) == syms.subscriptlist # uncovered
    ): # uncovered
        aux = NO # uncovered
        # No space between typevar tuples.
        exit(aux) # uncovered
    elif prevp.type in VARARGS_SPECIALS: # uncovered
        if is_vararg(prevp, within=VARARGS_PARENTS | UNPACKING_PARENTS): # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prevp.type == token.COLON: # uncovered
        if prevp.parent and prevp.parent.type in {syms.subscript, syms.sliceop}: # uncovered
            aux = SPACE if complex_subscript else NO # uncovered
            exit(aux) # uncovered
    elif ( # uncovered
        prevp.parent # uncovered
        and prevp.parent.type == syms.factor # uncovered
        and prevp.type in MATH_OPERATORS # uncovered
    ): # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif prevp.type == token.AT and p.parent and p.parent.type == syms.decorator: # uncovered
        aux = NO # uncovered
        # no space in decorators
        exit(aux) # uncovered
elif prev.type in OPENING_BRACKETS: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
if p.type in {syms.parameters, syms.arglist}: # uncovered
    # untyped function signatures or calls
    if not prev or prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.varargslist: # uncovered
    # lambdas
    if prev and prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.typedargslist: # uncovered
    # typed function signatures
    if not prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if t == token.EQUAL: # uncovered
        if prev.type not in TYPED_NAMES: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type == token.EQUAL: # uncovered
        aux = prev.prefix # uncovered
        # A bit hacky: if the equal sign has whitespace, it means we
        # previously found it's a typed argument.  So, we're using that, too.
        exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in TYPED_NAMES: # uncovered
    # type names
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type != token.COMMA: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.trailer: # uncovered
    # attributes and calls
    if t == token.LPAR or t == token.RPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        if t == token.DOT or t == token.LSQB: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.argument: # uncovered
    # single argument
    if t == token.EQUAL: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type == token.LPAR: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type in {token.EQUAL} | VARARGS_SPECIALS: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.decorator: # uncovered
    aux = NO # uncovered
    # decorators
    exit(aux) # uncovered
elif p.type == syms.dotted_name: # uncovered
    if prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    prevp = preceding_leaf(p) # uncovered
    if not prevp or prevp.type == token.AT or prevp.type == token.DOT: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.classdef: # uncovered
    if t == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if prev and prev.type == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.subscript, syms.sliceop}: # uncovered
    # indexing
    if not prev: # uncovered
        assert p.parent is not None, ""subscripts are always parented"" # uncovered
        if p.parent.type == syms.subscriptlist: # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif not complex_subscript: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.atom: # uncovered
    if prev and t == token.DOT: # uncovered
        aux = NO # uncovered
        # dots, but not the first one.
        exit(aux) # uncovered
elif p.type == syms.dictsetmaker: # uncovered
    # dict unpacking
    if prev and prev.type == token.DOUBLESTAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.factor, syms.star_expr}: # uncovered
    # unary ops
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type in OPENING_BRACKETS: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        prevp_parent = prevp.parent # uncovered
        assert prevp_parent is not None # uncovered
        if prevp.type == token.COLON and prevp_parent.type in { # uncovered
            syms.subscript, # uncovered
            syms.sliceop, # uncovered
        }: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t in {token.NAME, token.NUMBER, token.STRING}: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.import_from: # uncovered
    if t == token.DOT: # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t == token.NAME: # uncovered
        if v == ""import"": # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.sliceop: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
elif p.type == syms.except_clause: # uncovered
    if t == token.STAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
aux = SPACE # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:  # Mocking the leaf class\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n\n    def __repr__(self):\n        return f'MockLeaf(type={self.type}, value={self.value})'\n\nALWAYS_NO_SPACE = {token.NAME}\nOPENING_BRACKETS = {token.LPAR, token.LSQB}\nVARARGS_SPECIALS = {token.STAR}\nTYPED_NAMES = {token.NAME}\n\nclass MockParent:  # Mocking the parent class\n    def __init__(self, type, parent=None):\n        self.type = type\n        self.parent = parent\n\nleaf = MockLeaf(type=token.COMMENT, parent=MockParent(type=syms.functiondef), value='some comment')\n"",
            ""def preceding_leaf(parent):\n    return None  # No preceding leaf for simplicity\n"",
            ""def parent_type(leaf):\n    return leaf.parent.type if leaf.parent else None  # Return parent's type\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:"",
            ""    def __init__(self, type, parent, value, prev_sibling):"",
            ""        self.type = type"",
            ""        self.parent = parent"",
            ""        self.value = value"",
            ""        self.prev_sibling = prev_sibling"",
            """",
            ""leaf = MockLeaf(token.COMMENT, None, 'Some comment', None)"",
            """",
            ""ALWAYS_NO_SPACE = {token.NAME}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""preceding_leaf = lambda p: None"",
            ""parent_type = lambda x: None""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class Mock: pass"",
            ""leaf = Mock()"",
            ""leaf.type = token.COMMENT"",
            ""leaf.parent = Mock()"",
            ""leaf.parent.type = syms.decorators"",
            ""leaf.value = 'test'"",
            ""leaf.prev_sibling = None"",
            ""def preceding_leaf(mock): return None"",
            ""def parent_type(mock): return syms.decorator"",
            ""VARARGS_SPECIALS = set()"",
            ""OPENING_BRACKETS = set()"",
            ""ALWAYS_NO_SPACE = set()"",
            ""TYPED_NAMES = set()"",
            ""complex_subscript = False""
        ]
    },
    {
        ""imports"": [
            ""import token"",
            ""from typing import Final"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf(type('Mock', (), {})):\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling"",
            ""class MockParent(type('Mock', (), {})):\n    def __init__(self, type):\n        self.type = type"",
            ""leaf = MockLeaf(token.COMMENT, MockParent(syms.arglist), 'some_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""def preceding_leaf(parent): return None"",
            ""def is_vararg(prevp, within): return False"",
            ""def parent_type(leaf): return syms.arglist""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf: # Mock class for leaf\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None\n\n    def set_prev_sibling(self, sibling):\n        self.prev_sibling = sibling\n\n# Initialize token and syms equivalent mockups\ntoken.COMMENT = 1\ntoken.COLON = 2\nclass MockSyms:\n    def __init__(self):\n        self.subscript = 3\n        self.subscriptlist = 4\n        self.sliceop = 5\n        self.parameters = 6\n        self.arglist = 7\n        self.varargslist = 8\n        self.typedargslist = 9\n        self.trailer = 10\n        self.argument = 11\n        self.decorator = 12\n        self.dotted_name = 13\n        self.classdef = 14\n        self.factor = 15\n        self.star_expr = 16\n        self.import_from = 17\n        self.sliceop = 18\n        self.except_clause = 19\n        self.dictsetmaker = 20\n\nsyms = MockSyms()\n\n# Initialize variables for testing\nleaf = MockLeaf(type=token.COMMENT, parent=None, value='leaf_value')\nALWAYS_NO_SPACE = {1}\nOPENING_BRACKETS = set()\nVARARGS_SPECIALS = set()\nMATH_OPERATORS = set()\nTYPED_NAMES = set()\ncomplex_subscript = False\n\n# Set a parent for leaf to trigger the relevant paths\nleaf.parent = type('Parent', (object,), {'type': syms.parameters, 'prev_sibling': None})()""
        ]
    },
    {
        ""imports"": [
            ""import token"",
            ""from typing import Final"",
            ""class Mock: pass"",
            ""class Leaf(Mock): pass"",
            ""class Parent(Mock): pass"",
            ""class Sibling(Mock): pass"",
            ""class Node(Mock): pass""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {token.NAME, token.NUMBER}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""syms = type('syms', (), {})()"",
            ""syms.subscript = 1"",
            ""syms.subscriptlist = 2"",
            ""syms.sliceop = 3"",
            ""syms.parameters = 4"",
            ""syms.arglist = 5"",
            ""syms.varargslist = 6"",
            ""syms.typedargslist = 7"",
            ""syms.trailer = 8"",
            ""syms.argument = 9"",
            ""syms.decorator = 10"",
            ""syms.dotted_name = 11"",
            ""syms.classdef = 12"",
            ""syms.factor = 13"",
            ""syms.star_expr = 14"",
            ""syms.import_from = 15"",
            ""syms.sliceop = 16"",
            ""syms.except_clause = 17"",
            ""def preceding_leaf(p): return Leaf()"",
            ""def parent_type(p): return syms.factor"",
            ""leaf = Leaf()"",
            ""leaf.type = token.COMMENT"",
            ""leaf.parent = Parent()"",
            ""leaf.parent.type = syms.arguments"",
            ""leaf.value = 'test'"",
            ""leaf.prev_sibling = Sibling()"",
            ""leaf.prev_sibling.type = token.NAME""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf: pass"",
            ""leaf = MockLeaf()"",
            ""leaf.type = token.COMMENT"",
            ""leaf.parent = None"",
            ""leaf.value = ''"",
            ""class MockParent: pass"",
            ""leaf.parent = MockParent()"",
            ""leaf.prev_sibling = None"",
            ""def preceding_leaf(p): return None"",
            ""OPENING_BRACKETS = set()"",
            ""ALWAYS_NO_SPACE = {token.COMMENT}"",
            ""VARARGS_SPECIALS = set()"",
            ""TYPED_NAMES = set()"",
            ""MATH_OPERATORS = set()"",
            ""def parent_type(node): return None"",
            ""syms = Mock()"",
            ""syms.subscript = 'subscript'"",
            ""syms.subscriptlist = 'subscriptlist'"",
            ""syms.sliceop = 'sliceop'"",
            ""syms.parameters = 'parameters'"",
            ""syms.arglist = 'arglist'"",
            ""syms.varargslist = 'varargslist'"",
            ""syms.typedargslist = 'typedargslist'"",
            ""syms.trailer = 'trailer'"",
            ""syms.argument = 'argument'"",
            ""syms.decorator = 'decorator'"",
            ""syms.dotted_name = 'dotted_name'"",
            ""syms.classdef = 'classdef'"",
            ""syms.atom = 'atom'"",
            ""syms.dictsetmaker = 'dictsetmaker'"",
            ""syms.import_from = 'import_from'"",
            ""syms.sliceop = 'sliceop'"",
            ""syms.except_clause = 'except_clause'""
        ]
    },
    {
        ""imports"": [
            ""import token"",
            ""from collections import namedtuple"",
            ""import sys""
        ],
        ""initialization"": [
            ""syms = type('Mock', (object,), {'subscript': 'subscript', 'subscriptlist': 'subscriptlist', 'sliceop': 'sliceop', 'parameters': 'parameters', 'arglist': 'arglist', 'typedargslist': 'typedargslist', 'varargslist': 'varargslist', 'decorator': 'decorator', 'dotted_name': 'dotted_name', 'classdef': 'classdef', 'factor': 'factor', 'star_expr': 'star_expr', 'trailer': 'trailer', 'argument': 'argument', 'dictsetmaker': 'dictsetmaker'})()"",
            ""OPENING_BRACKETS = set()"",
            ""VARARGS_SPECIALS = set()"",
            ""token.COLON = 'COLON'"",
            ""token.COMMENT = 'COMMENT'"",
            ""token.EQUAL = 'EQUAL'"",
            ""token.STAR = 'STAR'"",
            ""token.DOT = 'DOT'"",
            ""token.NUMBER = 'NUMBER'"",
            ""token.STRING = 'STRING'"",
            ""token.NAME = 'NAME'"",
            ""token.LPAR = 'LPAR'"",
            ""token.RPAR = 'RPAR'"",
            ""token.LSQB = 'LSQB'"",
            ""token.RSQB = 'RSQB'"",
            ""token.DOUBLESTAR = 'DOUBLESTAR'"",
            ""token.AT = 'AT'"",
            ""MATH_OPERATORS = set()"",
            ""TYPED_NAMES = set()"",
            ""leaf = type('MockLeaf', (object,), {'type': token.COMMENT, 'parent': None, 'value': 'mock_value', 'prev_sibling': None})()"",
            ""preceding_leaf = lambda p: None"",
            ""complex_subscript = False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:  # Mocking the leaf object\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COMMENT, parent=MockParent(type=syms.argument), value='example')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def parent_type(leaf):  # Mocking the parent_type function\n    return syms.argument\n"",
            ""def preceding_leaf(parent):  # Mocking the preceding_leaf function\n    return MockLeaf(type=token.COMMA, parent=parent, value='prev')\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class Leaf: pass"",
            ""leaf = Leaf()"",
            ""leaf.type = token.COMMENT"",
            ""leaf.parent = type('Parent', (), {'type': syms.decorator})()"",
            ""leaf.value = 'some comment'"",
            ""leaf.prev_sibling = None"",
            ""def preceding_leaf(parent): return None"",
            ""ALWAYS_NO_SPACE = set()"",
            ""OPENING_BRACKETS = set()"",
            ""VARARGS_SPECIALS = set()"",
            ""TYPED_NAMES = set()"",
            ""MATH_OPERATORS = set()"",
            ""complex_subscript = False""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:  # Mocking the leaf class# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def __repr__(self):# pragma: no cover"",
            ""        return f'MockLeaf(type={self.type}, value={self.value})'# pragma: no cover"",
            ""# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}# pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            ""# pragma: no cover"",
            ""class MockParent:  # Mocking the parent class# pragma: no cover"",
            ""    def __init__(self, type, parent=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(parent):# pragma: no cover"",
            ""    return None  # No preceding leaf for simplicity# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf):# pragma: no cover"",
            ""    return leaf.parent.type if leaf.parent else None  # Return parent's type# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.parent = parent # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            "" # pragma: no cover"",
            ""leaf = MockLeaf(token.COMMENT, None, 'Some comment', None) # pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB, token.LBRACE} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""preceding_leaf = lambda p: None # pragma: no cover"",
            ""parent_type = lambda x: None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Mock: pass # pragma: no cover"",
            ""leaf = Mock() # pragma: no cover"",
            ""leaf.type = token.COMMENT # pragma: no cover"",
            ""leaf.parent = Mock() # pragma: no cover"",
            ""leaf.value = 'test' # pragma: no cover"",
            ""leaf.prev_sibling = None # pragma: no cover"",
            ""def preceding_leaf(mock): return None # pragma: no cover"",
            ""def parent_type(mock): return syms.decorator # pragma: no cover"",
            ""VARARGS_SPECIALS = set() # pragma: no cover"",
            ""OPENING_BRACKETS = set() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""TYPED_NAMES = set() # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import token # pragma: no cover"",
            ""from typing import Final # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf(type('Mock', (), {})):# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling # pragma: no cover"",
            ""class MockParent(type('Mock', (), {})):# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""def preceding_leaf(parent): return None # pragma: no cover"",
            ""def is_vararg(prevp, within): return False # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: # Mock class for leaf# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def set_prev_sibling(self, sibling):# pragma: no cover"",
            ""        self.prev_sibling = sibling# pragma: no cover"",
            ""# pragma: no cover"",
            ""# Initialize token and syms equivalent mockups# pragma: no cover"",
            ""token.COMMENT = 1# pragma: no cover"",
            ""token.COLON = 2# pragma: no cover"",
            ""class MockSyms:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.subscript = 3# pragma: no cover"",
            ""        self.subscriptlist = 4# pragma: no cover"",
            ""        self.sliceop = 5# pragma: no cover"",
            ""        self.parameters = 6# pragma: no cover"",
            ""        self.arglist = 7# pragma: no cover"",
            ""        self.varargslist = 8# pragma: no cover"",
            ""        self.typedargslist = 9# pragma: no cover"",
            ""        self.trailer = 10# pragma: no cover"",
            ""        self.argument = 11# pragma: no cover"",
            ""        self.decorator = 12# pragma: no cover"",
            ""        self.dotted_name = 13# pragma: no cover"",
            ""        self.classdef = 14# pragma: no cover"",
            ""        self.factor = 15# pragma: no cover"",
            ""        self.star_expr = 16# pragma: no cover"",
            ""        self.sliceop = 18# pragma: no cover"",
            ""        self.except_clause = 19# pragma: no cover"",
            ""        self.dictsetmaker = 20# pragma: no cover"",
            ""# pragma: no cover"",
            ""syms = MockSyms()# pragma: no cover"",
            ""# pragma: no cover"",
            ""# Initialize variables for testing# pragma: no cover"",
            ""leaf = MockLeaf(type=token.COMMENT, parent=None, value='leaf_value')# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {1}# pragma: no cover"",
            ""OPENING_BRACKETS = set()# pragma: no cover"",
            ""VARARGS_SPECIALS = set()# pragma: no cover"",
            ""MATH_OPERATORS = set()# pragma: no cover"",
            ""TYPED_NAMES = set()# pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            ""# pragma: no cover"",
            ""# Set a parent for leaf to trigger the relevant paths# pragma: no cover"",
            ""leaf.parent = type('Parent', (object,), {'type': syms.parameters, 'prev_sibling': None})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import token # pragma: no cover"",
            ""from typing import Final # pragma: no cover"",
            ""class Mock: pass # pragma: no cover"",
            ""class Leaf(Mock): pass # pragma: no cover"",
            ""class Parent(Mock): pass # pragma: no cover"",
            ""class Sibling(Mock): pass # pragma: no cover"",
            ""class Node(Mock): pass # pragma: no cover""
        ],
        ""initialization"": [
            ""ALWAYS_NO_SPACE = {token.NAME, token.NUMBER} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR, token.DOUBLESTAR} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""syms = type('syms', (), {})() # pragma: no cover"",
            ""syms.subscript = 1 # pragma: no cover"",
            ""syms.subscriptlist = 2 # pragma: no cover"",
            ""syms.sliceop = 3 # pragma: no cover"",
            ""syms.parameters = 4 # pragma: no cover"",
            ""syms.arglist = 5 # pragma: no cover"",
            ""syms.varargslist = 6 # pragma: no cover"",
            ""syms.typedargslist = 7 # pragma: no cover"",
            ""syms.trailer = 8 # pragma: no cover"",
            ""syms.argument = 9 # pragma: no cover"",
            ""syms.decorator = 10 # pragma: no cover"",
            ""syms.dotted_name = 11 # pragma: no cover"",
            ""syms.classdef = 12 # pragma: no cover"",
            ""syms.factor = 13 # pragma: no cover"",
            ""syms.star_expr = 14 # pragma: no cover"",
            ""syms.sliceop = 16 # pragma: no cover"",
            ""syms.except_clause = 17 # pragma: no cover"",
            ""def preceding_leaf(p): return Leaf() # pragma: no cover"",
            ""def parent_type(p): return syms.factor # pragma: no cover"",
            ""leaf = Leaf() # pragma: no cover"",
            ""leaf.type = token.COMMENT # pragma: no cover"",
            ""leaf.parent = Parent() # pragma: no cover"",
            ""leaf.value = 'test' # pragma: no cover"",
            ""leaf.prev_sibling = Sibling() # pragma: no cover"",
            ""leaf.prev_sibling.type = token.NAME # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf: pass # pragma: no cover"",
            ""leaf = MockLeaf() # pragma: no cover"",
            ""leaf.type = token.COMMENT # pragma: no cover"",
            ""leaf.parent = None # pragma: no cover"",
            ""leaf.value = '' # pragma: no cover"",
            ""class MockParent: pass # pragma: no cover"",
            ""leaf.parent = MockParent() # pragma: no cover"",
            ""leaf.prev_sibling = None # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""OPENING_BRACKETS = set() # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT} # pragma: no cover"",
            ""VARARGS_SPECIALS = set() # pragma: no cover"",
            ""TYPED_NAMES = set() # pragma: no cover"",
            ""MATH_OPERATORS = set() # pragma: no cover"",
            ""def parent_type(node): return None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import token # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""syms = type('Mock', (object,), {'subscript': 'subscript', 'subscriptlist': 'subscriptlist', 'sliceop': 'sliceop', 'parameters': 'parameters', 'arglist': 'arglist', 'typedargslist': 'typedargslist', 'varargslist': 'varargslist', 'decorator': 'decorator', 'dotted_name': 'dotted_name', 'classdef': 'classdef', 'factor': 'factor', 'star_expr': 'star_expr', 'trailer': 'trailer', 'argument': 'argument', 'dictsetmaker': 'dictsetmaker'})() # pragma: no cover"",
            ""OPENING_BRACKETS = set() # pragma: no cover"",
            ""VARARGS_SPECIALS = set() # pragma: no cover"",
            ""token.COLON = 'COLON' # pragma: no cover"",
            ""token.COMMENT = 'COMMENT' # pragma: no cover"",
            ""token.EQUAL = 'EQUAL' # pragma: no cover"",
            ""token.STAR = 'STAR' # pragma: no cover"",
            ""token.DOT = 'DOT' # pragma: no cover"",
            ""token.NUMBER = 'NUMBER' # pragma: no cover"",
            ""token.STRING = 'STRING' # pragma: no cover"",
            ""token.NAME = 'NAME' # pragma: no cover"",
            ""token.LPAR = 'LPAR' # pragma: no cover"",
            ""token.RPAR = 'RPAR' # pragma: no cover"",
            ""token.LSQB = 'LSQB' # pragma: no cover"",
            ""token.RSQB = 'RSQB' # pragma: no cover"",
            ""token.DOUBLESTAR = 'DOUBLESTAR' # pragma: no cover"",
            ""token.AT = 'AT' # pragma: no cover"",
            ""MATH_OPERATORS = set() # pragma: no cover"",
            ""TYPED_NAMES = set() # pragma: no cover"",
            ""leaf = type('MockLeaf', (object,), {'type': token.COMMENT, 'parent': None, 'value': 'mock_value', 'prev_sibling': None})() # pragma: no cover"",
            ""preceding_leaf = lambda p: None # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:  # Mocking the leaf object# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf):  # Mocking the parent_type function# pragma: no cover"",
            ""    return syms.argument# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(parent):  # Mocking the preceding_leaf function# pragma: no cover"",
            ""    return MockLeaf(type=token.COMMA, parent=parent, value='prev')# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf: pass # pragma: no cover"",
            ""leaf = Leaf() # pragma: no cover"",
            ""leaf.type = token.COMMENT # pragma: no cover"",
            ""leaf.value = 'some comment' # pragma: no cover"",
            ""leaf.prev_sibling = None # pragma: no cover"",
            ""def preceding_leaf(parent): return None # pragma: no cover"",
            ""ALWAYS_NO_SPACE = set() # pragma: no cover"",
            ""OPENING_BRACKETS = set() # pragma: no cover"",
            ""VARARGS_SPECIALS = set() # pragma: no cover"",
            ""TYPED_NAMES = set() # pragma: no cover"",
            ""MATH_OPERATORS = set() # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover""
        ]
    }
]",3,2489,0.0012445,3009,0.0045135,0.005758
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return whitespace prefix if needed for the given `leaf`.
    `complex_subscript` signals whether the given leaf is part of a subscription
    which has non-trivial arguments, like arithmetic expressions or function calls.
    """"""
NO: Final = """"
SPACE: Final = "" ""
DOUBLESPACE: Final = ""  ""
t = leaf.type
p = leaf.parent
v = leaf.value
if t in ALWAYS_NO_SPACE:
    aux = NO
    exit(aux) # uncovered
if t == token.COMMENT:
    aux = DOUBLESPACE
    exit(aux) # uncovered
assert p is not None, f""INTERNAL ERROR: hand-made leaf without parent: {leaf!r}""
if t == token.COLON and p.type not in { # uncovered
    syms.subscript, # uncovered
    syms.subscriptlist, # uncovered
    syms.sliceop, # uncovered
}: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
prev = leaf.prev_sibling
if not prev:
    prevp = preceding_leaf(p)
    if not prevp or prevp.type in OPENING_BRACKETS:
        aux = NO
        exit(aux) # uncovered
    if t == token.COLON: # uncovered
        if prevp.type == token.COLON: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type != token.COMMA and not complex_subscript: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        aux = SPACE # uncovered
        exit(aux) # uncovered
    if prevp.type == token.EQUAL: # uncovered
        if prevp.parent: # uncovered
            if prevp.parent.type in { # uncovered
                syms.arglist, # uncovered
                syms.argument, # uncovered
                syms.parameters, # uncovered
                syms.varargslist, # uncovered
            }: # uncovered
                aux = NO # uncovered
                exit(aux) # uncovered
            elif prevp.parent.type == syms.typedargslist: # uncovered
                aux = prevp.prefix # uncovered
                # A bit hacky: if the equal sign has whitespace, it means we
                # previously found it's a typed argument.  So, we're using
                # that, too.
                exit(aux) # uncovered
    elif ( # uncovered
        prevp.type == token.STAR # uncovered
        and parent_type(prevp) == syms.star_expr # uncovered
        and parent_type(prevp.parent) == syms.subscriptlist # uncovered
    ): # uncovered
        aux = NO # uncovered
        # No space between typevar tuples.
        exit(aux) # uncovered
    elif prevp.type in VARARGS_SPECIALS: # uncovered
        if is_vararg(prevp, within=VARARGS_PARENTS | UNPACKING_PARENTS): # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prevp.type == token.COLON: # uncovered
        if prevp.parent and prevp.parent.type in {syms.subscript, syms.sliceop}: # uncovered
            aux = SPACE if complex_subscript else NO # uncovered
            exit(aux) # uncovered
    elif ( # uncovered
        prevp.parent # uncovered
        and prevp.parent.type == syms.factor # uncovered
        and prevp.type in MATH_OPERATORS # uncovered
    ): # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif prevp.type == token.AT and p.parent and p.parent.type == syms.decorator: # uncovered
        aux = NO # uncovered
        # no space in decorators
        exit(aux) # uncovered
elif prev.type in OPENING_BRACKETS: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
if p.type in {syms.parameters, syms.arglist}: # uncovered
    # untyped function signatures or calls
    if not prev or prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.varargslist: # uncovered
    # lambdas
    if prev and prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.typedargslist: # uncovered
    # typed function signatures
    if not prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if t == token.EQUAL: # uncovered
        if prev.type not in TYPED_NAMES: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type == token.EQUAL: # uncovered
        aux = prev.prefix # uncovered
        # A bit hacky: if the equal sign has whitespace, it means we
        # previously found it's a typed argument.  So, we're using that, too.
        exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in TYPED_NAMES: # uncovered
    # type names
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type != token.COMMA: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.trailer: # uncovered
    # attributes and calls
    if t == token.LPAR or t == token.RPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        if t == token.DOT or t == token.LSQB: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.argument: # uncovered
    # single argument
    if t == token.EQUAL: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type == token.LPAR: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type in {token.EQUAL} | VARARGS_SPECIALS: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.decorator: # uncovered
    aux = NO # uncovered
    # decorators
    exit(aux) # uncovered
elif p.type == syms.dotted_name: # uncovered
    if prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    prevp = preceding_leaf(p) # uncovered
    if not prevp or prevp.type == token.AT or prevp.type == token.DOT: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.classdef: # uncovered
    if t == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if prev and prev.type == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.subscript, syms.sliceop}: # uncovered
    # indexing
    if not prev: # uncovered
        assert p.parent is not None, ""subscripts are always parented"" # uncovered
        if p.parent.type == syms.subscriptlist: # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif not complex_subscript: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.atom: # uncovered
    if prev and t == token.DOT: # uncovered
        aux = NO # uncovered
        # dots, but not the first one.
        exit(aux) # uncovered
elif p.type == syms.dictsetmaker: # uncovered
    # dict unpacking
    if prev and prev.type == token.DOUBLESTAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.factor, syms.star_expr}: # uncovered
    # unary ops
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type in OPENING_BRACKETS: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        prevp_parent = prevp.parent # uncovered
        assert prevp_parent is not None # uncovered
        if prevp.type == token.COLON and prevp_parent.type in { # uncovered
            syms.subscript, # uncovered
            syms.sliceop, # uncovered
        }: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t in {token.NAME, token.NUMBER, token.STRING}: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.import_from: # uncovered
    if t == token.DOT: # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t == token.NAME: # uncovered
        if v == ""import"": # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.sliceop: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
elif p.type == syms.except_clause: # uncovered
    if t == token.STAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
aux = SPACE # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='leaf_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = set()\n"",
            ""VARARGS_SPECIALS = set()\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(token.COMMA, MockParent(syms.typedargslist), 'prev')"",
            ""def parent_type(p): return syms.arglist""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:  # Mocking the leaf class\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None"",
            ""class MockParent:  # Mocking the parent class\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='some_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.NUMBER}\n"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""def preceding_leaf(parent):  # Mock the function\n    return MockLeaf(type=token.COMMA, parent=parent, value='previous')"",
            ""def parent_type(leaf):  # Mock the function\n    return syms.arglist""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""leaf.prev_sibling = None"",
            ""ALWAYS_NO_SPACE = {token.NAME}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""VARARGS_SPECIALS = {token.STAR}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""def preceding_leaf(parent): return None"",
            ""def parent_type(mock): return None""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent):\n        self.type = type\n        self.parent = parent\n        self.prev_sibling = None\n        self.value = 'test_value'\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist))"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""complex_subscript = False\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.subscript = 1\n"",
            ""syms.subscriptlist = 2\n"",
            ""syms.sliceop = 3\n"",
            ""syms.parameters = 4\n"",
            ""syms.arglist = 5\n"",
            ""syms.varargslist = 6\n"",
            ""syms.typedargslist = 7\n"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None)\n"",
            ""def parent_type(leaf): return syms.arglist""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='test')"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.NUMBER}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""VARARGS_SPECIALS = {token.STAR}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""def preceding_leaf(parent): return None"",
            ""def parent_type(leaf): return syms.arglist""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:  # Mock class for leaf\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:  # Mock class for parent\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(syms.arglist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""VARARGS_SPECIALS = {token.STAR}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(parent): return None"",
            ""def parent_type(leaf): return None""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:  # Mock class representing a leaf node\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None"",
            ""class MockParent:  # Mock class representing a parent node\n    def __init__(self, type):\n        self.type = type"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='example')"",
            ""ALWAYS_NO_SPACE = {token.NAME}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""VARARGS_SPECIALS = {token.STAR}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(parent): return None"",
            ""def parent_type(leaf): return syms.arglist""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n\nclass MockParent:\n    def __init__(self, type):\n        self.type = type\n\nleaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.argument), value='')"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.DOT}"",
            ""OPENING_BRACKETS = set()"",
            ""VARARGS_SPECIALS = {token.STAR}"",
            ""TYPED_NAMES = set()"",
            ""complex_subscript = False"",
            ""def preceding_leaf(parent): return None"",
            ""def parent_type(leaf): return syms.arglist""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:  # Mocking the leaf class\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None\n"",
            ""class MockParent:  # Mocking the parent of the leaf\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='example')"",
            ""ALWAYS_NO_SPACE = {token.NAME}"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}"",
            ""VARARGS_SPECIALS = {token.STAR}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS}"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=MockParent(type=syms.parameters), value='prev')"",
            ""def parent_type(leaf): return syms.arglist""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:  # Mock class for leaf\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None\n"",
            ""class MockParent:  # Mock class for parent\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='leaf_value')\n"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='prev_leaf')\n"",
            ""def parent_type(leaf): return syms.arglist\n""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = set()# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = set()# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(token.COMMA, MockParent(syms.typedargslist), 'prev') # pragma: no cover"",
            ""def parent_type(p): return syms.arglist # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:  # Mocking the leaf class# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None # pragma: no cover"",
            ""class MockParent:  # Mocking the parent class# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.NUMBER}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(parent):  # Mock the function# pragma: no cover"",
            ""    return MockLeaf(type=token.COMMA, parent=parent, value='previous') # pragma: no cover"",
            ""def parent_type(leaf):  # Mock the function# pragma: no cover"",
            ""    return syms.arglist # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""def preceding_leaf(parent): return None # pragma: no cover"",
            ""def parent_type(mock): return None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            ""        self.value = 'test_value'# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.varargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None)# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.NUMBER} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""def preceding_leaf(parent): return None # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:  # Mock class for leaf# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:  # Mock class for parent# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(parent): return None # pragma: no cover"",
            ""def parent_type(leaf): return None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:  # Mock class representing a leaf node# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None # pragma: no cover"",
            ""class MockParent:  # Mock class representing a parent node# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(parent): return None # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            ""# pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.DOT} # pragma: no cover"",
            ""OPENING_BRACKETS = set() # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR} # pragma: no cover"",
            ""TYPED_NAMES = set() # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(parent): return None # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:  # Mocking the leaf class# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:  # Mocking the parent of the leaf# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS} # pragma: no cover"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=MockParent(type=syms.parameters), value='prev') # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:  # Mock class for leaf# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:  # Mock class for parent# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            "" # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='prev_leaf')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover""
        ]
    }
]",3,7959,0.0039795,2540,0.00381,0.0077895
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return whitespace prefix if needed for the given `leaf`.
    `complex_subscript` signals whether the given leaf is part of a subscription
    which has non-trivial arguments, like arithmetic expressions or function calls.
    """"""
NO: Final = """"
SPACE: Final = "" ""
DOUBLESPACE: Final = ""  ""
t = leaf.type
p = leaf.parent
v = leaf.value
if t in ALWAYS_NO_SPACE:
    aux = NO
    exit(aux) # uncovered
if t == token.COMMENT:
    aux = DOUBLESPACE
    exit(aux) # uncovered
assert p is not None, f""INTERNAL ERROR: hand-made leaf without parent: {leaf!r}""
if t == token.COLON and p.type not in { # uncovered
    syms.subscript, # uncovered
    syms.subscriptlist, # uncovered
    syms.sliceop, # uncovered
}: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
prev = leaf.prev_sibling
if not prev:
    prevp = preceding_leaf(p)
    if not prevp or prevp.type in OPENING_BRACKETS:
        aux = NO
        exit(aux) # uncovered
    if t == token.COLON: # uncovered
        if prevp.type == token.COLON: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type != token.COMMA and not complex_subscript: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        aux = SPACE # uncovered
        exit(aux) # uncovered
    if prevp.type == token.EQUAL: # uncovered
        if prevp.parent: # uncovered
            if prevp.parent.type in { # uncovered
                syms.arglist, # uncovered
                syms.argument, # uncovered
                syms.parameters, # uncovered
                syms.varargslist, # uncovered
            }: # uncovered
                aux = NO # uncovered
                exit(aux) # uncovered
            elif prevp.parent.type == syms.typedargslist: # uncovered
                aux = prevp.prefix # uncovered
                # A bit hacky: if the equal sign has whitespace, it means we
                # previously found it's a typed argument.  So, we're using
                # that, too.
                exit(aux) # uncovered
    elif ( # uncovered
        prevp.type == token.STAR # uncovered
        and parent_type(prevp) == syms.star_expr # uncovered
        and parent_type(prevp.parent) == syms.subscriptlist # uncovered
    ): # uncovered
        aux = NO # uncovered
        # No space between typevar tuples.
        exit(aux) # uncovered
    elif prevp.type in VARARGS_SPECIALS: # uncovered
        if is_vararg(prevp, within=VARARGS_PARENTS | UNPACKING_PARENTS): # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prevp.type == token.COLON: # uncovered
        if prevp.parent and prevp.parent.type in {syms.subscript, syms.sliceop}: # uncovered
            aux = SPACE if complex_subscript else NO # uncovered
            exit(aux) # uncovered
    elif ( # uncovered
        prevp.parent # uncovered
        and prevp.parent.type == syms.factor # uncovered
        and prevp.type in MATH_OPERATORS # uncovered
    ): # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif prevp.type == token.AT and p.parent and p.parent.type == syms.decorator: # uncovered
        aux = NO # uncovered
        # no space in decorators
        exit(aux) # uncovered
elif prev.type in OPENING_BRACKETS: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
if p.type in {syms.parameters, syms.arglist}: # uncovered
    # untyped function signatures or calls
    if not prev or prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.varargslist: # uncovered
    # lambdas
    if prev and prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.typedargslist: # uncovered
    # typed function signatures
    if not prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if t == token.EQUAL: # uncovered
        if prev.type not in TYPED_NAMES: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type == token.EQUAL: # uncovered
        aux = prev.prefix # uncovered
        # A bit hacky: if the equal sign has whitespace, it means we
        # previously found it's a typed argument.  So, we're using that, too.
        exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in TYPED_NAMES: # uncovered
    # type names
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type != token.COMMA: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.trailer: # uncovered
    # attributes and calls
    if t == token.LPAR or t == token.RPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        if t == token.DOT or t == token.LSQB: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.argument: # uncovered
    # single argument
    if t == token.EQUAL: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type == token.LPAR: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type in {token.EQUAL} | VARARGS_SPECIALS: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.decorator: # uncovered
    aux = NO # uncovered
    # decorators
    exit(aux) # uncovered
elif p.type == syms.dotted_name: # uncovered
    if prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    prevp = preceding_leaf(p) # uncovered
    if not prevp or prevp.type == token.AT or prevp.type == token.DOT: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.classdef: # uncovered
    if t == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if prev and prev.type == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.subscript, syms.sliceop}: # uncovered
    # indexing
    if not prev: # uncovered
        assert p.parent is not None, ""subscripts are always parented"" # uncovered
        if p.parent.type == syms.subscriptlist: # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif not complex_subscript: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.atom: # uncovered
    if prev and t == token.DOT: # uncovered
        aux = NO # uncovered
        # dots, but not the first one.
        exit(aux) # uncovered
elif p.type == syms.dictsetmaker: # uncovered
    # dict unpacking
    if prev and prev.type == token.DOUBLESTAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.factor, syms.star_expr}: # uncovered
    # unary ops
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type in OPENING_BRACKETS: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        prevp_parent = prevp.parent # uncovered
        assert prevp_parent is not None # uncovered
        if prevp.type == token.COLON and prevp_parent.type in { # uncovered
            syms.subscript, # uncovered
            syms.sliceop, # uncovered
        }: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t in {token.NAME, token.NUMBER, token.STRING}: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.import_from: # uncovered
    if t == token.DOT: # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t == token.NAME: # uncovered
        if v == ""import"": # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.sliceop: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
elif p.type == syms.except_clause: # uncovered
    if t == token.STAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
aux = SPACE # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='example')"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.NUMBER}\n"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=MockParent(type=syms.arguments), value='prev')\n"",
            ""def parent_type(p): return syms.arglist""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COMMA}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=parent, value='prev')"",
            ""def parent_type(leaf): return syms.arglist""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.subscript), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.NUMBER}\n"",
            ""OPENING_BRACKETS = set()\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=MockParent(type=syms.arglist), value='previous')"",
            ""def parent_type(p): return syms.arglist""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='test')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='prev')\n"",
            ""def parent_type(leaf): return syms.arglist\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='leaf_value')"",
            ""ALWAYS_NO_SPACE = {}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""syms = type('syms', (), {})()  # Creating a mock for syms\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=parent, value='prev_leaf')\n"",
            ""def parent_type(leaf): return syms.arglist""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COMMA}\n"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.subscript = 1\n"",
            ""syms.subscriptlist = 2\n"",
            ""syms.sliceop = 3\n"",
            ""syms.parameters = 4\n"",
            ""syms.arglist = 5\n"",
            ""syms.varargslist = 6\n"",
            ""syms.typedargslist = 7\n"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=MockParent(type=syms.parameters), value='previous')"",
            ""def parent_type(leaf): return syms.arglist""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='')"",
            ""ALWAYS_NO_SPACE = {token.NAME}"",
            ""OPENING_BRACKETS = {token.LPAR}"",
            ""VARARGS_SPECIALS = {token.STAR}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='prev')"",
            ""def parent_type(leaf): return syms.arglist""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.NUMBER}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return None"",
            ""def parent_type(leaf): return syms.arglist""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.subscript), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.NUMBER}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COLON, parent=None, value='prev')\n"",
            ""def parent_type(leaf): return syms.arglist\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:  # Mock class for leaf\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:  # Mock class for parent\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(parent): return None\n"",
            ""def parent_type(leaf): return syms.arglist\n""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.NUMBER}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=MockParent(type=syms.arguments), value='prev')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.arglist # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COMMA}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=parent, value='prev') # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.NUMBER}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = set()# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=MockParent(type=syms.arglist), value='previous') # pragma: no cover"",
            ""def parent_type(p): return syms.arglist # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='prev')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()  # Creating a mock for syms# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=parent, value='prev_leaf')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COMMA}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.varargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=MockParent(type=syms.parameters), value='previous') # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='prev') # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.NUMBER}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return None # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.NUMBER}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COLON, parent=None, value='prev')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:  # Mock class for leaf# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:  # Mock class for parent# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR, token.LSQB}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(parent): return None# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover""
        ]
    }
]",3,7485,0.0037425,2640,0.00396,0.0077025
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return whitespace prefix if needed for the given `leaf`.
    `complex_subscript` signals whether the given leaf is part of a subscription
    which has non-trivial arguments, like arithmetic expressions or function calls.
    """"""
NO: Final = """"
SPACE: Final = "" ""
DOUBLESPACE: Final = ""  ""
t = leaf.type
p = leaf.parent
v = leaf.value
if t in ALWAYS_NO_SPACE:
    aux = NO
    exit(aux) # uncovered
if t == token.COMMENT:
    aux = DOUBLESPACE
    exit(aux) # uncovered
assert p is not None, f""INTERNAL ERROR: hand-made leaf without parent: {leaf!r}""
if t == token.COLON and p.type not in { # uncovered
    syms.subscript, # uncovered
    syms.subscriptlist, # uncovered
    syms.sliceop, # uncovered
}: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
prev = leaf.prev_sibling
if not prev:
    prevp = preceding_leaf(p)
    if not prevp or prevp.type in OPENING_BRACKETS:
        aux = NO
        exit(aux) # uncovered
    if t == token.COLON: # uncovered
        if prevp.type == token.COLON: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type != token.COMMA and not complex_subscript: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        aux = SPACE # uncovered
        exit(aux) # uncovered
    if prevp.type == token.EQUAL: # uncovered
        if prevp.parent: # uncovered
            if prevp.parent.type in { # uncovered
                syms.arglist, # uncovered
                syms.argument, # uncovered
                syms.parameters, # uncovered
                syms.varargslist, # uncovered
            }: # uncovered
                aux = NO # uncovered
                exit(aux) # uncovered
            elif prevp.parent.type == syms.typedargslist: # uncovered
                aux = prevp.prefix # uncovered
                # A bit hacky: if the equal sign has whitespace, it means we
                # previously found it's a typed argument.  So, we're using
                # that, too.
                exit(aux) # uncovered
    elif ( # uncovered
        prevp.type == token.STAR # uncovered
        and parent_type(prevp) == syms.star_expr # uncovered
        and parent_type(prevp.parent) == syms.subscriptlist # uncovered
    ): # uncovered
        aux = NO # uncovered
        # No space between typevar tuples.
        exit(aux) # uncovered
    elif prevp.type in VARARGS_SPECIALS: # uncovered
        if is_vararg(prevp, within=VARARGS_PARENTS | UNPACKING_PARENTS): # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prevp.type == token.COLON: # uncovered
        if prevp.parent and prevp.parent.type in {syms.subscript, syms.sliceop}: # uncovered
            aux = SPACE if complex_subscript else NO # uncovered
            exit(aux) # uncovered
    elif ( # uncovered
        prevp.parent # uncovered
        and prevp.parent.type == syms.factor # uncovered
        and prevp.type in MATH_OPERATORS # uncovered
    ): # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif prevp.type == token.AT and p.parent and p.parent.type == syms.decorator: # uncovered
        aux = NO # uncovered
        # no space in decorators
        exit(aux) # uncovered
elif prev.type in OPENING_BRACKETS: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
if p.type in {syms.parameters, syms.arglist}: # uncovered
    # untyped function signatures or calls
    if not prev or prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.varargslist: # uncovered
    # lambdas
    if prev and prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.typedargslist: # uncovered
    # typed function signatures
    if not prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if t == token.EQUAL: # uncovered
        if prev.type not in TYPED_NAMES: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type == token.EQUAL: # uncovered
        aux = prev.prefix # uncovered
        # A bit hacky: if the equal sign has whitespace, it means we
        # previously found it's a typed argument.  So, we're using that, too.
        exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in TYPED_NAMES: # uncovered
    # type names
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type != token.COMMA: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.trailer: # uncovered
    # attributes and calls
    if t == token.LPAR or t == token.RPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        if t == token.DOT or t == token.LSQB: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.argument: # uncovered
    # single argument
    if t == token.EQUAL: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type == token.LPAR: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type in {token.EQUAL} | VARARGS_SPECIALS: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.decorator: # uncovered
    aux = NO # uncovered
    # decorators
    exit(aux) # uncovered
elif p.type == syms.dotted_name: # uncovered
    if prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    prevp = preceding_leaf(p) # uncovered
    if not prevp or prevp.type == token.AT or prevp.type == token.DOT: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.classdef: # uncovered
    if t == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if prev and prev.type == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.subscript, syms.sliceop}: # uncovered
    # indexing
    if not prev: # uncovered
        assert p.parent is not None, ""subscripts are always parented"" # uncovered
        if p.parent.type == syms.subscriptlist: # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif not complex_subscript: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.atom: # uncovered
    if prev and t == token.DOT: # uncovered
        aux = NO # uncovered
        # dots, but not the first one.
        exit(aux) # uncovered
elif p.type == syms.dictsetmaker: # uncovered
    # dict unpacking
    if prev and prev.type == token.DOUBLESTAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.factor, syms.star_expr}: # uncovered
    # unary ops
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type in OPENING_BRACKETS: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        prevp_parent = prevp.parent # uncovered
        assert prevp_parent is not None # uncovered
        if prevp.type == token.COLON and prevp_parent.type in { # uncovered
            syms.subscript, # uncovered
            syms.sliceop, # uncovered
        }: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t in {token.NAME, token.NUMBER, token.STRING}: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.import_from: # uncovered
    if t == token.DOT: # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t == token.NAME: # uncovered
        if v == ""import"": # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.sliceop: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
elif p.type == syms.except_clause: # uncovered
    if t == token.STAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
aux = SPACE # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test')"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COMMA}"",
            ""OPENING_BRACKETS = {token.LPAR}"",
            ""VARARGS_SPECIALS = {token.STAR}"",
            ""TYPED_NAMES = {token.NAME}"",
            ""complex_subscript = False"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=parent, value='prev')"",
            ""def parent_type(leaf): return syms.arglist"",
            ""syms = type('syms', (), {})()\nsyms.subscript = 1\nsyms.subscriptlist = 2\nsyms.sliceop = 3\nsyms.parameters = 4\nsyms.arglist = 5\nsyms.typedargslist = 6""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=parent, value='prev')\n"",
            ""def parent_type(leaf): return syms.arglist""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""def parent_type(leaf): return syms.arglist""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev')\n"",
            ""def parent_type(leaf): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.subscript), value='example')"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COMMA}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')"",
            ""def parent_type(p): return syms.arglist"",
            ""syms = type('syms', (), {})()"",
            ""syms.arglist = 1\n"",
            ""syms.subscript = 2\n"",
            ""syms.subscriptlist = 3\n"",
            ""syms.sliceop = 4\n"",
            ""syms.typedargslist = 5\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='example')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.subscript = 2\n"",
            ""syms.sliceop = 3\n"",
            ""syms.parameters = 4\n"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='prev')"",
            ""def parent_type(leaf): return syms.arglist""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='leaf_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=MockParent(type=syms.arglist), value='previous')\n"",
            ""def parent_type(leaf): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.subscript = 1\n"",
            ""syms.subscriptlist = 2\n"",
            ""syms.sliceop = 3\n"",
            ""syms.arglist = 4\n"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""def parent_type(leaf): return syms.arglist""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.decorators), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.decorators = 3\n"",
            ""syms.typedargslist = 4\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""def parent_type(p): return syms.arglist""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=MockParent(type=syms.arglist), value='prev_value')\n"",
            ""def parent_type(p): return syms.arglist\n"",
            ""syms = type('syms', (), {})()"",
            ""syms.subscript = 1\n"",
            ""syms.subscriptlist = 2\n"",
            ""syms.sliceop = 3\n"",
            ""syms.parameters = 4\n"",
            ""syms.arglist = 5\n"",
            ""syms.varargslist = 6\n"",
            ""syms.typedargslist = 7\n""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COMMA} # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR} # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR} # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME} # pragma: no cover"",
            ""complex_subscript = False # pragma: no cover"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=parent, value='prev') # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            ""syms.subscript = 1# pragma: no cover"",
            ""syms.subscriptlist = 2# pragma: no cover"",
            ""syms.sliceop = 3# pragma: no cover"",
            ""syms.parameters = 4# pragma: no cover"",
            ""syms.arglist = 5# pragma: no cover"",
            ""syms.typedargslist = 6 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final, Optional # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=parent, value='prev')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COMMA}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous') # pragma: no cover"",
            ""def parent_type(p): return syms.arglist # pragma: no cover"",
            ""syms = type('syms', (), {})() # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 5# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='prev') # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=MockParent(type=syms.arglist), value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.decorators = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.arglist # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=MockParent(type=syms.arglist), value='prev_value')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})() # pragma: no cover"",
            ""syms.subscript = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.varargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 7# pragma: no cover"",
            "" # pragma: no cover""
        ]
    }
]",3,7585,0.0037925,3163,0.0047445,0.008537
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return whitespace prefix if needed for the given `leaf`.
    `complex_subscript` signals whether the given leaf is part of a subscription
    which has non-trivial arguments, like arithmetic expressions or function calls.
    """"""
NO: Final = """"
SPACE: Final = "" ""
DOUBLESPACE: Final = ""  ""
t = leaf.type
p = leaf.parent
v = leaf.value
if t in ALWAYS_NO_SPACE:
    aux = NO
    exit(aux) # uncovered
if t == token.COMMENT:
    aux = DOUBLESPACE
    exit(aux) # uncovered
assert p is not None, f""INTERNAL ERROR: hand-made leaf without parent: {leaf!r}""
if t == token.COLON and p.type not in { # uncovered
    syms.subscript, # uncovered
    syms.subscriptlist, # uncovered
    syms.sliceop, # uncovered
}: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
prev = leaf.prev_sibling
if not prev:
    prevp = preceding_leaf(p)
    if not prevp or prevp.type in OPENING_BRACKETS:
        aux = NO
        exit(aux) # uncovered
    if t == token.COLON: # uncovered
        if prevp.type == token.COLON: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type != token.COMMA and not complex_subscript: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        aux = SPACE # uncovered
        exit(aux) # uncovered
    if prevp.type == token.EQUAL: # uncovered
        if prevp.parent: # uncovered
            if prevp.parent.type in { # uncovered
                syms.arglist, # uncovered
                syms.argument, # uncovered
                syms.parameters, # uncovered
                syms.varargslist, # uncovered
            }: # uncovered
                aux = NO # uncovered
                exit(aux) # uncovered
            elif prevp.parent.type == syms.typedargslist: # uncovered
                aux = prevp.prefix # uncovered
                # A bit hacky: if the equal sign has whitespace, it means we
                # previously found it's a typed argument.  So, we're using
                # that, too.
                exit(aux) # uncovered
    elif ( # uncovered
        prevp.type == token.STAR # uncovered
        and parent_type(prevp) == syms.star_expr # uncovered
        and parent_type(prevp.parent) == syms.subscriptlist # uncovered
    ): # uncovered
        aux = NO # uncovered
        # No space between typevar tuples.
        exit(aux) # uncovered
    elif prevp.type in VARARGS_SPECIALS: # uncovered
        if is_vararg(prevp, within=VARARGS_PARENTS | UNPACKING_PARENTS): # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prevp.type == token.COLON: # uncovered
        if prevp.parent and prevp.parent.type in {syms.subscript, syms.sliceop}: # uncovered
            aux = SPACE if complex_subscript else NO # uncovered
            exit(aux) # uncovered
    elif ( # uncovered
        prevp.parent # uncovered
        and prevp.parent.type == syms.factor # uncovered
        and prevp.type in MATH_OPERATORS # uncovered
    ): # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif prevp.type == token.AT and p.parent and p.parent.type == syms.decorator: # uncovered
        aux = NO # uncovered
        # no space in decorators
        exit(aux) # uncovered
elif prev.type in OPENING_BRACKETS: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
if p.type in {syms.parameters, syms.arglist}: # uncovered
    # untyped function signatures or calls
    if not prev or prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.varargslist: # uncovered
    # lambdas
    if prev and prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.typedargslist: # uncovered
    # typed function signatures
    if not prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if t == token.EQUAL: # uncovered
        if prev.type not in TYPED_NAMES: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type == token.EQUAL: # uncovered
        aux = prev.prefix # uncovered
        # A bit hacky: if the equal sign has whitespace, it means we
        # previously found it's a typed argument.  So, we're using that, too.
        exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in TYPED_NAMES: # uncovered
    # type names
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type != token.COMMA: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.trailer: # uncovered
    # attributes and calls
    if t == token.LPAR or t == token.RPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        if t == token.DOT or t == token.LSQB: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.argument: # uncovered
    # single argument
    if t == token.EQUAL: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type == token.LPAR: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type in {token.EQUAL} | VARARGS_SPECIALS: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.decorator: # uncovered
    aux = NO # uncovered
    # decorators
    exit(aux) # uncovered
elif p.type == syms.dotted_name: # uncovered
    if prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    prevp = preceding_leaf(p) # uncovered
    if not prevp or prevp.type == token.AT or prevp.type == token.DOT: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.classdef: # uncovered
    if t == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if prev and prev.type == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.subscript, syms.sliceop}: # uncovered
    # indexing
    if not prev: # uncovered
        assert p.parent is not None, ""subscripts are always parented"" # uncovered
        if p.parent.type == syms.subscriptlist: # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif not complex_subscript: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.atom: # uncovered
    if prev and t == token.DOT: # uncovered
        aux = NO # uncovered
        # dots, but not the first one.
        exit(aux) # uncovered
elif p.type == syms.dictsetmaker: # uncovered
    # dict unpacking
    if prev and prev.type == token.DOUBLESTAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.factor, syms.star_expr}: # uncovered
    # unary ops
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type in OPENING_BRACKETS: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        prevp_parent = prevp.parent # uncovered
        assert prevp_parent is not None # uncovered
        if prevp.type == token.COLON and prevp_parent.type in { # uncovered
            syms.subscript, # uncovered
            syms.sliceop, # uncovered
        }: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t in {token.NAME, token.NUMBER, token.STRING}: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.import_from: # uncovered
    if t == token.DOT: # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t == token.NAME: # uncovered
        if v == ""import"": # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.sliceop: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
elif p.type == syms.except_clause: # uncovered
    if t == token.STAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
aux = SPACE # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COMMA}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=MockParent(type=syms.arglist), value='prev_value')\n"",
            ""def parent_type(p): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.decorators = 6\n"",
            ""syms.typedargslist = 7\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COMMA}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.subscript = 1\n"",
            ""syms.subscriptlist = 2\n"",
            ""syms.sliceop = 3\n"",
            ""syms.arglist = 4\n"",
            ""syms.parameters = 5\n"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')\n"",
            ""def parent_type(leaf): return syms.arglist""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.COMMA}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='prev')\n"",
            ""def parent_type(leaf): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='example_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='previous_leaf')\n"",
            ""def parent_type(leaf): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COMMA}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev')\n"",
            ""def parent_type(p): return syms.arglist""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COMMA}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='prev')"",
            ""def parent_type(leaf): return syms.arglist""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='previous')"",
            ""def parent_type(leaf): return syms.arglist"",
            ""syms = type('syms', (), {})()"",
            ""syms.subscript = 1\n"",
            ""syms.subscriptlist = 2\n"",
            ""syms.sliceop = 3\n"",
            ""syms.parameters = 4\n"",
            ""syms.arglist = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""syms.argument = 7\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.subscript = 1\n"",
            ""syms.subscriptlist = 2\n"",
            ""syms.sliceop = 3\n"",
            ""syms.parameters = 4\n"",
            ""syms.arglist = 5\n"",
            ""def parent_type(leaf): return syms.parameters""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COMMA}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""def parent_type(leaf): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""def parent_type(leaf): return syms.typedargslist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.typedargslist = 3\n"",
            ""syms.subscript = 4\n"",
            ""syms.sliceop = 5\n""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COMMA}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=MockParent(type=syms.arglist), value='prev_value')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.decorators = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 7# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COMMA}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMA}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='prev')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='previous_leaf')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COMMA}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.arglist # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COMMA}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='prev') # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='previous') # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist # pragma: no cover"",
            ""syms = type('syms', (), {})() # pragma: no cover"",
            ""syms.subscript = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 7# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.parameters # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COMMA}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.typedargslist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover""
        ]
    }
]",3,8108,0.004054,3296,0.004944,0.0089979999999999
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return whitespace prefix if needed for the given `leaf`.
    `complex_subscript` signals whether the given leaf is part of a subscription
    which has non-trivial arguments, like arithmetic expressions or function calls.
    """"""
NO: Final = """"
SPACE: Final = "" ""
DOUBLESPACE: Final = ""  ""
t = leaf.type
p = leaf.parent
v = leaf.value
if t in ALWAYS_NO_SPACE:
    aux = NO
    exit(aux) # uncovered
if t == token.COMMENT:
    aux = DOUBLESPACE
    exit(aux) # uncovered
assert p is not None, f""INTERNAL ERROR: hand-made leaf without parent: {leaf!r}""
if t == token.COLON and p.type not in { # uncovered
    syms.subscript, # uncovered
    syms.subscriptlist, # uncovered
    syms.sliceop, # uncovered
}: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
prev = leaf.prev_sibling
if not prev:
    prevp = preceding_leaf(p)
    if not prevp or prevp.type in OPENING_BRACKETS:
        aux = NO
        exit(aux) # uncovered
    if t == token.COLON: # uncovered
        if prevp.type == token.COLON: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type != token.COMMA and not complex_subscript: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        aux = SPACE # uncovered
        exit(aux) # uncovered
    if prevp.type == token.EQUAL: # uncovered
        if prevp.parent: # uncovered
            if prevp.parent.type in { # uncovered
                syms.arglist, # uncovered
                syms.argument, # uncovered
                syms.parameters, # uncovered
                syms.varargslist, # uncovered
            }: # uncovered
                aux = NO # uncovered
                exit(aux) # uncovered
            elif prevp.parent.type == syms.typedargslist: # uncovered
                aux = prevp.prefix # uncovered
                # A bit hacky: if the equal sign has whitespace, it means we
                # previously found it's a typed argument.  So, we're using
                # that, too.
                exit(aux) # uncovered
    elif ( # uncovered
        prevp.type == token.STAR # uncovered
        and parent_type(prevp) == syms.star_expr # uncovered
        and parent_type(prevp.parent) == syms.subscriptlist # uncovered
    ): # uncovered
        aux = NO # uncovered
        # No space between typevar tuples.
        exit(aux) # uncovered
    elif prevp.type in VARARGS_SPECIALS: # uncovered
        if is_vararg(prevp, within=VARARGS_PARENTS | UNPACKING_PARENTS): # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prevp.type == token.COLON: # uncovered
        if prevp.parent and prevp.parent.type in {syms.subscript, syms.sliceop}: # uncovered
            aux = SPACE if complex_subscript else NO # uncovered
            exit(aux) # uncovered
    elif ( # uncovered
        prevp.parent # uncovered
        and prevp.parent.type == syms.factor # uncovered
        and prevp.type in MATH_OPERATORS # uncovered
    ): # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif prevp.type == token.AT and p.parent and p.parent.type == syms.decorator: # uncovered
        aux = NO # uncovered
        # no space in decorators
        exit(aux) # uncovered
elif prev.type in OPENING_BRACKETS: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
if p.type in {syms.parameters, syms.arglist}: # uncovered
    # untyped function signatures or calls
    if not prev or prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.varargslist: # uncovered
    # lambdas
    if prev and prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.typedargslist: # uncovered
    # typed function signatures
    if not prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if t == token.EQUAL: # uncovered
        if prev.type not in TYPED_NAMES: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type == token.EQUAL: # uncovered
        aux = prev.prefix # uncovered
        # A bit hacky: if the equal sign has whitespace, it means we
        # previously found it's a typed argument.  So, we're using that, too.
        exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in TYPED_NAMES: # uncovered
    # type names
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type != token.COMMA: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.trailer: # uncovered
    # attributes and calls
    if t == token.LPAR or t == token.RPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        if t == token.DOT or t == token.LSQB: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.argument: # uncovered
    # single argument
    if t == token.EQUAL: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type == token.LPAR: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type in {token.EQUAL} | VARARGS_SPECIALS: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.decorator: # uncovered
    aux = NO # uncovered
    # decorators
    exit(aux) # uncovered
elif p.type == syms.dotted_name: # uncovered
    if prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    prevp = preceding_leaf(p) # uncovered
    if not prevp or prevp.type == token.AT or prevp.type == token.DOT: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.classdef: # uncovered
    if t == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if prev and prev.type == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.subscript, syms.sliceop}: # uncovered
    # indexing
    if not prev: # uncovered
        assert p.parent is not None, ""subscripts are always parented"" # uncovered
        if p.parent.type == syms.subscriptlist: # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif not complex_subscript: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.atom: # uncovered
    if prev and t == token.DOT: # uncovered
        aux = NO # uncovered
        # dots, but not the first one.
        exit(aux) # uncovered
elif p.type == syms.dictsetmaker: # uncovered
    # dict unpacking
    if prev and prev.type == token.DOUBLESTAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.factor, syms.star_expr}: # uncovered
    # unary ops
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type in OPENING_BRACKETS: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        prevp_parent = prevp.parent # uncovered
        assert prevp_parent is not None # uncovered
        if prevp.type == token.COLON and prevp_parent.type in { # uncovered
            syms.subscript, # uncovered
            syms.sliceop, # uncovered
        }: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t in {token.NAME, token.NUMBER, token.STRING}: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.import_from: # uncovered
    if t == token.DOT: # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t == token.NAME: # uncovered
        if v == ""import"": # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.sliceop: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
elif p.type == syms.except_clause: # uncovered
    if t == token.STAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
aux = SPACE # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""def parent_type(p): return syms.arguments\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""syms.decorator = 7\n"",
            ""syms.arguments = 8\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev')\n"",
            ""def parent_type(leaf): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""syms.varargslist = 7\n"",
            ""syms.factor = 8\n"",
            ""syms.star_expr = 9\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = None\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='some_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COMMA}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""def parent_type(leaf): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.decorators = 6\n"",
            ""syms.typedargslist = 7\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')\n"",
            ""def parent_type(leaf): return syms.arglist\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COMMA, token.COLON, token.STAR}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def is_vararg(prevp, within): return False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""def parent_type(p): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""syms.factor = 7\n"",
            ""syms.argument = 8\n"",
            ""syms.varargslist = 9\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""def parent_type(leaf): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""syms.varargslist = 7\n"",
            ""syms.factor = 8\n"",
            ""syms.star_expr = 9\n"",
            ""syms.decorator = 10\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COMMA, token.EQUAL}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.typedargslist = 3\n"",
            ""syms.subscript = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.factor = 6\n"",
            ""syms.star_expr = 7\n"",
            ""syms.trailer = 8\n"",
            ""syms.dotted_name = 9\n"",
            ""def parent_type(leaf): return syms.arglist""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='previous_leaf')\n"",
            ""def parent_type(leaf): return syms.arglist\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COMMA}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.subscript = 1\n"",
            ""syms.subscriptlist = 2\n"",
            ""syms.sliceop = 3\n"",
            ""syms.parameters = 4\n"",
            ""syms.arglist = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""syms.argument = 7\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous_leaf')\n"",
            ""def parent_type(p): return syms.typedargslist""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COMMA}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev')"",
            ""def parent_type(p): return syms.parameters\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.typedargslist = 3\n"",
            ""syms.subscript = 4\n"",
            ""syms.subscriptlist = 5\n"",
            ""syms.sliceop = 6\n"",
            ""syms.factor = 7\n"",
            ""syms.star_expr = 8\n"",
            ""syms.decorator = 9\n""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.arguments# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.decorator = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arguments = 8# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.varargslist = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 9# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = None# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COMMA}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.decorators = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 7# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COMMA, token.COLON, token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.varargslist = 9# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.varargslist = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.decorator = 10# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COMMA, token.EQUAL}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.trailer = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.dotted_name = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='previous_leaf')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COMMA}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous_leaf')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.typedargslist # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COMMA}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev') # pragma: no cover"",
            ""def parent_type(p): return syms.parameters# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.decorator = 9# pragma: no cover"",
            "" # pragma: no cover""
        ]
    }
]",3,8241,0.0041205,3596,0.005394,0.0095145
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return whitespace prefix if needed for the given `leaf`.
    `complex_subscript` signals whether the given leaf is part of a subscription
    which has non-trivial arguments, like arithmetic expressions or function calls.
    """"""
NO: Final = """"
SPACE: Final = "" ""
DOUBLESPACE: Final = ""  ""
t = leaf.type
p = leaf.parent
v = leaf.value
if t in ALWAYS_NO_SPACE:
    aux = NO
    exit(aux) # uncovered
if t == token.COMMENT:
    aux = DOUBLESPACE
    exit(aux) # uncovered
assert p is not None, f""INTERNAL ERROR: hand-made leaf without parent: {leaf!r}""
if t == token.COLON and p.type not in { # uncovered
    syms.subscript, # uncovered
    syms.subscriptlist, # uncovered
    syms.sliceop, # uncovered
}: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
prev = leaf.prev_sibling
if not prev:
    prevp = preceding_leaf(p)
    if not prevp or prevp.type in OPENING_BRACKETS:
        aux = NO
        exit(aux) # uncovered
    if t == token.COLON: # uncovered
        if prevp.type == token.COLON: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type != token.COMMA and not complex_subscript: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        aux = SPACE # uncovered
        exit(aux) # uncovered
    if prevp.type == token.EQUAL: # uncovered
        if prevp.parent: # uncovered
            if prevp.parent.type in { # uncovered
                syms.arglist, # uncovered
                syms.argument, # uncovered
                syms.parameters, # uncovered
                syms.varargslist, # uncovered
            }: # uncovered
                aux = NO # uncovered
                exit(aux) # uncovered
            elif prevp.parent.type == syms.typedargslist: # uncovered
                aux = prevp.prefix # uncovered
                # A bit hacky: if the equal sign has whitespace, it means we
                # previously found it's a typed argument.  So, we're using
                # that, too.
                exit(aux) # uncovered
    elif ( # uncovered
        prevp.type == token.STAR # uncovered
        and parent_type(prevp) == syms.star_expr # uncovered
        and parent_type(prevp.parent) == syms.subscriptlist # uncovered
    ): # uncovered
        aux = NO # uncovered
        # No space between typevar tuples.
        exit(aux) # uncovered
    elif prevp.type in VARARGS_SPECIALS: # uncovered
        if is_vararg(prevp, within=VARARGS_PARENTS | UNPACKING_PARENTS): # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prevp.type == token.COLON: # uncovered
        if prevp.parent and prevp.parent.type in {syms.subscript, syms.sliceop}: # uncovered
            aux = SPACE if complex_subscript else NO # uncovered
            exit(aux) # uncovered
    elif ( # uncovered
        prevp.parent # uncovered
        and prevp.parent.type == syms.factor # uncovered
        and prevp.type in MATH_OPERATORS # uncovered
    ): # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif prevp.type == token.AT and p.parent and p.parent.type == syms.decorator: # uncovered
        aux = NO # uncovered
        # no space in decorators
        exit(aux) # uncovered
elif prev.type in OPENING_BRACKETS: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
if p.type in {syms.parameters, syms.arglist}: # uncovered
    # untyped function signatures or calls
    if not prev or prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.varargslist: # uncovered
    # lambdas
    if prev and prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.typedargslist: # uncovered
    # typed function signatures
    if not prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if t == token.EQUAL: # uncovered
        if prev.type not in TYPED_NAMES: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type == token.EQUAL: # uncovered
        aux = prev.prefix # uncovered
        # A bit hacky: if the equal sign has whitespace, it means we
        # previously found it's a typed argument.  So, we're using that, too.
        exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in TYPED_NAMES: # uncovered
    # type names
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type != token.COMMA: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.trailer: # uncovered
    # attributes and calls
    if t == token.LPAR or t == token.RPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        if t == token.DOT or t == token.LSQB: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.argument: # uncovered
    # single argument
    if t == token.EQUAL: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type == token.LPAR: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type in {token.EQUAL} | VARARGS_SPECIALS: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.decorator: # uncovered
    aux = NO # uncovered
    # decorators
    exit(aux) # uncovered
elif p.type == syms.dotted_name: # uncovered
    if prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    prevp = preceding_leaf(p) # uncovered
    if not prevp or prevp.type == token.AT or prevp.type == token.DOT: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.classdef: # uncovered
    if t == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if prev and prev.type == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.subscript, syms.sliceop}: # uncovered
    # indexing
    if not prev: # uncovered
        assert p.parent is not None, ""subscripts are always parented"" # uncovered
        if p.parent.type == syms.subscriptlist: # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif not complex_subscript: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.atom: # uncovered
    if prev and t == token.DOT: # uncovered
        aux = NO # uncovered
        # dots, but not the first one.
        exit(aux) # uncovered
elif p.type == syms.dictsetmaker: # uncovered
    # dict unpacking
    if prev and prev.type == token.DOUBLESTAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.factor, syms.star_expr}: # uncovered
    # unary ops
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type in OPENING_BRACKETS: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        prevp_parent = prevp.parent # uncovered
        assert prevp_parent is not None # uncovered
        if prevp.type == token.COLON and prevp_parent.type in { # uncovered
            syms.subscript, # uncovered
            syms.sliceop, # uncovered
        }: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t in {token.NAME, token.NUMBER, token.STRING}: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.import_from: # uncovered
    if t == token.DOT: # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t == token.NAME: # uncovered
        if v == ""import"": # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.sliceop: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
elif p.type == syms.except_clause: # uncovered
    if t == token.STAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
aux = SPACE # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""syms.decorator = 7\n"",
            ""syms.factor = 8\n"",
            ""syms.star_expr = 9\n"",
            ""def parent_type(p): return syms.arglist\n"",
            ""def is_vararg(prevp, within): return False\n"",
            ""VARARGS_PARENTS = 10\n"",
            ""UNPACKING_PARENTS = 11\n"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS}\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev')\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""syms.factor = 7\n"",
            ""syms.star_expr = 8\n"",
            ""def parent_type(leaf): return syms.arglist\n"",
            ""def is_vararg(prevp, within): return False\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COMMA}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""def parent_type(leaf): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""syms.varargslist = 7\n"",
            ""syms.factor = 8\n"",
            ""syms.argument = 9\n"",
            ""syms.trailer = 10\n"",
            ""syms.decorator = 11\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""def is_vararg(prevp, within): return False\n"",
            ""def parent_type(leaf): return syms.arguments\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.typedargslist = 3\n"",
            ""syms.subscript = 4\n"",
            ""syms.subscriptlist = 5\n"",
            ""syms.sliceop = 6\n"",
            ""syms.factor = 7\n"",
            ""syms.star_expr = 8\n"",
            ""syms.dotted_name = 9\n"",
            ""syms.decorator = 10\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""def parent_type(p): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""syms.varargslist = 7\n"",
            ""syms.factor = 8\n"",
            ""syms.star_expr = 9\n"",
            ""syms.argument = 10\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COLON}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""def parent_type(leaf): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.typedargslist = 3\n"",
            ""syms.subscript = 4\n"",
            ""syms.subscriptlist = 5\n"",
            ""syms.sliceop = 6\n"",
            ""syms.factor = 7\n"",
            ""syms.star_expr = 8\n"",
            ""syms.trailer = 9\n"",
            ""syms.argument = 10\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')\n"",
            ""def parent_type(leaf): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.parameters = 1\n"",
            ""syms.arglist = 2\n"",
            ""syms.typedargslist = 3\n"",
            ""syms.subscript = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.factor = 6\n"",
            ""syms.star_expr = 7\n"",
            ""syms.argument = 8\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.parameters = 1\n"",
            ""syms.arglist = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""def parent_type(p): return syms.arglist\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""def is_vararg(leaf, within): return False\n"",
            ""def parent_type(leaf): return syms.parameters\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.parameters = 1\n"",
            ""syms.arglist = 2\n"",
            ""syms.typedargslist = 3\n"",
            ""syms.subscript = 4\n"",
            ""syms.subscriptlist = 5\n"",
            ""syms.sliceop = 6\n"",
            ""syms.factor = 7\n"",
            ""syms.trailer = 8\n"",
            ""syms.argument = 9\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')\n"",
            ""def parent_type(p): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""def is_vararg(prevp, within): return False\n"",
            ""syms.factor = 7\n"",
            ""syms.star_expr = 8\n""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.decorator = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return False# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_PARENTS = 10# pragma: no cover"",
            "" # pragma: no cover"",
            ""UNPACKING_PARENTS = 11# pragma: no cover"",
            "" # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS}# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev')# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return False# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COMMA}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.varargslist = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.trailer = 10# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.decorator = 11# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arguments# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.dotted_name = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.decorator = 10# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.varargslist = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 10# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COLON}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(parent): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.trailer = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 10# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 8# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(leaf, within): return False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.parameters# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.trailer = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 9# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return False# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 8# pragma: no cover"",
            "" # pragma: no cover""
        ]
    }
]",3,8541,0.0042705,3802,0.005703,0.0099735
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return whitespace prefix if needed for the given `leaf`.
    `complex_subscript` signals whether the given leaf is part of a subscription
    which has non-trivial arguments, like arithmetic expressions or function calls.
    """"""
NO: Final = """"
SPACE: Final = "" ""
DOUBLESPACE: Final = ""  ""
t = leaf.type
p = leaf.parent
v = leaf.value
if t in ALWAYS_NO_SPACE:
    aux = NO
    exit(aux) # uncovered
if t == token.COMMENT:
    aux = DOUBLESPACE
    exit(aux) # uncovered
assert p is not None, f""INTERNAL ERROR: hand-made leaf without parent: {leaf!r}""
if t == token.COLON and p.type not in { # uncovered
    syms.subscript, # uncovered
    syms.subscriptlist, # uncovered
    syms.sliceop, # uncovered
}: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
prev = leaf.prev_sibling
if not prev:
    prevp = preceding_leaf(p)
    if not prevp or prevp.type in OPENING_BRACKETS:
        aux = NO
        exit(aux) # uncovered
    if t == token.COLON: # uncovered
        if prevp.type == token.COLON: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type != token.COMMA and not complex_subscript: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        aux = SPACE # uncovered
        exit(aux) # uncovered
    if prevp.type == token.EQUAL: # uncovered
        if prevp.parent: # uncovered
            if prevp.parent.type in { # uncovered
                syms.arglist, # uncovered
                syms.argument, # uncovered
                syms.parameters, # uncovered
                syms.varargslist, # uncovered
            }: # uncovered
                aux = NO # uncovered
                exit(aux) # uncovered
            elif prevp.parent.type == syms.typedargslist: # uncovered
                aux = prevp.prefix # uncovered
                # A bit hacky: if the equal sign has whitespace, it means we
                # previously found it's a typed argument.  So, we're using
                # that, too.
                exit(aux) # uncovered
    elif ( # uncovered
        prevp.type == token.STAR # uncovered
        and parent_type(prevp) == syms.star_expr # uncovered
        and parent_type(prevp.parent) == syms.subscriptlist # uncovered
    ): # uncovered
        aux = NO # uncovered
        # No space between typevar tuples.
        exit(aux) # uncovered
    elif prevp.type in VARARGS_SPECIALS: # uncovered
        if is_vararg(prevp, within=VARARGS_PARENTS | UNPACKING_PARENTS): # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prevp.type == token.COLON: # uncovered
        if prevp.parent and prevp.parent.type in {syms.subscript, syms.sliceop}: # uncovered
            aux = SPACE if complex_subscript else NO # uncovered
            exit(aux) # uncovered
    elif ( # uncovered
        prevp.parent # uncovered
        and prevp.parent.type == syms.factor # uncovered
        and prevp.type in MATH_OPERATORS # uncovered
    ): # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif prevp.type == token.AT and p.parent and p.parent.type == syms.decorator: # uncovered
        aux = NO # uncovered
        # no space in decorators
        exit(aux) # uncovered
elif prev.type in OPENING_BRACKETS: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
if p.type in {syms.parameters, syms.arglist}: # uncovered
    # untyped function signatures or calls
    if not prev or prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.varargslist: # uncovered
    # lambdas
    if prev and prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.typedargslist: # uncovered
    # typed function signatures
    if not prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if t == token.EQUAL: # uncovered
        if prev.type not in TYPED_NAMES: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type == token.EQUAL: # uncovered
        aux = prev.prefix # uncovered
        # A bit hacky: if the equal sign has whitespace, it means we
        # previously found it's a typed argument.  So, we're using that, too.
        exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in TYPED_NAMES: # uncovered
    # type names
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type != token.COMMA: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.trailer: # uncovered
    # attributes and calls
    if t == token.LPAR or t == token.RPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        if t == token.DOT or t == token.LSQB: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.argument: # uncovered
    # single argument
    if t == token.EQUAL: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type == token.LPAR: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type in {token.EQUAL} | VARARGS_SPECIALS: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.decorator: # uncovered
    aux = NO # uncovered
    # decorators
    exit(aux) # uncovered
elif p.type == syms.dotted_name: # uncovered
    if prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    prevp = preceding_leaf(p) # uncovered
    if not prevp or prevp.type == token.AT or prevp.type == token.DOT: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.classdef: # uncovered
    if t == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if prev and prev.type == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.subscript, syms.sliceop}: # uncovered
    # indexing
    if not prev: # uncovered
        assert p.parent is not None, ""subscripts are always parented"" # uncovered
        if p.parent.type == syms.subscriptlist: # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif not complex_subscript: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.atom: # uncovered
    if prev and t == token.DOT: # uncovered
        aux = NO # uncovered
        # dots, but not the first one.
        exit(aux) # uncovered
elif p.type == syms.dictsetmaker: # uncovered
    # dict unpacking
    if prev and prev.type == token.DOUBLESTAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.factor, syms.star_expr}: # uncovered
    # unary ops
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type in OPENING_BRACKETS: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        prevp_parent = prevp.parent # uncovered
        assert prevp_parent is not None # uncovered
        if prevp.type == token.COLON and prevp_parent.type in { # uncovered
            syms.subscript, # uncovered
            syms.sliceop, # uncovered
        }: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t in {token.NAME, token.NUMBER, token.STRING}: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.import_from: # uncovered
    if t == token.DOT: # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t == token.NAME: # uncovered
        if v == ""import"": # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.sliceop: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
elif p.type == syms.except_clause: # uncovered
    if t == token.STAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
aux = SPACE # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME, token.EQUAL}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')\n"",
            ""def is_vararg(prevp, within): return False\n"",
            ""def parent_type(p): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.typedargslist = 3\n"",
            ""syms.subscript = 4\n"",
            ""syms.subscriptlist = 5\n"",
            ""syms.sliceop = 6\n"",
            ""syms.factor = 7\n"",
            ""syms.star_expr = 8\n"",
            ""syms.argument = 9\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COLON, parent=None, value='previous')\n"",
            ""def is_vararg(prevp, within): return False\n"",
            ""def parent_type(leaf): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""syms.factor = 7\n"",
            ""syms.star_expr = 8\n"",
            ""syms.decorator = 9\n"",
            ""syms.trailer = 10\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""def parent_type(p): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.parameters = 1\n"",
            ""syms.arglist = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""syms.varargslist = 7\n"",
            ""syms.factor = 8\n"",
            ""syms.star_expr = 9\n"",
            ""syms.argument = 10\n"",
            ""def is_vararg(prevp, within): return False\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""def parent_type(p): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.parameters = 1\n"",
            ""syms.arglist = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""def is_vararg(p, within): return False\n"",
            ""syms.factor = 7\n"",
            ""syms.star_expr = 8\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""def parent_type(p): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.typedargslist = 3\n"",
            ""syms.subscript = 4\n"",
            ""syms.subscriptlist = 5\n"",
            ""syms.sliceop = 6\n"",
            ""syms.factor = 7\n"",
            ""syms.star_expr = 8\n"",
            ""syms.argument = 9\n"",
            ""def is_vararg(prevp, within): return True\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""syms.factor = 7\n"",
            ""syms.argument = 8\n"",
            ""syms.trailer = 9\n"",
            ""def parent_type(leaf): return syms.arglist\n"",
            ""def is_vararg(prevp, within): return False\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COLON}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""def parent_type(p): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""syms.decorator = 7\n"",
            ""syms.factor = 8\n"",
            ""syms.star_expr = 9\n"",
            ""syms.argument = 10\n"",
            ""def is_vararg(prevp, within): return False\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')\n"",
            ""def parent_type(leaf): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""syms.varargslist = 7\n"",
            ""syms.factor = 8\n"",
            ""syms.star_expr = 9\n"",
            ""syms.argument = 10\n"",
            ""def is_vararg(prevp, within): return False\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.subscript), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""def parent_type(leaf): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""syms.factor = 7\n"",
            ""syms.star_expr = 8\n"",
            ""syms.decorator = 9\n"",
            ""def is_vararg(prevp, within): return False\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev')\n"",
            ""def is_vararg(prevp, within): return True\n"",
            ""def parent_type(p): return syms.argument\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.parameters = 1\n"",
            ""syms.arglist = 2\n"",
            ""syms.varargslist = 3\n"",
            ""syms.subscript = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""syms.factor = 7\n"",
            ""syms.star_expr = 8\n"",
            ""syms.argument = 9\n"",
            ""syms.decorator = 10\n""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME, token.EQUAL}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 9# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COLON, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.decorator = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.trailer = 10# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.varargslist = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 10# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return False# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(p, within): return False# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 8# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return True# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.trailer = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return False# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME, token.COLON}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.decorator = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 10# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return False# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.varargslist = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 10# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return False# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.decorator = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return False# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return True# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.argument# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.varargslist = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.decorator = 10# pragma: no cover"",
            "" # pragma: no cover""
        ]
    }
]",3,8747,0.0043735,3887,0.0058305,0.010204
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return whitespace prefix if needed for the given `leaf`.
    `complex_subscript` signals whether the given leaf is part of a subscription
    which has non-trivial arguments, like arithmetic expressions or function calls.
    """"""
NO: Final = """"
SPACE: Final = "" ""
DOUBLESPACE: Final = ""  ""
t = leaf.type
p = leaf.parent
v = leaf.value
if t in ALWAYS_NO_SPACE:
    aux = NO
    exit(aux) # uncovered
if t == token.COMMENT:
    aux = DOUBLESPACE
    exit(aux) # uncovered
assert p is not None, f""INTERNAL ERROR: hand-made leaf without parent: {leaf!r}""
if t == token.COLON and p.type not in { # uncovered
    syms.subscript, # uncovered
    syms.subscriptlist, # uncovered
    syms.sliceop, # uncovered
}: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
prev = leaf.prev_sibling
if not prev:
    prevp = preceding_leaf(p)
    if not prevp or prevp.type in OPENING_BRACKETS:
        aux = NO
        exit(aux) # uncovered
    if t == token.COLON: # uncovered
        if prevp.type == token.COLON: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type != token.COMMA and not complex_subscript: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        aux = SPACE # uncovered
        exit(aux) # uncovered
    if prevp.type == token.EQUAL: # uncovered
        if prevp.parent: # uncovered
            if prevp.parent.type in { # uncovered
                syms.arglist, # uncovered
                syms.argument, # uncovered
                syms.parameters, # uncovered
                syms.varargslist, # uncovered
            }: # uncovered
                aux = NO # uncovered
                exit(aux) # uncovered
            elif prevp.parent.type == syms.typedargslist: # uncovered
                aux = prevp.prefix # uncovered
                # A bit hacky: if the equal sign has whitespace, it means we
                # previously found it's a typed argument.  So, we're using
                # that, too.
                exit(aux) # uncovered
    elif ( # uncovered
        prevp.type == token.STAR # uncovered
        and parent_type(prevp) == syms.star_expr # uncovered
        and parent_type(prevp.parent) == syms.subscriptlist # uncovered
    ): # uncovered
        aux = NO # uncovered
        # No space between typevar tuples.
        exit(aux) # uncovered
    elif prevp.type in VARARGS_SPECIALS: # uncovered
        if is_vararg(prevp, within=VARARGS_PARENTS | UNPACKING_PARENTS): # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prevp.type == token.COLON: # uncovered
        if prevp.parent and prevp.parent.type in {syms.subscript, syms.sliceop}: # uncovered
            aux = SPACE if complex_subscript else NO # uncovered
            exit(aux) # uncovered
    elif ( # uncovered
        prevp.parent # uncovered
        and prevp.parent.type == syms.factor # uncovered
        and prevp.type in MATH_OPERATORS # uncovered
    ): # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif prevp.type == token.AT and p.parent and p.parent.type == syms.decorator: # uncovered
        aux = NO # uncovered
        # no space in decorators
        exit(aux) # uncovered
elif prev.type in OPENING_BRACKETS: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
if p.type in {syms.parameters, syms.arglist}: # uncovered
    # untyped function signatures or calls
    if not prev or prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.varargslist: # uncovered
    # lambdas
    if prev and prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.typedargslist: # uncovered
    # typed function signatures
    if not prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if t == token.EQUAL: # uncovered
        if prev.type not in TYPED_NAMES: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type == token.EQUAL: # uncovered
        aux = prev.prefix # uncovered
        # A bit hacky: if the equal sign has whitespace, it means we
        # previously found it's a typed argument.  So, we're using that, too.
        exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in TYPED_NAMES: # uncovered
    # type names
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type != token.COMMA: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.trailer: # uncovered
    # attributes and calls
    if t == token.LPAR or t == token.RPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        if t == token.DOT or t == token.LSQB: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.argument: # uncovered
    # single argument
    if t == token.EQUAL: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type == token.LPAR: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type in {token.EQUAL} | VARARGS_SPECIALS: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.decorator: # uncovered
    aux = NO # uncovered
    # decorators
    exit(aux) # uncovered
elif p.type == syms.dotted_name: # uncovered
    if prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    prevp = preceding_leaf(p) # uncovered
    if not prevp or prevp.type == token.AT or prevp.type == token.DOT: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.classdef: # uncovered
    if t == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if prev and prev.type == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.subscript, syms.sliceop}: # uncovered
    # indexing
    if not prev: # uncovered
        assert p.parent is not None, ""subscripts are always parented"" # uncovered
        if p.parent.type == syms.subscriptlist: # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif not complex_subscript: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.atom: # uncovered
    if prev and t == token.DOT: # uncovered
        aux = NO # uncovered
        # dots, but not the first one.
        exit(aux) # uncovered
elif p.type == syms.dictsetmaker: # uncovered
    # dict unpacking
    if prev and prev.type == token.DOUBLESTAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.factor, syms.star_expr}: # uncovered
    # unary ops
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type in OPENING_BRACKETS: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        prevp_parent = prevp.parent # uncovered
        assert prevp_parent is not None # uncovered
        if prevp.type == token.COLON and prevp_parent.type in { # uncovered
            syms.subscript, # uncovered
            syms.sliceop, # uncovered
        }: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t in {token.NAME, token.NUMBER, token.STRING}: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.import_from: # uncovered
    if t == token.DOT: # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t == token.NAME: # uncovered
        if v == ""import"": # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.sliceop: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
elif p.type == syms.except_clause: # uncovered
    if t == token.STAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
aux = SPACE # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.EQUAL}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""def is_vararg(prevp, within): return False\n"",
            ""def parent_type(p): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""syms.factor = 7\n"",
            ""def parent_type(p): return syms.subscriptlist\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""def parent_type(leaf): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.parameters = 1\n"",
            ""syms.arglist = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""syms.varargslist = 7\n"",
            ""syms.factor = 8\n"",
            ""syms.star_expr = 9\n"",
            ""syms.argument = 10\n"",
            ""def is_vararg(prevp, within): return False\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')\n"",
            ""def parent_type(leaf): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""syms.varargslist = 7\n"",
            ""syms.factor = 8\n"",
            ""syms.star_expr = 9\n"",
            ""syms.argument = 10\n"",
            ""def is_vararg(prevp, within): return False\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME, token.EQUAL}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')\n"",
            ""def is_vararg(prevp, within): return False\n"",
            ""def parent_type(p): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.parameters = 1\n"",
            ""syms.arglist = 2\n"",
            ""syms.typedargslist = 3\n"",
            ""syms.subscript = 4\n"",
            ""syms.subscriptlist = 5\n"",
            ""syms.sliceop = 6\n"",
            ""syms.factor = 7\n"",
            ""syms.star_expr = 8\n"",
            ""syms.argument = 9\n"",
            ""syms.decorator = 10\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')\n"",
            ""def is_vararg(prevp, within): return False\n"",
            ""def parent_type(p): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.parameters = 1\n"",
            ""syms.arglist = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""syms.factor = 7\n"",
            ""syms.star_expr = 8\n"",
            ""syms.argument = 9\n"",
            ""syms.decorator = 10\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')\n"",
            ""def is_vararg(prevp, within): return False\n"",
            ""def parent_type(p): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.parameters = 1\n"",
            ""syms.arglist = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""syms.factor = 7\n"",
            ""syms.star_expr = 8\n"",
            ""syms.argument = 9\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.subscript), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""def parent_type(p): return syms.subscript\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.subscript = 1\n"",
            ""syms.subscriptlist = 2\n"",
            ""syms.sliceop = 3\n"",
            ""syms.parameters = 4\n"",
            ""syms.arglist = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""syms.varargslist = 7\n"",
            ""syms.factor = 8\n"",
            ""syms.star_expr = 9\n"",
            ""syms.argument = 10\n"",
            ""def is_vararg(prevp, within): return False\n"",
            ""VARARGS_PARENTS = 0\n"",
            ""UNPACKING_PARENTS = 0\n"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS}""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.varargslist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')\n"",
            ""def parent_type(leaf): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.varargslist = 1\n"",
            ""syms.arglist = 2\n"",
            ""syms.parameters = 3\n"",
            ""syms.typedargslist = 4\n"",
            ""syms.subscript = 5\n"",
            ""syms.sliceop = 6\n"",
            ""syms.factor = 7\n"",
            ""syms.star_expr = 8\n"",
            ""syms.argument = 9\n"",
            ""syms.decorator = 10\n"",
            ""def is_vararg(prevp, within): return True\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""def is_vararg(prevp, within): return False\n"",
            ""def parent_type(p): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""syms.factor = 7\n"",
            ""syms.star_expr = 8\n"",
            ""syms.argument = 9\n"",
            ""syms.decorator = 10\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.EQUAL}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')\n"",
            ""def is_vararg(prevp, within): return False\n"",
            ""def parent_type(leaf): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.typedargslist = 3\n"",
            ""syms.subscript = 4\n"",
            ""syms.subscriptlist = 5\n"",
            ""syms.sliceop = 6\n"",
            ""syms.factor = 7\n"",
            ""syms.star_expr = 8\n"",
            ""syms.argument = 9\n"",
            ""syms.decorator = 10\n"",
            ""syms.dotted_name = 11\n""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.EQUAL}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.subscriptlist# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.varargslist = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 10# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return False# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.varargslist = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 10# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return False# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME, token.EQUAL}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.decorator = 10# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.decorator = 10# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 9# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.subscript# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.varargslist = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 10# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return False# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_PARENTS = 0# pragma: no cover"",
            "" # pragma: no cover"",
            ""UNPACKING_PARENTS = 0# pragma: no cover"",
            "" # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.varargslist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.decorator = 10# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return True# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.decorator = 10# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.EQUAL}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.decorator = 10# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.dotted_name = 11# pragma: no cover"",
            "" # pragma: no cover""
        ]
    }
]",3,8832,0.004416,3981,0.0059715,0.0103875
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Return whitespace prefix if needed for the given `leaf`.
    `complex_subscript` signals whether the given leaf is part of a subscription
    which has non-trivial arguments, like arithmetic expressions or function calls.
    """"""
NO: Final = """"
SPACE: Final = "" ""
DOUBLESPACE: Final = ""  ""
t = leaf.type
p = leaf.parent
v = leaf.value
if t in ALWAYS_NO_SPACE:
    aux = NO
    exit(aux) # uncovered
if t == token.COMMENT:
    aux = DOUBLESPACE
    exit(aux) # uncovered
assert p is not None, f""INTERNAL ERROR: hand-made leaf without parent: {leaf!r}""
if t == token.COLON and p.type not in { # uncovered
    syms.subscript, # uncovered
    syms.subscriptlist, # uncovered
    syms.sliceop, # uncovered
}: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
prev = leaf.prev_sibling
if not prev:
    prevp = preceding_leaf(p)
    if not prevp or prevp.type in OPENING_BRACKETS:
        aux = NO
        exit(aux) # uncovered
    if t == token.COLON: # uncovered
        if prevp.type == token.COLON: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type != token.COMMA and not complex_subscript: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        aux = SPACE # uncovered
        exit(aux) # uncovered
    if prevp.type == token.EQUAL: # uncovered
        if prevp.parent: # uncovered
            if prevp.parent.type in { # uncovered
                syms.arglist, # uncovered
                syms.argument, # uncovered
                syms.parameters, # uncovered
                syms.varargslist, # uncovered
            }: # uncovered
                aux = NO # uncovered
                exit(aux) # uncovered
            elif prevp.parent.type == syms.typedargslist: # uncovered
                aux = prevp.prefix # uncovered
                # A bit hacky: if the equal sign has whitespace, it means we
                # previously found it's a typed argument.  So, we're using
                # that, too.
                exit(aux) # uncovered
    elif ( # uncovered
        prevp.type == token.STAR # uncovered
        and parent_type(prevp) == syms.star_expr # uncovered
        and parent_type(prevp.parent) == syms.subscriptlist # uncovered
    ): # uncovered
        aux = NO # uncovered
        # No space between typevar tuples.
        exit(aux) # uncovered
    elif prevp.type in VARARGS_SPECIALS: # uncovered
        if is_vararg(prevp, within=VARARGS_PARENTS | UNPACKING_PARENTS): # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prevp.type == token.COLON: # uncovered
        if prevp.parent and prevp.parent.type in {syms.subscript, syms.sliceop}: # uncovered
            aux = SPACE if complex_subscript else NO # uncovered
            exit(aux) # uncovered
    elif ( # uncovered
        prevp.parent # uncovered
        and prevp.parent.type == syms.factor # uncovered
        and prevp.type in MATH_OPERATORS # uncovered
    ): # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif prevp.type == token.AT and p.parent and p.parent.type == syms.decorator: # uncovered
        aux = NO # uncovered
        # no space in decorators
        exit(aux) # uncovered
elif prev.type in OPENING_BRACKETS: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
if p.type in {syms.parameters, syms.arglist}: # uncovered
    # untyped function signatures or calls
    if not prev or prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.varargslist: # uncovered
    # lambdas
    if prev and prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.typedargslist: # uncovered
    # typed function signatures
    if not prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if t == token.EQUAL: # uncovered
        if prev.type not in TYPED_NAMES: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type == token.EQUAL: # uncovered
        aux = prev.prefix # uncovered
        # A bit hacky: if the equal sign has whitespace, it means we
        # previously found it's a typed argument.  So, we're using that, too.
        exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in TYPED_NAMES: # uncovered
    # type names
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type != token.COMMA: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.trailer: # uncovered
    # attributes and calls
    if t == token.LPAR or t == token.RPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        if t == token.DOT or t == token.LSQB: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type != token.COMMA: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.argument: # uncovered
    # single argument
    if t == token.EQUAL: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type == token.LPAR: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif prev.type in {token.EQUAL} | VARARGS_SPECIALS: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.decorator: # uncovered
    aux = NO # uncovered
    # decorators
    exit(aux) # uncovered
elif p.type == syms.dotted_name: # uncovered
    if prev: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    prevp = preceding_leaf(p) # uncovered
    if not prevp or prevp.type == token.AT or prevp.type == token.DOT: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.classdef: # uncovered
    if t == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    if prev and prev.type == token.LPAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.subscript, syms.sliceop}: # uncovered
    # indexing
    if not prev: # uncovered
        assert p.parent is not None, ""subscripts are always parented"" # uncovered
        if p.parent.type == syms.subscriptlist: # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
    elif not complex_subscript: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.atom: # uncovered
    if prev and t == token.DOT: # uncovered
        aux = NO # uncovered
        # dots, but not the first one.
        exit(aux) # uncovered
elif p.type == syms.dictsetmaker: # uncovered
    # dict unpacking
    if prev and prev.type == token.DOUBLESTAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type in {syms.factor, syms.star_expr}: # uncovered
    # unary ops
    if not prev: # uncovered
        prevp = preceding_leaf(p) # uncovered
        if not prevp or prevp.type in OPENING_BRACKETS: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        prevp_parent = prevp.parent # uncovered
        assert prevp_parent is not None # uncovered
        if prevp.type == token.COLON and prevp_parent.type in { # uncovered
            syms.subscript, # uncovered
            syms.sliceop, # uncovered
        }: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
        elif prevp.type == token.EQUAL and prevp_parent.type == syms.argument: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t in {token.NAME, token.NUMBER, token.STRING}: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
elif p.type == syms.import_from: # uncovered
    if t == token.DOT: # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
    elif t == token.NAME: # uncovered
        if v == ""import"": # uncovered
            aux = SPACE # uncovered
            exit(aux) # uncovered
        if prev and prev.type == token.DOT: # uncovered
            aux = NO # uncovered
            exit(aux) # uncovered
elif p.type == syms.sliceop: # uncovered
    aux = NO # uncovered
    exit(aux) # uncovered
elif p.type == syms.except_clause: # uncovered
    if t == token.STAR: # uncovered
        aux = NO # uncovered
        exit(aux) # uncovered
aux = SPACE # uncovered
exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.EQUAL}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""def is_vararg(prevp, within): return False\n"",
            ""def parent_type(p): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.parameters = 1\n"",
            ""syms.arglist = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""syms.varargslist = 7\n"",
            ""syms.factor = 8\n"",
            ""syms.star_expr = 9\n"",
            ""syms.argument = 10\n"",
            ""syms.decorator = 11\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.COMMENT}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')\n"",
            ""def is_vararg(prevp, within): return False\n"",
            ""def parent_type(p): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""syms.varargslist = 7\n"",
            ""syms.factor = 8\n"",
            ""syms.star_expr = 9\n"",
            ""syms.argument = 10\n"",
            ""syms.decorator = 11\n"",
            ""syms.dotted_name = 12\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.subscript), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME, token.EQUAL}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""def is_vararg(prevp, within): return False\n"",
            ""def parent_type(leaf): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.subscript = 1\n"",
            ""syms.subscriptlist = 2\n"",
            ""syms.sliceop = 3\n"",
            ""syms.arglist = 4\n"",
            ""syms.parameters = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""syms.varargslist = 7\n"",
            ""syms.factor = 8\n"",
            ""syms.star_expr = 9\n"",
            ""syms.argument = 10\n"",
            ""syms.decorator = 11\n"",
            ""def parent_type(p): return syms.arglist\n"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS}\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.subscript), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.EQUAL}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')\n"",
            ""def is_vararg(prevp, within): return False\n"",
            ""def parent_type(leaf): return syms.subscript\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""syms.varargslist = 7\n"",
            ""syms.factor = 8\n"",
            ""syms.star_expr = 9\n"",
            ""syms.argument = 10\n"",
            ""syms.decorator = 11\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.subscript), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.EQUAL, token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')\n"",
            ""def is_vararg(prevp, within): return True\n"",
            ""def parent_type(leaf): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.subscript = 1\n"",
            ""syms.subscriptlist = 2\n"",
            ""syms.sliceop = 3\n"",
            ""syms.arguments = 4\n"",
            ""syms.parameters = 5\n"",
            ""syms.varargslist = 6\n"",
            ""syms.typedargslist = 7\n"",
            ""syms.factor = 8\n"",
            ""syms.star_expr = 9\n"",
            ""syms.argument = 10\n"",
            ""syms.decorator = 11\n"",
            ""def parent_type(leaf): return syms.arglist\n"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS}\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')\n"",
            ""def is_vararg(prevp, within): return False\n"",
            ""def parent_type(p): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.typedargslist = 3\n"",
            ""syms.subscript = 4\n"",
            ""syms.subscriptlist = 5\n"",
            ""syms.sliceop = 6\n"",
            ""syms.factor = 7\n"",
            ""syms.star_expr = 8\n"",
            ""syms.argument = 9\n"",
            ""syms.decorator = 10\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.EQUAL, parent=MockParent(type=syms.typedargslist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.EQUAL}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value', prev_sibling=None)\n"",
            ""def is_vararg(prevp, within): return False\n"",
            ""def parent_type(p): return syms.argument\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.typedargslist = 1\n"",
            ""syms.argument = 2\n"",
            ""syms.parameters = 3\n"",
            ""syms.varargslist = 4\n"",
            ""syms.subscript = 5\n"",
            ""syms.subscriptlist = 6\n"",
            ""syms.sliceop = 7\n"",
            ""syms.factor = 8\n"",
            ""syms.star_expr = 9\n"",
            ""syms.decorators = 10\n"",
            ""syms.call = 11\n"",
            ""def parent_type(p): return syms.typedargslist""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.EQUAL, parent=MockParent(type=syms.typedargslist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME, token.EQUAL}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')\n"",
            ""def is_vararg(prevp, within): return False\n"",
            ""def parent_type(p): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.typedargslist = 1\n"",
            ""syms.argument = 2\n"",
            ""syms.parameters = 3\n"",
            ""syms.varargslist = 4\n"",
            ""syms.subscript = 5\n"",
            ""syms.subscriptlist = 6\n"",
            ""syms.sliceop = 7\n"",
            ""syms.factor = 8\n"",
            ""syms.star_expr = 9\n"",
            ""syms.dotted_name = 10\n"",
            ""def parent_type(p): return syms.typedargslist""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.parameters), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.COMMENT}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')\n"",
            ""def is_vararg(prevp, within): return False\n"",
            ""def parent_type(p): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.parameters = 1\n"",
            ""syms.arglist = 2\n"",
            ""syms.subscript = 3\n"",
            ""syms.subscriptlist = 4\n"",
            ""syms.sliceop = 5\n"",
            ""syms.typedargslist = 6\n"",
            ""syms.varargslist = 7\n"",
            ""syms.factor = 8\n"",
            ""syms.star_expr = 9\n"",
            ""syms.argument = 10\n"",
            ""syms.decorator = 11\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final"",
            ""import token"",
            ""import syms""
        ],
        ""initialization"": [
            ""class MockLeaf:\n    def __init__(self, type, parent, value, prev_sibling=None):\n        self.type = type\n        self.parent = parent\n        self.value = value\n        self.prev_sibling = prev_sibling\n"",
            ""class MockParent:\n    def __init__(self, type):\n        self.type = type\n"",
            ""leaf = MockLeaf(type=token.COLON, parent=MockParent(type=syms.arglist), value='test_value')"",
            ""ALWAYS_NO_SPACE = {token.NAME}\n"",
            ""OPENING_BRACKETS = {token.LPAR}\n"",
            ""VARARGS_SPECIALS = {token.STAR}\n"",
            ""TYPED_NAMES = {token.NAME}\n"",
            ""complex_subscript = False\n"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')\n"",
            ""def is_vararg(prevp, within): return False\n"",
            ""def parent_type(p): return syms.arglist\n"",
            ""syms = type('syms', (), {})()\n"",
            ""syms.arglist = 1\n"",
            ""syms.parameters = 2\n"",
            ""syms.varargslist = 3\n"",
            ""syms.typedargslist = 4\n"",
            ""syms.subscript = 5\n"",
            ""syms.subscriptlist = 6\n"",
            ""syms.sliceop = 7\n"",
            ""syms.factor = 8\n"",
            ""syms.star_expr = 9\n"",
            ""syms.argument = 10\n"",
            ""syms.decorator = 11\n"",
            ""syms.dotted_name = 12\n""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.EQUAL}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.varargslist = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 10# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.decorator = 11# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.varargslist = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 10# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.decorator = 11# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.dotted_name = 12# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME, token.EQUAL}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.varargslist = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 10# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.decorator = 11# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS}# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.EQUAL}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='previous')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.subscript# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.varargslist = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 10# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.decorator = 11# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.EQUAL, token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return True# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arguments = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.varargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 10# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.decorator = 11# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(leaf): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""MATH_OPERATORS = {token.PLUS, token.MINUS}# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.decorator = 10# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.EQUAL}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value', prev_sibling=None)# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.argument# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.varargslist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.decorators = 10# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.call = 11# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.typedargslist # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME, token.EQUAL}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.varargslist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.dotted_name = 10# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.typedargslist # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.COMMENT}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.varargslist = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 10# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.decorator = 11# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Final # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, parent, value, prev_sibling=None):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.parent = parent# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.prev_sibling = prev_sibling# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockParent:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""ALWAYS_NO_SPACE = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""OPENING_BRACKETS = {token.LPAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""VARARGS_SPECIALS = {token.STAR}# pragma: no cover"",
            "" # pragma: no cover"",
            ""TYPED_NAMES = {token.NAME}# pragma: no cover"",
            "" # pragma: no cover"",
            ""complex_subscript = False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def preceding_leaf(p): return MockLeaf(type=token.COMMA, parent=None, value='prev_value')# pragma: no cover"",
            "" # pragma: no cover"",
            ""def is_vararg(prevp, within): return False# pragma: no cover"",
            "" # pragma: no cover"",
            ""def parent_type(p): return syms.arglist# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms = type('syms', (), {})()# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.arglist = 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.parameters = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.varargslist = 3# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.typedargslist = 4# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscript = 5# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.subscriptlist = 6# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.sliceop = 7# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.factor = 8# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.star_expr = 9# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.argument = 10# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.decorator = 11# pragma: no cover"",
            "" # pragma: no cover"",
            ""syms.dotted_name = 12# pragma: no cover"",
            "" # pragma: no cover""
        ]
    }
]",3,8926,0.004463,4184,0.006276,0.010739
