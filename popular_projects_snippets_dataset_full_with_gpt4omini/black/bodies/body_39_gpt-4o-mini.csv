prompt,raw_predictions,predictions,prompt_type,input_size,input_price,output_size,output_price,total_price
"Provide self-contained and concrete Python values to initialize the undefined variables in the code snippet.

# begin code snippet
""""""Split according to delimiters of the highest priority.

    If the appropriate Features are given, the split will add trailing commas
    also in function signatures and calls that contain `*` and `**`.
    """"""
try:
    last_leaf = line.leaves[-1]
except IndexError:
    raise CannotSplit(""Line empty"") from None

bt = line.bracket_tracker
try:
    delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})
except ValueError:
    raise CannotSplit(""No delimiters found"") from None

if delimiter_priority == DOT_PRIORITY:
    if bt.delimiter_count_with_priority(delimiter_priority) == 1:
        raise CannotSplit(""Splitting a single attribute from its owner looks wrong"")

current_line = Line(
    mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets
)
lowest_depth = sys.maxsize
trailing_comma_safe = True

def append_to_line(leaf: Leaf) -> Iterator[Line]:
    """"""Append `leaf` to current line or to new line if appending impossible.""""""
    nonlocal current_line
    try:
        current_line.append_safe(leaf, preformatted=True)
    except ValueError:
        exit(current_line)

        current_line = Line(
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets
        )
        current_line.append(leaf)

for leaf in line.leaves:
    exit(append_to_line(leaf))

    for comment_after in line.comments_after(leaf):
        exit(append_to_line(comment_after))

    lowest_depth = min(lowest_depth, leaf.bracket_depth)
    if leaf.bracket_depth == lowest_depth:
        if is_vararg(leaf, within={syms.typedargslist}):
            trailing_comma_safe = (
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features
            )
        elif is_vararg(leaf, within={syms.arglist, syms.argument}):
            trailing_comma_safe = (
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features
            )

    leaf_priority = bt.delimiters.get(id(leaf))
    if leaf_priority == delimiter_priority:
        exit(current_line)

        current_line = Line(
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets
        )
if current_line:
    if (
        trailing_comma_safe
        and delimiter_priority == COMMA_PRIORITY
        and current_line.leaves[-1].type != token.COMMA
        and current_line.leaves[-1].type != STANDALONE_COMMENT
    ):
        new_comma = Leaf(token.COMMA, "","")
        current_line.append(new_comma)
    exit(current_line)

# end code snippet

# begin undefined variables
line
CannotSplit
DOT_PRIORITY
Line
sys
Leaf
Iterator
is_vararg
syms
Feature
features
COMMA_PRIORITY
token
STANDALONE_COMMENT
# end undefined variables

# begin undefined attributes and methods
line.leaves
line.bracket_tracker
line.mode
line.depth
line.inside_brackets
sys.maxsize
line.comments_after
syms.typedargslist
Feature.TRAILING_COMMA_IN_DEF
syms.arglist
syms.argument
Feature.TRAILING_COMMA_IN_CALL
token.COMMA
# end undefined attributes and methods

Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""from enum import Enum"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Mock: pass"",
            ""line = type('MockLine', (object,), {'leaves': [], 'bracket_tracker': Mock(), 'mode': 'test_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda leaf: []})()"",
            ""line.bracket_tracker.max_delimiter_priority = lambda exclude: 1"",
            ""line.bracket_tracker.delimiter_count_with_priority = lambda priority: 1"",
            ""line.bracket_tracker.delimiters = {}"",
            ""DOT_PRIORITY = 1"",
            ""Line = type('MockLineObj', (object,), {'__init__': lambda self, mode, depth, inside_brackets: None, 'append_safe': lambda self, leaf, preformatted: None, 'append': lambda self, leaf: None, 'leaves': []})"",
            ""Leaf = type('MockLeaf', (object,), {'__init__': lambda self, type, value: None, 'type': None, 'bracket_depth': 0})"",
            ""Feature = type('MockFeature', (object,), {' TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""def is_vararg(leaf, within): return False"",
            ""syms = type('MockSymbols', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n        self.comments = []\n\n    def append_safe(self, leaf, preformatted=False): pass\n    def append(self, leaf): self.leaves.append(leaf)"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0\n\nclass BracketTracker:\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 0\n    delimiters = {}"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)\nline.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]"",
            ""line.bracket_tracker = BracketTracker()"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""features = [Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL]"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""class Syms:\n    typedargslist = 1\n    arglist = 2\n    argument = 3\n\nsyms = Syms()"",
            ""STANDALONE_COMMENT = 3"",
            ""def is_vararg(leaf, within): return True"",
            ""class Mock: pass""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLeaf: \n    def __init__(self, bracket_depth, leaf_type): \n        self.bracket_depth = bracket_depth \n        self.type = leaf_type \n\nclass MockBracketTracker: \n    def __init__(self, leaves): \n        self.leaves = leaves \n        self.delimiters = {id(leaf): 1 for leaf in leaves} \n    \n    def max_delimiter_priority(self, exclude=set()): \n        return 1 \n\n    def delimiter_count_with_priority(self, priority): \n        return 1 \n    \nclass MockLine: \n    def __init__(self, mode, depth, inside_brackets, leaves, comments_after): \n        self.mode = mode \n        self.depth = depth \n        self.inside_brackets = inside_brackets \n        self.leaves = leaves \n        self.bracket_tracker = MockBracketTracker(leaves) \n        self.comments_after = comments_after \n    \n    def append_safe(self, leaf, preformatted=False): \n        self.leaves.append(leaf) \n    \nclass Feature: \n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' \n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' \n\nclass MockToken: \n    COMMA = 1\n    STANDALONE_COMMENT = 2\n\nline = MockLine(\n    mode='test', \n    depth=0, \n    inside_brackets=False, \n    leaves=[MockLeaf(bracket_depth=0, leaf_type=1)], \n    comments_after=lambda leaf: [] \n)\n\nDOT_PRIORITY = 1\nCOMMA_PRIORITY = 2\nfeatures = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}\nsyms = type('MockSyms', (), {'typedargslist': 1, 'arglist': 1, 'argument': 1})\nLeaf = MockLeaf\ntoken = MockToken\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n    def comments_after(self, leaf):\n        return []"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return COMMA_PRIORITY\n    def delimiter_count_with_priority(self, priority):\n        return 1\n    def __init__(self):\n        self.delimiters = {}"",
            ""class Leaf:\n    def __init__(self, type_, value):\n        self.type = type_\n        self.value = value\n        self.bracket_depth = 0"",
            ""line = MockLine('test_mode', 0, False)"",
            ""delimiter_priority = COMMA_PRIORITY"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('syms', (object,), {'typedargslist': 0, 'arglist': 1, 'argument': 2})"",
            ""STANDALONE_COMMENT = 'comment'"",
            ""current_line = line""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLine: def __init__(self): self.leaves = [] self.bracket_tracker = MockBracketTracker() self.mode = 'test' self.depth = 0 self.inside_brackets = False def comments_after(self, leaf): return []"",
            ""class MockBracketTracker: def max_delimiter_priority(self, exclude): return 1 def delimiter_count_with_priority(self, priority): return 1 def __init__(self): self.delimiters = {}"",
            ""class Leaf: def __init__(self, type, value): self.type = type self.value = value self.bracket_depth = 0"",
            ""class Feature: TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""class MockSyms: typedargslist = 'typedargslist' arglist = 'arglist' argument = 'argument'"",
            ""line = MockLine()"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = MockSyms()"",
            ""class MockToken: COMMA = 'COMMA'"",
            ""token = MockToken()"",
            ""STANDALONE_COMMENT = 'STANDALONE_COMMENT'"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf('argument', 'arg')]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""from dataclasses import dataclass, field""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockBracketTracker:\n    def __init__(self):\n        self.delimiters = {}\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 1\n\nline = type('MockLine', (object,), {\n    'leaves': [Leaf(token=1), Leaf(token=2)],\n    'bracket_tracker': MockBracketTracker(),\n    'mode': 'mock_mode',\n    'depth': 0,\n    'inside_brackets': False,\n    'comments_after': lambda leaf: []\n})()"",
            ""class Leaf:\n    def __init__(self, token):\n        self.token = token\n        self.bracket_depth = 0\n    def __repr__(self): return f'Leaf(token={self.token})'"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.leaves = []\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n    def append_safe(self, leaf, preformatted):\n        self.leaves.append(leaf)\n    @property\n    def mass_size(self): return sys.maxsize\n\nLine = MockLine"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""class MockSyms:\n    typedargslist = 'typedargslist'\n    arglist = 'arglist'\n    argument = 'argument'\nsyms = MockSyms()"",
            ""COMMA_PRIORITY = 1"",
            ""class MockToken:\n    COMMA = 1\n    STANDALONE_COMMENT = 2\ntoken = MockToken()"",
            ""DOT_PRIORITY = 0""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 0, 'delimiter_count_with_priority': lambda self, priority: 0, 'delimiters': {}})(), 'mode': 'some_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})()"",
            ""class CannotSplit(Exception): pass"",
            ""DOT_PRIORITY = 0"",
            ""class Line(object):\n    def __init__(self, mode, depth, inside_brackets):\n        self.leaves = []\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n    def append(self, leaf):\n        self.leaves.append(leaf)"",
            ""Leaf = type('MockLeaf', (object,), {'bracket_depth': 0, 'type': None})"",
            ""is_vararg = lambda leaf, within: False"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})()"",
            ""class Feature(object):\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 'standalone_comment'""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token"",
            ""from dataclasses import dataclass, field"",
            ""from typing import List, Dict, Any""
        ],
        ""initialization"": [
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0\n\nclass Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.leaves = []\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n\n    def append_safe(self, leaf: Leaf, preformatted=False):\n        self.leaves.append(leaf)\n\n    def comments_after(self, leaf: Leaf):\n        return []\n\nclass CannotSplit(Exception):\n    pass\n\nline = Line(mode='test_mode', depth=0, inside_brackets=False)\nline.leaves = [Leaf(token.COMMA, ',')] * 5  # Populate with dummy leaves\nline.bracket_tracker = type('MockBracketTracker', (object,), {\n        'max_delimiter_priority': lambda self, exclude: 1,\n        'delimiter_count_with_priority': lambda self, priority: 1,\n        'delimiters': {id(line.leaves[0]): 1}\n    })()\n\nDOT_PRIORITY = 1\nCOMMA_PRIORITY = 2\nfeatures = [Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL]\nsyms = type('MockSyms', (object,), {\n    'typedargslist': 'TypedArgsList',\n    'arglist': 'ArgList',\n    'argument': 'Argument'\n})()\nFeature = type('Feature', (object,), {\n    'TRAILING_COMMA_IN_DEF': 1,\n    'TRAILING_COMMA_IN_CALL': 2\n})\nSTANDALONE_COMMENT = 3\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n    def comments_after(self, leaf):\n        return []"",
            ""class BracketTracker:\n    def __init__(self):\n        self.delimiters = {}\n    def max_delimiter_priority(self, exclude):\n        return 0\n    def delimiter_count_with_priority(self, priority):\n        return 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)\nline.leaves = [Leaf(token.COMMA, ','), Leaf('id', 'example')]\nline.bracket_tracker = BracketTracker()"",
            ""DOT_PRIORITY = 0"",
            ""COMMA_PRIORITY = 1"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class Syms:\n    typedargslist = 'typedargslist'\n    arglist = 'arglist'\n    argument = 'argument'"",
            ""syms = Syms()"",
            ""def is_vararg(leaf, within):\n    return leaf.type == 'arg'""
        ]
    },
    {
        ""imports"": [
            ""sys"",
            ""typing.Iterator""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0\n\nclass Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class BracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return DOT_PRIORITY\n    def delimiter_count_with_priority(self, priority):\n        return 1\n    def __init__(self):\n        self.delimiters = {}"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""sys.maxsize = 9223372036854775807"",
            ""def is_vararg(leaf, within):\n    return False"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""import token\nSTANDALONE_COMMENT = 'standalone_comment'""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Mock: pass # pragma: no cover"",
            ""line = type('MockLine', (object,), {'leaves': [], 'bracket_tracker': Mock(), 'mode': 'test_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda leaf: []})() # pragma: no cover"",
            ""line.bracket_tracker.max_delimiter_priority = lambda exclude: 1 # pragma: no cover"",
            ""line.bracket_tracker.delimiter_count_with_priority = lambda priority: 1 # pragma: no cover"",
            ""line.bracket_tracker.delimiters = {} # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""Line = type('MockLineObj', (object,), {'__init__': lambda self, mode, depth, inside_brackets: None, 'append_safe': lambda self, leaf, preformatted: None, 'append': lambda self, leaf: None, 'leaves': []}) # pragma: no cover"",
            ""Leaf = type('MockLeaf', (object,), {'__init__': lambda self, type, value: None, 'type': None, 'bracket_depth': 0}) # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), {' TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2}) # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""syms = type('MockSymbols', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.comments = []# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): pass# pragma: no cover"",
            ""    def append(self, leaf): self.leaves.append(leaf) # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0# pragma: no cover"",
            ""# pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 0# pragma: no cover"",
            ""    delimiters = {} # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')] # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""class Syms:# pragma: no cover"",
            ""    typedargslist = 1# pragma: no cover"",
            ""    arglist = 2# pragma: no cover"",
            ""    argument = 3# pragma: no cover"",
            ""# pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""STANDALONE_COMMENT = 3 # pragma: no cover"",
            ""def is_vararg(leaf, within): return True # pragma: no cover"",
            ""class Mock: pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, bracket_depth, leaf_type): # pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            ""        self.type = leaf_type # pragma: no cover"",
            ""# pragma: no cover"",
            ""class MockBracketTracker: # pragma: no cover"",
            ""    def __init__(self, leaves): # pragma: no cover"",
            ""        self.leaves = leaves # pragma: no cover"",
            ""        self.delimiters = {id(leaf): 1 for leaf in leaves} # pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    # pragma: no cover"",
            ""class MockLine: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets, leaves, comments_after): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = leaves # pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker(leaves) # pragma: no cover"",
            ""        self.comments_after = comments_after # pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""# pragma: no cover"",
            ""class MockToken: # pragma: no cover"",
            ""    COMMA = 1# pragma: no cover"",
            ""    STANDALONE_COMMENT = 2# pragma: no cover"",
            ""# pragma: no cover"",
            ""line = MockLine(# pragma: no cover"",
            ""    mode='test', # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    leaves=[MockLeaf(bracket_depth=0, leaf_type=1)], # pragma: no cover"",
            ""    comments_after=lambda leaf: [] # pragma: no cover"",
            "")# pragma: no cover"",
            ""# pragma: no cover"",
            ""DOT_PRIORITY = 1# pragma: no cover"",
            ""COMMA_PRIORITY = 2# pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}# pragma: no cover"",
            ""syms = type('MockSyms', (), {'typedargslist': 1, 'arglist': 1, 'argument': 1})# pragma: no cover"",
            ""Leaf = MockLeaf# pragma: no cover"",
            ""token = MockToken# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return COMMA_PRIORITY# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type_, value):# pragma: no cover"",
            ""        self.type = type_# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""line = MockLine('test_mode', 0, False) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 0, 'arglist': 1, 'argument': 2}) # pragma: no cover"",
            ""STANDALONE_COMMENT = 'comment' # pragma: no cover"",
            ""current_line = line # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('MockLine', (object,), {'leaves': [], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 0, 'delimiter_count_with_priority': lambda self, priority: 0, 'delimiters': {}})(), 'mode': 'some_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda self, leaf: []})() # pragma: no cover"",
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""DOT_PRIORITY = 0 # pragma: no cover"",
            ""class Line(object):# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def append(self, leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""Leaf = type('MockLeaf', (object,), {'bracket_depth': 0, 'type': None}) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})() # pragma: no cover"",
            ""class Feature(object):# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""from dataclasses import dataclass, field # pragma: no cover"",
            ""from typing import List, Dict, Any # pragma: no cover""
        ],
        ""initialization"": [
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf: Leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def comments_after(self, leaf: Leaf):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""# pragma: no cover"",
            ""class CannotSplit(Exception):# pragma: no cover"",
            ""    pass# pragma: no cover"",
            ""# pragma: no cover"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ',')] * 5  # Populate with dummy leaves# pragma: no cover"",
            ""line.bracket_tracker = type('MockBracketTracker', (object,), {# pragma: no cover"",
            ""        'max_delimiter_priority': lambda self, exclude: 1,# pragma: no cover"",
            ""        'delimiter_count_with_priority': lambda self, priority: 1,# pragma: no cover"",
            ""        'delimiters': {id(line.leaves[0]): 1}# pragma: no cover"",
            ""    })()# pragma: no cover"",
            ""# pragma: no cover"",
            ""DOT_PRIORITY = 1# pragma: no cover"",
            ""COMMA_PRIORITY = 2# pragma: no cover"",
            ""syms = type('MockSyms', (object,), {# pragma: no cover"",
            ""    'typedargslist': 'TypedArgsList',# pragma: no cover"",
            ""    'arglist': 'ArgList',# pragma: no cover"",
            ""    'argument': 'Argument'# pragma: no cover"",
            ""})()# pragma: no cover"",
            ""Feature = type('Feature', (object,), {# pragma: no cover"",
            ""    'TRAILING_COMMA_IN_DEF': 1,# pragma: no cover"",
            ""    'TRAILING_COMMA_IN_CALL': 2# pragma: no cover"",
            ""})# pragma: no cover"",
            ""STANDALONE_COMMENT = 3# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {}# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 0# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf('id', 'example')]# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""DOT_PRIORITY = 0 # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class Syms:# pragma: no cover"",
            ""    typedargslist = 'typedargslist'# pragma: no cover"",
            ""    arglist = 'arglist'# pragma: no cover"",
            ""    argument = 'argument' # pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""def is_vararg(leaf, within):# pragma: no cover"",
            ""    return leaf.type == 'arg' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            """"
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return DOT_PRIORITY# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""def is_vararg(leaf, within):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover""
        ]
    }
]",1,953,0.0004765,4157,0.0062355,0.006712
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 50:
    ^
SyntaxError: no binding for nonlocal 'current_line' found
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""from enum import Enum"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Mock: pass"",
            ""line = type('MockLine', (object,), {'leaves': [], 'bracket_tracker': Mock(), 'mode': 'test_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda leaf: []})()"",
            ""line.bracket_tracker.max_delimiter_priority = lambda exclude: 1"",
            ""line.bracket_tracker.delimiter_count_with_priority = lambda priority: 1"",
            ""line.bracket_tracker.delimiters = {}"",
            ""DOT_PRIORITY = 1"",
            ""Line = type('MockLineObj', (object,), {'__init__': lambda self, mode, depth, inside_brackets: None, 'append_safe': lambda self, leaf, preformatted: None, 'append': lambda self, leaf: None, 'leaves': []})"",
            ""Leaf = type('MockLeaf', (object,), {'__init__': lambda self, type, value: None, 'type': None, 'bracket_depth': 0})"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""def is_vararg(leaf, within): return False"",
            ""syms = type('MockSymbols', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""current_line = Line('test_mode', 0, False)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""from enum import Enum"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Mock: pass"",
            ""class MockLine: "",
            ""    def __init__(self):"",
            ""        self.leaves = [MockLeaf()]"",
            ""        self.bracket_tracker = MockBracketTracker()"",
            ""        self.mode = 'test_mode'"",
            ""        self.depth = 0"",
            ""        self.inside_brackets = False"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            ""class MockBracketTracker:"",
            ""    def max_delimiter_priority(self, exclude):"",
            ""        return 1"",
            ""    def delimiter_count_with_priority(self, priority):"",
            ""        return 1"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""class MockLeaf:"",
            ""    def __init__(self):"",
            ""        self.type = 'example_type'"",
            ""        self.bracket_depth = 0"",
            ""DOT_PRIORITY = 1"",
            ""Line = MockLine"",
            ""Leaf = MockLeaf"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""def is_vararg(leaf, within): return False"",
            ""syms = type('MockSymbols', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""line = MockLine()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""from enum import Enum"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Mock: pass"",
            ""line = type('MockLine', (object,), {'leaves': [], 'bracket_tracker': Mock(), 'mode': 'test_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda leaf: []})()"",
            ""line.bracket_tracker.max_delimiter_priority = lambda exclude: 1"",
            ""line.bracket_tracker.delimiter_count_with_priority = lambda priority: 1"",
            ""line.bracket_tracker.delimiters = {}"",
            ""DOT_PRIORITY = 1"",
            ""Line = type('MockLineObj', (object,), {'__init__': lambda self, mode, depth, inside_brackets: None, 'append_safe': lambda self, leaf, preformatted: None, 'append': lambda self, leaf: None, 'leaves': []})"",
            ""Leaf = type('MockLeaf', (object,), {'__init__': lambda self, type, value: None, 'type': None, 'bracket_depth': 0})"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""def is_vararg(leaf, within): return False"",
            ""syms = type('MockSymbols', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""current_line = Line('test_mode', 0, False)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""from enum import Enum"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Mock: pass"",
            ""line = type('MockLine', (object,), {'leaves': [], 'bracket_tracker': Mock(), 'mode': 'test_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda leaf: []})()"",
            ""line.bracket_tracker.max_delimiter_priority = lambda exclude: 1"",
            ""line.bracket_tracker.delimiter_count_with_priority = lambda priority: 1"",
            ""line.bracket_tracker.delimiters = {}"",
            ""DOT_PRIORITY = 1"",
            ""Line = type('MockLineObj', (object,), {'__init__': lambda self, mode, depth, inside_brackets: None, 'append_safe': lambda self, leaf, preformatted: None, 'append': lambda self, leaf: None, 'leaves': []})"",
            ""Leaf = type('MockLeaf', (object,), {'__init__': lambda self, type, value: None, 'type': None, 'bracket_depth': 0})"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""def is_vararg(leaf, within): return False"",
            ""syms = type('MockSymbols', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""current_line = Mock()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""from enum import Enum"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Mock: pass"",
            ""line = type('MockLine', (object,), {'leaves': [], 'bracket_tracker': Mock(), 'mode': 'test_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda leaf: []})()"",
            ""line.bracket_tracker.max_delimiter_priority = lambda exclude: 1"",
            ""line.bracket_tracker.delimiter_count_with_priority = lambda priority: 1"",
            ""line.bracket_tracker.delimiters = {}"",
            ""DOT_PRIORITY = 1"",
            ""Line = type('MockLineObj', (object,), {'__init__': lambda self, mode, depth, inside_brackets: None, 'append_safe': lambda self, leaf, preformatted: None, 'append': lambda self, leaf: None, 'leaves': []})"",
            ""Leaf = type('MockLeaf', (object,), {'__init__': lambda self, type, value: None, 'type': None, 'bracket_depth': 0})"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""def is_vararg(leaf, within): return False"",
            ""syms = type('MockSymbols', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""current_line = Line('test_mode', 0, False)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""from enum import Enum"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Mock: pass"",
            ""line = type('MockLine', (object,), {'leaves': [], 'bracket_tracker': Mock(), 'mode': 'test_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda leaf: []})()"",
            ""line.bracket_tracker.max_delimiter_priority = lambda exclude: 1"",
            ""line.bracket_tracker.delimiter_count_with_priority = lambda priority: 1"",
            ""line.bracket_tracker.delimiters = {}"",
            ""DOT_PRIORITY = 1"",
            ""Line = type('MockLineObj', (object,), {'__init__': lambda self, mode, depth, inside_brackets: None, 'append_safe': lambda self, leaf, preformatted: None, 'append': lambda self, leaf: None, 'leaves': []})"",
            ""Leaf = type('MockLeaf', (object,), {'__init__': lambda self, type, value: None, 'type': None, 'bracket_depth': 0})"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""def is_vararg(leaf, within): return False"",
            ""syms = type('MockSymbols', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""from enum import Enum"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Mock: pass"",
            ""line = type('MockLine', (object,), {'leaves': [], 'bracket_tracker': Mock(), 'mode': 'test_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda leaf: []})()"",
            ""line.bracket_tracker.max_delimiter_priority = lambda exclude: 1"",
            ""line.bracket_tracker.delimiter_count_with_priority = lambda priority: 1"",
            ""line.bracket_tracker.delimiters = {}"",
            ""DOT_PRIORITY = 1"",
            ""Line = type('MockLineObj', (object,), {'__init__': lambda self, mode, depth, inside_brackets: None, 'append_safe': lambda self, leaf, preformatted: None, 'append': lambda self, leaf: None, 'leaves': []})"",
            ""Leaf = type('MockLeaf', (object,), {'__init__': lambda self, type, value: None, 'type': None, 'bracket_depth': 0})"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""def is_vararg(leaf, within): return False"",
            ""syms = type('MockSymbols', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""from enum import Enum"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Mock: pass"",
            ""line = type('MockLine', (object,), {'leaves': [], 'bracket_tracker': Mock(), 'mode': 'test_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda leaf: []})()"",
            ""line.bracket_tracker.max_delimiter_priority = lambda exclude: 1"",
            ""line.bracket_tracker.delimiter_count_with_priority = lambda priority: 1"",
            ""line.bracket_tracker.delimiters = {}"",
            ""DOT_PRIORITY = 1"",
            ""Line = type('MockLineObj', (object,), {'__init__': lambda self, mode, depth, inside_brackets: None, 'append_safe': lambda self, leaf, preformatted: None, 'append': lambda self, leaf: None, 'leaves': []})"",
            ""Leaf = type('MockLeaf', (object,), {'__init__': lambda self, type, value: None, 'type': None, 'bracket_depth': 0})"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""def is_vararg(leaf, within): return False"",
            ""syms = type('MockSymbols', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""current_line = Line('test_mode', 0, False)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""from enum import Enum"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Mock: pass"",
            ""line = type('MockLine', (object,), {'leaves': [], 'bracket_tracker': Mock(), 'mode': 'test_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda leaf: []})()"",
            ""line.bracket_tracker.max_delimiter_priority = lambda exclude: 1"",
            ""line.bracket_tracker.delimiter_count_with_priority = lambda priority: 1"",
            ""line.bracket_tracker.delimiters = {}"",
            ""DOT_PRIORITY = 1"",
            ""Line = type('MockLineObj', (object,), {'__init__': lambda self, mode, depth, inside_brackets: None, 'append_safe': lambda self, leaf, preformatted: None, 'append': lambda self, leaf: None, 'leaves': []})"",
            ""Leaf = type('MockLeaf', (object,), {'__init__': lambda self, type, value: None, 'type': None, 'bracket_depth': 0})"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""def is_vararg(leaf, within): return False"",
            ""syms = type('MockSymbols', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""current_line = Line(mode='test_mode', depth=0, inside_brackets=False)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""from enum import Enum"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Mock: pass"",
            ""line = type('MockLine', (object,), {'leaves': [], 'bracket_tracker': Mock(), 'mode': 'test_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda leaf: []})()"",
            ""line.bracket_tracker.max_delimiter_priority = lambda exclude: 1"",
            ""line.bracket_tracker.delimiter_count_with_priority = lambda priority: 1"",
            ""line.bracket_tracker.delimiters = {}"",
            ""DOT_PRIORITY = 1"",
            ""Line = type('MockLineObj', (object,), {'__init__': lambda self, mode, depth, inside_brackets: None, 'append_safe': lambda self, leaf, preformatted: None, 'append': lambda self, leaf: None, 'leaves': []})"",
            ""Leaf = type('MockLeaf', (object,), {'__init__': lambda self, type, value: None, 'type': None, 'bracket_depth': 0})"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""def is_vararg(leaf, within): return False"",
            ""syms = type('MockSymbols', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""current_line = None""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Mock: pass # pragma: no cover"",
            ""line = type('MockLine', (object,), {'leaves': [], 'bracket_tracker': Mock(), 'mode': 'test_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda leaf: []})() # pragma: no cover"",
            ""line.bracket_tracker.max_delimiter_priority = lambda exclude: 1 # pragma: no cover"",
            ""line.bracket_tracker.delimiter_count_with_priority = lambda priority: 1 # pragma: no cover"",
            ""line.bracket_tracker.delimiters = {} # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""Line = type('MockLineObj', (object,), {'__init__': lambda self, mode, depth, inside_brackets: None, 'append_safe': lambda self, leaf, preformatted: None, 'append': lambda self, leaf: None, 'leaves': []}) # pragma: no cover"",
            ""Leaf = type('MockLeaf', (object,), {'__init__': lambda self, type, value: None, 'type': None, 'bracket_depth': 0}) # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2}) # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""syms = type('MockSymbols', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""current_line = Line('test_mode', 0, False) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Mock: pass # pragma: no cover"",
            ""class MockLine:  # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.leaves = [MockLeaf()] # pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker() # pragma: no cover"",
            ""        self.mode = 'test_mode' # pragma: no cover"",
            ""        self.depth = 0 # pragma: no cover"",
            ""        self.inside_brackets = False # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class MockBracketTracker: # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.type = 'example_type' # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""Line = MockLine # pragma: no cover"",
            ""Leaf = MockLeaf # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2}) # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""syms = type('MockSymbols', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""line = MockLine() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Mock: pass # pragma: no cover"",
            ""line = type('MockLine', (object,), {'leaves': [], 'bracket_tracker': Mock(), 'mode': 'test_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda leaf: []})() # pragma: no cover"",
            ""line.bracket_tracker.max_delimiter_priority = lambda exclude: 1 # pragma: no cover"",
            ""line.bracket_tracker.delimiter_count_with_priority = lambda priority: 1 # pragma: no cover"",
            ""line.bracket_tracker.delimiters = {} # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""Line = type('MockLineObj', (object,), {'__init__': lambda self, mode, depth, inside_brackets: None, 'append_safe': lambda self, leaf, preformatted: None, 'append': lambda self, leaf: None, 'leaves': []}) # pragma: no cover"",
            ""Leaf = type('MockLeaf', (object,), {'__init__': lambda self, type, value: None, 'type': None, 'bracket_depth': 0}) # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2}) # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""syms = type('MockSymbols', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""current_line = Line('test_mode', 0, False) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Mock: pass # pragma: no cover"",
            ""line = type('MockLine', (object,), {'leaves': [], 'bracket_tracker': Mock(), 'mode': 'test_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda leaf: []})() # pragma: no cover"",
            ""line.bracket_tracker.max_delimiter_priority = lambda exclude: 1 # pragma: no cover"",
            ""line.bracket_tracker.delimiter_count_with_priority = lambda priority: 1 # pragma: no cover"",
            ""line.bracket_tracker.delimiters = {} # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""Line = type('MockLineObj', (object,), {'__init__': lambda self, mode, depth, inside_brackets: None, 'append_safe': lambda self, leaf, preformatted: None, 'append': lambda self, leaf: None, 'leaves': []}) # pragma: no cover"",
            ""Leaf = type('MockLeaf', (object,), {'__init__': lambda self, type, value: None, 'type': None, 'bracket_depth': 0}) # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2}) # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""syms = type('MockSymbols', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""current_line = Mock() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Mock: pass # pragma: no cover"",
            ""line = type('MockLine', (object,), {'leaves': [], 'bracket_tracker': Mock(), 'mode': 'test_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda leaf: []})() # pragma: no cover"",
            ""line.bracket_tracker.max_delimiter_priority = lambda exclude: 1 # pragma: no cover"",
            ""line.bracket_tracker.delimiter_count_with_priority = lambda priority: 1 # pragma: no cover"",
            ""line.bracket_tracker.delimiters = {} # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""Line = type('MockLineObj', (object,), {'__init__': lambda self, mode, depth, inside_brackets: None, 'append_safe': lambda self, leaf, preformatted: None, 'append': lambda self, leaf: None, 'leaves': []}) # pragma: no cover"",
            ""Leaf = type('MockLeaf', (object,), {'__init__': lambda self, type, value: None, 'type': None, 'bracket_depth': 0}) # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2}) # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""syms = type('MockSymbols', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""current_line = Line('test_mode', 0, False) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Mock: pass # pragma: no cover"",
            ""line = type('MockLine', (object,), {'leaves': [], 'bracket_tracker': Mock(), 'mode': 'test_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda leaf: []})() # pragma: no cover"",
            ""line.bracket_tracker.max_delimiter_priority = lambda exclude: 1 # pragma: no cover"",
            ""line.bracket_tracker.delimiter_count_with_priority = lambda priority: 1 # pragma: no cover"",
            ""line.bracket_tracker.delimiters = {} # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""Line = type('MockLineObj', (object,), {'__init__': lambda self, mode, depth, inside_brackets: None, 'append_safe': lambda self, leaf, preformatted: None, 'append': lambda self, leaf: None, 'leaves': []}) # pragma: no cover"",
            ""Leaf = type('MockLeaf', (object,), {'__init__': lambda self, type, value: None, 'type': None, 'bracket_depth': 0}) # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2}) # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""syms = type('MockSymbols', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Mock: pass # pragma: no cover"",
            ""line = type('MockLine', (object,), {'leaves': [], 'bracket_tracker': Mock(), 'mode': 'test_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda leaf: []})() # pragma: no cover"",
            ""line.bracket_tracker.max_delimiter_priority = lambda exclude: 1 # pragma: no cover"",
            ""line.bracket_tracker.delimiter_count_with_priority = lambda priority: 1 # pragma: no cover"",
            ""line.bracket_tracker.delimiters = {} # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""Line = type('MockLineObj', (object,), {'__init__': lambda self, mode, depth, inside_brackets: None, 'append_safe': lambda self, leaf, preformatted: None, 'append': lambda self, leaf: None, 'leaves': []}) # pragma: no cover"",
            ""Leaf = type('MockLeaf', (object,), {'__init__': lambda self, type, value: None, 'type': None, 'bracket_depth': 0}) # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2}) # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""syms = type('MockSymbols', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Mock: pass # pragma: no cover"",
            ""line = type('MockLine', (object,), {'leaves': [], 'bracket_tracker': Mock(), 'mode': 'test_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda leaf: []})() # pragma: no cover"",
            ""line.bracket_tracker.max_delimiter_priority = lambda exclude: 1 # pragma: no cover"",
            ""line.bracket_tracker.delimiter_count_with_priority = lambda priority: 1 # pragma: no cover"",
            ""line.bracket_tracker.delimiters = {} # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""Line = type('MockLineObj', (object,), {'__init__': lambda self, mode, depth, inside_brackets: None, 'append_safe': lambda self, leaf, preformatted: None, 'append': lambda self, leaf: None, 'leaves': []}) # pragma: no cover"",
            ""Leaf = type('MockLeaf', (object,), {'__init__': lambda self, type, value: None, 'type': None, 'bracket_depth': 0}) # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2}) # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""syms = type('MockSymbols', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""current_line = Line('test_mode', 0, False) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Mock: pass # pragma: no cover"",
            ""line = type('MockLine', (object,), {'leaves': [], 'bracket_tracker': Mock(), 'mode': 'test_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda leaf: []})() # pragma: no cover"",
            ""line.bracket_tracker.max_delimiter_priority = lambda exclude: 1 # pragma: no cover"",
            ""line.bracket_tracker.delimiter_count_with_priority = lambda priority: 1 # pragma: no cover"",
            ""line.bracket_tracker.delimiters = {} # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""Line = type('MockLineObj', (object,), {'__init__': lambda self, mode, depth, inside_brackets: None, 'append_safe': lambda self, leaf, preformatted: None, 'append': lambda self, leaf: None, 'leaves': []}) # pragma: no cover"",
            ""Leaf = type('MockLeaf', (object,), {'__init__': lambda self, type, value: None, 'type': None, 'bracket_depth': 0}) # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2}) # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""syms = type('MockSymbols', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""current_line = Line(mode='test_mode', depth=0, inside_brackets=False) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from enum import Enum # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Mock: pass # pragma: no cover"",
            ""line = type('MockLine', (object,), {'leaves': [], 'bracket_tracker': Mock(), 'mode': 'test_mode', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda leaf: []})() # pragma: no cover"",
            ""line.bracket_tracker.max_delimiter_priority = lambda exclude: 1 # pragma: no cover"",
            ""line.bracket_tracker.delimiter_count_with_priority = lambda priority: 1 # pragma: no cover"",
            ""line.bracket_tracker.delimiters = {} # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""Line = type('MockLineObj', (object,), {'__init__': lambda self, mode, depth, inside_brackets: None, 'append_safe': lambda self, leaf, preformatted: None, 'append': lambda self, leaf: None, 'leaves': []}) # pragma: no cover"",
            ""Leaf = type('MockLeaf', (object,), {'__init__': lambda self, type, value: None, 'type': None, 'bracket_depth': 0}) # pragma: no cover"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2}) # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""syms = type('MockSymbols', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""current_line = None # pragma: no cover""
        ]
    }
]",2,1642,0.000821,4162,0.006243,0.007064
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 73:
    ^
SyntaxError: no binding for nonlocal 'current_line' found
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n\n    def append_safe(self, leaf, preformatted=False): pass\n    def append(self, leaf): self.leaves.append(leaf)"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class BracketTracker:\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 1\n    delimiters = {}"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)\nline.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]\nline.bracket_tracker = BracketTracker()"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""features = {1, 2}"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""class Syms:\n    typedargslist = 1\n    arglist = 2\n    argument = 3"",
            ""syms = Syms()"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""def is_vararg(leaf, within): return True"",
            ""current_line = None""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n\n    def append_safe(self, leaf, preformatted=False): pass\n    def append(self, leaf): self.leaves.append(leaf)"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class BracketTracker:\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 1\n    delimiters = {}"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)\nline.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]\nline.bracket_tracker = BracketTracker()"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""features = [Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL]"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""class Syms:\n    typedargslist = 1\n    arglist = 2\n    argument = 3\n\nsyms = Syms()"",
            ""STANDALONE_COMMENT = 3"",
            ""current_line = None"",
            ""def is_vararg(leaf, within): return True"",
            ""def append_to_line(leaf: Leaf) -> Iterator[Line]:\n    nonlocal current_line\n    current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)\n    current_line.append_safe(leaf, preformatted=True)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n\n    def append(self, leaf):\n        self.leaves.append(leaf)"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class BracketTracker:\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 2\n    delimiters = {}"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)\nline.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]\nline.bracket_tracker = BracketTracker()"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class Syms:\n    typedargslist = 1\n    arglist = 2\n    argument = 3"",
            ""syms = Syms()"",
            ""STANDALONE_COMMENT = 3"",
            ""def is_vararg(leaf, within): return True"",
            ""current_line = Line(mode='test', depth=0, inside_brackets=False)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n        self.comments = []\n\n    def append_safe(self, leaf, preformatted=False):\n        if leaf.type == token.COMMA:\n            raise ValueError('Append failed')\n        self.leaves.append(leaf)\n\n    def append(self, leaf):\n        self.leaves.append(leaf)"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class BracketTracker:\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 1\n    delimiters = {}"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)\nline.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]\nline.bracket_tracker = BracketTracker()"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""features = {1, 2}"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""class Syms:\n    typedargslist = 1\n    arglist = 2\n    argument = 3\n\nsyms = Syms()"",
            ""STANDALONE_COMMENT = 3"",
            ""def is_vararg(leaf, within): return True"",
            ""current_line = None""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n        self.comments = []\n\n    def append_safe(self, leaf, preformatted=False): pass\n    def append(self, leaf): self.leaves.append(leaf)"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0\n\nclass BracketTracker:\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 1\n    delimiters = {}"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)\nline.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]\nline.bracket_tracker = BracketTracker()"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""features = {1, 2}"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""class Syms:\n    typedargslist = 1\n    arglist = 2\n    argument = 3\n\nsyms = Syms()"",
            ""STANDALONE_COMMENT = 3"",
            ""def is_vararg(leaf, within): return True"",
            ""current_line = None"",
            ""def append_to_line(leaf):\n    global current_line\n    current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)\n    current_line.append(leaf)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n\n    def append_safe(self, leaf, preformatted=False): pass\n    def append(self, leaf): self.leaves.append(leaf)"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class BracketTracker:\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 1\n    delimiters = {}"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)\nline.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]\nline.bracket_tracker = BracketTracker()"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class Syms:\n    typedargslist = 1\n    arglist = 2\n    argument = 3\n\nsyms = Syms()"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""def is_vararg(leaf, within): return True"",
            ""current_line = None""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n\n    def append_safe(self, leaf, preformatted=False):\n        pass\n    def append(self, leaf):\n        self.leaves.append(leaf)"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class BracketTracker:\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 0\n    delimiters = { }"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)\nline.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]\nline.bracket_tracker = BracketTracker()"",
            ""current_line = None"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class Syms:\n    typedargslist = 1\n    arglist = 2\n    argument = 3\n\nsyms = Syms()"",
            ""STANDALONE_COMMENT = 3"",
            ""def is_vararg(leaf, within): return True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n        self.comments = []\n\n    def append_safe(self, leaf, preformatted=False): pass\n    def append(self, leaf): self.leaves.append(leaf)"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0\n\nclass BracketTracker:\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 0\n    delimiters = {}"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)\nline.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]\nline.bracket_tracker = BracketTracker()"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""features = [Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL]"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""class Syms:\n    typedargslist = 1\n    arglist = 2\n    argument = 3\n\nsyms = Syms()"",
            ""STANDALONE_COMMENT = 3"",
            ""def is_vararg(leaf, within): return True"",
            ""def append_to_line(leaf):\n    global current_line\n    try:\n        current_line.append_safe(leaf, preformatted=True)\n    except ValueError:\n        exit(current_line)\n    current_line.append(leaf)"",
            ""current_line = Line(mode='test', depth=0, inside_brackets=False)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n\n    def append_safe(self, leaf, preformatted=False): pass\n    def append(self, leaf): self.leaves.append(leaf)"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class BracketTracker:\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 1\n    delimiters = {}"",
            ""bt = BracketTracker()"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)\nline.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]"",
            ""line.bracket_tracker = bt"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class Syms:\n    typedargslist = 1\n    arglist = 2\n    argument = 3"",
            ""syms = Syms()"",
            ""STANDALONE_COMMENT = 3"",
            ""def is_vararg(leaf, within): return True"",
            ""current_line = None""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n\n    def append_safe(self, leaf, preformatted=False):\n        if len(self.leaves) < 2:  # Mock logic\n            self.leaves.append(leaf)\n        else:\n            raise ValueError('Cannot append')\n\n    def append(self, leaf): self.leaves.append(leaf)"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class BracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1\n    delimiters = {}"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)\nline.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]\nline.bracket_tracker = BracketTracker()"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class Syms:\n    typedargslist = 1\n    arglist = 2\n    argument = 3\n\nsyms = Syms()"",
            ""STANDALONE_COMMENT = 3"",
            ""def is_vararg(leaf, within): return True"",
            ""current_line = None""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): pass# pragma: no cover"",
            ""    def append(self, leaf): self.leaves.append(leaf) # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1# pragma: no cover"",
            ""    delimiters = {} # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""features = {1, 2} # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""class Syms:# pragma: no cover"",
            ""    typedargslist = 1# pragma: no cover"",
            ""    arglist = 2# pragma: no cover"",
            ""    argument = 3 # pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""def is_vararg(leaf, within): return True # pragma: no cover"",
            ""current_line = None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): pass# pragma: no cover"",
            ""    def append(self, leaf): self.leaves.append(leaf) # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1# pragma: no cover"",
            ""    delimiters = {} # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""class Syms:# pragma: no cover"",
            ""    typedargslist = 1# pragma: no cover"",
            ""    arglist = 2# pragma: no cover"",
            ""    argument = 3# pragma: no cover"",
            ""# pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""STANDALONE_COMMENT = 3 # pragma: no cover"",
            ""current_line = None # pragma: no cover"",
            ""def is_vararg(leaf, within): return True # pragma: no cover"",
            ""def append_to_line(leaf: Leaf) -> Iterator[Line]:# pragma: no cover"",
            ""    current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)# pragma: no cover"",
            ""    current_line.append_safe(leaf, preformatted=True) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append(self, leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2# pragma: no cover"",
            ""    delimiters = {} # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class Syms:# pragma: no cover"",
            ""    typedargslist = 1# pragma: no cover"",
            ""    arglist = 2# pragma: no cover"",
            ""    argument = 3 # pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""STANDALONE_COMMENT = 3 # pragma: no cover"",
            ""def is_vararg(leaf, within): return True # pragma: no cover"",
            ""current_line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.comments = []# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        if leaf.type == token.COMMA:# pragma: no cover"",
            ""            raise ValueError('Append failed')# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append(self, leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1# pragma: no cover"",
            ""    delimiters = {} # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""features = {1, 2} # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""class Syms:# pragma: no cover"",
            ""    typedargslist = 1# pragma: no cover"",
            ""    arglist = 2# pragma: no cover"",
            ""    argument = 3# pragma: no cover"",
            ""# pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""STANDALONE_COMMENT = 3 # pragma: no cover"",
            ""def is_vararg(leaf, within): return True # pragma: no cover"",
            ""current_line = None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.comments = []# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): pass# pragma: no cover"",
            ""    def append(self, leaf): self.leaves.append(leaf) # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0# pragma: no cover"",
            ""# pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1# pragma: no cover"",
            ""    delimiters = {} # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""features = {1, 2} # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""class Syms:# pragma: no cover"",
            ""    typedargslist = 1# pragma: no cover"",
            ""    arglist = 2# pragma: no cover"",
            ""    argument = 3# pragma: no cover"",
            ""# pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""STANDALONE_COMMENT = 3 # pragma: no cover"",
            ""def is_vararg(leaf, within): return True # pragma: no cover"",
            ""current_line = None # pragma: no cover"",
            ""def append_to_line(leaf):# pragma: no cover"",
            ""    global current_line# pragma: no cover"",
            ""    current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)# pragma: no cover"",
            ""    current_line.append(leaf) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): pass# pragma: no cover"",
            ""    def append(self, leaf): self.leaves.append(leaf) # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1# pragma: no cover"",
            ""    delimiters = {} # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class Syms:# pragma: no cover"",
            ""    typedargslist = 1# pragma: no cover"",
            ""    arglist = 2# pragma: no cover"",
            ""    argument = 3# pragma: no cover"",
            ""# pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""def is_vararg(leaf, within): return True # pragma: no cover"",
            ""current_line = None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        pass# pragma: no cover"",
            ""    def append(self, leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 0# pragma: no cover"",
            ""    delimiters = { } # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""current_line = None # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class Syms:# pragma: no cover"",
            ""    typedargslist = 1# pragma: no cover"",
            ""    arglist = 2# pragma: no cover"",
            ""    argument = 3# pragma: no cover"",
            ""# pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""STANDALONE_COMMENT = 3 # pragma: no cover"",
            ""def is_vararg(leaf, within): return True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.comments = []# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): pass# pragma: no cover"",
            ""    def append(self, leaf): self.leaves.append(leaf) # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0# pragma: no cover"",
            ""# pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 0# pragma: no cover"",
            ""    delimiters = {} # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""class Syms:# pragma: no cover"",
            ""    typedargslist = 1# pragma: no cover"",
            ""    arglist = 2# pragma: no cover"",
            ""    argument = 3# pragma: no cover"",
            ""# pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""STANDALONE_COMMENT = 3 # pragma: no cover"",
            ""def is_vararg(leaf, within): return True # pragma: no cover"",
            ""def append_to_line(leaf):# pragma: no cover"",
            ""    global current_line# pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): pass# pragma: no cover"",
            ""    def append(self, leaf): self.leaves.append(leaf) # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1# pragma: no cover"",
            ""    delimiters = {} # pragma: no cover"",
            ""bt = BracketTracker() # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')] # pragma: no cover"",
            ""line.bracket_tracker = bt # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class Syms:# pragma: no cover"",
            ""    typedargslist = 1# pragma: no cover"",
            ""    arglist = 2# pragma: no cover"",
            ""    argument = 3 # pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""STANDALONE_COMMENT = 3 # pragma: no cover"",
            ""def is_vararg(leaf, within): return True # pragma: no cover"",
            ""current_line = None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        if len(self.leaves) < 2:  # Mock logic# pragma: no cover"",
            ""            self.leaves.append(leaf)# pragma: no cover"",
            ""        else:# pragma: no cover"",
            ""            raise ValueError('Cannot append')# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append(self, leaf): self.leaves.append(leaf) # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    delimiters = {} # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class Syms:# pragma: no cover"",
            ""    typedargslist = 1# pragma: no cover"",
            ""    arglist = 2# pragma: no cover"",
            ""    argument = 3# pragma: no cover"",
            ""# pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""STANDALONE_COMMENT = 3 # pragma: no cover"",
            ""def is_vararg(leaf, within): return True # pragma: no cover"",
            ""current_line = None # pragma: no cover""
        ]
    }
]",2,2340,0.00117,4307,0.0064605,0.0076305
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 87:
    ^
SyntaxError: no binding for nonlocal 'current_line' found
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLeaf: \n    def __init__(self, bracket_depth, leaf_type): \n        self.bracket_depth = bracket_depth \n        self.type = leaf_type \n\nclass MockBracketTracker: \n    def __init__(self, leaves): \n        self.leaves = leaves \n        self.delimiters = {id(leaf): 1 for leaf in leaves} \n    \n    def max_delimiter_priority(self, exclude=set()): \n        return 1 \n\n    def delimiter_count_with_priority(self, priority): \n        return 1 \n    \nclass MockLine: \n    def __init__(self, mode, depth, inside_brackets, leaves, comments_after): \n        self.mode = mode \n        self.depth = depth \n        self.inside_brackets = inside_brackets \n        self.leaves = leaves \n        self.bracket_tracker = MockBracketTracker(leaves) \n        self.comments_after = comments_after \n    \n    def append_safe(self, leaf, preformatted=False): \n        self.leaves.append(leaf) \n    \n    def append(self, leaf): \n        self.leaves.append(leaf)\n\nclass Feature: \n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' \n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' \n\nclass MockToken: \n    COMMA = 1\n    STANDALONE_COMMENT = 2\n\nline = MockLine(\n    mode='test', \n    depth=0, \n    inside_brackets=False, \n    leaves=[MockLeaf(bracket_depth=0, leaf_type=1)], \n    comments_after=lambda leaf: [] \n)\n\nDOT_PRIORITY = 1\nCOMMA_PRIORITY = 2\nfeatures = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}\nsyms = type('MockSyms', (), {'typedargslist': 1, 'arglist': 1, 'argument': 1})\n\ncurrent_line = line\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n        self.comments = []\n    \n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n    \n    def append(self, leaf):\n        self.leaves.append(leaf)"",
            ""class BracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return 1\n    \n    def delimiter_count_with_priority(self, priority):\n        return 1\n    \n    def __init__(self):\n        self.delimiters = {}"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)\nline.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]\nline.bracket_tracker = BracketTracker()"",
            ""DOT_PRIORITY = 1\nCOMMA_PRIORITY = 2"",
            ""Feature = type('Feature', (), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class MockSyms:\n    typedargslist = object()\n    arglist = object()\n    argument = object()"",
            ""syms = MockSyms()"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""def is_vararg(leaf, within): return True"",
            ""current_line = None""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLeaf:\n    def __init__(self, bracket_depth, leaf_type):\n        self.bracket_depth = bracket_depth\n        self.type = leaf_type\n\nclass MockBracketTracker:\n    def __init__(self, leaves):\n        self.leaves = leaves\n        self.delimiters = {id(leaf): 1 for leaf in leaves}\n    \n    def max_delimiter_priority(self, exclude=set()):\n        return 1\n\n    def delimiter_count_with_priority(self, priority):\n        return len(self.leaves)\n\nclass MockLine:\n    def __init__(self, mode, depth, inside_brackets, leaves, comments_after):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = leaves\n        self.bracket_tracker = MockBracketTracker(leaves)\n        self.comments_after = comments_after\n\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n\nDOT_PRIORITY = 1\nCOMMA_PRIORITY = 2\nfeatures = [1, 2]  # Mocked Feature enum values\nsyms = type('MockSyms', (), {'typedargslist': 1, 'arglist': 1, 'argument': 1})\n\n# Initialize leaves and line\nleaf1 = MockLeaf(0, token.COMMA)\nleaf2 = MockLeaf(0, token.STANDALONE_COMMENT)\nline = MockLine(\n    mode='test',\n    depth=0,\n    inside_brackets=False,\n    leaves=[leaf1, leaf2],\n    comments_after=lambda leaf: []\n)\n\ncurrent_line = None\n\n# Now we define the nonlocal current_line in a function\ndef set_current_line():\n    global current_line\n    current_line = MockLine(\n        mode=line.mode,\n        depth=line.depth,\n        inside_brackets=line.inside_brackets,\n        leaves=[],\n        comments_after=lambda leaf: []\n    )\n\nset_current_line()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLeaf: \n    def __init__(self, bracket_depth, leaf_type): \n        self.bracket_depth = bracket_depth \n        self.type = leaf_type"",
            ""class MockBracketTracker: \n    def __init__(self, leaves): \n        self.leaves = leaves \n        self.delimiters = {id(leaf): 1 for leaf in leaves} \n    \n    def max_delimiter_priority(self, exclude=set()): \n        return 1 \n\n    def delimiter_count_with_priority(self, priority): \n        return 1"",
            ""class MockLine: \n    def __init__(self, mode, depth, inside_brackets, leaves, comments_after): \n        self.mode = mode \n        self.depth = depth \n        self.inside_brackets = inside_brackets \n        self.leaves = leaves \n        self.bracket_tracker = MockBracketTracker(leaves) \n        self.comments_after = comments_after \n    \n    def append_safe(self, leaf, preformatted=False): \n        self.leaves.append(leaf) \n    \n    def append(self, leaf): \n        self.leaves.append(leaf)"",
            ""class Feature: \n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' \n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""class MockToken: \n    COMMA = 1\n    STANDALONE_COMMENT = 2"",
            ""leaves = [MockLeaf(bracket_depth=0, leaf_type=MockToken.COMMA) for _ in range(3)]\ncomments_after = lambda leaf: []"",
            ""line = MockLine(mode='test', depth=0, inside_brackets=False, leaves=leaves, comments_after=comments_after)"",
            ""DOT_PRIORITY = 1\nCOMMA_PRIORITY = 2\nfeatures = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}\nsyms = type('MockSyms', (), {'typedargslist': 1, 'arglist': 1, 'argument': 1})\nLeaf = MockLeaf\ntoken = MockToken\ncurrent_line = None\n\ndef append_to_line(leaf: MockLeaf) -> Iterator[MockLine]:\n    global current_line\n    current_line = line\n    current_line.append_safe(leaf, preformatted=True)\n    return iter([current_line])""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n\n    def append_safe(self, leaf, preformatted=False):\n        if len(self.leaves) < 5:\n            self.leaves.append(leaf)\n        else:\n            raise ValueError('Cannot append leaf')\n\n    def append(self, leaf):\n        self.leaves.append(leaf)"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 1\n    delimiters = {}"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)\nline.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]\nline.bracket_tracker = MockBracketTracker()"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class MockSyms:\n    typedargslist = 1\n    arglist = 2\n    argument = 3"",
            ""syms = MockSyms()"",
            ""STANDALONE_COMMENT = 3"",
            ""def is_vararg(leaf, within): return True"",
            ""current_line = Line(mode='test_mode', depth=0, inside_brackets=False)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLeaf: \n    def __init__(self, bracket_depth, leaf_type): \n        self.bracket_depth = bracket_depth \n        self.type = leaf_type \n\nclass MockBracketTracker: \n    def __init__(self, leaves): \n        self.leaves = leaves \n        self.delimiters = {id(leaf): 1 for leaf in leaves} \n    \n    def max_delimiter_priority(self, exclude=set()): \n        return 1 \n\n    def delimiter_count_with_priority(self, priority): \n        return 1 \n    \nclass MockLine: \n    def __init__(self, mode, depth, inside_brackets, leaves, comments_after): \n        self.mode = mode \n        self.depth = depth \n        self.inside_brackets = inside_brackets \n        self.leaves = leaves \n        self.bracket_tracker = MockBracketTracker(leaves) \n        self.comments_after = comments_after \n    \n    def append_safe(self, leaf, preformatted=False): \n        self.leaves.append(leaf) \n    \nclass Feature: \n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' \n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' \n\nclass MockToken: \n    COMMA = 1\n    STANDALONE_COMMENT = 2\n\nline = MockLine(\n    mode='test', \n    depth=0, \n    inside_brackets=False, \n    leaves=[MockLeaf(0, MockToken.COMMA)], \n    comments_after=lambda leaf: [] \n)\n\nDOT_PRIORITY = 1\nCOMMA_PRIORITY = 2\nfeatures = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}\nsyms = type('MockSyms', (), {'typedargslist': 1, 'arglist': 1, 'argument': 1})\nLeaf = MockLeaf\n\ndef is_vararg(leaf, within):\n    return False\n\ncurrent_line = None\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLeaf: \n    def __init__(self, bracket_depth, leaf_type): \n        self.bracket_depth = bracket_depth \n        self.type = leaf_type \n\nclass MockBracketTracker: \n    def __init__(self, leaves): \n        self.leaves = leaves \n        self.delimiters = {id(leaf): 1 for leaf in leaves} \n    \n    def max_delimiter_priority(self, exclude=set()): \n        return 1 \n\n    def delimiter_count_with_priority(self, priority): \n        return 1 \n    \nclass MockLine: \n    def __init__(self, mode, depth, inside_brackets): \n        self.mode = mode \n        self.depth = depth \n        self.inside_brackets = inside_brackets \n        self.leaves = [] \n        self.bracket_tracker = MockBracketTracker(self.leaves) \n    \n    def append_safe(self, leaf, preformatted=False): \n        self.leaves.append(leaf) \n    \nclass Feature: \n    TRAILING_COMMA_IN_DEF = 1 \n    TRAILING_COMMA_IN_CALL = 2 \n\nclass MockToken: \n    COMMA = 1\n    STANDALONE_COMMENT = 2\n\n# Initialize line with appropriate parameters\nline = MockLine(\n    mode='test', \n    depth=0, \n    inside_brackets=False \n)\n\n# Initialize line leaves and comments_after method\nline.leaves = [MockLeaf(bracket_depth=0, leaf_type=MockToken.COMMA)]\nline.comments_after = lambda leaf: []\n\nDOT_PRIORITY = 1\nCOMMA_PRIORITY = 2\nfeatures = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}\nsyms = type('MockSyms', (), {'typedargslist': 1, 'arglist': 1, 'argument': 1})\n\n# Nonlocal variable to be modified in the append_to_line function\ncurrent_line = line\nleaf = line.leaves[0]\n\ndef is_vararg(leaf, within): return True\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLeaf: \n    def __init__(self, bracket_depth, leaf_type): \n        self.bracket_depth = bracket_depth \n        self.type = leaf_type \n\nclass MockBracketTracker: \n    def __init__(self, leaves): \n        self.leaves = leaves \n        self.delimiters = {id(leaf): 1 for leaf in leaves} \n    \n    def max_delimiter_priority(self, exclude=set()): \n        return 1 \n    \n    def delimiter_count_with_priority(self, priority): \n        return 1 \n\nclass MockLine: \n    def __init__(self, mode, depth, inside_brackets, leaves, comments_after): \n        self.mode = mode \n        self.depth = depth \n        self.inside_brackets = inside_brackets \n        self.leaves = leaves \n        self.bracket_tracker = MockBracketTracker(leaves) \n        self.comments_after = comments_after \n    \n    def append_safe(self, leaf, preformatted=False): \n        if isinstance(leaf, MockLeaf): \n            self.leaves.append(leaf) \n        else: \n            raise ValueError('Cannot append non-leaf object') \n    \n    def append(self, leaf): \n        self.leaves.append(leaf) \n\nclass Feature: \n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' \n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' \n\nclass MockToken: \n    COMMA = 1\n    STANDALONE_COMMENT = 2\n\nleaves = [MockLeaf(bracket_depth=0, leaf_type=MockToken.COMMA), MockLeaf(bracket_depth=0, leaf_type=MockToken.COMMA)] \nline = MockLine(\n    mode='test', \n    depth=0, \n    inside_brackets=False, \n    leaves=leaves, \n    comments_after=lambda leaf: [] \n)\n\ncurrent_line = line \nDOT_PRIORITY = 1\nCOMMA_PRIORITY = 2\nfeatures = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}\nsyms = type('MockSyms', (), {'typedargslist': 1, 'arglist': 1, 'argument': 1})\nLeaf = MockLeaf\ntoken = MockToken\n\ndef is_vararg(leaf, within): return True\n""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLeaf:\n    def __init__(self, leaf_type, bracket_depth):\n        self.type = leaf_type\n        self.bracket_depth = bracket_depth\n"",
            ""class MockBracketTracker:\n    def __init__(self, leaves):\n        self.leaves = leaves\n        self.delimiters = {id(leaf): 1 for leaf in leaves}\n\n    def max_delimiter_priority(self, exclude=set()):\n        return 1\n\n    def delimiter_count_with_priority(self, priority):\n        return 1\n"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker(self.leaves)\n\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n\n    def append(self, leaf):\n        self.leaves.append(leaf)\n\n    def comments_after(self, leaf):\n        return []"",
            ""line = MockLine(mode='test', depth=0, inside_brackets=False)\nline.leaves = [MockLeaf(token.COMMA, 0)]\n"",
            ""DOT_PRIORITY = 1\nCOMMA_PRIORITY = 2\nfeatures = {1, 2}\nclass Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""class MockSyms:\n    typedargslist = 1\n    arglist = 2\n    argument = 3\nsyms = MockSyms()"",
            ""STANDALONE_COMMENT = 4\n\ndef is_vararg(leaf, within):\n    return True\n\ncurrent_line = None""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLeaf:\n    def __init__(self, bracket_depth, leaf_type):\n        self.bracket_depth = bracket_depth\n        self.type = leaf_type\n"",
            ""class MockBracketTracker:\n    def __init__(self, leaves):\n        self.leaves = leaves\n        self.delimiters = {id(leaf): 1 for leaf in leaves}\n    \n    def max_delimiter_priority(self, exclude=set()):\n        return 1\n\n    def delimiter_count_with_priority(self, priority):\n        return 1\n"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets, leaves):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = leaves\n        self.bracket_tracker = MockBracketTracker(leaves)\n\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n\n    def append(self, leaf):\n        self.leaves.append(leaf)\n"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2\n"",
            ""class MockToken:\n    COMMA = 1\n    STANDALONE_COMMENT = 2\n"",
            ""leaves = [MockLeaf(0, MockToken.COMMA), MockLeaf(1, MockToken.STANDALONE_COMMENT)]\nline = MockLine(mode='test', depth=0, inside_brackets=False, leaves=leaves)\nline.comments_after = lambda leaf: []\n\nDOT_PRIORITY = 1\nCOMMA_PRIORITY = 2\nfeatures = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}\nsyms = type('MockSyms', (), {'typedargslist': 1, 'arglist': 2, 'argument': 3})\n\ncurrent_line = None\n\ndef append_to_line(leaf: MockLeaf) -> Iterator[MockLine]:\n    nonlocal current_line\n    try:\n        current_line.append_safe(leaf)\n    except ValueError:\n        exit(current_line)\n        current_line = MockLine(mode='test', depth=0, inside_brackets=False, leaves=[])\n        current_line.append(leaf)\n    return current_line\n""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, bracket_depth, leaf_type): # pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            ""        self.type = leaf_type # pragma: no cover"",
            ""# pragma: no cover"",
            ""class MockBracketTracker: # pragma: no cover"",
            ""    def __init__(self, leaves): # pragma: no cover"",
            ""        self.leaves = leaves # pragma: no cover"",
            ""        self.delimiters = {id(leaf): 1 for leaf in leaves} # pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    # pragma: no cover"",
            ""class MockLine: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets, leaves, comments_after): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = leaves # pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker(leaves) # pragma: no cover"",
            ""        self.comments_after = comments_after # pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""# pragma: no cover"",
            ""class MockToken: # pragma: no cover"",
            ""    COMMA = 1# pragma: no cover"",
            ""    STANDALONE_COMMENT = 2# pragma: no cover"",
            ""# pragma: no cover"",
            ""line = MockLine(# pragma: no cover"",
            ""    mode='test', # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    leaves=[MockLeaf(bracket_depth=0, leaf_type=1)], # pragma: no cover"",
            ""    comments_after=lambda leaf: [] # pragma: no cover"",
            "")# pragma: no cover"",
            ""# pragma: no cover"",
            ""DOT_PRIORITY = 1# pragma: no cover"",
            ""COMMA_PRIORITY = 2# pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}# pragma: no cover"",
            ""syms = type('MockSyms', (), {'typedargslist': 1, 'arglist': 1, 'argument': 1})# pragma: no cover"",
            ""# pragma: no cover"",
            ""current_line = line# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.comments = []# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def append(self, leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""DOT_PRIORITY = 1# pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""Feature = type('Feature', (), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2}) # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class MockSyms:# pragma: no cover"",
            ""    typedargslist = object()# pragma: no cover"",
            ""    arglist = object()# pragma: no cover"",
            ""    argument = object() # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""def is_vararg(leaf, within): return True # pragma: no cover"",
            ""current_line = None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, bracket_depth, leaf_type): # pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            ""        self.type = leaf_type # pragma: no cover"",
            ""class MockBracketTracker: # pragma: no cover"",
            ""    def __init__(self, leaves): # pragma: no cover"",
            ""        self.leaves = leaves # pragma: no cover"",
            ""        self.delimiters = {id(leaf): 1 for leaf in leaves} # pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""class MockLine: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets, leaves, comments_after): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = leaves # pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker(leaves) # pragma: no cover"",
            ""        self.comments_after = comments_after # pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""class MockToken: # pragma: no cover"",
            ""    COMMA = 1# pragma: no cover"",
            ""    STANDALONE_COMMENT = 2 # pragma: no cover"",
            ""leaves = [MockLeaf(bracket_depth=0, leaf_type=MockToken.COMMA) for _ in range(3)]# pragma: no cover"",
            ""comments_after = lambda leaf: [] # pragma: no cover"",
            ""line = MockLine(mode='test', depth=0, inside_brackets=False, leaves=leaves, comments_after=comments_after) # pragma: no cover"",
            ""DOT_PRIORITY = 1# pragma: no cover"",
            ""COMMA_PRIORITY = 2# pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}# pragma: no cover"",
            ""syms = type('MockSyms', (), {'typedargslist': 1, 'arglist': 1, 'argument': 1})# pragma: no cover"",
            ""Leaf = MockLeaf# pragma: no cover"",
            ""token = MockToken# pragma: no cover"",
            ""current_line = None# pragma: no cover"",
            ""# pragma: no cover"",
            ""def append_to_line(leaf: MockLeaf) -> Iterator[MockLine]:# pragma: no cover"",
            ""    global current_line# pragma: no cover"",
            ""    current_line = line# pragma: no cover"",
            ""    current_line.append_safe(leaf, preformatted=True)# pragma: no cover"",
            ""    return iter([current_line]) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        if len(self.leaves) < 5:# pragma: no cover"",
            ""            self.leaves.append(leaf)# pragma: no cover"",
            ""        else:# pragma: no cover"",
            ""            raise ValueError('Cannot append leaf')# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append(self, leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1# pragma: no cover"",
            ""    delimiters = {} # pragma: no cover"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]# pragma: no cover"",
            ""line.bracket_tracker = MockBracketTracker() # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class MockSyms:# pragma: no cover"",
            ""    typedargslist = 1# pragma: no cover"",
            ""    arglist = 2# pragma: no cover"",
            ""    argument = 3 # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""STANDALONE_COMMENT = 3 # pragma: no cover"",
            ""def is_vararg(leaf, within): return True # pragma: no cover"",
            ""current_line = Line(mode='test_mode', depth=0, inside_brackets=False) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, bracket_depth, leaf_type): # pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            ""        self.type = leaf_type # pragma: no cover"",
            ""# pragma: no cover"",
            ""class MockBracketTracker: # pragma: no cover"",
            ""    def __init__(self, leaves): # pragma: no cover"",
            ""        self.leaves = leaves # pragma: no cover"",
            ""        self.delimiters = {id(leaf): 1 for leaf in leaves} # pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    # pragma: no cover"",
            ""class MockLine: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets, leaves, comments_after): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = leaves # pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker(leaves) # pragma: no cover"",
            ""        self.comments_after = comments_after # pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""# pragma: no cover"",
            ""class MockToken: # pragma: no cover"",
            ""    COMMA = 1# pragma: no cover"",
            ""    STANDALONE_COMMENT = 2# pragma: no cover"",
            ""# pragma: no cover"",
            ""line = MockLine(# pragma: no cover"",
            ""    mode='test', # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    leaves=[MockLeaf(0, MockToken.COMMA)], # pragma: no cover"",
            ""    comments_after=lambda leaf: [] # pragma: no cover"",
            "")# pragma: no cover"",
            ""# pragma: no cover"",
            ""DOT_PRIORITY = 1# pragma: no cover"",
            ""COMMA_PRIORITY = 2# pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}# pragma: no cover"",
            ""syms = type('MockSyms', (), {'typedargslist': 1, 'arglist': 1, 'argument': 1})# pragma: no cover"",
            ""Leaf = MockLeaf# pragma: no cover"",
            ""# pragma: no cover"",
            ""def is_vararg(leaf, within):# pragma: no cover"",
            ""    return False# pragma: no cover"",
            ""# pragma: no cover"",
            ""current_line = None# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, bracket_depth, leaf_type): # pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            ""        self.type = leaf_type # pragma: no cover"",
            ""# pragma: no cover"",
            ""class MockBracketTracker: # pragma: no cover"",
            ""    def __init__(self, leaves): # pragma: no cover"",
            ""        self.leaves = leaves # pragma: no cover"",
            ""        self.delimiters = {id(leaf): 1 for leaf in leaves} # pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    # pragma: no cover"",
            ""class MockLine: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker(self.leaves) # pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1 # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""# pragma: no cover"",
            ""class MockToken: # pragma: no cover"",
            ""    COMMA = 1# pragma: no cover"",
            ""    STANDALONE_COMMENT = 2# pragma: no cover"",
            ""# pragma: no cover"",
            ""# Initialize line with appropriate parameters# pragma: no cover"",
            ""line = MockLine(# pragma: no cover"",
            ""    mode='test', # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False # pragma: no cover"",
            "")# pragma: no cover"",
            ""# pragma: no cover"",
            ""# Initialize line leaves and comments_after method# pragma: no cover"",
            ""line.leaves = [MockLeaf(bracket_depth=0, leaf_type=MockToken.COMMA)]# pragma: no cover"",
            ""line.comments_after = lambda leaf: []# pragma: no cover"",
            ""# pragma: no cover"",
            ""DOT_PRIORITY = 1# pragma: no cover"",
            ""COMMA_PRIORITY = 2# pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}# pragma: no cover"",
            ""syms = type('MockSyms', (), {'typedargslist': 1, 'arglist': 1, 'argument': 1})# pragma: no cover"",
            ""# pragma: no cover"",
            ""# Nonlocal variable to be modified in the append_to_line function# pragma: no cover"",
            ""current_line = line# pragma: no cover"",
            ""leaf = line.leaves[0]# pragma: no cover"",
            ""# pragma: no cover"",
            ""def is_vararg(leaf, within): return True# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLeaf: # pragma: no cover"",
            ""    def __init__(self, bracket_depth, leaf_type): # pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            ""        self.type = leaf_type # pragma: no cover"",
            ""# pragma: no cover"",
            ""class MockBracketTracker: # pragma: no cover"",
            ""    def __init__(self, leaves): # pragma: no cover"",
            ""        self.leaves = leaves # pragma: no cover"",
            ""        self.delimiters = {id(leaf): 1 for leaf in leaves} # pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""# pragma: no cover"",
            ""class MockLine: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets, leaves, comments_after): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = leaves # pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker(leaves) # pragma: no cover"",
            ""        self.comments_after = comments_after # pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        if isinstance(leaf, MockLeaf): # pragma: no cover"",
            ""            self.leaves.append(leaf) # pragma: no cover"",
            ""        else: # pragma: no cover"",
            ""            raise ValueError('Cannot append non-leaf object') # pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""# pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""# pragma: no cover"",
            ""class MockToken: # pragma: no cover"",
            ""    COMMA = 1# pragma: no cover"",
            ""    STANDALONE_COMMENT = 2# pragma: no cover"",
            ""# pragma: no cover"",
            ""leaves = [MockLeaf(bracket_depth=0, leaf_type=MockToken.COMMA), MockLeaf(bracket_depth=0, leaf_type=MockToken.COMMA)] # pragma: no cover"",
            ""line = MockLine(# pragma: no cover"",
            ""    mode='test', # pragma: no cover"",
            ""    depth=0, # pragma: no cover"",
            ""    inside_brackets=False, # pragma: no cover"",
            ""    leaves=leaves, # pragma: no cover"",
            ""    comments_after=lambda leaf: [] # pragma: no cover"",
            "")# pragma: no cover"",
            ""# pragma: no cover"",
            ""current_line = line # pragma: no cover"",
            ""DOT_PRIORITY = 1# pragma: no cover"",
            ""COMMA_PRIORITY = 2# pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}# pragma: no cover"",
            ""syms = type('MockSyms', (), {'typedargslist': 1, 'arglist': 1, 'argument': 1})# pragma: no cover"",
            ""Leaf = MockLeaf# pragma: no cover"",
            ""token = MockToken# pragma: no cover"",
            ""# pragma: no cover"",
            ""def is_vararg(leaf, within): return True# pragma: no cover"",
            "" # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, leaf_type, bracket_depth):# pragma: no cover"",
            ""        self.type = leaf_type# pragma: no cover"",
            ""        self.bracket_depth = bracket_depth# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def __init__(self, leaves):# pragma: no cover"",
            ""        self.leaves = leaves# pragma: no cover"",
            ""        self.delimiters = {id(leaf): 1 for leaf in leaves}# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker(self.leaves)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append(self, leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""line = MockLine(mode='test', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.leaves = [MockLeaf(token.COMMA, 0)]# pragma: no cover"",
            "" # pragma: no cover"",
            ""DOT_PRIORITY = 1# pragma: no cover"",
            ""COMMA_PRIORITY = 2# pragma: no cover"",
            ""features = {1, 2}# pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""class MockSyms:# pragma: no cover"",
            ""    typedargslist = 1# pragma: no cover"",
            ""    arglist = 2# pragma: no cover"",
            ""    argument = 3# pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""STANDALONE_COMMENT = 4# pragma: no cover"",
            ""# pragma: no cover"",
            ""def is_vararg(leaf, within):# pragma: no cover"",
            ""    return True# pragma: no cover"",
            ""# pragma: no cover"",
            ""current_line = None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, bracket_depth, leaf_type):# pragma: no cover"",
            ""        self.bracket_depth = bracket_depth# pragma: no cover"",
            ""        self.type = leaf_type# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def __init__(self, leaves):# pragma: no cover"",
            ""        self.leaves = leaves# pragma: no cover"",
            ""        self.delimiters = {id(leaf): 1 for leaf in leaves}# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude=set()):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets, leaves):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = leaves# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker(leaves)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append(self, leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            "" # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockToken:# pragma: no cover"",
            ""    COMMA = 1# pragma: no cover"",
            ""    STANDALONE_COMMENT = 2# pragma: no cover"",
            "" # pragma: no cover"",
            ""leaves = [MockLeaf(0, MockToken.COMMA), MockLeaf(1, MockToken.STANDALONE_COMMENT)]# pragma: no cover"",
            ""line = MockLine(mode='test', depth=0, inside_brackets=False, leaves=leaves)# pragma: no cover"",
            ""line.comments_after = lambda leaf: []# pragma: no cover"",
            ""# pragma: no cover"",
            ""DOT_PRIORITY = 1# pragma: no cover"",
            ""COMMA_PRIORITY = 2# pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}# pragma: no cover"",
            ""syms = type('MockSyms', (), {'typedargslist': 1, 'arglist': 2, 'argument': 3})# pragma: no cover"",
            ""# pragma: no cover"",
            ""current_line = None# pragma: no cover"",
            ""# pragma: no cover"",
            ""def append_to_line(leaf: MockLeaf) -> Iterator[MockLine]:# pragma: no cover"",
            ""    try:# pragma: no cover"",
            ""        current_line.append_safe(leaf)# pragma: no cover"",
            ""    except ValueError:# pragma: no cover"",
            ""        current_line = MockLine(mode='test', depth=0, inside_brackets=False, leaves=[])# pragma: no cover"",
            ""        current_line.append(leaf)# pragma: no cover"",
            ""    return current_line# pragma: no cover"",
            "" # pragma: no cover""
        ]
    }
]",2,3125,0.0015625,5161,0.0077415,0.009304
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 67:
    ^
SyntaxError: no binding for nonlocal 'current_line' found
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Iterator, List"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n    \n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n    \n    def comments_after(self, leaf):\n        return []"",
            ""class MockBracketTracker:\n    def __init__(self):\n        self.delimiters = {}\n    \n    def max_delimiter_priority(self, exclude):\n        return COMMA_PRIORITY\n    \n    def delimiter_count_with_priority(self, priority):\n        return 1"",
            ""class Leaf:\n    def __init__(self, type_, value):\n        self.type = type_\n        self.value = value\n        self.bracket_depth = 0"",
            ""line = MockLine('test_mode', 0, False)\nline.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, 'value')]"",
            ""sys.maxsize = 2147483647"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 1, 'argument': 1})"",
            ""STANDALONE_COMMENT = 3"",
            ""current_line = None"",
            ""def append_to_line(leaf):\n    nonlocal current_line\n    if not current_line:\n        current_line = line\n    current_line.append_safe(leaf)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n\n    def comments_after(self, leaf):\n        return [Leaf(token.COMMA, ',')]"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return COMMA_PRIORITY\n\n    def delimiter_count_with_priority(self, priority):\n        return 1\n\n    def __init__(self):\n        self.delimiters = {}"",
            ""class Leaf:\n    def __init__(self, type_, value):\n        self.type = type_\n        self.value = value\n        self.bracket_depth = 0"",
            ""line = MockLine('test_mode', 0, False)"",
            ""current_line = line"",
            ""delimiter_priority = COMMA_PRIORITY"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('syms', (object,), {'typedargslist': 0, 'arglist': 1, 'argument': 2})"",
            ""STANDALONE_COMMENT = 'comment'"",
            ""from collections import deque""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n    \n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n\n    def comments_after(self, leaf):\n        return []"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return 1\n    \n    def delimiter_count_with_priority(self, priority):\n        return 1\n\n    def __init__(self):\n        self.delimiters = {id(leaf): 1 for leaf in []}"",
            ""class Leaf:\n    def __init__(self, type_, value, bracket_depth=0):\n        self.type = type_\n        self.value = value\n        self.bracket_depth = bracket_depth"",
            ""line = MockLine('test_mode', 0, False)\nline.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]"",
            ""DOT_PRIORITY = 1\nCOMMA_PRIORITY = 2\nfeatures = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""STANDALONE_COMMENT = 3"",
            ""def is_vararg(leaf, within): return False"",
            ""current_line = None"",
            ""def set_current_line(line):\n    global current_line\n    current_line = line"",
            ""set_current_line(line)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n    def comments_after(self, leaf):\n        return []"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return COMMA_PRIORITY\n    def delimiter_count_with_priority(self, priority):\n        return 1\n    def __init__(self):\n        self.delimiters = {}"",
            ""class Leaf:\n    def __init__(self, type_, value):\n        self.type = type_\n        self.value = value\n        self.bracket_depth = 0"",
            ""line = MockLine('test_mode', 0, False)"",
            ""line.leaves = [Leaf(token.COMMA, ',')]"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('syms', (object,), {'typedargslist': 0, 'arglist': 1, 'argument': 2})"",
            ""STANDALONE_COMMENT = 'comment'"",
            ""current_line = line""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n    def comments_after(self, leaf):\n        return []"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1\n    def __init__(self):\n        self.delimiters = {}"",
            ""class Leaf:\n    def __init__(self, type_, value):\n        self.type = type_\n        self.value = value\n        self.bracket_depth = 0"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('syms', (object,), {'typedargslist': 0, 'arglist': 1, 'argument': 2})"",
            ""STANDALONE_COMMENT = 3"",
            ""line = MockLine('test_mode', 0, False)"",
            ""current_line = line""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n    \n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n    \n    def comments_after(self, leaf):\n        return []"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return 1\n    \n    def delimiter_count_with_priority(self, priority):\n        return 1\n    \n    def __init__(self):\n        self.delimiters = {}"",
            ""class MockLeaf:\n    def __init__(self, type_, value):\n        self.type = type_\n        self.value = value\n        self.bracket_depth = 0\n"",
            ""line = MockLine('test_mode', 0, False)"",
            ""line.leaves = [MockLeaf(token.COMMA, ','), MockLeaf(token.STANDALONE_COMMENT, 'comment')]"",
            ""current_line = None"",
            ""def set_current_line(line):\n    global current_line\n    current_line = line"",
            ""set_current_line(MockLine(line.mode, line.depth, line.inside_brackets))"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""STANDALONE_COMMENT = 3""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n        return self\n    def comments_after(self, leaf):\n        return []"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1\n    def __init__(self):\n        self.delimiters = {}"",
            ""class MockLeaf:\n    def __init__(self, bracket_depth, type_):\n        self.bracket_depth = bracket_depth\n        self.type = type_"",
            ""line = MockLine('test_mode', 0, False)\nline.leaves = [MockLeaf(0, token.COMMA), MockLeaf(0, token.COMMA)]"",
            ""current_line = None"",
            ""DOT_PRIORITY = 0"",
            ""COMMA_PRIORITY = 1"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('mock_syms', (object,), {'typedargslist': 1, 'arglist': 1, 'argument': 1})"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""def is_vararg(leaf, within): return False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, bracket_depth, type_value):\n        self.bracket_depth = bracket_depth\n        self.type = type_value"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n        self.comments_after = lambda leaf: []\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n    def append(self, leaf):\n        self.leaves.append(leaf)"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return COMMA_PRIORITY\n    def delimiter_count_with_priority(self, priority):\n        return 1\n    def __init__(self):\n        self.delimiters = {}"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)\nline.bracket_tracker = MockBracketTracker()"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""Feature = type('Feature', (), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('syms', (), {'typedargslist': 0, 'arglist': 1, 'argument': 2})"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""current_line = line"",
            ""line.leaves.append(Leaf(0, token.COMMA))""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n    def append_safe(self, leaf, preformatted=False): pass\n    def comments_after(self, leaf): return []"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 1\n    def __init__(self): self.delimiters = {}"",
            ""class Leaf:\n    def __init__(self, type_, value):\n        self.type = type_\n        self.value = value\n        self.bracket_depth = 0\n\n    def __repr__(self): return f'Leaf(type={self.type}, value={self.value})'"",
            ""line = MockLine('test_mode', 0, False)"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.STANDALONE_COMMENT, 'comment')]"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""current_line = line"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""STANDALONE_COMMENT = token.STANDALONE_COMMENT if hasattr(token, 'STANDALONE_COMMENT') else 'standalone_comment'"",
            ""def is_vararg(leaf, within): return True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n    def comments_after(self, leaf):\n        return []"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return COMMA_PRIORITY\n    def delimiter_count_with_priority(self, priority):\n        return 1\n    def __init__(self):\n        self.delimiters = {}"",
            ""class Leaf:\n    def __init__(self, type_, value):\n        self.type = type_\n        self.value = value\n        self.bracket_depth = 0"",
            ""line = MockLine('test_mode', 0, False)"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('syms', (object,), {'typedargslist': 0, 'arglist': 1, 'argument': 2})"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""current_line = None"",
            ""def append_to_line(leaf: Leaf) -> Iterator[MockLine]:\n    global current_line\n    if current_line is None:\n        current_line = MockLine('test_mode', 0, False)\n    current_line.append_safe(leaf, preformatted=True)""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Iterator, List # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {}# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return COMMA_PRIORITY# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type_, value):# pragma: no cover"",
            ""        self.type = type_# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""line = MockLine('test_mode', 0, False)# pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, 'value')] # pragma: no cover"",
            ""sys.maxsize = 2147483647 # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 1, 'argument': 1}) # pragma: no cover"",
            ""STANDALONE_COMMENT = 3 # pragma: no cover"",
            ""current_line = None # pragma: no cover"",
            ""def append_to_line(leaf):# pragma: no cover"",
            ""    if not current_line:# pragma: no cover"",
            ""        current_line = line# pragma: no cover"",
            ""    current_line.append_safe(leaf) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [Leaf(token.COMMA, ',')] # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return COMMA_PRIORITY# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type_, value):# pragma: no cover"",
            ""        self.type = type_# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""line = MockLine('test_mode', 0, False) # pragma: no cover"",
            ""current_line = line # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 0, 'arglist': 1, 'argument': 2}) # pragma: no cover"",
            ""STANDALONE_COMMENT = 'comment' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {id(leaf): 1 for leaf in []} # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type_, value, bracket_depth=0):# pragma: no cover"",
            ""        self.type = type_# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            ""line = MockLine('test_mode', 0, False)# pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')] # pragma: no cover"",
            ""DOT_PRIORITY = 1# pragma: no cover"",
            ""COMMA_PRIORITY = 2# pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""STANDALONE_COMMENT = 3 # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""current_line = None # pragma: no cover"",
            ""def set_current_line(line):# pragma: no cover"",
            ""    global current_line# pragma: no cover"",
            ""    current_line = line # pragma: no cover"",
            ""set_current_line(line) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return COMMA_PRIORITY# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type_, value):# pragma: no cover"",
            ""        self.type = type_# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""line = MockLine('test_mode', 0, False) # pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ',')] # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 0, 'arglist': 1, 'argument': 2}) # pragma: no cover"",
            ""STANDALONE_COMMENT = 'comment' # pragma: no cover"",
            ""current_line = line # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type_, value):# pragma: no cover"",
            ""        self.type = type_# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 0, 'arglist': 1, 'argument': 2}) # pragma: no cover"",
            ""STANDALONE_COMMENT = 3 # pragma: no cover"",
            ""line = MockLine('test_mode', 0, False) # pragma: no cover"",
            ""current_line = line # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type_, value):# pragma: no cover"",
            ""        self.type = type_# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0# pragma: no cover"",
            "" # pragma: no cover"",
            ""line = MockLine('test_mode', 0, False) # pragma: no cover"",
            ""current_line = None # pragma: no cover"",
            ""def set_current_line(line):# pragma: no cover"",
            ""    global current_line# pragma: no cover"",
            ""    current_line = line # pragma: no cover"",
            ""set_current_line(MockLine(line.mode, line.depth, line.inside_brackets)) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""STANDALONE_COMMENT = 3 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""        return self# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, bracket_depth, type_):# pragma: no cover"",
            ""        self.bracket_depth = bracket_depth# pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""line = MockLine('test_mode', 0, False)# pragma: no cover"",
            ""line.leaves = [MockLeaf(0, token.COMMA), MockLeaf(0, token.COMMA)] # pragma: no cover"",
            ""current_line = None # pragma: no cover"",
            ""DOT_PRIORITY = 0 # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('mock_syms', (object,), {'typedargslist': 1, 'arglist': 1, 'argument': 1}) # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, bracket_depth, type_value):# pragma: no cover"",
            ""        self.bracket_depth = bracket_depth# pragma: no cover"",
            ""        self.type = type_value # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.comments_after = lambda leaf: []# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def append(self, leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return COMMA_PRIORITY# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.bracket_tracker = MockBracketTracker() # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""Feature = type('Feature', (), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2}) # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('syms', (), {'typedargslist': 0, 'arglist': 1, 'argument': 2}) # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""current_line = line # pragma: no cover"",
            ""line.leaves.append(Leaf(0, token.COMMA)) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): pass# pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1# pragma: no cover"",
            ""    def __init__(self): self.delimiters = {} # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type_, value):# pragma: no cover"",
            ""        self.type = type_# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def __repr__(self): return f'Leaf(type={self.type}, value={self.value})' # pragma: no cover"",
            ""line = MockLine('test_mode', 0, False) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""current_line = line # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""STANDALONE_COMMENT = token.STANDALONE_COMMENT if hasattr(token, 'STANDALONE_COMMENT') else 'standalone_comment' # pragma: no cover"",
            ""def is_vararg(leaf, within): return True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return COMMA_PRIORITY# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type_, value):# pragma: no cover"",
            ""        self.type = type_# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""line = MockLine('test_mode', 0, False) # pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')] # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 0, 'arglist': 1, 'argument': 2}) # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""current_line = None # pragma: no cover"",
            ""def append_to_line(leaf: Leaf) -> Iterator[MockLine]:# pragma: no cover"",
            ""    global current_line# pragma: no cover"",
            ""    if current_line is None:# pragma: no cover"",
            ""        current_line = MockLine('test_mode', 0, False)# pragma: no cover"",
            ""    current_line.append_safe(leaf, preformatted=True) # pragma: no cover""
        ]
    }
]",2,3786,0.001893,4337,0.0065055,0.0083985
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 36:
    ^
SyntaxError: no binding for nonlocal 'current_line' found
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLine:\n    def __init__(self):\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n        self.mode = 'test'\n        self.depth = 0\n        self.inside_brackets = False\n    def comments_after(self, leaf): return []"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1\n    def __init__(self):\n        self.delimiters = {}"",
            ""class Leaf:\n    def __init__(self, type_, value):\n        self.type = type_\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""class MockSyms:\n    typedargslist = 'typedargslist'\n    arglist = 'arglist'\n    argument = 'argument'"",
            ""line = MockLine()"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = MockSyms()"",
            ""class MockToken:\n    COMMA = 'COMMA'\n    STANDALONE_COMMENT = 'STANDALONE_COMMENT'"",
            ""token = MockToken()"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf('arg', 'arg')]"",
            ""current_line = line""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLine:\n    def __init__(self):\n        self.leaves = [Leaf(token.COMMA, ',')]\n        self.bracket_tracker = MockBracketTracker()\n        self.mode = 'test_mode'\n        self.depth = 0\n        self.inside_brackets = False\n    def comments_after(self, leaf):\n        return []"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1\n    def __init__(self):\n        self.delimiters = {id(leaf): 1 for leaf in [Leaf(token.COMMA, ',')]}"",
            ""class Leaf:\n    def __init__(self, type_, value):\n        self.type = type_\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""class MockSyms:\n    typedargslist = 1\n    arglist = 2\n    argument = 3"",
            ""line = MockLine()"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = MockSyms()"",
            ""class MockToken:\n    COMMA = 1\n    STANDALONE_COMMENT = 2"",
            ""token = MockToken()"",
            ""current_line = line""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLine: \n    def __init__(self, mode, depth, inside_brackets): \n        self.leaves = [] \n        self.bracket_tracker = MockBracketTracker() \n        self.mode = mode \n        self.depth = depth \n        self.inside_brackets = inside_brackets \n    \n    def comments_after(self, leaf): \n        return []"",
            ""class MockBracketTracker: \n    def max_delimiter_priority(self, exclude): \n        return 1 \n    \n    def delimiter_count_with_priority(self, priority): \n        return 1 \n    \n    def __init__(self): \n        self.delimiters = {}"",
            ""class Leaf: \n    def __init__(self, type_, value): \n        self.type = type_ \n        self.value = value \n        self.bracket_depth = 0"",
            ""line = MockLine('test_mode', 0, False)"",
            ""current_line = line"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature: \n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' \n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class MockSyms: \n    typedargslist = 0 \n    arglist = 1 \n    argument = 2"",
            ""syms = MockSyms()"",
            ""STANDALONE_COMMENT = 3"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]"",
            ""token = type('MockToken', (), {'COMMA': 1})()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLine:\n    def __init__(self):\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n        self.mode = 'test'\n        self.depth = 0\n        self.inside_brackets = False\n    \n    def comments_after(self, leaf):\n        return []"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return DOT_PRIORITY\n    \n    def delimiter_count_with_priority(self, priority):\n        return 1\n    \n    def __init__(self):\n        self.delimiters = {}"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""class MockSyms:\n    typedargslist = 'typedargslist'\n    arglist = 'arglist'\n    argument = 'argument'"",
            ""line = MockLine()"",
            ""current_line = line"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = MockSyms()"",
            ""class MockToken:\n    COMMA = 'COMMA'\n    STANDALONE_COMMENT = 'STANDALONE_COMMENT'"",
            ""token = MockToken()"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf('argument', 'arg')]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLine:\n    def __init__(self):\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n        self.mode = 'test'\n        self.depth = 0\n        self.inside_brackets = False\n    def comments_after(self, leaf):\n        return []"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1\n    def __init__(self):\n        self.delimiters = {}"",
            ""class Leaf:\n    def __init__(self, type_, value):\n        self.type = type_\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""class MockSyms:\n    typedargslist = 1\n    arglist = 2\n    argument = 3"",
            ""line = MockLine()"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]\nline.bracket_tracker.delimiters = {id(leaf): 1 for leaf in line.leaves}"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = MockSyms()"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""current_line = line  # Initialize current_line to reference the line object""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return 1\n    \n    def delimiter_count_with_priority(self, priority):\n        return 1\n    \n    def __init__(self):\n        self.delimiters = {}"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n    \n    def comments_after(self, leaf):\n        return []\n    \n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)  # Simplified for context"",
            ""class Leaf:\n    def __init__(self, leaf_type, value):\n        self.type = leaf_type\n        self.value = value\n        self.bracket_depth = 0"",
            ""line = MockLine('test_mode', 0, False)\nline.leaves.append(Leaf(token.COMMA, ','))"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""STANDALONE_COMMENT = 3"",
            ""current_line = line""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLeaf:\n    def __init__(self, type_, value, bracket_depth=0):\n        self.type = type_\n        self.value = value\n        self.bracket_depth = bracket_depth"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n    \n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n\n    def comments_after(self, leaf):\n        return []"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 1\n    def __init__(self):\n        self.delimiters = {}"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""class MockSyms:\n    typedargslist = 'typedargslist'\n    arglist = 'arglist'\n    argument = 'argument'"",
            ""line = MockLine('test_mode', 0, False)\nline.leaves = [MockLeaf(token.COMMA, ','), MockLeaf('argument', 'arg', bracket_depth=0)]\nline.bracket_tracker = MockBracketTracker()"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = MockSyms()"",
            ""class MockToken:\n    COMMA = 'COMMA'\n    STANDALONE_COMMENT = 'STANDALONE_COMMENT'"",
            ""token = MockToken()"",
            ""current_line = line""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLine:\n    def __init__(self):\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n        self.mode = 'test_mode'\n        self.depth = 0\n        self.inside_brackets = False\n    \n    def comments_after(self, leaf):\n        return []"",
            ""class MockBracketTracker:\n    def __init__(self):\n        self.delimiters = {}\n    \n    def max_delimiter_priority(self, exclude):\n        return 1\n    \n    def delimiter_count_with_priority(self, priority):\n        return 1"",
            ""class Leaf:\n    def __init__(self, leaf_type):\n        self.type = leaf_type\n        self.bracket_depth = 0"",
            ""line = MockLine()"",
            ""line.leaves = [Leaf(token.COMMA), Leaf(token.STANDALONE_COMMENT)]"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class MockSyms:\n    typedargslist = 0\n    arglist = 1\n    argument = 2"",
            ""syms = MockSyms()"",
            ""class MockToken:\n    COMMA = 1\n    STANDALONE_COMMENT = 2"",
            ""token = MockToken()"",
            ""trailing_comma_safe = True"",
            ""current_line = line""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLine:\n    def __init__(self):\n        self.leaves = []\n        self.semicolon = False\n        self.bracket_tracker = MockBracketTracker()\n        self.mode = 'test'\n        self.depth = 0\n        self.inside_brackets = False\n    def comments_after(self, leaf):\n        return []"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1\n    def __init__(self):\n        self.delimiters = {}"",
            ""class Leaf:\n    def __init__(self, type_, value):\n        self.type = type_\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""class MockSyms:\n    typedargslist = 1\n    arglist = 2\n    argument = 3"",
            ""line = MockLine()"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""line.leaves.append(Leaf('arg', 'arg_value'))"",
            ""line.leaves.append(Leaf('arg', 'arg_value_2'))"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = MockSyms()"",
            ""token = type('Token', (), {'COMMA': 1, 'STANDALONE_COMMENT': 2})()"",
            ""current_line = line""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n    def comments_after(self, leaf): return []"",
            ""class MockBracketTracker:\n    def __init__(self):\n        self.delimiters = {}\n    def max_delimiter_priority(self, exclude):\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1"",
            ""class Leaf:\n    def __init__(self, type_, value):\n        self.type = type_\n        self.value = value\n        self.bracket_depth = 0"",
            ""line = MockLine(mode='test_mode', depth=0, inside_brackets=False)"",
            ""current_line = line"",
            ""features = {1, 2}  # Mock Feature set for testing"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""        self.mode = 'test'# pragma: no cover"",
            ""        self.depth = 0# pragma: no cover"",
            ""        self.inside_brackets = False# pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type_, value):# pragma: no cover"",
            ""        self.type = type_# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""class MockSyms:# pragma: no cover"",
            ""    typedargslist = 'typedargslist'# pragma: no cover"",
            ""    arglist = 'arglist'# pragma: no cover"",
            ""    argument = 'argument' # pragma: no cover"",
            ""line = MockLine() # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""class MockToken:# pragma: no cover"",
            ""    COMMA = 'COMMA'# pragma: no cover"",
            ""    STANDALONE_COMMENT = 'STANDALONE_COMMENT' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf('arg', 'arg')] # pragma: no cover"",
            ""current_line = line # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.leaves = [Leaf(token.COMMA, ',')]# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""        self.mode = 'test_mode'# pragma: no cover"",
            ""        self.depth = 0# pragma: no cover"",
            ""        self.inside_brackets = False# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {id(leaf): 1 for leaf in [Leaf(token.COMMA, ',')]} # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type_, value):# pragma: no cover"",
            ""        self.type = type_# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""class MockSyms:# pragma: no cover"",
            ""    typedargslist = 1# pragma: no cover"",
            ""    arglist = 2# pragma: no cover"",
            ""    argument = 3 # pragma: no cover"",
            ""line = MockLine() # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""class MockToken:# pragma: no cover"",
            ""    COMMA = 1# pragma: no cover"",
            ""    STANDALONE_COMMENT = 2 # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""current_line = line # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLine: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker() # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class MockBracketTracker: # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): # pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""line = MockLine('test_mode', 0, False) # pragma: no cover"",
            ""current_line = line # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class MockSyms: # pragma: no cover"",
            ""    typedargslist = 0 # pragma: no cover"",
            ""    arglist = 1 # pragma: no cover"",
            ""    argument = 2 # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""STANDALONE_COMMENT = 3 # pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')] # pragma: no cover"",
            ""token = type('MockToken', (), {'COMMA': 1})() # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""        self.mode = 'test'# pragma: no cover"",
            ""        self.depth = 0# pragma: no cover"",
            ""        self.inside_brackets = False# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return DOT_PRIORITY# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""class MockSyms:# pragma: no cover"",
            ""    typedargslist = 'typedargslist'# pragma: no cover"",
            ""    arglist = 'arglist'# pragma: no cover"",
            ""    argument = 'argument' # pragma: no cover"",
            ""line = MockLine() # pragma: no cover"",
            ""current_line = line # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""class MockToken:# pragma: no cover"",
            ""    COMMA = 'COMMA'# pragma: no cover"",
            ""    STANDALONE_COMMENT = 'STANDALONE_COMMENT' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf('argument', 'arg')] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""        self.mode = 'test'# pragma: no cover"",
            ""        self.depth = 0# pragma: no cover"",
            ""        self.inside_brackets = False# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type_, value):# pragma: no cover"",
            ""        self.type = type_# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""class MockSyms:# pragma: no cover"",
            ""    typedargslist = 1# pragma: no cover"",
            ""    arglist = 2# pragma: no cover"",
            ""    argument = 3 # pragma: no cover"",
            ""line = MockLine() # pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]# pragma: no cover"",
            ""line.bracket_tracker.delimiters = {id(leaf): 1 for leaf in line.leaves} # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""current_line = line  # Initialize current_line to reference the line object # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)  # Simplified for context # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, leaf_type, value):# pragma: no cover"",
            ""        self.type = leaf_type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""line = MockLine('test_mode', 0, False)# pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""STANDALONE_COMMENT = 3 # pragma: no cover"",
            ""current_line = line # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type_, value, bracket_depth=0):# pragma: no cover"",
            ""        self.type = type_# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""class MockSyms:# pragma: no cover"",
            ""    typedargslist = 'typedargslist'# pragma: no cover"",
            ""    arglist = 'arglist'# pragma: no cover"",
            ""    argument = 'argument' # pragma: no cover"",
            ""line = MockLine('test_mode', 0, False)# pragma: no cover"",
            ""line.leaves = [MockLeaf(token.COMMA, ','), MockLeaf('argument', 'arg', bracket_depth=0)]# pragma: no cover"",
            ""line.bracket_tracker = MockBracketTracker() # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""class MockToken:# pragma: no cover"",
            ""    COMMA = 'COMMA'# pragma: no cover"",
            ""    STANDALONE_COMMENT = 'STANDALONE_COMMENT' # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""current_line = line # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""        self.mode = 'test_mode'# pragma: no cover"",
            ""        self.depth = 0# pragma: no cover"",
            ""        self.inside_brackets = False# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {}# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, leaf_type):# pragma: no cover"",
            ""        self.type = leaf_type# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""line = MockLine() # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class MockSyms:# pragma: no cover"",
            ""    typedargslist = 0# pragma: no cover"",
            ""    arglist = 1# pragma: no cover"",
            ""    argument = 2 # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""class MockToken:# pragma: no cover"",
            ""    COMMA = 1# pragma: no cover"",
            ""    STANDALONE_COMMENT = 2 # pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover"",
            ""current_line = line # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.semicolon = False# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""        self.mode = 'test'# pragma: no cover"",
            ""        self.depth = 0# pragma: no cover"",
            ""        self.inside_brackets = False# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type_, value):# pragma: no cover"",
            ""        self.type = type_# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""class MockSyms:# pragma: no cover"",
            ""    typedargslist = 1# pragma: no cover"",
            ""    arglist = 2# pragma: no cover"",
            ""    argument = 3 # pragma: no cover"",
            ""line = MockLine() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""line.leaves.append(Leaf('arg', 'arg_value')) # pragma: no cover"",
            ""line.leaves.append(Leaf('arg', 'arg_value_2')) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""token = type('Token', (), {'COMMA': 1, 'STANDALONE_COMMENT': 2})() # pragma: no cover"",
            ""current_line = line # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {}# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type_, value):# pragma: no cover"",
            ""        self.type = type_# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""line = MockLine(mode='test_mode', depth=0, inside_brackets=False) # pragma: no cover"",
            ""current_line = line # pragma: no cover"",
            ""features = {1, 2}  # Mock Feature set for testing # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')] # pragma: no cover""
        ]
    }
]",2,4427,0.0022135,4165,0.0062475,0.008461
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 34:
    ^
SyntaxError: no binding for nonlocal 'current_line' found
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockBracketTracker:\n    def __init__(self):\n        self.delimiters = {}\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 1"",
            ""class Leaf:\n    def __init__(self, type_, value):\n        self.type = type_\n        self.value = value\n        self.bracket_depth = 0"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n    def append_safe(self, leaf, preformatted):\n        self.leaves.append(leaf)"",
            ""line = MockLine('mock_mode', 0, False)"",
            ""line.leaves.append(Leaf(token.COMMA, ','))\nline.leaves.append(Leaf('argument', 'arg'))"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('MockSyms', (), {'typedargslist': 1, 'arglist': 1, 'argument': 1})()"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""current_line = None"",
            ""def exit(line):\n    global current_line\n    current_line = line""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 1\n    def __init__(self): self.delimiters = {}"",
            ""class Leaf:\n    def __init__(self, type_, value):\n        self.type = type_\n        self.value = value\n        self.bracket_depth = 0"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n    def append_safe(self, leaf, preformatted):\n        self.leaves.append(leaf)\n    def comments_after(self, leaf): return []"",
            ""line = MockLine('test_mode', 0, False)"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf('argument', 'arg')]"",
            ""current_line = line"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('MockSyms', (), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""STANDALONE_COMMENT = 'standalone_comment'""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1\n    def __init__(self):\n        self.delimiters = {}"",
            ""class Leaf:\n    def __init__(self, leaf_type):\n        self.type = leaf_type\n        self.bracket_depth = 0"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n    def append_safe(self, leaf, preformatted):\n        self.leaves.append(leaf)\n    def comments_after(self, leaf):\n        return []"",
            ""line = MockLine('test_mode', 0, False)"",
            ""line.leaves = [Leaf(token.COMMA), Leaf(2)]"",
            ""trailing_comma_safe = True"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('MockSymbols', (object,), {'typedargslist': 0, 'arglist': 1, 'argument': 2})"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""current_line = line""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Callable, Any"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockBracketTracker:\n    def __init__(self):\n        self.delimiters = {}\n    def max_delimiter_priority(self, exclude):\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1"",
            ""class Leaf:\n    def __init__(self, leaf_type):\n        self.type = leaf_type\n        self.bracket_depth = 0"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.leaves = []\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n    def append_safe(self, leaf, preformatted):\n        self.leaves.append(leaf)  \n    def comments_after(self, leaf):\n        return []"",
            ""line = MockLine('test_mode', 0, False)"",
            ""line.leaves = [Leaf(token.COMMA), Leaf(token.STANDALONE_COMMENT)]"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 0, 'arglist': 1, 'argument': 2})()"",
            ""COMMA_PRIORITY = 2"",
            ""DOT_PRIORITY = 1"",
            ""current_line = None"",
            ""current_line = MockLine(line.mode, line.depth, line.inside_brackets)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 1\n    def __init__(self): self.delimiters = {}"",
            ""class Leaf:\n    def __init__(self, type_, value):\n        self.type = type_\n        self.value = value\n        self.bracket_depth = 0"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n    def comments_after(self, leaf): return []"",
            ""line = MockLine('test_mode', 0, False)"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]"",
            ""current_line = line"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""is_vararg = lambda leaf, within: False""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class MockBracketTracker:\n    def __init__(self):\n        self.delimiters = {}\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 2"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n    def comments_after(self, leaf): return []\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)"",
            ""line = MockLine('test_mode', 0, False)"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.STANDALONE_COMMENT, 'comment')]"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class MockToken:\n    COMMA = 1\n    STANDALONE_COMMENT = 2\n\ntoken = MockToken()"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSymbols', (object,), {'typedargslist': object, 'arglist': object, 'argument': object})"",
            ""current_line = None""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Callable, Any"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockBracketTracker:\n    def __init__(self):\n        self.delimiters = {}\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 1"",
            ""class Leaf:\n    def __init__(self, type_, value):\n        self.type = type_\n        self.value = value\n        self.bracket_depth = 0"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n    def append_safe(self, leaf: Leaf, preformatted: bool):\n        self.leaves.append(leaf)"",
            ""line = MockLine('test_mode', 0, False)"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.STANDALONE_COMMENT, 'comment')]"",
            ""line.comments_after = lambda leaf: []"",
            ""current_line = line"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class MockSyms:\n    typedargslist = 'typedargslist'\n    arglist = 'arglist'\n    argument = 'argument'\nsyms = MockSyms()"",
            ""STANDALONE_COMMENT = token.STANDALONE_COMMENT"",
            ""is_vararg = lambda leaf, within: False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 1\n    def __init__(self):\n        self.delimiters = {}"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n    def append_safe(self, leaf, preformatted):\n        self.leaves.append(leaf)\n    def comments_after(self, leaf): return []"",
            ""line = MockLine('test_mode', 0, False)"",
            ""current_line = line"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""features = {1, 2}"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""syms = type('syms', (object,), {'typedargslist': 0, 'arglist': 1, 'argument': 2})"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf('arg', 'arg_value')]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1\n    def __init__(self):\n        self.delimiters = {}"",
            ""class Leaf:\n    def __init__(self, leaf_type):\n        self.type = leaf_type\n        self.bracket_depth = 0"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n    def comments_after(self, leaf):\n        return []"",
            ""line = MockLine('mock_mode', 0, False)"",
            ""line.leaves.append(Leaf(token.COMMA))\nline.leaves.append(Leaf('argument'))\nline.leaves.append(Leaf('another_argument'))"",
            ""current_line = line"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('syms', (), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""STANDALONE_COMMENT = 'standalone_comment'""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLeaf:\n    def __init__(self, bracket_depth, leaf_type):\n        self.bracket_depth = bracket_depth\n        self.type = leaf_type"",
            ""class MockBracketTracker:\n    def __init__(self):\n        self.delimiters = {}\n    def max_delimiter_priority(self, exclude):\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n    def comments_after(self, leaf):\n        return []"",
            ""line = MockLine(mode='test_mode', depth=0, inside_brackets=False)"",
            ""current_line = line"",
            ""line.leaves = [MockLeaf(bracket_depth=0, leaf_type=token.COMMA), MockLeaf(bracket_depth=1, leaf_type=token.STANDALONE_COMMENT)]"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class MockSyms:\n    typedargslist = 'typedargslist'\n    arglist = 'arglist'\n    argument = 'argument'"",
            ""syms = MockSyms()"",
            ""STANDALONE_COMMENT = 'standalone_comment'""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {}# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type_, value):# pragma: no cover"",
            ""        self.type = type_# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted):# pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""line = MockLine('mock_mode', 0, False) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ','))# pragma: no cover"",
            ""line.leaves.append(Leaf('argument', 'arg')) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('MockSyms', (), {'typedargslist': 1, 'arglist': 1, 'argument': 1})() # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""current_line = None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1# pragma: no cover"",
            ""    def __init__(self): self.delimiters = {} # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type_, value):# pragma: no cover"",
            ""        self.type = type_# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""line = MockLine('test_mode', 0, False) # pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf('argument', 'arg')] # pragma: no cover"",
            ""current_line = line # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('MockSyms', (), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, leaf_type):# pragma: no cover"",
            ""        self.type = leaf_type# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""line = MockLine('test_mode', 0, False) # pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA), Leaf(2)] # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('MockSymbols', (object,), {'typedargslist': 0, 'arglist': 1, 'argument': 2}) # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""current_line = line # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Callable, Any # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {}# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, leaf_type):# pragma: no cover"",
            ""        self.type = leaf_type# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted):# pragma: no cover"",
            ""        self.leaves.append(leaf)  # pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""line = MockLine('test_mode', 0, False) # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 0, 'arglist': 1, 'argument': 2})() # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""current_line = None # pragma: no cover"",
            ""current_line = MockLine(line.mode, line.depth, line.inside_brackets) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1# pragma: no cover"",
            ""    def __init__(self): self.delimiters = {} # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type_, value):# pragma: no cover"",
            ""        self.type = type_# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""line = MockLine('test_mode', 0, False) # pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')] # pragma: no cover"",
            ""current_line = line # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {}# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""    def comments_after(self, leaf): return []# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""line = MockLine('test_mode', 0, False) # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class MockToken:# pragma: no cover"",
            ""    COMMA = 1# pragma: no cover"",
            ""    STANDALONE_COMMENT = 2# pragma: no cover"",
            ""# pragma: no cover"",
            ""token = MockToken() # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSymbols', (object,), {'typedargslist': object, 'arglist': object, 'argument': object}) # pragma: no cover"",
            ""current_line = None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import List, Callable, Any # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {}# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type_, value):# pragma: no cover"",
            ""        self.type = type_# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""    def append_safe(self, leaf: Leaf, preformatted: bool):# pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""line = MockLine('test_mode', 0, False) # pragma: no cover"",
            ""line.comments_after = lambda leaf: [] # pragma: no cover"",
            ""current_line = line # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class MockSyms:# pragma: no cover"",
            ""    typedargslist = 'typedargslist'# pragma: no cover"",
            ""    arglist = 'arglist'# pragma: no cover"",
            ""    argument = 'argument'# pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""line = MockLine('test_mode', 0, False) # pragma: no cover"",
            ""current_line = line # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""features = {1, 2} # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 0, 'arglist': 1, 'argument': 2}) # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf('arg', 'arg_value')] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, leaf_type):# pragma: no cover"",
            ""        self.type = leaf_type# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""line = MockLine('mock_mode', 0, False) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA))# pragma: no cover"",
            ""line.leaves.append(Leaf('argument'))# pragma: no cover"",
            ""line.leaves.append(Leaf('another_argument')) # pragma: no cover"",
            ""current_line = line # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('syms', (), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, bracket_depth, leaf_type):# pragma: no cover"",
            ""        self.bracket_depth = bracket_depth# pragma: no cover"",
            ""        self.type = leaf_type # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {}# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""line = MockLine(mode='test_mode', depth=0, inside_brackets=False) # pragma: no cover"",
            ""current_line = line # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class MockSyms:# pragma: no cover"",
            ""    typedargslist = 'typedargslist'# pragma: no cover"",
            ""    arglist = 'arglist'# pragma: no cover"",
            ""    argument = 'argument' # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover""
        ]
    }
]",2,5184,0.002592,4101,0.0061515,0.0087435
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 57:
    ^
SyntaxError: no binding for nonlocal 'current_line' found
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 1\n    def __init__(self):\n        self.delimiters = {}"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n    def comments_after(self, leaf): return []\n    def append(self, leaf): self.leaves.append(leaf)\n    def append_safe(self, leaf, preformatted): self.leaves.append(leaf)"",
            ""current_line = MockLine('test_mode', 0, False)"",
            ""class Leaf:\n    def __init__(self, type_, value):\n        self.type = type_\n        self.value = value\n        self.bracket_depth = 0"",
            ""line = MockLine('test', 0, False)"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""is_vararg = lambda leaf, within: True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLeaf:\n    def __init__(self, bracket_depth, leaf_type):\n        self.bracket_depth = bracket_depth\n        self.type = leaf_type"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1\n    def __init__(self):\n        self.delimiters = {}"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.leaves = []\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.bracket_tracker = MockBracketTracker()\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n    def append(self, leaf):\n        self.leaves.append(leaf)"",
            ""line = MockLine('test_mode', 0, False)"",
            ""current_line = line"",
            ""features = []"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""token = type('MockToken', (object,), {'COMMA': 1, 'STANDALONE_COMMENT': 2})()"",
            ""line.leaves = [MockLeaf(0, 1), MockLeaf(0, 2)]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLine:\n    def __init__(self):\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n        self.mode = 'test_mode'\n        self.depth = 0\n        self.inside_brackets = False\n    def comments_after(self, leaf): return []"",
            ""class Leaf:\n    def __init__(self, leaf_type):\n        self.type = leaf_type\n        self.bracket_depth = 0"",
            ""class MockBracketTracker:\n    def __init__(self):\n        self.delimiters = {}\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 1"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class MockSyms:\n    typedargslist = 'typedargslist'\n    arglist = 'arglist'\n    argument = 'argument'\nsyms = MockSyms()"",
            ""token = type('MockToken', (), {'COMMA': 1, 'STANDALONE_COMMENT': 2})"",
            ""line = MockLine()"",
            ""current_line = line""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLeaf:\n    def __init__(self, type_):\n        self.type = type_\n        self.bracket_depth = 0"",
            ""class MockBracketTracker:\n    def __init__(self):\n        self.delimiters = {}\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 1"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n    def comments_after(self, leaf):\n        return []"",
            ""line = MockLine('test_mode', 0, False)"",
            ""current_line = line"",
            ""DOT_PRIORITY = 0"",
            ""COMMA_PRIORITY = 1"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})()"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""line.leaves = [MockLeaf(token.COMMA), MockLeaf('arg'), MockLeaf('kwarg')]"",
            ""is_vararg = lambda leaf, within: False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 1\n    def __init__(self): self.delimiters = {}"",
            ""class Leaf:\n    def __init__(self, leaf_type):\n        self.type = leaf_type\n        self.bracket_depth = 0"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.leaves = []\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n    \n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n    \n    def append(self, leaf):\n        self.leaves.append(leaf)"",
            ""line = Line('test_mode', 0, False)\nline.bracket_tracker = MockBracketTracker()"",
            ""line.leaves = [Leaf(token.COMMA), Leaf(token.STANDALONE_COMMENT)]"",
            ""current_line = Line(line.mode, line.depth, line.inside_brackets)"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""features = {1, 2}"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""token = type('token', (object,), {'COMMA': 1, 'STANDALONE_COMMENT': 2})"",
            ""STANDALONE_COMMENT = 2"",
            ""is_vararg = lambda leaf, within: False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 1\n    def __init__(self): self.delimiters = {}"",
            ""line = type('MockLine', (object,), {\n    'leaves': [],\n    'bracket_tracker': MockBracketTracker(),\n    'mode': 'test_mode',\n    'depth': 0,\n    'inside_brackets': False,\n    'comments_after': lambda leaf: []\n})()"",
            ""class Leaf:\n    def __init__(self, type_, value):\n        self.type = type_\n        self.value = value\n        self.bracket_depth = 0"",
            ""current_line = None"",
            ""def create_current_line():\n    global current_line\n    current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.leaves = []\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n    def append(self, leaf):\n        self.leaves.append(leaf)"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLeaf:\n    def __init__(self, token, bracket_depth=0):\n        self.token = token\n        self.bracket_depth = bracket_depth\n        self.type = token\n"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 1\n    def __init__(self):\n        self.delimiters = {}\n"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n    def comments_after(self, leaf): return []\n    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf)"",
            ""line = MockLine(mode='test_mode', depth=0, inside_brackets=False)"",
            ""line.leaves = [MockLeaf(token.COMMA, bracket_depth=0), MockLeaf(token.STRING, bracket_depth=1)]"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class MockSyms:\n    typedargslist = 'typedargslist'\n    arglist = 'arglist'\n    argument = 'argument'\nsyms = MockSyms()"",
            ""current_line = line"",
            ""STANDALONE_COMMENT = 3"",
            ""def is_vararg(leaf, within): return False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n    def comments_after(self, leaf): return []"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return len(self.delimiters)\n    def __init__(self):\n        self.delimiters = {}"",
            ""class Leaf:\n    def __init__(self, type):\n        self.type = type\n        self.bracket_depth = 0"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 1, 'argument': 1})"",
            ""line = MockLine('test_mode', 0, False)"",
            ""line.leaves = [Leaf(token.COMMA), Leaf(token.COMMA)]"",
            ""current_line = line""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLeaf:\n    def __init__(self, leaf_type):\n        self.type = leaf_type\n        self.bracket_depth = 0\n"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 1\n    def __init__(self): self.delimiters = {}"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n    def append(self, leaf):\n        self.leaves.append(leaf)\n    def comments_after(self, leaf):\n        return []"",
            ""line = MockLine('test_mode', 0, False)"",
            ""current_line = line"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('MockSymbols', (object,), {'typedargslist': 0, 'arglist': 1, 'argument': 2})"",
            ""token = type('MockToken', (object,), {'COMMA': 1, 'STANDALONE_COMMENT': 2})()"",
            ""line.leaves = [MockLeaf(token.COMMA), MockLeaf(token.STANDALONE_COMMENT)]"",
            ""is_vararg = lambda leaf, within: False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 1\n    def __init__(self):\n        self.delimiters = {}"",
            ""class Leaf:\n    def __init__(self, type_):\n        self.type = type_\n        self.bracket_depth = 0"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)"",
            ""def is_vararg(leaf, within): return False"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)\nline.bracket_tracker = MockBracketTracker()"",
            ""line.leaves = [Leaf(token.COMMA), Leaf(token.STANDALONE_COMMENT), Leaf(token.COMMA)]"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2\nfeatures = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""STANDALONE_COMMENT = token.STANDALONE_COMMENT"",
            ""current_line = None""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""    def comments_after(self, leaf): return []# pragma: no cover"",
            ""    def append(self, leaf): self.leaves.append(leaf)# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted): self.leaves.append(leaf) # pragma: no cover"",
            ""current_line = MockLine('test_mode', 0, False) # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type_, value):# pragma: no cover"",
            ""        self.type = type_# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""line = MockLine('test', 0, False) # pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')] # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, bracket_depth, leaf_type):# pragma: no cover"",
            ""        self.bracket_depth = bracket_depth# pragma: no cover"",
            ""        self.type = leaf_type # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def append(self, leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""line = MockLine('test_mode', 0, False) # pragma: no cover"",
            ""current_line = line # pragma: no cover"",
            ""features = [] # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMA': 1, 'STANDALONE_COMMENT': 2})() # pragma: no cover"",
            ""line.leaves = [MockLeaf(0, 1), MockLeaf(0, 2)] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""        self.mode = 'test_mode'# pragma: no cover"",
            ""        self.depth = 0# pragma: no cover"",
            ""        self.inside_brackets = False# pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, leaf_type):# pragma: no cover"",
            ""        self.type = leaf_type# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {}# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class MockSyms:# pragma: no cover"",
            ""    typedargslist = 'typedargslist'# pragma: no cover"",
            ""    arglist = 'arglist'# pragma: no cover"",
            ""    argument = 'argument'# pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""token = type('MockToken', (), {'COMMA': 1, 'STANDALONE_COMMENT': 2}) # pragma: no cover"",
            ""line = MockLine() # pragma: no cover"",
            ""current_line = line # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type_):# pragma: no cover"",
            ""        self.type = type_# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {}# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""line = MockLine('test_mode', 0, False) # pragma: no cover"",
            ""current_line = line # pragma: no cover"",
            ""DOT_PRIORITY = 0 # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})() # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""line.leaves = [MockLeaf(token.COMMA), MockLeaf('arg'), MockLeaf('kwarg')] # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1# pragma: no cover"",
            ""    def __init__(self): self.delimiters = {} # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, leaf_type):# pragma: no cover"",
            ""        self.type = leaf_type# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def append(self, leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""line = Line('test_mode', 0, False)# pragma: no cover"",
            ""line.bracket_tracker = MockBracketTracker() # pragma: no cover"",
            ""current_line = Line(line.mode, line.depth, line.inside_brackets) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""features = {1, 2} # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""token = type('token', (object,), {'COMMA': 1, 'STANDALONE_COMMENT': 2}) # pragma: no cover"",
            ""STANDALONE_COMMENT = 2 # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1# pragma: no cover"",
            ""    def __init__(self): self.delimiters = {} # pragma: no cover"",
            ""line = type('MockLine', (object,), {# pragma: no cover"",
            ""    'leaves': [],# pragma: no cover"",
            ""    'bracket_tracker': MockBracketTracker(),# pragma: no cover"",
            ""    'mode': 'test_mode',# pragma: no cover"",
            ""    'depth': 0,# pragma: no cover"",
            ""    'inside_brackets': False,# pragma: no cover"",
            ""    'comments_after': lambda leaf: []# pragma: no cover"",
            ""})() # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type_, value):# pragma: no cover"",
            ""        self.type = type_# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""current_line = None # pragma: no cover"",
            ""def create_current_line():# pragma: no cover"",
            ""    global current_line# pragma: no cover"",
            ""    current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def append(self, leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, token, bracket_depth=0):# pragma: no cover"",
            ""        self.token = token# pragma: no cover"",
            ""        self.bracket_depth = bracket_depth# pragma: no cover"",
            ""        self.type = token# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {}# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""    def comments_after(self, leaf): return []# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf) # pragma: no cover"",
            ""line = MockLine(mode='test_mode', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.leaves = [MockLeaf(token.COMMA, bracket_depth=0), MockLeaf(token.STRING, bracket_depth=1)] # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class MockSyms:# pragma: no cover"",
            ""    typedargslist = 'typedargslist'# pragma: no cover"",
            ""    arglist = 'arglist'# pragma: no cover"",
            ""    argument = 'argument'# pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""current_line = line # pragma: no cover"",
            ""STANDALONE_COMMENT = 3 # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return len(self.delimiters)# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 1, 'argument': 1}) # pragma: no cover"",
            ""line = MockLine('test_mode', 0, False) # pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA), Leaf(token.COMMA)] # pragma: no cover"",
            ""current_line = line # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, leaf_type):# pragma: no cover"",
            ""        self.type = leaf_type# pragma: no cover"",
            ""        self.bracket_depth = 0# pragma: no cover"",
            "" # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1# pragma: no cover"",
            ""    def __init__(self): self.delimiters = {} # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def append(self, leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""line = MockLine('test_mode', 0, False) # pragma: no cover"",
            ""current_line = line # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('MockSymbols', (object,), {'typedargslist': 0, 'arglist': 1, 'argument': 2}) # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMA': 1, 'STANDALONE_COMMENT': 2})() # pragma: no cover"",
            ""line.leaves = [MockLeaf(token.COMMA), MockLeaf(token.STANDALONE_COMMENT)] # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type_):# pragma: no cover"",
            ""        self.type = type_# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.bracket_tracker = MockBracketTracker() # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2# pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""current_line = None # pragma: no cover""
        ]
    }
]",2,5887,0.0029435,4215,0.0063225,0.009266
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 80:
    ^
SyntaxError: no binding for nonlocal 'current_line' found
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLeaf:\n    def __init__(self, bracket_depth, leaf_type):\n        self.bracket_depth = bracket_depth\n        self.type = leaf_type"",
            ""class MockBracketTracker:\n    def __init__(self):\n        self.delimiters = {}\n    def max_delimiter_priority(self, exclude):\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n    def comments_after(self, leaf):\n        return []\n"",
            ""line = MockLine(mode='test_mode', depth=0, inside_brackets=False)\nline.leaves.append(MockLeaf(bracket_depth=0, leaf_type=1))  # Add a dummy leaf\n"",
            ""current_line = line"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class syms:\n    typedargslist = 'typedargslist'\n    arglist = 'arglist'\n    argument = 'argument'"",
            ""token = type('MockToken', (object,), {'COMMA': 1, 'STANDALONE_COMMENT': 2})()"",
            ""STANDALONE_COMMENT = 'standalone_comment'""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLeaf:\n    def __init__(self, type, bracket_depth):\n        self.type = type\n        self.bracket_depth = bracket_depth"",
            ""class MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.leaves = []\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n    \n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n    \n    def comments_after(self, leaf):\n        return []"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 1\n    delimiters = {}"",
            ""line = MockLine('test_mode', 0, False)\nline.bracket_tracker = MockBracketTracker()"",
            ""line.leaves = [MockLeaf(token.COMMA, 0)] * 3"",
            ""current_line = MockLine(line.mode, line.depth, line.inside_brackets)"",
            ""DOT_PRIORITY = 1\nCOMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class MockSyms:\n    typedargslist = 1\n    arglist = 2\n    argument = 3"",
            ""syms = MockSyms()"",
            ""STANDALONE_COMMENT = 'standalone_comment'""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List, Any"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockBracketTracker:\n    def __init__(self):\n        self.delimiters = {}\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 1"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.leaves = []\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n    def comments_after(self, leaf): return []"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)\nline.bracket_tracker = MockBracketTracker()"",
            ""DOT_PRIORITY = 1\nCOMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""current_line = line"",
            ""line.leaves = [Leaf(token.COMMA, ',')]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List, Dict, Any"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, token, value):\n        self.token = token\n        self.value = value\n        self.bracket_depth = 0"",
            ""class MockBracketTracker:\n    def __init__(self):\n        self.delimiters = {}\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 1"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.leaves = []\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n    def append_safe(self, leaf, preformatted):\n        self.leaves.append(leaf)\n    def append(self, leaf):\n        self.leaves.append(leaf)"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)\nline.bracket_tracker = MockBracketTracker()"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]"",
            ""current_line = line"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 1, 'argument': 1})()"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""is_vararg = lambda leaf, within: False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, type_, value):\n        self.type = type_\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.leaves = []\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n    def comments_after(self, leaf):\n        return []"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 1\n    delimiters = {}"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)\nline.bracket_tracker = MockBracketTracker()"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""features = {1, 2}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""token = type('MockToken', (object,), {'COMMA': 1, 'STANDALONE_COMMENT': 2})()"",
            ""current_line = line"",
            ""def is_vararg(leaf, within): return False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class MockLeaf:\n    def __init__(self, bracket_depth, leaf_type):\n        self.bracket_depth = bracket_depth\n        self.type = leaf_type\n\nclass MockBracketTracker:\n    def __init__(self):\n        self.delimiters = {}\n    def max_delimiter_priority(self, exclude):\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1\n\nclass MockLine:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n        self.bracket_tracker = MockBracketTracker()\n\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n\nline = MockLine(mode='test_mode', depth=0, inside_brackets=False)\nline.leaves = [MockLeaf(0, token.COMMA) for _ in range(5)]\nline.bracket_tracker.delimiters = {id(leaf): 1 for leaf in line.leaves}\n\ncurrent_line = line\nDOT_PRIORITY = 1\nCOMMA_PRIORITY = 2\nfeatures = {1, 2}\nsyms = type('MockSymbols', (object,), {'typedargslist': 0, 'arglist': 1, 'argument': 2})\nSTANDALONE_COMMENT = 'standalone_comment'\nFeature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.leaves = []\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n    def comments_after(self, leaf):\n        return []"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return 0\n    def delimiter_count_with_priority(self, priority):\n        return 1\n    def __init__(self):\n        self.delimiters = {}"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)\nline.bracket_tracker = MockBracketTracker()"",
            ""line.leaves = [Leaf(token.COMMA, ',')] * 5"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class MockSyms:\n    typedargslist = 1\n    arglist = 2\n    argument = 3\nsyms = MockSyms()"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""current_line = line""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, token, value):\n        self.token = token\n        self.value = value\n        self.bracket_depth = 0"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return 1\n    \ndef delimiter_count_with_priority(self, priority):\n        return 1\n    def __init__(self):\n        self.delimiters = {}"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.leaves = []\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n\n    def append_safe(self, leaf: Leaf, preformatted=False):\n        self.leaves.append(leaf)\n\n    def comments_after(self, leaf):\n        return []"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)\n\nline.bracket_tracker = MockBracketTracker()"",
            ""line.leaves = [Leaf(token.COMMA, ',')] * 3"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class MockSyms:\n    typedargslist = 1\n    arglist = 2\n    argument = 3"",
            ""syms = MockSyms()"",
            ""STANDALONE_COMMENT = 'comment'"",
            ""current_line = line""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, leaf_type, value):\n        self.type = leaf_type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class MockBracketTracker:\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 1\n    def __init__(self):\n        self.delimiters = {id(leaf): 1 for leaf in [Leaf(token.COMMA, ',')]}"",
            ""line = type('MockLine', (object,), {\n    'leaves': [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')],\n    'bracket_tracker': MockBracketTracker(),\n    'mode': 'mock_mode',\n    'depth': 0,\n    'inside_brackets': False,\n    'comments_after': lambda leaf: []\n})()"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.leaves = []\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n    def append(self, leaf):\n        self.leaves.append(leaf)"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""current_line = Line(line.mode, line.depth, line.inside_brackets)"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 'standalone_comment'""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List, Dict, Any"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, type_, value):\n        self.type = type_\n        self.value = value\n        self.bracket_depth = 0"",
            ""class MockBracketTracker:\n    def __init__(self):\n        self.delimiters = {}\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 1"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.leaves = []\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n    def append_safe(self, leaf: Leaf, preformatted=False):\n        self.leaves.append(leaf)\n    def comments_after(self, leaf): return []"",
            ""line = Line('test_mode', 0, False)\nline.bracket_tracker = MockBracketTracker()"",
            ""line.leaves = [Leaf(token.COMMA, ',')] * 5  # Populate with dummy Leaf objects"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""features = [Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL]"",
            ""class MockSyms:\n    typedargslist = 'typedargslist'\n    arglist = 'arglist'\n    argument = 'argument'\nsyms = MockSyms()"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""current_line = line  # Defining current_line to avoid nonlocal error""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, bracket_depth, leaf_type):# pragma: no cover"",
            ""        self.bracket_depth = bracket_depth# pragma: no cover"",
            ""        self.type = leaf_type # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {}# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return []# pragma: no cover"",
            "" # pragma: no cover"",
            ""line = MockLine(mode='test_mode', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.leaves.append(MockLeaf(bracket_depth=0, leaf_type=1))  # Add a dummy leaf# pragma: no cover"",
            "" # pragma: no cover"",
            ""current_line = line # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class syms:# pragma: no cover"",
            ""    typedargslist = 'typedargslist'# pragma: no cover"",
            ""    arglist = 'arglist'# pragma: no cover"",
            ""    argument = 'argument' # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMA': 1, 'STANDALONE_COMMENT': 2})() # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, type, bracket_depth):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1# pragma: no cover"",
            ""    delimiters = {} # pragma: no cover"",
            ""line = MockLine('test_mode', 0, False)# pragma: no cover"",
            ""line.bracket_tracker = MockBracketTracker() # pragma: no cover"",
            ""line.leaves = [MockLeaf(token.COMMA, 0)] * 3 # pragma: no cover"",
            ""current_line = MockLine(line.mode, line.depth, line.inside_brackets) # pragma: no cover"",
            ""DOT_PRIORITY = 1# pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class MockSyms:# pragma: no cover"",
            ""    typedargslist = 1# pragma: no cover"",
            ""    arglist = 2# pragma: no cover"",
            ""    argument = 3 # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List, Any # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {}# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.bracket_tracker = MockBracketTracker() # pragma: no cover"",
            ""DOT_PRIORITY = 1# pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""current_line = line # pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ',')] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List, Dict, Any # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, token, value):# pragma: no cover"",
            ""        self.token = token# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {}# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def append(self, leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.bracket_tracker = MockBracketTracker() # pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')] # pragma: no cover"",
            ""current_line = line # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 1, 'argument': 1})() # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type_, value):# pragma: no cover"",
            ""        self.type = type_# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1# pragma: no cover"",
            ""    delimiters = {} # pragma: no cover"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.bracket_tracker = MockBracketTracker() # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""features = {1, 2} # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""token = type('MockToken', (object,), {'COMMA': 1, 'STANDALONE_COMMENT': 2})() # pragma: no cover"",
            ""current_line = line # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class MockLeaf:# pragma: no cover"",
            ""    def __init__(self, bracket_depth, leaf_type):# pragma: no cover"",
            ""        self.bracket_depth = bracket_depth# pragma: no cover"",
            ""        self.type = leaf_type# pragma: no cover"",
            ""# pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {}# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""# pragma: no cover"",
            ""class MockLine:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""line = MockLine(mode='test_mode', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.leaves = [MockLeaf(0, token.COMMA) for _ in range(5)]# pragma: no cover"",
            ""line.bracket_tracker.delimiters = {id(leaf): 1 for leaf in line.leaves}# pragma: no cover"",
            ""# pragma: no cover"",
            ""current_line = line# pragma: no cover"",
            ""DOT_PRIORITY = 1# pragma: no cover"",
            ""COMMA_PRIORITY = 2# pragma: no cover"",
            ""features = {1, 2}# pragma: no cover"",
            ""syms = type('MockSymbols', (object,), {'typedargslist': 0, 'arglist': 1, 'argument': 2})# pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment'# pragma: no cover"",
            ""Feature = type('MockFeature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 0# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.bracket_tracker = MockBracketTracker() # pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ',')] * 5 # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class MockSyms:# pragma: no cover"",
            ""    typedargslist = 1# pragma: no cover"",
            ""    arglist = 2# pragma: no cover"",
            ""    argument = 3# pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""current_line = line # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, leaf_type, value):# pragma: no cover"",
            ""        self.type = leaf_type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {id(leaf): 1 for leaf in [Leaf(token.COMMA, ',')]} # pragma: no cover"",
            ""line = type('MockLine', (object,), {# pragma: no cover"",
            ""    'leaves': [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')],# pragma: no cover"",
            ""    'bracket_tracker': MockBracketTracker(),# pragma: no cover"",
            ""    'mode': 'mock_mode',# pragma: no cover"",
            ""    'depth': 0,# pragma: no cover"",
            ""    'inside_brackets': False,# pragma: no cover"",
            ""    'comments_after': lambda leaf: []# pragma: no cover"",
            ""})() # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def append(self, leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3}) # pragma: no cover"",
            ""current_line = Line(line.mode, line.depth, line.inside_brackets) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List, Dict, Any # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type_, value):# pragma: no cover"",
            ""        self.type = type_# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {}# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""    def append_safe(self, leaf: Leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""line = Line('test_mode', 0, False)# pragma: no cover"",
            ""line.bracket_tracker = MockBracketTracker() # pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ',')] * 5  # Populate with dummy Leaf objects # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""features = [Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL] # pragma: no cover"",
            ""class MockSyms:# pragma: no cover"",
            ""    typedargslist = 'typedargslist'# pragma: no cover"",
            ""    arglist = 'arglist'# pragma: no cover"",
            ""    argument = 'argument'# pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""current_line = line  # Defining current_line to avoid nonlocal error # pragma: no cover""
        ]
    }
]",2,6628,0.003314,4164,0.006246,0.0095599999999999
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 74:
    ^
SyntaxError: no binding for nonlocal 'current_line' found
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, type_, value):\n        self.type = type_\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.leaves = []\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n\n    def comments_after(self, leaf):\n        return []"",
            ""class MockBracketTracker:\n    def __init__(self):\n        self.delimiters = {}\n\n    def max_delimiter_priority(self, exclude):\n        return 1\n\n    def delimiter_count_with_priority(self, priority):\n        return 1"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)\nline.leaves = [Leaf(token.COMMA, ','), Leaf(token.NAME, 'example')]\nline.bracket_tracker = MockBracketTracker()"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class Syms:\n    typedargslist = 'typedargslist'\n    arglist = 'arglist'\n    argument = 'argument'"",
            ""syms = Syms()"",
            ""current_line = line"",
            ""is_vararg = lambda leaf, within: leaf.type in ['*', '**']""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, token_type, value):\n        self.type = token_type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n    def comments_after(self, leaf):\n        return []"",
            ""class BracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1\n    def __init__(self):\n        self.delimiters = {1: 1}"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)\nline.bracket_tracker = BracketTracker()\nline.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class Syms:\n    typedargslist = 1\n    arglist = 2\n    argument = 3"",
            ""syms = Syms()"",
            ""def is_vararg(leaf, within):\n    return False"",
            ""current_line = line""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n    def comments_after(self, leaf):\n        return []"",
            ""class BracketTracker:\n    def __init__(self):\n        self.delimiters = {}\n    def max_delimiter_priority(self, exclude):\n        return 0\n    def delimiter_count_with_priority(self, priority):\n        return 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)\nline.bracket_tracker = BracketTracker()"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf('dummy', 'value')]\ncurrent_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""DOT_PRIORITY = 0"",
            ""COMMA_PRIORITY = 1"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class Syms:\n    typedargslist = 1\n    arglist = 2\n    argument = 3"",
            ""syms = Syms()"",
            ""def is_vararg(leaf, within): return leaf.type in ['*', '**']""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n    def comments_after(self, leaf):\n        return []"",
            ""class BracketTracker:\n    def __init__(self):\n        self.delimiters = {}\n    def max_delimiter_priority(self, exclude):\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)\nline.leaves = [Leaf(token.COMMA, ','), Leaf('example', 'example')]\nline.bracket_tracker = BracketTracker()"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class Syms:\n    typedargslist = 'typedargslist'\n    arglist = 'arglist'\n    argument = 'argument'"",
            ""syms = Syms()"",
            ""def is_vararg(leaf, within):\n    return isinstance(leaf, Leaf)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n    def comments_after(self, leaf):\n        return []"",
            ""class BracketTracker:\n    def __init__(self):\n        self.delimiters = {}\n    def max_delimiter_priority(self, exclude):\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1"",
            ""line = Line(mode='mock_mode', depth=0, inside_brackets=False)\nline.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]\nline.bracket_tracker = BracketTracker()"",
            ""current_line = line"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class Syms:\n    typedargslist = 1\n    arglist = 2\n    argument = 3"",
            ""syms = Syms()"",
            ""def is_vararg(leaf, within):\n    return True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n        self.comments_after_fn = lambda leaf: []  \n    def comments_after(self, leaf):\n        return self.comments_after_fn(leaf)\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n    def append(self, leaf):\n        self.leaves.append(leaf)"",
            ""class MockBracketTracker:\n    def __init__(self):\n        self.delimiters = {}\n    def max_delimiter_priority(self, exclude):\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)\nline.bracket_tracker = MockBracketTracker()\nline.leaves = [Leaf(token.COMMA, ','), Leaf(token.STANDALONE_COMMENT, 'comment')]"",
            ""DOT_PRIORITY = 1\nCOMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class Syms:\n    typedargslist = 'typedargslist'\n    arglist = 'arglist'\n    argument = 'argument'"",
            ""syms = Syms()"",
            ""def is_vararg(leaf, within):\n    return leaf.type in {syms.arglist, syms.argument}"",
            ""current_line = line""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n    def comments_after(self, leaf):\n        return []"",
            ""class BracketTracker:\n    def __init__(self):\n        self.delimiters = {}\n    def max_delimiter_priority(self, exclude):\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 2"",
            ""DOT_PRIORITY = 0"",
            ""COMMA_PRIORITY = 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)\nline.leaves = [Leaf(token.COMMA, ','), Leaf('id', 'example')]\nline.bracket_tracker = BracketTracker()"",
            ""trailing_comma_safe = True"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class Syms:\n    typedargslist = 'typedargslist'\n    arglist = 'arglist'\n    argument = 'argument'"",
            ""syms = Syms()"",
            ""def is_vararg(leaf, within):\n    return False"",
            ""current_line = line""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n    \n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n    \n    def comments_after(self, leaf):\n        return []"",
            ""class BracketTracker:\n    def __init__(self):\n        self.delimiters = {}\n    \n    def max_delimiter_priority(self, exclude):\n        return 1\n    \n    def delimiter_count_with_priority(self, priority):\n        return 1"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)\nline.leaves = [Leaf(token.COMMA, ','), Leaf('arg', 'value')]\nline.bracket_tracker = BracketTracker()"",
            ""DOT_PRIORITY = 1\nCOMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class Syms:\n    typedargslist = 1\n    arglist = 2\n    argument = 3\nsyms = Syms()"",
            ""def is_vararg(leaf, within): return leaf.type == 'arg'"",
            ""current_line = None""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List, Dict"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n    def append_safe(self, leaf: Leaf, preformatted=False):\n        self.leaves.append(leaf)\n    def comments_after(self, leaf: Leaf):\n        return []"",
            ""class BracketTracker:\n    def __init__(self):\n        self.delimiters = {}\n    def max_delimiter_priority(self, exclude):\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)\nline.leaves = [Leaf(token.COMMA, ','), Leaf(token.STANDALONE_COMMENT, '// comment')]"",
            ""line.bracket_tracker = BracketTracker()"",
            ""DOT_PRIORITY = 0"",
            ""COMMA_PRIORITY = 1"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class MockSymbols:\n    typedargslist = 'typedargslist'\n    arglist = 'arglist'\n    argument = 'argument'"",
            ""syms = MockSymbols()"",
            ""current_line = line"",
            ""def is_vararg(leaf, within):\n    return leaf.type in [syms.argument]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n    def comments_after(self, leaf):\n        return []"",
            ""class BracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1\n    def __init__(self):\n        self.delimiters = {1: 1, 2: 1}"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)\nline.leaves = [Leaf(token.COMMA, ','), Leaf('arg', 'value')]\nline.bracket_tracker = BracketTracker()"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class Syms:\n    typedargslist = 1\n    arglist = 2\n    argument = 3"",
            ""syms = Syms()"",
            ""trailing_comma_safe = True\ncurrent_line = line""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type_, value):# pragma: no cover"",
            ""        self.type = type_# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {}# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.NAME, 'example')]# pragma: no cover"",
            ""line.bracket_tracker = MockBracketTracker() # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class Syms:# pragma: no cover"",
            ""    typedargslist = 'typedargslist'# pragma: no cover"",
            ""    arglist = 'arglist'# pragma: no cover"",
            ""    argument = 'argument' # pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""current_line = line # pragma: no cover"",
            ""is_vararg = lambda leaf, within: leaf.type in ['*', '**'] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, token_type, value):# pragma: no cover"",
            ""        self.type = token_type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {1: 1} # pragma: no cover"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker()# pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')] # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class Syms:# pragma: no cover"",
            ""    typedargslist = 1# pragma: no cover"",
            ""    arglist = 2# pragma: no cover"",
            ""    argument = 3 # pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""def is_vararg(leaf, within):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""current_line = line # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {}# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 0# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf('dummy', 'value')]# pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""DOT_PRIORITY = 0 # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class Syms:# pragma: no cover"",
            ""    typedargslist = 1# pragma: no cover"",
            ""    arglist = 2# pragma: no cover"",
            ""    argument = 3 # pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""def is_vararg(leaf, within): return leaf.type in ['*', '**'] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {}# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf('example', 'example')]# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class Syms:# pragma: no cover"",
            ""    typedargslist = 'typedargslist'# pragma: no cover"",
            ""    arglist = 'arglist'# pragma: no cover"",
            ""    argument = 'argument' # pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""def is_vararg(leaf, within):# pragma: no cover"",
            ""    return isinstance(leaf, Leaf) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {}# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""line = Line(mode='mock_mode', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.COMMA, ',')]# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""current_line = line # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class Syms:# pragma: no cover"",
            ""    typedargslist = 1# pragma: no cover"",
            ""    arglist = 2# pragma: no cover"",
            ""    argument = 3 # pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""def is_vararg(leaf, within):# pragma: no cover"",
            ""    return True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""        self.comments_after_fn = lambda leaf: []  # pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return self.comments_after_fn(leaf)# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def append(self, leaf):# pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""class MockBracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {}# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.bracket_tracker = MockBracketTracker()# pragma: no cover"",
            ""DOT_PRIORITY = 1# pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class Syms:# pragma: no cover"",
            ""    typedargslist = 'typedargslist'# pragma: no cover"",
            ""    arglist = 'arglist'# pragma: no cover"",
            ""    argument = 'argument' # pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""def is_vararg(leaf, within):# pragma: no cover"",
            ""    return leaf.type in {syms.arglist, syms.argument} # pragma: no cover"",
            ""current_line = line # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {}# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 2 # pragma: no cover"",
            ""DOT_PRIORITY = 0 # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf('id', 'example')]# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class Syms:# pragma: no cover"",
            ""    typedargslist = 'typedargslist'# pragma: no cover"",
            ""    arglist = 'arglist'# pragma: no cover"",
            ""    argument = 'argument' # pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""def is_vararg(leaf, within):# pragma: no cover"",
            ""    return False # pragma: no cover"",
            ""current_line = line # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {}# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf('arg', 'value')]# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""DOT_PRIORITY = 1# pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class Syms:# pragma: no cover"",
            ""    typedargslist = 1# pragma: no cover"",
            ""    arglist = 2# pragma: no cover"",
            ""    argument = 3# pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""def is_vararg(leaf, within): return leaf.type == 'arg' # pragma: no cover"",
            ""current_line = None # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List, Dict # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""    def append_safe(self, leaf: Leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def comments_after(self, leaf: Leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {}# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""DOT_PRIORITY = 0 # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class MockSymbols:# pragma: no cover"",
            ""    typedargslist = 'typedargslist'# pragma: no cover"",
            ""    arglist = 'arglist'# pragma: no cover"",
            ""    argument = 'argument' # pragma: no cover"",
            ""syms = MockSymbols() # pragma: no cover"",
            ""current_line = line # pragma: no cover"",
            ""def is_vararg(leaf, within):# pragma: no cover"",
            ""    return leaf.type in [syms.argument] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {1: 1, 2: 1} # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf('arg', 'value')]# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class Syms:# pragma: no cover"",
            ""    typedargslist = 1# pragma: no cover"",
            ""    arglist = 2# pragma: no cover"",
            ""    argument = 3 # pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""trailing_comma_safe = True# pragma: no cover"",
            ""current_line = line # pragma: no cover""
        ]
    }
]",2,7343,0.0036715,4354,0.006531,0.0102025
"When trying to execute the code snippet with the provided imports and initialization, the following error happens:
# begin error message
Execution error at line 65:
    ^
SyntaxError: no binding for nonlocal 'current_line' found
# end error message

Please, provide self-contained and concrete Python fixed values of the imports and initialization to solve the error and make the code snippet executable.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n    \n    def append_safe(self, leaf: Leaf, preformatted=False):\n        self.leaves.append(leaf)\n    \n    def comments_after(self, leaf: Leaf):\n        return []"",
            ""class BracketTracker:\n    def __init__(self):\n        self.delimiters = {}\n    \n    def max_delimiter_priority(self, exclude):\n        return 1\n    \n    def delimiter_count_with_priority(self, priority):\n        return 1"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)\nline.leaves = [Leaf(token.COMMA, ','), Leaf('arg', 'example')]\nline.bracket_tracker = BracketTracker()"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class Syms:\n    typedargslist = 'typedargslist'\n    arglist = 'arglist'\n    argument = 'argument'"",
            ""syms = Syms()"",
            ""def is_vararg(leaf, within):\n    return leaf.type == 'arg'""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n\n    def comments_after(self, leaf):\n        return []"",
            ""class BracketTracker:\n    def __init__(self):\n        self.delimiters = {}\n\n    def max_delimiter_priority(self, exclude):\n        return 1\n\n    def delimiter_count_with_priority(self, priority):\n        return 1"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)\nline.bracket_tracker = BracketTracker()\nline.leaves = [Leaf(token.COMMA, ','), Leaf(token.STANDALONE_COMMENT, 'comment')]"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class Syms:\n    typedargslist = 1\n    arglist = 2\n    argument = 3"",
            ""syms = Syms()"",
            ""current_line = None"",
            ""def is_vararg(leaf, within):\n    return False""
        ]
    },
    {
        ""imports"": [
            ""sys"",
            ""import token"",
            ""from typing import Iterator""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n\n    def comments_after(self, leaf):\n        return []"",
            ""class BracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1\n    def __init__(self):\n        self.delimiters = {}"",
            ""line = Line(mode='mock_mode', depth=0, inside_brackets=False)\nline.leaves = [Leaf(token.COMMA, ','), Leaf(token.STANDALONE_COMMENT, 'comment')]"",
            ""line.bracket_tracker = BracketTracker()"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class Syms:\n    typedargslist = 'typedargslist'\n    arglist = 'arglist'\n    argument = 'argument'\nsyms = Syms()"",
            ""current_line = line""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0\n\nclass Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n\n    def comments_after(self, leaf):\n        return []"",
            ""class BracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1\n    def __init__(self):\n        self.delimiters = {}"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)\nline.bracket_tracker = BracketTracker()"",
            ""current_line = line"",
            ""DOT_PRIORITY = 0"",
            ""COMMA_PRIORITY = 1"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('syms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})()"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""def is_vararg(leaf, within):\n    return False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, token_type, value):\n        self.type = token_type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n\n    def comments_after(self, leaf):\n        return []"",
            ""class BracketTracker:\n    def __init__(self):\n        self.delimiters = {}\n    def max_delimiter_priority(self, exclude):\n        return 0\n    def delimiter_count_with_priority(self, priority):\n        return 1"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)\nline.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.COMMA, ','))\nline.leaves.append(Leaf(token.NAME, 'example'))"",
            ""current_line = Line('test_mode', 0, False)"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class Syms:\n    typedargslist = 'typedargslist'\n    arglist = 'arglist'\n    argument = 'argument'"",
            ""syms = Syms()"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""def is_vararg(leaf, within):\n    return False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 1\n\nclass Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n\n    def comments_after(self, leaf):\n        return []"",
            ""class BracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1\n    def __init__(self):\n        self.delimiters = {}"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)\nline.bracket_tracker = BracketTracker()"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf('x', 'value')]"",
            ""current_line = line"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class Syms:\n    typedargslist = 1\n    arglist = 2\n    argument = 3"",
            ""syms = Syms()"",
            ""def is_vararg(leaf, within): return False"",
            ""STANDALONE_COMMENT = 4""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)"",
            ""class BracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1\n    def __init__(self):\n        self.delimiters = {}"",
            ""line.bracket_tracker = BracketTracker()"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class Syms:\n    typedargslist = 1\n    arglist = 2\n    argument = 3"",
            ""syms = Syms()"",
            ""current_line = line"",
            ""def is_vararg(leaf, within): return leaf.type == 'vararg'"",
            ""STANDALONE_COMMENT = 3""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n    def append_safe(self, leaf, preformatted=False): self.leaves.append(leaf)"",
            ""class BracketTracker:\n    def max_delimiter_priority(self, exclude): return 1\n    def delimiter_count_with_priority(self, priority): return 1\n    def __init__(self): self.delimiters = {}"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)\nline.bracket_tracker = BracketTracker()"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.NAME, 'example')]"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'\n    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""class MockSyms:\n    typedargslist = 1\n    arglist = 2\n    argument = 3\n    def __init__(self): pass"",
            ""syms = MockSyms()"",
            ""current_line = line""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)"",
            ""class BracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1\n    def __init__(self):\n        self.delimiters = {}"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)\nline.bracket_tracker = BracketTracker()"",
            ""current_line = line"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})()"",
            ""STANDALONE_COMMENT = 'standalone_comment'"",
            ""def is_vararg(leaf, within): return False"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf('arg', 'value')]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n        self.bracket_depth = 0"",
            ""class Line:\n    def __init__(self, mode, depth, inside_brackets):\n        self.mode = mode\n        self.depth = depth\n        self.inside_brackets = inside_brackets\n        self.leaves = []\n    def append_safe(self, leaf, preformatted=False):\n        self.leaves.append(leaf)\n    def comments_after(self, leaf):\n        return []"",
            ""class BracketTracker:\n    def max_delimiter_priority(self, exclude):\n        return 1\n    def delimiter_count_with_priority(self, priority):\n        return 1\n    def __init__(self):\n        self.delimiters = {}"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)\nline.leaves = [Leaf(1, 'arg1'), Leaf(2, 'arg2'), Leaf(3, 'arg3')]\nline.bracket_tracker = BracketTracker()"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""class Feature:\n    TRAILING_COMMA_IN_DEF = 1\n    TRAILING_COMMA_IN_CALL = 2"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})()"",
            ""STANDALONE_COMMENT = 2"",
            ""current_line = None""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def append_safe(self, leaf: Leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def comments_after(self, leaf: Leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {}# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf('arg', 'example')]# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class Syms:# pragma: no cover"",
            ""    typedargslist = 'typedargslist'# pragma: no cover"",
            ""    arglist = 'arglist'# pragma: no cover"",
            ""    argument = 'argument' # pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""def is_vararg(leaf, within):# pragma: no cover"",
            ""    return leaf.type == 'arg' # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {}# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker()# pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class Syms:# pragma: no cover"",
            ""    typedargslist = 1# pragma: no cover"",
            ""    arglist = 2# pragma: no cover"",
            ""    argument = 3 # pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""current_line = None # pragma: no cover"",
            ""def is_vararg(leaf, within):# pragma: no cover"",
            ""    return False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""import token # pragma: no cover"",
            ""from typing import Iterator # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""line = Line(mode='mock_mode', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class Syms:# pragma: no cover"",
            ""    typedargslist = 'typedargslist'# pragma: no cover"",
            ""    arglist = 'arglist'# pragma: no cover"",
            ""    argument = 'argument'# pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""current_line = line # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""current_line = line # pragma: no cover"",
            ""DOT_PRIORITY = 0 # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})() # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""def is_vararg(leaf, within):# pragma: no cover"",
            ""    return False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, token_type, value):# pragma: no cover"",
            ""        self.type = token_type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {}# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 0# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1 # pragma: no cover"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ','))# pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'example')) # pragma: no cover"",
            ""current_line = Line('test_mode', 0, False) # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class Syms:# pragma: no cover"",
            ""    typedargslist = 'typedargslist'# pragma: no cover"",
            ""    arglist = 'arglist'# pragma: no cover"",
            ""    argument = 'argument' # pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""def is_vararg(leaf, within):# pragma: no cover"",
            ""    return False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 1# pragma: no cover"",
            ""# pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf('x', 'value')] # pragma: no cover"",
            ""current_line = line # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class Syms:# pragma: no cover"",
            ""    typedargslist = 1# pragma: no cover"",
            ""    arglist = 2# pragma: no cover"",
            ""    argument = 3 # pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""STANDALONE_COMMENT = 4 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False) # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class Syms:# pragma: no cover"",
            ""    typedargslist = 1# pragma: no cover"",
            ""    arglist = 2# pragma: no cover"",
            ""    argument = 3 # pragma: no cover"",
            ""syms = Syms() # pragma: no cover"",
            ""current_line = line # pragma: no cover"",
            ""def is_vararg(leaf, within): return leaf.type == 'vararg' # pragma: no cover"",
            ""STANDALONE_COMMENT = 3 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): self.leaves.append(leaf) # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1# pragma: no cover"",
            ""    def __init__(self): self.delimiters = {} # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf(token.NAME, 'example')] # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""class MockSyms:# pragma: no cover"",
            ""    typedargslist = 1# pragma: no cover"",
            ""    arglist = 2# pragma: no cover"",
            ""    argument = 3# pragma: no cover"",
            ""    def __init__(self): pass # pragma: no cover"",
            ""syms = MockSyms() # pragma: no cover"",
            ""current_line = line # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""current_line = line # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})() # pragma: no cover"",
            ""STANDALONE_COMMENT = 'standalone_comment' # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ','), Leaf('arg', 'value')] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf:# pragma: no cover"",
            ""    def __init__(self, type, value):# pragma: no cover"",
            ""        self.type = type# pragma: no cover"",
            ""        self.value = value# pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line:# pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets):# pragma: no cover"",
            ""        self.mode = mode# pragma: no cover"",
            ""        self.depth = depth# pragma: no cover"",
            ""        self.inside_brackets = inside_brackets# pragma: no cover"",
            ""        self.leaves = []# pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False):# pragma: no cover"",
            ""        self.leaves.append(leaf)# pragma: no cover"",
            ""    def comments_after(self, leaf):# pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class BracketTracker:# pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority):# pragma: no cover"",
            ""        return 1# pragma: no cover"",
            ""    def __init__(self):# pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)# pragma: no cover"",
            ""line.leaves = [Leaf(1, 'arg1'), Leaf(2, 'arg2'), Leaf(3, 'arg3')]# pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""class Feature:# pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 1# pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 2 # pragma: no cover"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL} # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})() # pragma: no cover"",
            ""STANDALONE_COMMENT = 2 # pragma: no cover"",
            ""current_line = None # pragma: no cover""
        ]
    }
]",2,8000,0.004,4203,0.0063045,0.0103045
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Split according to delimiters of the highest priority.
    If the appropriate Features are given, the split will add trailing commas
    also in function signatures and calls that contain `*` and `**`.
    """"""
try: # uncovered
    last_leaf = line.leaves[-1] # uncovered
except IndexError: # uncovered
    raise CannotSplit(""Line empty"") from None # uncovered
bt = line.bracket_tracker # uncovered
try: # uncovered
    delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)}) # uncovered
except ValueError: # uncovered
    raise CannotSplit(""No delimiters found"") from None # uncovered
if delimiter_priority == DOT_PRIORITY: # uncovered
    if bt.delimiter_count_with_priority(delimiter_priority) == 1: # uncovered
        raise CannotSplit(""Splitting a single attribute from its owner looks wrong"") # uncovered
current_line = Line( # uncovered
    mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
) # uncovered
lowest_depth = sys.maxsize # uncovered
trailing_comma_safe = True # uncovered
def append_to_line(leaf: Leaf) -> Iterator[Line]: # uncovered
    """"""Append `leaf` to current line or to new line if appending impossible.""""""
    nonlocal current_line # uncovered
    try: # uncovered
        current_line.append_safe(leaf, preformatted=True) # uncovered
    except ValueError: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
        current_line.append(leaf) # uncovered
for leaf in line.leaves: # uncovered
    aux = append_to_line(leaf) # uncovered
    exit(aux) # uncovered
    for comment_after in line.comments_after(leaf): # uncovered
        aux = append_to_line(comment_after) # uncovered
        exit(aux) # uncovered
    lowest_depth = min(lowest_depth, leaf.bracket_depth) # uncovered
    if leaf.bracket_depth == lowest_depth: # uncovered
        if is_vararg(leaf, within={syms.typedargslist}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features # uncovered
            ) # uncovered
        elif is_vararg(leaf, within={syms.arglist, syms.argument}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features # uncovered
            ) # uncovered
    leaf_priority = bt.delimiters.get(id(leaf)) # uncovered
    if leaf_priority == delimiter_priority: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
if current_line: # uncovered
    if ( # uncovered
        trailing_comma_safe # uncovered
        and delimiter_priority == COMMA_PRIORITY # uncovered
        and current_line.leaves[-1].type != token.COMMA # uncovered
        and current_line.leaves[-1].type != STANDALONE_COMMENT # uncovered
    ): # uncovered
        new_comma = Leaf(token.COMMA, "","") # uncovered
        current_line.append(new_comma) # uncovered
    aux = current_line # uncovered
    exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""from collections import namedtuple""
        ],
        ""initialization"": [
            ""Leaf = namedtuple('Leaf', ['bracket_depth', 'type'])"",
            ""Line = namedtuple('Line', ['leaves', 'comments_after', 'mode', 'depth', 'inside_brackets', 'append_safe'])"",
            ""BracketTracker = type('BracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiter_count_with_priority': lambda self, priority: 1, 'delimiters': {}})"",
            ""line = Line(leaves=[Leaf(bracket_depth=0, type='test')], comments_after=lambda x: [], mode='test', depth=0, inside_brackets=False, append_safe=lambda leaf, preformatted: None)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""COMMA_PRIORITY = 0"",
            ""DOT_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 2"",
            ""Feature = type('Feature', 'TRAILING_COMMA_IN_DEF TRAILING_COMMA_IN_CALL'.split(), {})"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""is_vararg = lambda leaf, within: True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""token"",
            ""syms""
        ],
        ""initialization"": [
            ""class Leaf:  # Mock class to simulate behavior of Leaf"",
            ""    def __init__(self, type_, content):"",
            ""        self.type = type_"",
            ""        self.content = content"",
            ""        self.bracket_depth = 0"",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        pass"",
            """",
            ""class Line:  # Mock class to simulate behavior of Line"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    def append_safe(self, leaf, preformatted):"",
            ""        self.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            """",
            ""class CannotSplit(Exception):  # Custom exception"",
            ""    pass"",
            """",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)"",
            ""line.leaves = [Leaf(type='dummy', content='example')]"",
            ""line.leaves[0].bracket_depth = 0"",
            ""line.leaves.append(Leaf(type='dummy', content='example2'))"",
            ""line.leaves[1].bracket_depth = 0"",
            ""line.bracket_tracker = type('MockBracketTracker', (object,), {"",
            ""    'max_delimiter_priority': lambda self, exclude: 1,"",
            ""    'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""    'delimiters': {id(line.leaves[0]): 1, id(line.leaves[1]): 1}"",
            ""})()"",
            ""features = { 'TRAILING_COMMA_IN_DEF' }"",
            ""DOT_PRIORITY = 1, COMMA_PRIORITY = 2""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token"",
            ""from some_module import Line, Leaf, CannotSplit, Feature, DOT_PRIORITY, COMMA_PRIORITY, is_vararg, syms, STANDALONE_COMMENT""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), {'leaves': [type('Mock', (object,), {'bracket_depth': 0, 'type': 0})()], 'depth': 0, 'mode': 'test', 'inside_brackets': False, 'bracket_tracker': type('Mock', (object,), {'max_delimiter_priority': lambda self, exclude: 0, 'delimiter_count_with_priority': lambda self, priority: 1, 'delimiters': {}}), 'comments_after': lambda self, leaf: []})()"",
            ""features = [Feature.TRAILING_COMMA_IN_DEF]"",
            ""bt = line.bracket_tracker"",
            ""last_leaf = line.leaves[-1]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf: def __init__(self, type, value): self.type = type; self.value = value; self.bracket_depth = 0"",
            ""class Line: def __init__(self, mode, depth, inside_brackets): self.mode = mode; self.depth = depth; self.inside_brackets = inside_brackets; self.leaves = []; self.comments_after = lambda leaf: []"",
            ""class BracketTracker: def __init__(self): self.delimiters = {}; self.leaves = []; self.max_delimiter_priority = lambda exclude: 1; self.delimiter_count_with_priority = lambda priority: 2"",
            ""line = type('Line', (object,), {'leaves': [Leaf(token.COMMA, 'a'), Leaf(token.COMMA, 'b')], 'bracket_tracker': BracketTracker(), 'mode': 'test', 'depth': 0, 'inside_brackets': False, 'comments_after': lambda leaf: []})()"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""features = [Feature.TRAILING_COMMA_IN_DEF]"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""def is_vararg(leaf, within): return True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""Line = type('MockLine', (object,), {'mode': 'test', 'depth': 0, 'inside_brackets': False, 'leaves': [], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {}})()})"",
            ""Leaf = type('MockLeaf', (object,), {'bracket_depth': 0, 'type': 'test'})"",
            ""line = MockLine()""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""from dataclasses import dataclass"",
            ""class CannotSplit(Exception): pass"",
            ""class Line: ..."",
            ""class Leaf: ..."",
            ""class Feature: TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def', TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""class Token: COMMA = 'COMMA', STANDALONE_COMMENT = 'STANDALONE_COMMENT'"",
            ""class syms: typedargslist = 'typedargslist', arglist = 'arglist', argument = 'argument'""
        ],
        ""initialization"": [
            ""class Mock: pass"",
            ""line = Mock()"",
            ""line.leaves = []"",
            ""line.bracket_tracker = Mock()"",
            ""line.comments_after = lambda leaf: []"",
            ""line.mode = 'test'"",
            ""line.depth = 0"",
            ""line.inside_brackets = False"",
            ""bt = line.bracket_tracker"",
            ""bt.max_delimiter_priority = lambda exclude: 1"",
            ""bt.delimiter_count_with_priority = lambda priority: 2"",
            ""bt.delimiters = {}"",
            ""line.leaves.append(Mock())"",
            ""line.leaves[0].bracket_depth = 0"",
            ""line.leaves[0].type = Token.COMMA"",
            ""features = [Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL]"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Line: "",
            ""    def __init__(self, mode=None, depth=0, inside_brackets=False):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""def is_vararg(leaf, within): return False"",
            ""class Features:"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def'"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call'"",
            ""line = Line()"",
            ""line.leaves = [Leaf('name', 'function_name'), Leaf('arg', 'arg1')]"",
            ""line.bracket_tracker = type('MockBracketTracker', (object,), {"",
            ""    'max_delimiter_priority': lambda self, exclude: 0,"",
            ""    'delimiter_count_with_priority': lambda self, priority: 2,"",
            ""    'delimiters': {id(line.leaves[0]): 0, id(line.leaves[1]): 0}"",
            ""})()"",
            ""features = {Features.TRAILING_COMMA_IN_DEF, Features.TRAILING_COMMA_IN_CALL}"",
            ""DOT_PRIORITY = 0, COMMA_PRIORITY = 1""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf: def __init__(self, type, value): self.type = type; self.value = value; self.bracket_depth = 0"",
            ""class Line: def __init__(self, mode, depth, inside_brackets): self.mode = mode; self.depth = depth; self.inside_brackets = inside_brackets; self.leaves = []; self.comments = []; def append_safe(self, leaf, preformatted): self.leaves.append(leaf); def append(self, leaf): self.leaves.append(leaf)"",
            ""class BracketTracker: def __init__(self): self.delimiters = {}; def max_delimiter_priority(self, exclude): return 1; def delimiter_count_with_priority(self, priority): return 1"",
            ""line = type('MockLine', (object,), {'leaves': [Leaf(token.NAME, 'a')], 'comments_after': lambda self, leaf: [], 'bracket_tracker': BracketTracker(), 'mode': 'mock', 'depth': 0, 'inside_brackets': False})()"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 'typedargslist', 'arglist': 'arglist', 'argument': 'argument'})()"",
            ""is_vararg = lambda leaf, within: True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""        self.bracket_tracker = BracketTracker()"",
            ""    def append_safe(self, leaf, preformatted=False): pass"",
            ""    def comments_after(self, leaf): return []"",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class BracketTracker:"",
            ""    def max_delimiter_priority(self, exclude): return 0"",
            ""    def delimiter_count_with_priority(self, priority): return 1"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""def is_vararg(leaf, within): return False"",
            ""syms = type('Mock', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""Feature = type('Mock', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})()"",
            ""DOT_PRIORITY = 0"",
            ""COMMA_PRIORITY = 1"",
            ""STANDALONE_COMMENT = 2"",
            ""line = Line(mode='mock_mode', depth=0, inside_brackets=False)"",
            ""line.leaves = [Leaf(token.COMMA, ',')]""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Line: "",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""        self.comments_after = lambda leaf: []"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""    @property"",
            ""    def bracket_depth(self): return 0"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.leaves = [type('Leaf', (object,), {'type': 'TOKEN', 'bracket_depth': 0})()]"",
            ""line.leaves.append(type('Leaf', (object,), {'type': 'TOKEN', 'bracket_depth': 0})())"",
            ""line.leaves.append(type('Leaf', (object,), {'type': 'COMMA', 'bracket_depth': 0})())"",
            ""line.bracket_tracker = type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {id(line.leaves[0]): 1, id(line.leaves[1]): 1}})()"",
            ""features = ['TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL']"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""token = type('token', (object,), {'COMMA': 'COMMA', 'STANDALONE_COMMENT': 'COMMENT'})"",
            ""is_vararg = lambda leaf, within: True""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from collections import namedtuple # pragma: no cover""
        ],
        ""initialization"": [
            ""Leaf = namedtuple('Leaf', ['bracket_depth', 'type']) # pragma: no cover"",
            ""Line = namedtuple('Line', ['leaves', 'comments_after', 'mode', 'depth', 'inside_brackets', 'append_safe']) # pragma: no cover"",
            ""BracketTracker = type('BracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiter_count_with_priority': lambda self, priority: 1, 'delimiters': {}}) # pragma: no cover"",
            ""line = Line(leaves=[Leaf(bracket_depth=0, type='test')], comments_after=lambda x: [], mode='test', depth=0, inside_brackets=False, append_safe=lambda leaf, preformatted: None) # pragma: no cover"",
            ""COMMA_PRIORITY = 0 # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 2 # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""line = type('Mock', (object,), {'leaves': [type('Mock', (object,), {'bracket_depth': 0, 'type': 0})()], 'depth': 0, 'mode': 'test', 'inside_brackets': False, 'bracket_tracker': type('Mock', (object,), {'max_delimiter_priority': lambda self, exclude: 0, 'delimiter_count_with_priority': lambda self, priority: 1, 'delimiters': {}}), 'comments_after': lambda self, leaf: []})() # pragma: no cover"",
            ""bt = line.bracket_tracker # pragma: no cover"",
            ""last_leaf = line.leaves[-1] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""Line = type('MockLine', (object,), {'mode': 'test', 'depth': 0, 'inside_brackets': False, 'leaves': [], 'bracket_tracker': type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {}})()}) # pragma: no cover"",
            ""Leaf = type('MockLeaf', (object,), {'bracket_depth': 0, 'type': 'test'}) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""from dataclasses import dataclass # pragma: no cover"",
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Line: ... # pragma: no cover"",
            ""class Leaf: ... # pragma: no cover""
        ],
        ""initialization"": [
            ""class Mock: pass # pragma: no cover"",
            ""line = Mock() # pragma: no cover"",
            ""line.leaves = [] # pragma: no cover"",
            ""line.bracket_tracker = Mock() # pragma: no cover"",
            ""line.comments_after = lambda leaf: [] # pragma: no cover"",
            ""line.mode = 'test' # pragma: no cover"",
            ""line.depth = 0 # pragma: no cover"",
            ""line.inside_brackets = False # pragma: no cover"",
            ""bt = line.bracket_tracker # pragma: no cover"",
            ""bt.max_delimiter_priority = lambda exclude: 1 # pragma: no cover"",
            ""bt.delimiter_count_with_priority = lambda priority: 2 # pragma: no cover"",
            ""bt.delimiters = {} # pragma: no cover"",
            ""line.leaves.append(Mock()) # pragma: no cover"",
            ""line.leaves[0].bracket_depth = 0 # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Line:  # pragma: no cover"",
            ""    def __init__(self, mode=None, depth=0, inside_brackets=False): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""class Features: # pragma: no cover"",
            ""    TRAILING_COMMA_IN_DEF = 'trailing_comma_in_def' # pragma: no cover"",
            ""    TRAILING_COMMA_IN_CALL = 'trailing_comma_in_call' # pragma: no cover"",
            ""line = Line() # pragma: no cover"",
            ""line.leaves = [Leaf('name', 'function_name'), Leaf('arg', 'arg1')] # pragma: no cover"",
            ""line.bracket_tracker = type('MockBracketTracker', (object,), { # pragma: no cover"",
            ""    'max_delimiter_priority': lambda self, exclude: 0, # pragma: no cover"",
            ""    'delimiter_count_with_priority': lambda self, priority: 2, # pragma: no cover"",
            ""    'delimiters': {id(line.leaves[0]): 0, id(line.leaves[1]): 0} # pragma: no cover"",
            ""})() # pragma: no cover"",
            ""features = {Features.TRAILING_COMMA_IN_DEF, Features.TRAILING_COMMA_IN_CALL} # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""        self.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): pass # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 0 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""def is_vararg(leaf, within): return False # pragma: no cover"",
            ""syms = type('Mock', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""Feature = type('Mock', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})() # pragma: no cover"",
            ""DOT_PRIORITY = 0 # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""STANDALONE_COMMENT = 2 # pragma: no cover"",
            ""line = Line(mode='mock_mode', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.leaves = [Leaf(token.COMMA, ',')] # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Line:  # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""        self.comments_after = lambda leaf: [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    @property # pragma: no cover"",
            ""    def bracket_depth(self): return 0 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.leaves = [type('Leaf', (object,), {'type': 'TOKEN', 'bracket_depth': 0})()] # pragma: no cover"",
            ""line.leaves.append(type('Leaf', (object,), {'type': 'TOKEN', 'bracket_depth': 0})()) # pragma: no cover"",
            ""line.leaves.append(type('Leaf', (object,), {'type': 'COMMA', 'bracket_depth': 0})()) # pragma: no cover"",
            ""line.bracket_tracker = type('MockBracketTracker', (object,), {'max_delimiter_priority': lambda self, exclude: 1, 'delimiter_count_with_priority': lambda self, priority: 2, 'delimiters': {id(line.leaves[0]): 1, id(line.leaves[1]): 1}})() # pragma: no cover"",
            ""features = ['TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL'] # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""token = type('token', (object,), {'COMMA': 'COMMA', 'STANDALONE_COMMENT': 'COMMENT'}) # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover""
        ]
    }
]",3,1052,0.000526,3487,0.0052305,0.0057564999999999
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Split according to delimiters of the highest priority.
    If the appropriate Features are given, the split will add trailing commas
    also in function signatures and calls that contain `*` and `**`.
    """"""
try: # uncovered
    last_leaf = line.leaves[-1] # uncovered
except IndexError: # uncovered
    raise CannotSplit(""Line empty"") from None # uncovered
bt = line.bracket_tracker # uncovered
try: # uncovered
    delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)}) # uncovered
except ValueError: # uncovered
    raise CannotSplit(""No delimiters found"") from None # uncovered
if delimiter_priority == DOT_PRIORITY: # uncovered
    if bt.delimiter_count_with_priority(delimiter_priority) == 1: # uncovered
        raise CannotSplit(""Splitting a single attribute from its owner looks wrong"") # uncovered
current_line = Line( # uncovered
    mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
) # uncovered
lowest_depth = sys.maxsize # uncovered
trailing_comma_safe = True # uncovered
def append_to_line(leaf: Leaf) -> Iterator[Line]: # uncovered
    """"""Append `leaf` to current line or to new line if appending impossible.""""""
    nonlocal current_line # uncovered
    try: # uncovered
        current_line.append_safe(leaf, preformatted=True) # uncovered
    except ValueError: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
        current_line.append(leaf) # uncovered
for leaf in line.leaves: # uncovered
    aux = append_to_line(leaf) # uncovered
    exit(aux) # uncovered
    for comment_after in line.comments_after(leaf): # uncovered
        aux = append_to_line(comment_after) # uncovered
        exit(aux) # uncovered
    lowest_depth = min(lowest_depth, leaf.bracket_depth) # uncovered
    if leaf.bracket_depth == lowest_depth: # uncovered
        if is_vararg(leaf, within={syms.typedargslist}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features # uncovered
            ) # uncovered
        elif is_vararg(leaf, within={syms.arglist, syms.argument}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features # uncovered
            ) # uncovered
    leaf_priority = bt.delimiters.get(id(leaf)) # uncovered
    if leaf_priority == delimiter_priority: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
if current_line: # uncovered
    if ( # uncovered
        trailing_comma_safe # uncovered
        and delimiter_priority == COMMA_PRIORITY # uncovered
        and current_line.leaves[-1].type != token.COMMA # uncovered
        and current_line.leaves[-1].type != STANDALONE_COMMENT # uncovered
    ): # uncovered
        new_comma = Leaf(token.COMMA, "","") # uncovered
        current_line.append(new_comma) # uncovered
    aux = current_line # uncovered
    exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""        self.comments_after = lambda leaf: []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""class BracketTracker:"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.leaves = [Leaf(token.NAME, 'func')]"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf):"",
            ""        return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.leaves.append(Leaf(token.COMMA, 'value'))"",
            ""line.bracket_tracker = BracketTracker()"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""is_vararg = lambda leaf, within: False"",
            ""line.leaves[0].bracket_depth = 0""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        if not leaf: raise ValueError('Cannot append None')"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.leaves.append(Leaf(token.COMMA, 'comma'))"",
            ""line.leaves.append(Leaf(token.STANDALONE_COMMENT, 'comment'))"",
            ""line.bracket_tracker = BracketTracker()"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True"",
            ""def is_vararg(leaf, within): return True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf: def __init__(self, type, value): self.type = type; self.value = value; self.bracket_depth = 0"",
            ""class Line: def __init__(self, mode, depth, inside_brackets): self.mode = mode; self.depth = depth; self.inside_brackets = inside_brackets; self.leaves = []; def append_safe(self, leaf, preformatted): self.leaves.append(leaf)"",
            ""class BracketTracker: def max_delimiter_priority(self, exclude): return 1; def delimiter_count_with_priority(self, priority): return 2; def __init__(self): self.delimiters = {id(leaf): 1 for leaf in [Leaf(token.NAME, 'a'), Leaf(token.NAME, 'b')]}"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)"",
            ""line.leaves = [Leaf(token.NAME, 'arg1'), Leaf(token.COMMA, ',')]"",
            ""line.bracket_tracker = BracketTracker()"",
            ""features = {Feature.TRAILING_COMMA_IN_DEF, Feature.TRAILING_COMMA_IN_CALL}"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""Feature = type('Feature', (object,), {'TRAILING_COMMA_IN_DEF': 1, 'TRAILING_COMMA_IN_CALL': 2})"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})"",
            ""def is_vararg(leaf, within): return True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""leaf1 = Leaf(type=token.COMMA, value=',')"",
            ""line.leaves.append(leaf1)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""bt = line.bracket_tracker"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode='test', depth=0, inside_brackets=False)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf: def __init__(self, type_, value): self.type = type_; self.value = value; self.bracket_depth = 0"",
            ""class Line: def __init__(self, mode, depth, inside_brackets): self.mode = mode; self.depth = depth; self.inside_brackets = inside_brackets; self.leaves = []; self.comments_after = lambda leaf: []"",
            ""class BracketTracker: def __init__(self): self.delimiters = {}; self.max_delimiter_priority = lambda self, exclude: 1; self.delimiter_count_with_priority = lambda self, priority: 2"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)"",
            ""line.leaves = [Leaf(token.NAME, 'first_leaf')]"",
            ""line.bracket_tracker = BracketTracker()"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""is_vararg = lambda leaf, within: True"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""STANDALONE_COMMENT = 3""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'a'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""line.leaves[0].bracket_depth = 0"",
            ""line.leaves[1].bracket_depth = 0"",
            ""current_line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 0"",
            ""COMMA_PRIORITY = 1"",
            ""is_vararg = lambda leaf, within: True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""        self.comments_after = lambda leaf: []"",
            ""    def append_safe(self, leaf, preformatted=False):"",
            ""        self.leaves.append(leaf)"",
            ""    def append(self, leaf):"",
            ""        self.leaves.append(leaf)"",
            ""class BracketTracker:"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.leaves.append(Leaf(token.NAME, 'example'))"",
            ""line.bracket_tracker = BracketTracker()"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""is_vararg = lambda leaf, within: False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf: def __init__(self, type): self.type = type; self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""        self.comments = []"",
            ""    def append_safe(self, leaf, preformatted=False): self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class MockBracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude): return 2"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.leaves = [Leaf(token.NAME), Leaf(token.COMMA)]"",
            ""line.bracket_tracker = MockBracketTracker()"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 2"",
            ""COMMA_PRIORITY = 1"",
            ""is_vararg = lambda leaf, within: True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""leaf1 = Leaf(token.COMMA, 'value1')"",
            ""leaf2 = Leaf(token.NAME, 'value2')"",
            ""line.leaves.append(leaf1)"",
            ""line.leaves.append(leaf2)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 0"",
            ""COMMA_PRIORITY = 1"",
            ""is_vararg = lambda leaf, within: False""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""        self.comments_after = lambda leaf: [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.leaves = [Leaf(token.NAME, 'func')] # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): # pragma: no cover"",
            ""        return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, 'value')) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""line.leaves[0].bracket_depth = 0 # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        if not leaf: raise ValueError('Cannot append None') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, 'comma')) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover"",
            ""def is_vararg(leaf, within): return True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""leaf1 = Leaf(type=token.COMMA, value=',') # pragma: no cover"",
            ""line.leaves.append(leaf1) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""bt = line.bracket_tracker # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'a')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""line.leaves[0].bracket_depth = 0 # pragma: no cover"",
            ""line.leaves[1].bracket_depth = 0 # pragma: no cover"",
            ""current_line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 0 # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""        self.comments_after = lambda leaf: [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=False): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def append(self, leaf): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'example')) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            """"
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""leaf1 = Leaf(token.COMMA, 'value1') # pragma: no cover"",
            ""leaf2 = Leaf(token.NAME, 'value2') # pragma: no cover"",
            ""line.leaves.append(leaf1) # pragma: no cover"",
            ""line.leaves.append(leaf2) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 0 # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover""
        ]
    }
]",3,5568,0.002784,3812,0.005718,0.008502
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Split according to delimiters of the highest priority.
    If the appropriate Features are given, the split will add trailing commas
    also in function signatures and calls that contain `*` and `**`.
    """"""
try: # uncovered
    last_leaf = line.leaves[-1] # uncovered
except IndexError: # uncovered
    raise CannotSplit(""Line empty"") from None # uncovered
bt = line.bracket_tracker # uncovered
try: # uncovered
    delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)}) # uncovered
except ValueError: # uncovered
    raise CannotSplit(""No delimiters found"") from None # uncovered
if delimiter_priority == DOT_PRIORITY: # uncovered
    if bt.delimiter_count_with_priority(delimiter_priority) == 1: # uncovered
        raise CannotSplit(""Splitting a single attribute from its owner looks wrong"") # uncovered
current_line = Line( # uncovered
    mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
) # uncovered
lowest_depth = sys.maxsize # uncovered
trailing_comma_safe = True # uncovered
def append_to_line(leaf: Leaf) -> Iterator[Line]: # uncovered
    """"""Append `leaf` to current line or to new line if appending impossible.""""""
    nonlocal current_line # uncovered
    try: # uncovered
        current_line.append_safe(leaf, preformatted=True) # uncovered
    except ValueError: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
        current_line.append(leaf) # uncovered
for leaf in line.leaves: # uncovered
    aux = append_to_line(leaf) # uncovered
    exit(aux) # uncovered
    for comment_after in line.comments_after(leaf): # uncovered
        aux = append_to_line(comment_after) # uncovered
        exit(aux) # uncovered
    lowest_depth = min(lowest_depth, leaf.bracket_depth) # uncovered
    if leaf.bracket_depth == lowest_depth: # uncovered
        if is_vararg(leaf, within={syms.typedargslist}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features # uncovered
            ) # uncovered
        elif is_vararg(leaf, within={syms.arglist, syms.argument}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features # uncovered
            ) # uncovered
    leaf_priority = bt.delimiters.get(id(leaf)) # uncovered
    if leaf_priority == delimiter_priority: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
if current_line: # uncovered
    if ( # uncovered
        trailing_comma_safe # uncovered
        and delimiter_priority == COMMA_PRIORITY # uncovered
        and current_line.leaves[-1].type != token.COMMA # uncovered
        and current_line.leaves[-1].type != STANDALONE_COMMENT # uncovered
    ): # uncovered
        new_comma = Leaf(token.COMMA, "","") # uncovered
        current_line.append(new_comma) # uncovered
    aux = current_line # uncovered
    exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""bt = BracketTracker()"",
            ""line = Line(mode='test_mode', depth=1, inside_brackets=False)"",
            ""line.leaves.append(Leaf(token.NAME, 'value1'))"",
            ""line.bracket_tracker = bt"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""is_vararg = lambda leaf, within: True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.leaves.append(Leaf(token.NAME, 'function'))"",
            ""line.bracket_tracker = BracketTracker()"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""line.bracket_tracker = BracketTracker()"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""is_vararg = lambda leaf, within: True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token"",
            ""import enum""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, leaf_type):"",
            ""        self.type = leaf_type"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""        self.comments_after = lambda leaf: []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.leaves.append(Leaf(token.NAME))"",
            ""line.bracket_tracker = BracketTracker()"",
            ""features = ['TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL']"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True"",
            ""is_vararg = lambda leaf, within: False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf: def __init__(self, type, value): self.type = type; self.value = value; self.bracket_depth = 0"",
            ""class Line: def __init__(self, mode, depth, inside_brackets): self.mode = mode; self.depth = depth; self.inside_brackets = inside_brackets; self.leaves = []; self.comments_after = lambda leaf: []"",
            ""class BracketTracker: def __init__(self): self.delimiters = {}; self.max_delimiter_priority = lambda self, exclude: 1; self.delimiter_count_with_priority = lambda self, priority: 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""leaf1 = Leaf(token.NAME, 'arg1')"",
            ""line.leaves.append(leaf1)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""is_vararg = lambda leaf, within: True"",
            ""current_line = Line(mode='test', depth=0, inside_brackets=False)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves[0].bracket_depth = 0"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""current_line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""is_vararg = lambda leaf, within: True"",
            ""bracket_tracker = line.bracket_tracker""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'first'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""line.leaves.append(Leaf(token.NAME, 'second'))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""is_vararg = lambda leaf, within: False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'example'))"",
            ""line.leaves[0].bracket_depth = 0"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""line.leaves[1].bracket_depth = 0"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""is_vararg = lambda leaf, within: True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {};"",
            ""    def max_delimiter_priority(self, exclude): return 1;"",
            ""    def delimiter_count_with_priority(self, priority): return 2;"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""leaf1 = Leaf(token.NAME, 'function')"",
            ""leaf1.bracket_depth = 0"",
            ""line.leaves.append(leaf1)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""is_vararg = lambda leaf, within: True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type, value): self.type = type; self.value = value; self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude): return 2"",
            ""    def delimiter_count_with_priority(self, priority): return 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'function'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 2"",
            ""COMMA_PRIORITY = 1"",
            ""is_vararg = lambda leaf, within: False""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""bt = BracketTracker() # pragma: no cover"",
            ""line = Line(mode='test_mode', depth=1, inside_brackets=False) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'value1')) # pragma: no cover"",
            ""line.bracket_tracker = bt # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'function')) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover"",
            ""import enum # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, leaf_type): # pragma: no cover"",
            ""        self.type = leaf_type # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""        self.comments_after = lambda leaf: [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME)) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""features = ['TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL'] # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves[0].bracket_depth = 0 # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""current_line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""bracket_tracker = line.bracket_tracker # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'first')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'second')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'example')) # pragma: no cover"",
            ""line.leaves[0].bracket_depth = 0 # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""line.leaves[1].bracket_depth = 0 # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {}; # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1; # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2; # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""leaf1 = Leaf(token.NAME, 'function') # pragma: no cover"",
            ""leaf1.bracket_depth = 0 # pragma: no cover"",
            ""line.leaves.append(leaf1) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): self.type = type; self.value = value; self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'function')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover""
        ]
    }
]",3,10409,0.0052045,3774,0.005661,0.0108655
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Split according to delimiters of the highest priority.
    If the appropriate Features are given, the split will add trailing commas
    also in function signatures and calls that contain `*` and `**`.
    """"""
try: # uncovered
    last_leaf = line.leaves[-1] # uncovered
except IndexError: # uncovered
    raise CannotSplit(""Line empty"") from None # uncovered
bt = line.bracket_tracker # uncovered
try: # uncovered
    delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)}) # uncovered
except ValueError: # uncovered
    raise CannotSplit(""No delimiters found"") from None # uncovered
if delimiter_priority == DOT_PRIORITY: # uncovered
    if bt.delimiter_count_with_priority(delimiter_priority) == 1: # uncovered
        raise CannotSplit(""Splitting a single attribute from its owner looks wrong"") # uncovered
current_line = Line( # uncovered
    mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
) # uncovered
lowest_depth = sys.maxsize # uncovered
trailing_comma_safe = True # uncovered
def append_to_line(leaf: Leaf) -> Iterator[Line]: # uncovered
    """"""Append `leaf` to current line or to new line if appending impossible.""""""
    nonlocal current_line # uncovered
    try: # uncovered
        current_line.append_safe(leaf, preformatted=True) # uncovered
    except ValueError: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
        current_line.append(leaf) # uncovered
for leaf in line.leaves: # uncovered
    aux = append_to_line(leaf) # uncovered
    exit(aux) # uncovered
    for comment_after in line.comments_after(leaf): # uncovered
        aux = append_to_line(comment_after) # uncovered
        exit(aux) # uncovered
    lowest_depth = min(lowest_depth, leaf.bracket_depth) # uncovered
    if leaf.bracket_depth == lowest_depth: # uncovered
        if is_vararg(leaf, within={syms.typedargslist}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features # uncovered
            ) # uncovered
        elif is_vararg(leaf, within={syms.arglist, syms.argument}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features # uncovered
            ) # uncovered
    leaf_priority = bt.delimiters.get(id(leaf)) # uncovered
    if leaf_priority == delimiter_priority: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
if current_line: # uncovered
    if ( # uncovered
        trailing_comma_safe # uncovered
        and delimiter_priority == COMMA_PRIORITY # uncovered
        and current_line.leaves[-1].type != token.COMMA # uncovered
        and current_line.leaves[-1].type != STANDALONE_COMMENT # uncovered
    ): # uncovered
        new_comma = Leaf(token.COMMA, "","") # uncovered
        current_line.append(new_comma) # uncovered
    aux = current_line # uncovered
    exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        if isinstance(leaf, Leaf): self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, 'comma')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 2"",
            ""    def delimiter_count_with_priority(self, priority): return 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.leaves.append(Leaf(token.NAME, 'function'))"",
            ""line.bracket_tracker = BracketTracker()"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {};"",
            ""    def max_delimiter_priority(self, exclude): return 1;"",
            ""    def delimiter_count_with_priority(self, priority): return 1;"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False)"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.bracket_tracker = BracketTracker()"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=1, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'function'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves[0].bracket_depth = 0"",
            ""line.bracket_tracker = BracketTracker()"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {};"",
            ""    def max_delimiter_priority(self, exclude): return 1;"",
            ""    def delimiter_count_with_priority(self, priority): return 2;"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.bracket_tracker = BracketTracker()"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""        if len(self.leaves) > 1: raise ValueError('Too many leaves')"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.bracket_tracker = BracketTracker()"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: True"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type, value): self.type = type; self.value = value; self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.leaves.append(Leaf(token.NAME, 'func'))"",
            ""line.bracket_tracker = BracketTracker()"",
            ""current_line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: True"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type, value):"",
            ""        self.type = type"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'test_function'))"",
            ""line.leaves[0].bracket_depth = 0"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode='test', depth=0, inside_brackets=False)""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        if isinstance(leaf, Leaf): self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, 'comma')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'function')) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {}; # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1; # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1; # pragma: no cover"",
            ""line = Line(mode='test_mode', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=1, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'function')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves[0].bracket_depth = 0 # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {}; # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1; # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2; # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""        if len(self.leaves) > 1: raise ValueError('Too many leaves') # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): self.type = type; self.value = value; self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'func')) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""current_line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type, value): # pragma: no cover"",
            ""        self.type = type # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'test_function')) # pragma: no cover"",
            ""line.leaves[0].bracket_depth = 0 # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover""
        ]
    }
]",3,10696,0.005348,4098,0.006147,0.011495
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Split according to delimiters of the highest priority.
    If the appropriate Features are given, the split will add trailing commas
    also in function signatures and calls that contain `*` and `**`.
    """"""
try: # uncovered
    last_leaf = line.leaves[-1] # uncovered
except IndexError: # uncovered
    raise CannotSplit(""Line empty"") from None # uncovered
bt = line.bracket_tracker # uncovered
try: # uncovered
    delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)}) # uncovered
except ValueError: # uncovered
    raise CannotSplit(""No delimiters found"") from None # uncovered
if delimiter_priority == DOT_PRIORITY: # uncovered
    if bt.delimiter_count_with_priority(delimiter_priority) == 1: # uncovered
        raise CannotSplit(""Splitting a single attribute from its owner looks wrong"") # uncovered
current_line = Line( # uncovered
    mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
) # uncovered
lowest_depth = sys.maxsize # uncovered
trailing_comma_safe = True # uncovered
def append_to_line(leaf: Leaf) -> Iterator[Line]: # uncovered
    """"""Append `leaf` to current line or to new line if appending impossible.""""""
    nonlocal current_line # uncovered
    try: # uncovered
        current_line.append_safe(leaf, preformatted=True) # uncovered
    except ValueError: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
        current_line.append(leaf) # uncovered
for leaf in line.leaves: # uncovered
    aux = append_to_line(leaf) # uncovered
    exit(aux) # uncovered
    for comment_after in line.comments_after(leaf): # uncovered
        aux = append_to_line(comment_after) # uncovered
        exit(aux) # uncovered
    lowest_depth = min(lowest_depth, leaf.bracket_depth) # uncovered
    if leaf.bracket_depth == lowest_depth: # uncovered
        if is_vararg(leaf, within={syms.typedargslist}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features # uncovered
            ) # uncovered
        elif is_vararg(leaf, within={syms.arglist, syms.argument}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features # uncovered
            ) # uncovered
    leaf_priority = bt.delimiters.get(id(leaf)) # uncovered
    if leaf_priority == delimiter_priority: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
if current_line: # uncovered
    if ( # uncovered
        trailing_comma_safe # uncovered
        and delimiter_priority == COMMA_PRIORITY # uncovered
        and current_line.leaves[-1].type != token.COMMA # uncovered
        and current_line.leaves[-1].type != STANDALONE_COMMENT # uncovered
    ): # uncovered
        new_comma = Leaf(token.COMMA, "","") # uncovered
        current_line.append(new_comma) # uncovered
    aux = current_line # uncovered
    exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 2}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""current_line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=1, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        if len(self.leaves) >= 1: raise ValueError('Too many leaves')"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 2"",
            ""    def delimiter_count_with_priority(self, priority): return 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        if len(self.leaves) > 0: raise ValueError('Cannot append more leaves')"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: True"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        if isinstance(leaf, Leaf): self.leaves.append(leaf);"",
            ""        else: raise ValueError('Invalid leaf')"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 2"",
            ""    def delimiter_count_with_priority(self, priority): return 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'function'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""is_vararg = lambda leaf, within: True"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""        self.comments_after = lambda leaf: []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, 'comma')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 2"",
            ""    def delimiter_count_with_priority(self, priority): return 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""line.leaves[0].bracket_depth = 0"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {};"",
            ""    def max_delimiter_priority(self, exclude): return 1;"",
            ""    def delimiter_count_with_priority(self, priority): return 2;"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.leaves.append(Leaf(token.NAME, 'last_arg'))"",
            ""line.bracket_tracker = BracketTracker()"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude): return 2"",
            ""    def delimiter_count_with_priority(self, priority): return 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.COMMA, ',' ))"",
            ""line.leaves[0].bracket_depth = 0"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 2"",
            ""    def delimiter_count_with_priority(self, priority): return 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""        if len(self.leaves) > 1: raise ValueError('Cannot add more than one leaf')"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {}"",
            ""    def max_delimiter_priority(self, exclude): return 2"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'variable'))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: True"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""current_line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=1, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: raise ValueError('Too many leaves') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        if len(self.leaves) > 0: raise ValueError('Cannot append more leaves') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        if isinstance(leaf, Leaf): self.leaves.append(leaf); # pragma: no cover"",
            ""        else: raise ValueError('Invalid leaf') # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'function')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""        self.comments_after = lambda leaf: [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, 'comma')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""line.leaves[0].bracket_depth = 0 # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {}; # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1; # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2; # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'last_arg')) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',' )) # pragma: no cover"",
            ""line.leaves[0].bracket_depth = 0 # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""        if len(self.leaves) > 1: raise ValueError('Cannot add more than one leaf') # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'variable')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover""
        ]
    }
]",3,10982,0.005491,4502,0.006753,0.012244
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Split according to delimiters of the highest priority.
    If the appropriate Features are given, the split will add trailing commas
    also in function signatures and calls that contain `*` and `**`.
    """"""
try: # uncovered
    last_leaf = line.leaves[-1] # uncovered
except IndexError: # uncovered
    raise CannotSplit(""Line empty"") from None # uncovered
bt = line.bracket_tracker # uncovered
try: # uncovered
    delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)}) # uncovered
except ValueError: # uncovered
    raise CannotSplit(""No delimiters found"") from None # uncovered
if delimiter_priority == DOT_PRIORITY: # uncovered
    if bt.delimiter_count_with_priority(delimiter_priority) == 1: # uncovered
        raise CannotSplit(""Splitting a single attribute from its owner looks wrong"") # uncovered
current_line = Line( # uncovered
    mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
) # uncovered
lowest_depth = sys.maxsize # uncovered
trailing_comma_safe = True # uncovered
def append_to_line(leaf: Leaf) -> Iterator[Line]: # uncovered
    """"""Append `leaf` to current line or to new line if appending impossible.""""""
    nonlocal current_line # uncovered
    try: # uncovered
        current_line.append_safe(leaf, preformatted=True) # uncovered
    except ValueError: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
        current_line.append(leaf) # uncovered
for leaf in line.leaves: # uncovered
    aux = append_to_line(leaf) # uncovered
    exit(aux) # uncovered
    for comment_after in line.comments_after(leaf): # uncovered
        aux = append_to_line(comment_after) # uncovered
        exit(aux) # uncovered
    lowest_depth = min(lowest_depth, leaf.bracket_depth) # uncovered
    if leaf.bracket_depth == lowest_depth: # uncovered
        if is_vararg(leaf, within={syms.typedargslist}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features # uncovered
            ) # uncovered
        elif is_vararg(leaf, within={syms.arglist, syms.argument}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features # uncovered
            ) # uncovered
    leaf_priority = bt.delimiters.get(id(leaf)) # uncovered
    if leaf_priority == delimiter_priority: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
if current_line: # uncovered
    if ( # uncovered
        trailing_comma_safe # uncovered
        and delimiter_priority == COMMA_PRIORITY # uncovered
        and current_line.leaves[-1].type != token.COMMA # uncovered
        and current_line.leaves[-1].type != STANDALONE_COMMENT # uncovered
    ): # uncovered
        new_comma = Leaf(token.COMMA, "","") # uncovered
        current_line.append(new_comma) # uncovered
    aux = current_line # uncovered
    exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 2"",
            ""    def delimiter_count_with_priority(self, priority): return 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""line.leaves[0].bracket_depth = 0"",
            ""line.leaves[1].bracket_depth = 0"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: True"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True): "",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {}; self.delimiters[id(Leaf(token.COMMA, ','))] = 1"",
            ""    def max_delimiter_priority(self, exclude): return 2"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'func'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=1, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 2, id(Leaf(token.NAME, 'var')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'var'))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 1"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=1, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'last_arg'))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: True"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 2"",
            ""    def delimiter_count_with_priority(self, priority): return 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves[0].bracket_depth = 0"",
            ""line.leaves[1].bracket_depth = 1"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 2"",
            ""    def delimiter_count_with_priority(self, priority): return 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: True"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 1"",
            ""# Set bracket_depth to a value to avoid `IndexError`"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 2"",
            ""# Return a high delimiter priority to proceed"",
            ""    def delimiter_count_with_priority(self, priority): return 1"",
            ""# Allow only 1 delimiter"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""# Add a leaf to avoid IndexError"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""# Change to match the expected conditions"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""# Initialize lowest_depth"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""        if len(self.leaves) > 5: raise ValueError('Too many leaves')"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=1, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.COMMA, ',' ))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves[0].bracket_depth = 0"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""line.leaves[0].bracket_depth = 0 # pragma: no cover"",
            ""line.leaves[1].bracket_depth = 0 # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('syms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True):  # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {}; self.delimiters[id(Leaf(token.COMMA, ','))] = 1 # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'func')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=1, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 2, id(Leaf(token.NAME, 'var')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'var')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 1 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=1, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'last_arg')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves[0].bracket_depth = 0 # pragma: no cover"",
            ""line.leaves[1].bracket_depth = 1 # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 1 # pragma: no cover"",
            ""# Set bracket_depth to a value to avoid `IndexError` # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 2 # pragma: no cover"",
            ""# Return a high delimiter priority to proceed # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""# Allow only 1 delimiter # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""# Add a leaf to avoid IndexError # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""# Change to match the expected conditions # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""# Initialize lowest_depth # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""        if len(self.leaves) > 5: raise ValueError('Too many leaves') # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=1, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',' )) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves[0].bracket_depth = 0 # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    }
]",3,11710,0.005855,4725,0.0070875,0.0129425
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Split according to delimiters of the highest priority.
    If the appropriate Features are given, the split will add trailing commas
    also in function signatures and calls that contain `*` and `**`.
    """"""
try: # uncovered
    last_leaf = line.leaves[-1] # uncovered
except IndexError: # uncovered
    raise CannotSplit(""Line empty"") from None # uncovered
bt = line.bracket_tracker # uncovered
try: # uncovered
    delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)}) # uncovered
except ValueError: # uncovered
    raise CannotSplit(""No delimiters found"") from None # uncovered
if delimiter_priority == DOT_PRIORITY: # uncovered
    if bt.delimiter_count_with_priority(delimiter_priority) == 1: # uncovered
        raise CannotSplit(""Splitting a single attribute from its owner looks wrong"") # uncovered
current_line = Line( # uncovered
    mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
) # uncovered
lowest_depth = sys.maxsize # uncovered
trailing_comma_safe = True # uncovered
def append_to_line(leaf: Leaf) -> Iterator[Line]: # uncovered
    """"""Append `leaf` to current line or to new line if appending impossible.""""""
    nonlocal current_line # uncovered
    try: # uncovered
        current_line.append_safe(leaf, preformatted=True) # uncovered
    except ValueError: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
        current_line.append(leaf) # uncovered
for leaf in line.leaves: # uncovered
    aux = append_to_line(leaf) # uncovered
    exit(aux) # uncovered
    for comment_after in line.comments_after(leaf): # uncovered
        aux = append_to_line(comment_after) # uncovered
        exit(aux) # uncovered
    lowest_depth = min(lowest_depth, leaf.bracket_depth) # uncovered
    if leaf.bracket_depth == lowest_depth: # uncovered
        if is_vararg(leaf, within={syms.typedargslist}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features # uncovered
            ) # uncovered
        elif is_vararg(leaf, within={syms.arglist, syms.argument}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features # uncovered
            ) # uncovered
    leaf_priority = bt.delimiters.get(id(leaf)) # uncovered
    if leaf_priority == delimiter_priority: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
if current_line: # uncovered
    if ( # uncovered
        trailing_comma_safe # uncovered
        and delimiter_priority == COMMA_PRIORITY # uncovered
        and current_line.leaves[-1].type != token.COMMA # uncovered
        and current_line.leaves[-1].type != STANDALONE_COMMENT # uncovered
    ): # uncovered
        new_comma = Leaf(token.COMMA, "","") # uncovered
        current_line.append(new_comma) # uncovered
    aux = current_line # uncovered
    exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""line.leaves[0].bracket_depth = 0"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves[1].bracket_depth = 0"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves[0].bracket_depth = 0"",
            ""line.leaves[1].bracket_depth = 0"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 2"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 2"",
            ""    def delimiter_count_with_priority(self, priority): return 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""line.leaves[0].bracket_depth = 0"",
            ""line.leaves[1].bracket_depth = 0"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: True"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, typ, value):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""line.leaves[0].bracket_depth = 0"",
            ""line.leaves[1].bracket_depth = 0"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 2}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'first_arg'))"",
            ""line.leaves.append(Leaf(token.NAME, 'second_arg'))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 1"",
            ""line = Line(mode='test', depth=1, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: True"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""line.leaves[0].bracket_depth = 0 # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves[1].bracket_depth = 0 # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves[0].bracket_depth = 0 # pragma: no cover"",
            ""line.leaves[1].bracket_depth = 0 # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""line.leaves[0].bracket_depth = 0 # pragma: no cover"",
            ""line.leaves[1].bracket_depth = 0 # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, typ, value): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""line.leaves[0].bracket_depth = 0 # pragma: no cover"",
            ""line.leaves[1].bracket_depth = 0 # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'first_arg')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'second_arg')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=1, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    }
]",3,6806,0.003403,4795,0.0071925,0.0105955
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Split according to delimiters of the highest priority.
    If the appropriate Features are given, the split will add trailing commas
    also in function signatures and calls that contain `*` and `**`.
    """"""
try: # uncovered
    last_leaf = line.leaves[-1] # uncovered
except IndexError: # uncovered
    raise CannotSplit(""Line empty"") from None # uncovered
bt = line.bracket_tracker # uncovered
try: # uncovered
    delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)}) # uncovered
except ValueError: # uncovered
    raise CannotSplit(""No delimiters found"") from None # uncovered
if delimiter_priority == DOT_PRIORITY: # uncovered
    if bt.delimiter_count_with_priority(delimiter_priority) == 1: # uncovered
        raise CannotSplit(""Splitting a single attribute from its owner looks wrong"") # uncovered
current_line = Line( # uncovered
    mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
) # uncovered
lowest_depth = sys.maxsize # uncovered
trailing_comma_safe = True # uncovered
def append_to_line(leaf: Leaf) -> Iterator[Line]: # uncovered
    """"""Append `leaf` to current line or to new line if appending impossible.""""""
    nonlocal current_line # uncovered
    try: # uncovered
        current_line.append_safe(leaf, preformatted=True) # uncovered
    except ValueError: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
        current_line.append(leaf) # uncovered
for leaf in line.leaves: # uncovered
    aux = append_to_line(leaf) # uncovered
    exit(aux) # uncovered
    for comment_after in line.comments_after(leaf): # uncovered
        aux = append_to_line(comment_after) # uncovered
        exit(aux) # uncovered
    lowest_depth = min(lowest_depth, leaf.bracket_depth) # uncovered
    if leaf.bracket_depth == lowest_depth: # uncovered
        if is_vararg(leaf, within={syms.typedargslist}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features # uncovered
            ) # uncovered
        elif is_vararg(leaf, within={syms.arglist, syms.argument}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features # uncovered
            ) # uncovered
    leaf_priority = bt.delimiters.get(id(leaf)) # uncovered
    if leaf_priority == delimiter_priority: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
if current_line: # uncovered
    if ( # uncovered
        trailing_comma_safe # uncovered
        and delimiter_priority == COMMA_PRIORITY # uncovered
        and current_line.leaves[-1].type != token.COMMA # uncovered
        and current_line.leaves[-1].type != STANDALONE_COMMENT # uncovered
    ): # uncovered
        new_comma = Leaf(token.COMMA, "","") # uncovered
        current_line.append(new_comma) # uncovered
    aux = current_line # uncovered
    exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 2}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'argument1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'argument2'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""line.leaves[0].bracket_depth = 1"",
            ""line.leaves[1].bracket_depth = 1"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: True"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, typ, value):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""line.leaves[0].bracket_depth = 0"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, typ, value):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 2}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 1"",
            ""  # Set to a depth that will be the lowest"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: True"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 1"",
            ""  # to trigger the uncovered path"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""  # simulating a comma in leaves"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 2}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""line.leaves[0].bracket_depth = 0"",
            ""line.leaves[1].bracket_depth = 0"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: True"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        if len(self.leaves) >= 2: raise ValueError()"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves[0].bracket_depth = 1"",
            ""line.leaves[1].bracket_depth = 1"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, typ, value):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 2}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=1, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves[0].bracket_depth = 1"",
            ""line.leaves[1].bracket_depth = 1"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: True"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 2}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'argument1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'argument2')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""line.leaves[0].bracket_depth = 1 # pragma: no cover"",
            ""line.leaves[1].bracket_depth = 1 # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, typ, value): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""line.leaves[0].bracket_depth = 0 # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, typ, value): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 1 # pragma: no cover"",
            ""  # Set to a depth that will be the lowest # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 1 # pragma: no cover"",
            ""  # to trigger the uncovered path # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""  # simulating a comma in leaves # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""line.leaves[0].bracket_depth = 0 # pragma: no cover"",
            ""line.leaves[1].bracket_depth = 0 # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        if len(self.leaves) >= 2: raise ValueError() # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves[0].bracket_depth = 1 # pragma: no cover"",
            ""line.leaves[1].bracket_depth = 1 # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, typ, value): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=1, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves[0].bracket_depth = 1 # pragma: no cover"",
            ""line.leaves[1].bracket_depth = 1 # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    }
]",3,6876,0.003438,4847,0.0072705,0.0107085
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Split according to delimiters of the highest priority.
    If the appropriate Features are given, the split will add trailing commas
    also in function signatures and calls that contain `*` and `**`.
    """"""
try: # uncovered
    last_leaf = line.leaves[-1] # uncovered
except IndexError: # uncovered
    raise CannotSplit(""Line empty"") from None # uncovered
bt = line.bracket_tracker # uncovered
try: # uncovered
    delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)}) # uncovered
except ValueError: # uncovered
    raise CannotSplit(""No delimiters found"") from None # uncovered
if delimiter_priority == DOT_PRIORITY: # uncovered
    if bt.delimiter_count_with_priority(delimiter_priority) == 1: # uncovered
        raise CannotSplit(""Splitting a single attribute from its owner looks wrong"") # uncovered
current_line = Line( # uncovered
    mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
) # uncovered
lowest_depth = sys.maxsize # uncovered
trailing_comma_safe = True # uncovered
def append_to_line(leaf: Leaf) -> Iterator[Line]: # uncovered
    """"""Append `leaf` to current line or to new line if appending impossible.""""""
    nonlocal current_line # uncovered
    try: # uncovered
        current_line.append_safe(leaf, preformatted=True) # uncovered
    except ValueError: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
        current_line.append(leaf) # uncovered
for leaf in line.leaves: # uncovered
    aux = append_to_line(leaf) # uncovered
    exit(aux) # uncovered
    for comment_after in line.comments_after(leaf): # uncovered
        aux = append_to_line(comment_after) # uncovered
        exit(aux) # uncovered
    lowest_depth = min(lowest_depth, leaf.bracket_depth) # uncovered
    if leaf.bracket_depth == lowest_depth: # uncovered
        if is_vararg(leaf, within={syms.typedargslist}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features # uncovered
            ) # uncovered
        elif is_vararg(leaf, within={syms.arglist, syms.argument}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features # uncovered
            ) # uncovered
    leaf_priority = bt.delimiters.get(id(leaf)) # uncovered
    if leaf_priority == delimiter_priority: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
if current_line: # uncovered
    if ( # uncovered
        trailing_comma_safe # uncovered
        and delimiter_priority == COMMA_PRIORITY # uncovered
        and current_line.leaves[-1].type != token.COMMA # uncovered
        and current_line.leaves[-1].type != STANDALONE_COMMENT # uncovered
    ): # uncovered
        new_comma = Leaf(token.COMMA, "","") # uncovered
        current_line.append(new_comma) # uncovered
    aux = current_line # uncovered
    exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, typ, value):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        if len(self.leaves) >= 2: raise ValueError()"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        if len(self.leaves) >= 1: raise ValueError()"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""features = {'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL'}"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, typ, value):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        if len(self.leaves) >= 2: raise ValueError()"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, typ, value):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: True"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, typ, value):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 2}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""line.leaves[0].bracket_depth = 1"",
            ""line.leaves[1].bracket_depth = 1"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: True"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 1"",
            ""  # Set depth to trigger processing"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        if len(self.leaves) < 2: self.leaves.append(leaf)"",
            ""        else: raise ValueError()"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 2}"",
            ""    def max_delimiter_priority(self, exclude): return 2"",
            ""    def delimiter_count_with_priority(self, priority): return 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: True"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, typ, value):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.bracket_depth = 1"",
            ""  # Set depth to trigger logic in the code"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        if len(self.leaves) >= 5: raise ValueError('Cannot append')"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        if len(self.leaves) >= 2: raise ValueError()"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 2}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""line.leaves[0].bracket_depth = 1"",
            ""line.leaves[1].bracket_depth = 1"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: True"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, typ, value):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: True"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, typ, value): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        if len(self.leaves) >= 2: raise ValueError() # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: raise ValueError() # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""features = {'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL'} # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, typ, value): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        if len(self.leaves) >= 2: raise ValueError() # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, typ, value): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, typ, value): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""line.leaves[0].bracket_depth = 1 # pragma: no cover"",
            ""line.leaves[1].bracket_depth = 1 # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 1 # pragma: no cover"",
            ""  # Set depth to trigger processing # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        if len(self.leaves) < 2: self.leaves.append(leaf) # pragma: no cover"",
            ""        else: raise ValueError() # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, typ, value): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 1 # pragma: no cover"",
            ""  # Set depth to trigger logic in the code # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        if len(self.leaves) >= 5: raise ValueError('Cannot append') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        if len(self.leaves) >= 2: raise ValueError() # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""line.leaves[0].bracket_depth = 1 # pragma: no cover"",
            ""line.leaves[1].bracket_depth = 1 # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, typ, value): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    }
]",3,6928,0.003464,4898,0.007347,0.010811
"When trying to execute the code snippet with the provided imports and initialization, the lines with # uncovered are not executed.

# begin code snippet
""""""Split according to delimiters of the highest priority.
    If the appropriate Features are given, the split will add trailing commas
    also in function signatures and calls that contain `*` and `**`.
    """"""
try: # uncovered
    last_leaf = line.leaves[-1] # uncovered
except IndexError: # uncovered
    raise CannotSplit(""Line empty"") from None # uncovered
bt = line.bracket_tracker # uncovered
try: # uncovered
    delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)}) # uncovered
except ValueError: # uncovered
    raise CannotSplit(""No delimiters found"") from None # uncovered
if delimiter_priority == DOT_PRIORITY: # uncovered
    if bt.delimiter_count_with_priority(delimiter_priority) == 1: # uncovered
        raise CannotSplit(""Splitting a single attribute from its owner looks wrong"") # uncovered
current_line = Line( # uncovered
    mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
) # uncovered
lowest_depth = sys.maxsize # uncovered
trailing_comma_safe = True # uncovered
def append_to_line(leaf: Leaf) -> Iterator[Line]: # uncovered
    """"""Append `leaf` to current line or to new line if appending impossible.""""""
    nonlocal current_line # uncovered
    try: # uncovered
        current_line.append_safe(leaf, preformatted=True) # uncovered
    except ValueError: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
        current_line.append(leaf) # uncovered
for leaf in line.leaves: # uncovered
    aux = append_to_line(leaf) # uncovered
    exit(aux) # uncovered
    for comment_after in line.comments_after(leaf): # uncovered
        aux = append_to_line(comment_after) # uncovered
        exit(aux) # uncovered
    lowest_depth = min(lowest_depth, leaf.bracket_depth) # uncovered
    if leaf.bracket_depth == lowest_depth: # uncovered
        if is_vararg(leaf, within={syms.typedargslist}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features # uncovered
            ) # uncovered
        elif is_vararg(leaf, within={syms.arglist, syms.argument}): # uncovered
            trailing_comma_safe = ( # uncovered
                trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features # uncovered
            ) # uncovered
    leaf_priority = bt.delimiters.get(id(leaf)) # uncovered
    if leaf_priority == delimiter_priority: # uncovered
        aux = current_line # uncovered
        exit(aux) # uncovered
        current_line = Line( # uncovered
            mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets # uncovered
        ) # uncovered
if current_line: # uncovered
    if ( # uncovered
        trailing_comma_safe # uncovered
        and delimiter_priority == COMMA_PRIORITY # uncovered
        and current_line.leaves[-1].type != token.COMMA # uncovered
        and current_line.leaves[-1].type != STANDALONE_COMMENT # uncovered
    ): # uncovered
        new_comma = Leaf(token.COMMA, "","") # uncovered
        current_line.append(new_comma) # uncovered
    aux = current_line # uncovered
    exit(aux) # uncovered

# end code snippet

Please, provide self-contained and concrete Python modified values of the imports and initialization to execute one of the uncovered paths in the code snippet.
Respond strictly with JSON. The JSON should be compatible with the TypeScript type `Response` from the following:

```ts
interface Response {
// Python import statements needed in the initialization code. One string per import.
imports: string[];
// Python code to initialize the undefined variables and make the code snippet executable. One string per undefined variable. The statements in the code snippet above are not part of the initialization of undefined variables. Therefore, their copy or modified versions should not be added here. The values should be self-contained and concrete, i.e. without assumptions or expected replacements of any code that is not present in the code snippet. In case there are undefined attributes or methods and the attribute or method base is not initialized, initialize the attribute or method base using type(""Mock"", bases, dict), where bases is a tuple containing the base classes that the Mock object inherits from, e.g. object, and dict is a dictionary containing the initialization of the undefined attributes and methods in the code snippet.
initialization: string[];
}
```","[
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        if len(self.leaves) >= 5: raise ValueError('Cannot append')"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 2}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""line.leaves[0].bracket_depth = 1"",
            ""line.leaves[1].bracket_depth = 1"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: True"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, typ, value):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.bracket_depth = 1"",
            ""  # Set to 1 to allow further branching."",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        if len(self.leaves) >= 2: raise ValueError()"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: True"",
            ""  # Adjust to always return True."",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, typ, value):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.bracket_depth = 1"",
            ""  # Set this to trigger comparisons"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        if len(self.leaves) < 2: self.leaves.append(leaf)"",
            ""        else: raise ValueError('Cannot append')"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: True"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, typ, value):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        if len(self.leaves) >= 1: raise ValueError('Cannot append more than allowed')"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: True"",
            ""  # Ensure is_vararg returns True for testing"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, type_, value):"",
            ""        self.type = type_"",
            ""        self.value = value"",
            ""        self.bracket_depth = 1"",
            ""  # Set depth to trigger processing"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1, id(Leaf(token.DOT, '.')): 2}"",
            ""    def max_delimiter_priority(self, exclude): return 2"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""line.leaves.append(Leaf(token.DOT, '.'))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 2"",
            ""COMMA_PRIORITY = 1"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, typ, value):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.bracket_depth = 1"",
            ""  # Set depth to pass conditions"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self):"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1, id(Leaf(token.DOT, '.')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg3'))"",
            ""  # Additional leaf to test multiple leaves"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: True"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, typ, value, bracket_depth):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.bracket_depth = bracket_depth"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 2}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='function', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1', 0))"",
            ""line.leaves.append(Leaf(token.COMMA, ',', 0))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2', 0))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, typ, value):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.bracket_depth = 0"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves: List[Leaf] = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1}"",
            ""    def max_delimiter_priority(self, exclude): return 1"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""features = {'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL'}"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, typ, value):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.bracket_depth = 1"",
            ""  # Set to trigger logic"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        if len(self.leaves) < 2: self.leaves.append(leaf)"",
            ""        else: raise ValueError('Cannot append')"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 2}"",
            ""    def max_delimiter_priority(self, exclude): return 2"",
            ""    def delimiter_count_with_priority(self, priority): return 2"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator"",
            ""import sys"",
            ""import token""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass"",
            ""class Leaf:"",
            ""    def __init__(self, typ, value):"",
            ""        self.type = typ"",
            ""        self.value = value"",
            ""        self.bracket_depth = 1"",
            ""  # Setting a bracket depth to trigger logic in the code"",
            ""class Line:"",
            ""    def __init__(self, mode, depth, inside_brackets):"",
            ""        self.mode = mode"",
            ""        self.depth = depth"",
            ""        self.inside_brackets = inside_brackets"",
            ""        self.leaves = []"",
            ""    def append_safe(self, leaf, preformatted=True):"",
            ""        if len(self.leaves) >= 1: raise ValueError()"",
            ""        self.leaves.append(leaf)"",
            ""    def comments_after(self, leaf): return []"",
            ""class BracketTracker:"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 2}"",
            ""    def max_delimiter_priority(self, exclude): return 2"",
            ""    def delimiter_count_with_priority(self, priority): return 1"",
            ""line = Line(mode='test', depth=0, inside_brackets=False)"",
            ""line.bracket_tracker = BracketTracker()"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1'))"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2'))"",
            ""line.leaves.append(Leaf(token.COMMA, ','))"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' }"",
            ""DOT_PRIORITY = 1"",
            ""COMMA_PRIORITY = 2"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})()"",
            ""is_vararg = lambda leaf, within: False"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets)"",
            ""lowest_depth = sys.maxsize"",
            ""trailing_comma_safe = True""
        ]
    }
]","[
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        if len(self.leaves) >= 5: raise ValueError('Cannot append') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""line.leaves[0].bracket_depth = 1 # pragma: no cover"",
            ""line.leaves[1].bracket_depth = 1 # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, typ, value): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 1 # pragma: no cover"",
            ""  # Set to 1 to allow further branching. # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        if len(self.leaves) >= 2: raise ValueError() # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""  # Adjust to always return True. # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, typ, value): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 1 # pragma: no cover"",
            ""  # Set this to trigger comparisons # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        if len(self.leaves) < 2: self.leaves.append(leaf) # pragma: no cover"",
            ""        else: raise ValueError('Cannot append') # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, typ, value): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: raise ValueError('Cannot append more than allowed') # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""  # Ensure is_vararg returns True for testing # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, type_, value): # pragma: no cover"",
            ""        self.type = type_ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 1 # pragma: no cover"",
            ""  # Set depth to trigger processing # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1, id(Leaf(token.DOT, '.')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.DOT, '.')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 2 # pragma: no cover"",
            ""COMMA_PRIORITY = 1 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, typ, value): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 1 # pragma: no cover"",
            ""  # Set depth to pass conditions # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): # pragma: no cover"",
            ""        self.delimiters = {id(Leaf(token.COMMA, ',')): 1, id(Leaf(token.DOT, '.')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg3')) # pragma: no cover"",
            ""  # Additional leaf to test multiple leaves # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: True # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, typ, value, bracket_depth): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = bracket_depth # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='function', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1', 0)) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',', 0)) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2', 0)) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator, List # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, typ, value): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 0 # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves: List[Leaf] = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 1} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 1 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""features = {'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL'} # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, typ, value): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 1 # pragma: no cover"",
            ""  # Set to trigger logic # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        if len(self.leaves) < 2: self.leaves.append(leaf) # pragma: no cover"",
            ""        else: raise ValueError('Cannot append') # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 2 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    },
    {
        ""imports"": [
            ""from typing import Iterator # pragma: no cover"",
            ""import sys # pragma: no cover"",
            ""import token # pragma: no cover""
        ],
        ""initialization"": [
            ""class CannotSplit(Exception): pass # pragma: no cover"",
            ""class Leaf: # pragma: no cover"",
            ""    def __init__(self, typ, value): # pragma: no cover"",
            ""        self.type = typ # pragma: no cover"",
            ""        self.value = value # pragma: no cover"",
            ""        self.bracket_depth = 1 # pragma: no cover"",
            ""  # Setting a bracket depth to trigger logic in the code # pragma: no cover"",
            ""class Line: # pragma: no cover"",
            ""    def __init__(self, mode, depth, inside_brackets): # pragma: no cover"",
            ""        self.mode = mode # pragma: no cover"",
            ""        self.depth = depth # pragma: no cover"",
            ""        self.inside_brackets = inside_brackets # pragma: no cover"",
            ""        self.leaves = [] # pragma: no cover"",
            ""    def append_safe(self, leaf, preformatted=True): # pragma: no cover"",
            ""        if len(self.leaves) >= 1: raise ValueError() # pragma: no cover"",
            ""        self.leaves.append(leaf) # pragma: no cover"",
            ""    def comments_after(self, leaf): return [] # pragma: no cover"",
            ""class BracketTracker: # pragma: no cover"",
            ""    def __init__(self): self.delimiters = {id(Leaf(token.COMMA, ',')): 2} # pragma: no cover"",
            ""    def max_delimiter_priority(self, exclude): return 2 # pragma: no cover"",
            ""    def delimiter_count_with_priority(self, priority): return 1 # pragma: no cover"",
            ""line = Line(mode='test', depth=0, inside_brackets=False) # pragma: no cover"",
            ""line.bracket_tracker = BracketTracker() # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg1')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.NAME, 'arg2')) # pragma: no cover"",
            ""line.leaves.append(Leaf(token.COMMA, ',')) # pragma: no cover"",
            ""features = { 'TRAILING_COMMA_IN_DEF', 'TRAILING_COMMA_IN_CALL' } # pragma: no cover"",
            ""DOT_PRIORITY = 1 # pragma: no cover"",
            ""COMMA_PRIORITY = 2 # pragma: no cover"",
            ""syms = type('MockSyms', (object,), {'typedargslist': 1, 'arglist': 2, 'argument': 3})() # pragma: no cover"",
            ""is_vararg = lambda leaf, within: False # pragma: no cover"",
            ""current_line = Line(mode=line.mode, depth=line.depth, inside_brackets=line.inside_brackets) # pragma: no cover"",
            ""lowest_depth = sys.maxsize # pragma: no cover"",
            ""trailing_comma_safe = True # pragma: no cover""
        ]
    }
]",3,6979,0.0034895,5038,0.007557,0.0110465
